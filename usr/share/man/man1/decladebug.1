.\" This manpage source uses rsml coding. 
.so /usr/share/lib/tmac/sml
.so /usr/share/lib/tmac/rsml
.\"
.\"
.\" *********************************************************************
.\" *                                                                   *
.\" *      Copyright (c) Digital Equipment Corporation, 1991, 1994      *
.\" *                                                                   *
.\" *                       All Rights Reserved.                        *
.\" *                                                                   *
.\" *********************************************************************
.\"
.\"
.\" HISTORY
.\"
.\" @(#)$RCSfile: decladebug.1,v $ $Revision: 1.1.2.3 $ (DEC) $Date: 1993/11/29 20:35:44 $
.\"
.TH decladebug 1
.SH NAME
.PP
\*Ldecladebug\*O \- Invokes the command-line interface to the DECladebug sourcecode- and machine-level symbolic debugger.
.SH SYNOPSIS
.PP
.sS
\*Ldecladebug\*O [\*L-I\*O \*Vdir\*O ] [\*L-c\*O \*Vfile\*O ] [\*L-prompt\*O \*Vstring\*O] [\*Vexecfile\*O [\*Vcorefile\*O ]]
.sE
.SH DESCRIPTION
.PP
.iX "debugger"
.iX "debugging C++ programs"
.iX "debugging C programs"
.iX "C++" "debugging"
.iX "C" "debugging"
The DECladebug debugger debugs C, C++, and mixed C and C++ programs
compiled by the DEC C++, DEC C, and portable C compilers. The debugger also
identifies Ada source code and executes Ada routines. Pascal and FORTRAN are
not supported, but the debugger will step through a Pascal or FORTRAN routine
and return to the C or C++ calling program.
.PP
For full source-level debugging capability, compile the source code with the
compiler option that includes the symbol table information in the compiled
executable file. Limited debugging capability is available for executables that
do not have symbol table information.
.PP
You can control program execution, specify when the debugger should take
control from the target program, and examine the program state.
.PP
The debugger displays target program source listings if the source files are
located in the current directory or a directory specified with the
\*L-I\*O
option to the
\*Ldecladebug\*O
command or the
\*Luse\*O
debugger command.
.PP
To leave the debugger, enter the
\*Lquit\*O
command.
.PP
To debug a core file, specify the executable file and the core file when
invoking the debugger. You can examine the program stack trace and program
variables at the instant the system encountered the irrecoverable error.
.\"
.SS Options
.VL 10m
.LI "\*Vexecfile\*O"
Specifies the program executable file. If the file is not in the current
directory, specify the full pathname.
.\"
.LI "\*Vcorefile\*O"
Specifies the core file. If the core file is not in the current directory,
specify the full pathname.
.\"
.LI "\*L-I\*O"
Specifies the directory containing the source code for the target program.
Use multiple
\*L-I\*O
options to specify more than one directory. The debugger searches directories
in the order in which they were specified on the command line.
.\"
.LI "\*L-c\*O"
Specifies an initialization command file. The default initialization
file is
\*L.dbxinit\*O.
.LI "\*L-prompt\*O"
Specifies a debugger prompt.  The default debugger prompt is
\*L(DECladebug)\*O.
If the prompt argument contains spaces or special characters, enclose the
argument in quotes.
.LE
.\"
.SS Commands
Enter DECladebug commands at the debugger prompt.
.PP
You can enter more than one command on the same line by separating each command
with a semicolon. Commands are executed in the same order in which they are
entered in the command line.
.PP
Continue command input to another line by entering a backslash at the end of
each line. The maximum command-line length is 255 characters.
.PP
The following table lists the DECladebug commands, and groups them in
functionally related sets:
.PP
.IP "\*L#\*O, \*Lsh\*O, \*Lcatch\*O, \*Lignore\*O, \*Lhistory\*O, \*L!\*O, \*Lquit\*O"
Comment, shell, signal handling, history, and exit commands.
.IP "\*Lalias\*O, \*Lunalias\*O, \*Lset\*O, \*Lunset\*O"
Debugger alias and variable commands.
.IP "\*Llist\*O, \*Luse\*O, \*Lunuse\*O, \*Lfile\*O, \*L/\*O, \*L?\*O"
Source code file commands.
.IP "\*Lstepi\*O, \*Lnexti\*O, \*Lstopi\*O, \*Ltracei\*O, \*Lwheni\*O, \*Lprintregs\*O, \*Vaddress\*O"
Machine-code-level commands.
.IP "\*Lrun\*O, \*Lrerun\*O, \*Lcont\*O, \*Lstep\*O, \*Lnext\*O, \*Lreturn\*O, \*Lcall\*O, \*Lgoto\*O, \*Lkill\*O"
Program execution commands.
.IP "\*Lplayback\*O, \*Lrecord\*O, \*Lsource\*O"
Debugger script commands.
.IP "\*Lstop\*O, \*Ltrace\*O, \*Lwhen\*O, \*Lstatus\*O, \*Ldelete\*O, \*Lenable\*O, \*Ldisable\*O"
Breakpoint and tracepoint commands.
.IP "\*Lwhere\*O, \*Lup\*O, \*Ldown\*O, \*Lfunc\*O, \*Lclass\*O"
Stack trace and scope commands.
.PP
.\"
.SS Command Descriptions
\*Vstartaddress\*O , \*Vendaddress\*O \*L/\*O \*Vmode\*O
.sp
\*Vstartaddress\*O \*L/\*O \*Vcount mode\*O
.sp
.rS 5
.PP
You can display stored values as character strings,
machine instructions, or decimal, octal, hexadecimal, or real numbers. Specify
the address and the number of words or bytes (count) information in
hexadecimal, octal, or decimal. The display mode must be specified along with
the address range. The modes are:
.IP d
Print a short word in decimal
.IP D
Print a long word in decimal
.IP o
Print a short word in octal
.IP O
Print a long word in octal
.IP x
Print a short word in hexadecimal
.IP X
Print a long word in hexadecimal
.IP b
Print a byte in octal
.IP c
Print a byte as a character
.IP s
Print a string of characters (a C-style string that ends in null)
.IP f
Print a single-precision real number
.IP g
Print a double-precision real number
.IP i
Disassemble machine instructions
.rE
.PP
\*L#\*O \*Vcomment\*O
.sp
.rS 5
.PP
When the debugger encounters the
\*L#\*O
command, it ignores all inputs until the end of the line. The
\*L#\*O
command must be the first identifier on the command line. (White space may
precede the
\*L#\*O
command.)
.rE
.PP
\*L!!\*O or \*L!\*O[\*L-\*O]\*Vinteger\*O or \*L!\*O\*Vtext\*O
.sp
.rS 5
.PP
To repeat the last command line, enter two exclamation points
(\*L!!\*O)
or press the Return key. You can also enter
\*L!-1\*O.
.PP
To repeat a command line entered during the current debugging session, enter an
exclamation point followed by the integer associated with the command line.
(Use the
\*Lhistory\*O
command to see a list of commands used.) For example, to repeat the seventh
command used in the current debugging session, enter
\*L!7\*O.
Enter
\*L!-3\*O
to repeat the third-to-last command.
.PP
To repeat the most recent command starting with a string, use the last form of
the command. For example, to repeat a command that started with
\*Lbp\*O,
enter
\*L!bp\*O.
.rE
.PP
\*L/\*O [\*Vstring\*O] or \*L?\*O [\*Vstring\*O]
.rS 5
.PP
Use the string search commands
\*L/\*O
and
\*L?\*O
to locate text in the source code. The
\*L/\*O
character invokes a forward search; the
\*L?\*O
character invokes a backwards search. Enter
\*L/\*O
or
\*L?\*O
without an argument to find the next location of the previously specified text.
.PP
The search begins from the current position of the program counter. If no
program counter exists for the current source file, the search begins after the
last source line displayed by the debugger.
.rE
.PP
\*Lalias\*O [\*Valiasname\*O ]
.sp
\*Lalias \*Valiasname\*O [\*L(\*O\*Vargument\*O\*L)\*O] \*L"\*O[\*Valiasname\*O] \*Vstring\*O\*L"\*O
.sp
\*Lunalias\*O \*Valiasname\*O
.PP
.rS 5
.PP
Enter the
\*Lalias\*O
command without an argument to display all aliases and their definitions.
Specify an alias name to display the definition for that alias.
.PP
Use the second form to define a new alias or to redefine an existing alias. The
definition can contain the name of another alias, if the nested alias is the
first identifier in the definition. Invoke the alias by entering the alias
name, including an argument if the alias definition specified an argument.
.PP
The following example defines a nested alias and invokes the alias:
.sp
\*C(DECladebug)\*O\*Lalias begin "stop in main; run"\*O
.sp
\*C(DECladebug)\*O\*Lalias pv(x) "begin; print(x)"\*O
.sp
\*C(DECladebug)\*O\*Lpv(i)\*O
.PP
Use the
\*Lunalias\*O
command to delete an alias.
.PP
Alias commands may contain no more than 56 arguments.
.PP
The following predefined aliases are included with the debugger:
.IP a 9
assign
.IP b 9
stop at
.IP bp 9
stop in
.IP c 9
cont
.IP d 9
delete
.IP e 9
file
.IP f 9
func
.IP h 9
history
.IP j 9
status
.IP l 9
list
.IP li 9
$curpc/10i; set $curpc=$curpc+40
.IP "n or S" 9
next
.IP "ni or Si" 9
nexti
.IP pd 9
printf "%d"
.IP po 9
printf "0%o"
.IP ps 9
printf "%s"
.IP px 9
printf "0x%x"
.IP pr 9
printregs
.IP q 9
quit
.IP r 9
rerun
.IP ri 9
record input
.IP ro 9
record output
.IP s 9
step
.IP si 9
stepi
.IP t 9
where
.IP u 9
list $curline-9:10
.IP W 9
list $curline-10:20
.IP w 9
list $curline-5:10
.IP wi 9
$curpc-20/10i
.rE
.PP
\*Lassign\*O \*Vtarget\*O \*L=\*O \*Vexpression\*O
.rS 5
.PP
Use the
\*Lassign\*O
command to change the value of a variable, memory address, or expression that
is accessible according to the scope and visiblity rules of the language.  The
expression can be any expression that is valid in the current context.
.PP
For C++:
.sp
\*Lassign \*O[\*Vclassname\*L::\*O]\*Vmember\*L = \*O[\*L"\*Vfilename\*L"`\*O]\*Vexpression\*O
.sp
\*Lassign \*O[\*Vobject\*L.\*O]\*Vmember\*L = \*O[\*L"\*Vfilename\*L"`\*O]\*Vexpression\*O
.PP
Use the
\*Lassign\*O
command to modify static and object data members in a class, and variables
declared as reference types, type
\*Lconst\*O,
or type
\*Lstatic\*O.
Note that the address referred to by a reference type may not
be changed, but the value at that address may be changed.
.rE
.PP
\*Lcall\*O \*Vfunction\*O\*L(\*O[\*Vparameter\*O]\*L)\*O
.rS 5
.PP
Use the
\*Lcall\*O
command to execute a single function. Specify the function as if you were
calling it from within the program. If the function has no parameters, specify
empty parentheses.
.PP
Nest called functions by setting a breakpoint in a function and executing it
using the
\*Lcall\*O
command. When execution suspends at the breakpoint, use the
\*Lcall\*O
command to execute the nested function.
.PP
For C++:
.PP
When you set the
\*L$overloadmenu\*O
debugger variable to 1, and call an overloaded function, the debugger will list
the overloaded functions and call the function you specify.
.rE
.PP
\*Lcatch\*O [\*Vsignal\*O]
.rS 5
.PP
Enter the
\*Lcatch\*O
command or the
\*Lignore\*O
command without an argument to see which operating system signals the debugger
currently traps or ignores. Use the
\*Lcatch\*O
command or the
\*Lignore\*O
command followed by an argument to trap or ignore, respectively, that signal.
.PP
Only one signal at a time can be added to, or removed from, the list of trapped
or ignored signals.
.rE
.PP
\*Lclass\*O [\*Vclassname\*O]
.rS 5
.PP
.PP
For C++ only:
.PP
Use the
\*Lclass\*O
command without an argument to display the current class scope.  Specify an
argument to change the class scope. Once the class scope is set, refer to
members of the class omitting the
\*Vclassname\*L::\*O
prefix.
.PP
Setting the class scope nullifies the function scope.
.rE
.PP
\*Lcont\*O [\*Vsignal\*O]
.rS 5
.PP
Use the
\*Lcont\*O
command without arguments to resume program execution until a breakpoint, a
signal, an error, or the end of the program is encountered. Include an argument
to send an operating system signal to the program before continuing execution.
.rE
.PP
\*Ldelete\*O \*Vinteger\*O[,...] or \*Ldelete all\*O  or \*Ldelete * \*O
.rS 5
.PP
Enter the
\*Ldelete\*O
command followed by the number or numbers associated with a breakpoint or trace
(as listed by the
\*Lstatus\*O
command) to remove the specified breakpoint or tracepoint.
.PP
Enter the
\*Ldelete all\*O
command or the
\*Ldelete *\*O
command to remove all breakpoints and tracepoints.
.rE
.PP
\*Ldisable\*O \*Vinteger\*O[,...] or \*Ldisable all\*O or \*Ldisable * \*O
.rS 5
.PP
Enter the
\*Ldisable\*O
command followed by the number or numbers associated with a breakpoint or trace
(as listed by the
\*Lstatus\*O
command) to disable the breakpoint or trace.  Enter the
\*Ldisable all\*O
command or the
\*Ldisable *\*O
command, to disable all breakpoints and traces.
.PP
The disabled breakpoint is displayed in response to the
\*Lstatus\*O
command, but it is ignored during execution. Disabled breakpoints remain
disabled until they are explicitly reactivated or deleted.
.rE
.PP
\*Ldown\*O [\*Vnumber\*O]
.rS 5
.PP
Use the
\*Lup\*O
command or the
\*Ldown\*O
command without an argument to change the function scope to the function
located one level up or down the stack. Enter a number argument to change
the function scope to the function up or down the specified number of levels.
If the number of levels exceeds the number of active functions on the stack,
the function scope moves up or down as many levels as possible and the debugger
issues a warning message.
.PP
When the function scope changes, the debugger displays the source line
corresponding to the last point of execution in that function.
.rE
.PP
\*Ldump\*O [\*Vfunction\*O] or \*Ldump . \*O
.rS 5
.PP
Use the
\*Ldump\*O
command without an argument to list the parameters and local variables in the
current function. To list the parameters and local variables in an active
function, specify it as an argument.
.PP
Enter the
\*Ldump .\*O
command to list the parameters and local variables for all functions active on
the stack.
.rE
.PP
\*Lenable\*O \*Vinteger\*O[,...] or \*Lenable all\*O or \*Lenable * \*O
.rS 5
.PP
Enter the
\*Lenable\*O
command followed by the number or numbers associated with a breakpoint or trace
(as listed by the
\*Lstatus\*O
command) to enable a breakpoint or trace.
.PP
Enter the
\*Lenable all\*O
command or the
\*Lenable *\*O
command to activate all previously disabled breakpoints and traces.
.rE
.PP
\*Lfile\*O [\*Vfilename\*O]
.rS 5
.PP
Enter the
\*Lfile\*O
command without an argument to display the name of the current file scope.
Include a filename as an argument to change the file scope. Change the file
scope to see the source code or set a breakpoint in a function not in the file
currently being executed.
.rE
.PP
\*Lfunc\*O [\*Vfunction\*O | \*Vinteger\*O]
.rS 5
.PP
.PP
Use the
\*Lfunc\*O
command without an argument to display the current function scope. To change
the function scope to a function currently active on the stack, specify either
the name of the function or the number corresponding to the stack activation
level. (Enter the
\*Lwhere\*O
command to display the stack trace.)
.PP
When the function scope is changed, the debugger displays the source line
corresponding to the last point of execution in that function.
.rE
.PP
\*Lgoto \*O\*Vlinenumber\*O
.rS 5
.PP
Use the
\*Lgoto\*O
command to branch to a line located in the function where execution is
suspended. When you branch to a line, the source code between the line
where execution suspended and the specified line is not executed.
.rE
.PP
\*Lhelp \*O[\*Vcommand\*O]
.rS 5
.PP
Enter the
\*Lhelp\*O
command without an argument to display a list of debugger commands. Include a
command argument to display a description of that command.
.rE
.PP
\*Lhistory\*O [\*Vinteger\*O]
.rS 5
.PP
Enter the
\*Lhistory\*O
command without an argument to display previously executed commands. The
debugger displays the number of command lines defined for the
\*L$historylines\*O
debugger variable. (The default is 20 lines of user input.)
Include an integer argument to display that number of previous commands.
.rE
.PP
\*Lignore\*O [\*Vsignal\*O]
.rS 5
.PP
Enter the
\*Lcatch\*O
command or the
\*Lignore\*O
command without an argument to see which operating system signals the debugger
currently traps or ignores. Use the
\*Lcatch\*O
command or the
\*Lignore\*O
command followed by an argument to trap or ignore, respectively, that signal.
.PP
Only one signal at a time can be added to, or removed from, the list of trapped
or ignored signals.
.rE
.PP
\*Lkill\*O
.rS 5
.PP
Use the
\*Lkill\*O
command to terminate the program process leaving the debugger running. Any
breakpoints and traces previously set are retained. You can rerun the program
after it has been killed.
.rE
.PP
\*Llist \*O [\*Vstartline\*O [\*L,\*O\*Vendline\*O | \*L:\*O\*Vcount\*O] ]
.sp
\*Llist \*O \*Vfunction\*O
.rS 5
.PP
The
\*Llist\*O
command displays source-code lines beginning with the source
line corresponding to the position of the program counter, the last line listed
if multiple list commands are issued, or the line number specified as the first
argument to the
\*Llist\*O
command. Specify the exact range of source-code
lines by including either the endline or the number of lines you want to
display. The arguments may be expressions that evaluate to integer values.
.PP
To display the source code for a particular function, enter the function as an
argument.
.rE
.PP
\*Lnext\*O
.rS 5
.PP
Use the
\*Lnext\*O
and the
\*Lstep\*O
commands to execute a line of source code.
When the next line to be executed contains a function call, the
\*Lnext\*O
command executes the function being called and returns to the line
immediately after the function call. The
\*Lstep\*O
command executes only the first line of the function.
.rE
.PP
\*Lnexti
.rS 5
.PP
Use the
\*Lstepi\*O
command and the
\*Lnexti\*O
command to execute a machine
instruction. When the instruction contains a function call, the
\*Lstepi\*O
command steps into the function being called, and the
\*Lnexti\*O
command executes the function being called.
.rE
.PP
\*Lplayback input\*O \*Vfilename\*O
.rS 5
.PP
Use the
\*Lsource\*O
command and the
\*Lplayback input\*O
command to execute debugger commands contained within a file. Format commands
as if they were entered at the debugger prompt.
.PP
When a command file is executed the value of the
\*L$pimode\*O
debugger variable determines whether the commands are echoed. If the
\*L$pimode\*O
variable is set to 1, commands are echoed; if
\*L$pimode\*O
is set to 0 (the default), commands are not echoed. The debugger output
resulting from the commands is always echoed.
.rE
.PP
\*Lprint\*O \*Vexpression\*O [,...]
.rS 5
.PP
The
\*Lprint\*O
command displays the current value of a variable or expression that is visible
in the current context, as defined by the scope and visibility rules of the
program language.  The expression can be any expression that is valid in the
current context.
.PP
For C++:
.PP
.sp
\*Lprint *this \*O
.sp
\*Lprint \*Vobject\*O
.sp
\*Lprint\*O [\*Vobject\*O.]\*Vmember\*O
.sp
\*Lprint *(\*Vderived_class\*L*)\*Vobject\*O
.PP
Use the
\*Lprint\*O
command to display the value of an object, including inherited members and the
value of data members in an object. Type casts can be used to interpret a base
class object as a derived class object, or to interpret a derived class object
as a base class object. To interpret a base class type object as the derived
type, use the last form of the
\*Lprint\*O
command.
.rE
.PP
\*Lprintf\*O \*Vformat\*O [\*Vexpression\*O,...]
.rS 5
.PP
Use the
\*Lprintf\*O
command to format and display a complex structure. The
\*Vformat\*O
argument is a string expression of characters and conversion specifications,
using the same format specifiers as the
\*Lprintf\*O
C function.
.rE
.PP
\*Lprintregs \*O
.rS 5
.PP
Use the
\*Lprintregs\*O
command to display the contents of all machine registers.
Register values are given in both decimal and hexadecimal. The list of
registers displayed by the debugger is machine dependent.
.rE
.PP
\*Lquit\*O
.rS 5
.PP
Use the
\*Lquit\*O
command to end the debugging session and return to the
operating system prompt.
.rE
.PP
\*Lrecord input\*O \*Vfilename\*O
.sp
\*Lrecord output \*Vfilename\*O
.sp
\*Lrecord io \*Vfilename\*O
.rS 5
.PP
Use the
\*Lrecord input\*O
command to save all the debugger commands to a file. The commands in the file
can be executed by using the
\*Lsource\*O
command or the
\*Lplayback input\*O
command.
.PP
The
\*Lrecord output\*O
command saves all debugger output to a file. The output is simultaneously
echoed to the screen. (The program output is not saved.)
.PP
The
\*Lrecord io\*O
command saves both input to and output from the debugger.
.PP
To stop recording debugger input or output, exit the debugger.
.rE
.PP
\*Lreturn\*O [\*Vfunction\*O]
.rS 5
.PP
Use the
\*Lreturn\*O
command without an argument to continue execution of the current function until
it returns to its caller. If you include a function name, execution continues
until control is returned to the specified function. The function must be
active on the call stack.
.rE
.PP
\*Lrun\*O [\*Vprogram arguments\*O] [\*Vio redirection\*O]
.sp
\*Lrerun\*O [\*Vprogram arguments\*O] [\*Vio redirections\*O]
.rS 5
.PP
Use the
\*Lrun\*O
and
\*Lrerun\*O
commands to start program execution. Enter program flags, options, and input
and output redirections as arguments. If the
\*Lrerun\*O
command is specified without arguments, the arguments entered with the previous
\*Lrun\*O
command are used.
.rE
.PP
\*Lset\*O [\*Vvariable\*O \*L= \*O\*Vdefinition\*O]
.sp
\*Lunset\*O \*Vvariable\*O
.rS 5
.PP
To examine the definitions of all debugger variables,
enter the
\*Lset\*O
command without arguments.  (Use the
\*Lprint\*O
command to display the definition of a single debugger variable.)
.PP
To define a debugger variable, enter the
\*Lset\*O
command followed by a
variable name, an equal sign, and a definition. Enclose string definitions in
quotes. The definition can be any expression allowed by the language of the
program being debugged.
.PP
Use the
\*Lunset\*O
command to delete a variable.
.PP
The debugger contains many predefined variables to describe the current state
of the debugger, and to allow you to customize the debugger environment. You
can delete and redefine the predefined debugger variables in the same way you
define your own variables. If you delete a predefined debugger variable, the
debugger uses the default value for that variable.
.PP
The debugger has the following predefined variables:
.IP "\*L$curfile\*O    " 5
Specifies the current
source-code file.
.IP "\*L$curline\*O    " 5
Specifies the current
line in the source file.
.IP "\*L$cursrcline\*O    " 5
Specifies the line number of the last
line of source code listed plus one.
.IP "\*L$curpc\*O    "5
Specifies the current point of program execution.
The \*L$curpc\*O variable is used by the
\*Lwi\*O
and
\*Lli\*O
aliases.
.IP "\*L$eventecho\*O  " 5
When set to a nonzero value, echoes events (such as breakpoints) with event
numbers when executed. The default is 1.
.IP "\*L$eventecho\*O  " 5
When set to a nonzero value, echoes events (such as breakpoints) with event
numbers when executed. The default is 1.
.IP "\*L$hexints\*O   "5
When set to a nonzero value, all integers will be displayed as hexadecimal
numbers.
.IP "\*L$historylines\*O   " 5
Specifies the number of previously input commands listed in response to
the \*Lhistory\*O command. The default is 20.
.IP "\*L$indent\*O      " 5
If nonzero, specifies that structures will be printed with added indentation
to render them more readable.
.IP "\*L$lang\*O  " 5
Specifies the programming language used in the program being debugged.
For mixed-language programs,
\*L$lang\*O
is continuously updated to reflect the language being debugged.
.IP "\*L$listwindow\*O   " 5
Specifies how many lines the
\*Llist\*O
command displays.
The default is 20.
.IP "\*L$main\*O    " 5
Specifies the name of the function that the debugger enters first. The
default is \*Lmain()\*O, but this can be set to any function. This variable
is useful when debugging languages whose primary function is called something
other than
\*Lmain()\*O.
.IP "\*L$maxstrlen\*O   " 5
Specifies the maximum number of characters to print when the value of a
string is printed.
The default is 128.
.IP "\*L$octints\*O   " 5
When set to a nonzero value, all integers printed by the debugger will be
displayed as octal numbers.
.IP "\*L$overloadmenu\*O     " 5
When debugging C++ programs only, if this variable is
set to 1, a menu of overloaded functions is displayed
so you can select the desired function from the list of type
signatures of the function.
When set to 0, no menu is displayed, and you must
disambiguate overloaded functions by providing the full type signature.
The default is 0.
.IP "\*L$pimode\*O     " 5
Specifies whether the \*Lplayback input\*O command echoes input.
If set to 1, commands from the script file are echoed.
If set to 0, commands are not echoed.  The default is 0.
.IP "\*L$prompt\*O     " 5
Specifies the debugger prompt.
The default is \*L(DECladebug)\*O.
.IP "\*L$stepg0\*O    " 5
When set to 0, the debugger steps over calls to routines that are
compiled with with no symbol information.
When set to 1, the debugger will step into these calls.
The default is 0.
.IP "\*L$verbose\*O    " 5
Specifies whether debugger output should include all possible program
information, including base pointers and virtual function pointers (relevant
only when debugging C++ programs).
.rE
.PP
\*Lsh\*O \*Vcommand\*O
.rS 5
.PP
Use the
\*Lsh\*O
command to execute a Bourne shell command. Do not enclose the shell command and
its arguments in quotations.  For example:
.PP
.sp
\*C(DECladebug)\*O\*Lsh ls -l sample.c \*O
.rE
.PP
\*Lsource\*O \*Vfilename\*O
.rS 5
.PP
Use the
\*Lsource\*O
command and the
\*Lplayback input\*O
command to execute debugger commands contained within a file. Format commands
as if they were entered at the debugger prompt.
.PP
When a command file is executed, the value of the
\*L$pimode\*O
debugger variable determines whether the commands are echoed. If the
\*L$pimode\*O
variable is set to 1, commands are echoed; if
\*L$pimode\*O
is set to 0 (the default), commands are not echoed. The debugger output
resulting from the commands is always echoed.
.rE
.PP
\*Lstatus\*O
.rS 5
.PP
The
\*Lstatus
\*O
command lists all breakpoints and tracepoints, the reference
number associated with each, and whether the breakpoint is disabled.
.rE
.PP
\*Lstep\*O
.rS 5
.PP
Use the
\*Lnext\*O
and the
\*Lstep\*O
commands to execute a line of source code.
When the next line to be executed contains a function call, the
\*Lnext\*O
command executes the function being called and returns to the line
immediately after the function call. The
\*Lstep\*O
command executes only the first line of the function.
.rE
.PP
\*Lstepi\*O
.rS 5
.PP
Use the
\*Lstepi\*O
command and the
\*Lnexti\*O
command to execute a machine
instruction. When the instruction contains a function call, the
\*Lstepi\*O
command steps into the function being called, and the
\*Lnexti\*O
command executes the function being called.
.rE
.PP
\*Lstop \*Vvariable\*O
.sp
\*Lstop [\*Vvariable\*O] if \*Vexpression\*O
.sp
\*Lstop [\*Vvariable\*O] at \*Vlinenumber\*O [if \*Vexpression\*O]
.sp
\*Lstop [\*Vvariable\*O] in \*Vfunction\*O [if \*Vexpression\*O]
.rS 5
.PP
Enter the
\*Lstop\*O
command with a variable argument to suspend program execution when the variable
changes.
.PP
Specify an expression to suspend execution when the expression evaluates to
true.  When you specify both an expression and a variable, execution suspends
only if the specified expression evaluates to true and the variable has changed.
.PP
To suspend execution when a line or function is encountered, use the third or
fourth form.  If you specify a variable, execution suspends only if the
variable has changed when the line or function is encountered.  If you specify
an expression, execution suspends only if the expression evaluates true when
the line or function is encountered.  If you specify both a variable and an
expression, execution suspends only if the variable has changed and the
expression evaluates to true when the line or function is encountered.
.PP
The following example shows how to suspend program execution when
line number 10 is encountered and the variable
\*Vf\*O
is equal to 2:
.PP
For C++:
.PP
.sp
\*Lstop in \*O[\*Vclassname\*O::]\*Vfunction\*O
.sp
\*Lstop in \*Vobject\*O.\*Vfunction\*O
.sp
\*Lstop in \*Vobjectprt\*L->\*Vfunction\*O
.sp
\*Lstop in \*Vobject\*O.\*Vfunction\*L if (&\*Vobject\*L==this) \*O
.sp
\*Lstop in \*O[\*Vclassname\*L::\*O]\*Vclassname\*O[\*L(\*Vtype signature\*L)\*O]
.sp
\*Lstop in \*O[\*Vclassname\*L::\*O]\*L~\*Vclassname\*O
.sp
\*Lstop in \*O[\*Vclassname\*L::\*O]\*Vfunction\*O\*L(\*Vtype signature\*O|\*Lvoid)\*O
.sp
\*Lstop in all \*Vfunction\*O
.PP
The first form of the
\*Lstop\*O
command sets a breakpoint in a member function using the static class type
information. This form presumes that run-time information from an object is
needed to determine the address of the function at which to set the breakpoint.
.PP
If you need run-time information to determine the correct virtual function, use
the second or third form to qualify the function name with the object when you
set the breakpoint. Note that this way of setting the breakpoint causes the
debugger to stop at the member function in all objects declared with the same
class type as the specified object.
.PP
To set a breakpoint that stops only in the member function for this specific
object and not all instances of the same class type, use the fourth form of the
\*Lstop\*O
command.
.PP
The fifth and sixth forms set breakpoints in a constructor and destructor,
respectively.
.PP
To set a breakpoint in a specific version of an overloaded function, either set
\*L$overloadmenu\*O
to 1, enter the command
\*Lstop in\*O \*Vfunction\*O,
and choose the appropriate function from the menu, or specify the function and
the type signature as arguments to the command. If the overloaded function has
no parameters,
\*Lvoid\*O
must be explicitly specified.
.PP
Use the last form to set a breakpoint in all versions of an overloaded
function.
.PP
.sp
\*C(DECladebug)\*O\*Lstop at 10 if f==2\*O
.rE
.PP
\*Lstopi\*O \*Vvariable\*O
.sp
\*Lstopi\*O [\*Vvariable\*O] if \*Vexpression\*O
.sp
\*Lstopi [\*Vvariable\*O] in \*Vfunction\*O [if \*Vexpression\*O]
.sp
\*Lstopi [\*Vvariable\*O] at \*Vaddress\*O [if \*Vexpression\*O]
.rS 5
.PP
Enter the
\*Lstopi\*O
command with a variable to suspend execution when the variable value changes.
.PP
Specify an expression to suspend execution when the expression evaluates to
true.  When you specify both a variable and an expression, execution suspends
only if the specified expression evaluates to true and the variable has changed.
.PP
To suspend execution when an address or function is encountered, use the third
or fourth form.  If you specify a variable, execution suspends only if the
variable has changed when the address or function is encountered.  If you
specify an expression, execution suspends only if the expression evaluates to
true when the address or function is encountered.  If you specify both a
variable and an expression, execution suspends only if the variable has changed
and the expression evaluates to true when the address or function is
encountered.
.PP
The
\*Lstopi\*O
command is different from the
\*Lstop\*O
command because the
debugger checks the breakpoint set with the
\*Lstopi\*O
command after executing
each machine instruction. Thus, the debugger performance is affected when you
use the
\*Lstopi\*O
command.
.PP
The breakpoint in the following example stops program execution if the value
of variable
\*Vi\*O
changes while executing the function
\*Lfactorial\*O:
.sp
\*C(DECladebug)\*O\*Lstopi i in factorial\*O
.rE
.PP
\*Ltrace\*O [\*Vvariable\*O] [if \*Vexpression\*O]
.sp
\*Ltrace\*O [\*Vvariable\*O] at \*Vlinenumber\*O [if \*Vexpression\*O]
.sp
\*Ltrace\*O [\*Vvariable\*O] in \*Vfunction\*O [if \*Vexpression\*O]
.rS 5
.PP
When you use the
\*Ltrace\*O
command without an argument, the debugger prints a message, but does not
suspend program execution, when each function is entered.  Specify a variable
to print a message when the variable value changes.  Specify an expression to
print a message when an expression evaluates to true. When you specify both a
variable and an expression, a message is printed only if the expression
evaluates to true and the variable has changed.
.PP
To print a message when a line or function is encountered, use the second
or third form.  If you specify a variable, a message is printed only if the
variable has changed when the line or function is encountered. If you specify
an expression, a message is printed only if the expression evaluates to true
when the line or function is encountered. If you specify both a variable and an
expression, a message is printed only if the variable has changed and the
expression evaluates to true when the line or function is encountered.
.PP
The following example traces the variable
\*Vf\*O
when the program is executing the function
\*Lmain\*O:
.sp
\*C(DECladebug)\*O\*Ltrace f in main\*O
.rE
.PP
\*Ltracei\*O [\*Vvariable\*O] [if \*Vexpression\*O]
.sp
\*Ltracei\*O [\*Vvariable\*O] at \*Vaddress\*O [if \*Vexpression\*O]
.sp
\*Ltracei\*O [\*Vvariable\*O] in \*Vfunction\*O [if \*Vexpression\*O]
.rS 5
.PP
When you use the
\*Ltracei\*O
command the debugger prints a message, but does not suspend program execution.
Specify a variable to print a message when the variable value changes.  Specify
an expression to print a message when an expression evaluates to true.  When
you specify both a variable and an expression, a message is printed only if the
expression evaluates to true and the variable has changed.
.PP
To print a message when an address or function is encountered, use the second
or third form.  If you specify a variable, a message is printed only if the
variable has changed when the address or function is encountered.  If you
specify an expression, a message is printed only if the expression evaluates to
true when the address or function is encountered.  If you specify both a
variable and an expression, a message is printed only if the variable has
changed and the expression evaluates to true when the address or function is
encountered.
.PP
The
\*Ltracei\*O
command differs from the
\*Ltrace\*O
command in that the debugger evaluates the tracepoint set with the
\*Ltracei\*O
command after the
debugger executes each machine instruction. Thus, when you use the
\*Ltracei\*O
command, the debugger performance is affected.
.PP
In the following example, a breakpoint is set to print a message every time the
function
\*Lfactorial\*O
is entered:
.PP
.sp
\*C(DECladebug)\*O\*Ltracei factorial\*O
.rE
.PP
\*Lup\*O [\*Vnumber\*O]
.rS 5
.PP
Use the
\*Lup\*O
command or the
\*Ldown\*O
command without an argument to change the function scope to the function
located one level up or down the stack. Enter a number argument to change
the function scope to the function up or down the specified number of levels.
If the number of levels exceeds the number of active functions on the stack,
the function scope moves up or down as many levels as possible and the debugger
issues a warning message.
.PP
When the function scope changes, the debugger displays the source line
corresponding to the last point of execution in that function.
.rE
.PP
\*Luse\*O [\*Vdirectory\*O]
.sp
\*Lunuse\*O [\*Vdirectory\*O | \*L *\*O ]
.rS 5
.PP
Enter the
\*Luse\*O
command without an argument, to list the directories the debugger searches for
source-code files.  Specify a directory argument to make source-code files in
that directory available to the debugger. (You can also use the
\*L decladebug
command
\*L-I\*O
option to specify search directories.)
.PP
Enter the
\*Lunuse\*O
command without an argument to set the search list to the default, the home
directory, the current directory, and the directory containing the executable
file. Include the name of a directory to remove it from the search list. The
asterisk
(\*L*\*O)
argument removes all directories from the search list.
.rE
.PP
\*Lwhatis\*O \*Vexpression\*O
.rS 5
.PP
The
\*Lwhatis\*O
command prints the type of the specified expression. The
expression can be any expression that follows the syntax, scope, and visibility
rules of the program language.
.PP
For C++:
.PP
.sp
\*Lwhatis \*Vclassname\*O
.sp
\*Lwhatis\*O [\*Vclassname\*O::]\*Vmember\*O
.sp
\*Lwhatis \*O[\*Vclassname\*O::]\*Vfunction\*O
.PP
The first form of the
\*Lwhatis\*O
command displays the class type.
The second form displays the type of a member function or data member.
To display all versions of an overloaded function, use the third form.
.rE
.PP
\*Lwhen\*O \*Vvariable\*O {\*Vcommand\*O[;...]}
.sp
\*Lwhen\*O \*Vvariable\*O [if \*Vexpression\*O] {\*Vcommand\*O[;...]}
.sp
\*Lwhen\*O [\*Vvariable\*O] at \*Vlinenumber\*O [if \*Vexpression\*O] {\*Vcommand\*O[;...]}
.sp
\*Lwhen\*O [\*Vvariable\*O] in \*Vfunction\*O [if \*Vexpression\*O] {\*Vcommand\*O[;...]}
.rS 5
.PP
Use the
\*Lwhen\*O
command to suspend program execution and execute the specified command
when the variable changes value. The debugger command must be enclosed in
braces. Separate multiple commands with semicolons.
.PP
To execute a command when an expression evaluates to true, use the second form.
When you specify a variable and an expression, the command is executed only if
the expression evaluates true and the variable has changed.
.PP
To execute commands when a line or function is encountered, use the third form
or fourth form.  If you specify a variable, the command is executed only if the
variable has changed when the line or function is encountered.  If you specify
an expression, the command is executed only if the expression evaluates true
when the line or function is encountered. If you specify a variable and an
expression, the command is executed only if the variable has changed and the
expression evaluates to true when the line or function is encountered.
.PP
For example:
.sp
\*C(DECladebug)\*O\*Lwhen at 5 {list;where}\*O
.rE
.PP
\*Lwheni\*O \*Vvariable\*O {\*Vcommand\*O[;...]}
.sp
\*Lwheni\*O [\*Vvariable\*O] if \*Vexpression\*O {\*Vcommand\*O[;...]}
.sp
\*Lwheni\*O [\*Vvariable\*O] at \*Vaddress\*O [if \*Vexpression\*O] {\*Vcommand\*O[;...]}
.sp
\*Lwheni\*O [\*Vvariable\*O] in \*Vfunction\*O [if \*Vexpression\*O] {\*Vcommand\*O[;...]}
.rS 5
.PP
Use the
\*Lwheni\*O
command to suspend program execution and execute the specified command when
the variable changes value.  The debugger command must be enclosed in braces.
Separate multiple commands with semicolons.
.PP
To execute a command when an expression evaluates to true, use the second form.
When you specify a variable and an expression, the command is executed only if
the expression evaluates to true and the variable has changed.
.PP
To execute a command when an address or function is encountered, use the third
or fourth form.  If you specify a variable, the command is executed only if the
variable has changed when the address or function is encountered.  If you
specify an expression, the command is executed only if the expression evaluates
to true when the address or function is encountered.  If you specify a variable
and an expression, the command is executed only if the variable has changed and
the expression evaluates to true when the address or function is encountered.
.PP
The
\*Lwheni\*O
command differs from the
\*Lwhen\*O
command in that the debugger evaluates the tracepoint set with the
\*Lwheni\*O
command after each machine instruction is executed.  Thus, using the
\*Lwheni\*O
command effects performance.
.PP
For example, the following command stops
program execution, lists ten lines of source code and displays the stack trace
when the value of the variable
\*Li\*O
is equal to 3 in the function
\*Lmain\*O:
.PP
.sp
\*C(DECladebug)\*O\*Lwheni in main if i == 3 {w;where} \*O
.rE
.PP
\*Lwhere\*O [\*Vnumber\*O]
.rS 5
.PP
The
\*Lwhere\*O
command displays the stack trace of currently active functions. Include a
number argument to list that number of levels at the top of the stack. Each
active function is designated by a number which can be used as an argument
to the
\*Lfunc\*O
command.
.rE
.PP
\*Lwhereis\*O \*Vexpression\*O
.rS 5
.PP
The
\*Lwhereis\*O
command shows all declarations of the expression. Each declaration is fully
qualified with scope information.
.rE
.PP
\*Lwhich\*O \*Vexpression\*O
.rS 5
.PP
The
\*Lwhich\*O
command shows the fully qualified scope information for the instance of the
specified expression in the current scope. If available to the debugger, the
name of the source file containing the function in which the expression is
declared, the name of the function, and the name of the expression are
included. The components of the qualification are separated by period
(\*L.\*O)
characters.
.rE
.SS Debugging C++ Programs
There are two ways to disambiguate overloaded function names. To see a
selection menu each time you refer to an overloaded function name, set the
\*L$overloadmenu\*O
variable to 1 and choose the appropriate function. Alternatively,
use the type signature, as displayed by the
\*Lwhatis\*O
command,
to disambiguate overloaded functions. If the overloaded function has no
parameters,
\*Lvoid\*O
must be explicitly specified.
.PP
In stack traces, the implicit
\*Lthis\*O
pointer that is a part of all
nonstatic member functions is displayed as an address. The class type
of the object is also given. The syntax for a member function on the
stack trace is:
.PP
((\*Vthis class type\*O*)\*Vthis address\*O)->\*Vfunction\*O(\*Vfunction parameters\*O)
.PP
The debugger provides support for function templates and class templates
with some limitations. For class templates, it is not possible to use the
\*Lstop\*O, \*Lwhatis\*O,
or
\*Lclass\*O
command on the template name, but you can use the
\*Lstop\*O, \*Lwhatis\*O,
or
\*Lclass\*O
command on a specific instantiation of the
class template. Note that the instantiated name is printed by the debugger
when variables of a template class type are encountered.
.PP
The following examples show some commands involving templates:
.PP
\*C(DECladebug)\*O\*Lwhatis stack<int,100>  \*O
.sp
\*C(DECladebug)\*O\*Lstop in stack<int,100>::pop\*O
.sp
\*C(DECladebug)\*O\*Lclass stack<int,100> \*O
.PP
In the debugger, expressions in the instantiated template name can be full
constant expressions such as
\*Lstack<double,f*10>\*O.
Note that setting a
breakpoint by a line number that is inside a template function will not
necessarily stop at all instantiations of the function within the given file,
but only a randomly chosen few.
.PP
You can debug exception handlers by setting breakpoints in the exception
handler or in the predefined C++ functions that are used when exceptions
occur. You can also examine and modify variables that are used in
exception handlers.
.PP
The
\*L$verbose\*O
debugger variable determines whether the debugger prints all
possible information about class hierarchies. If you set the
\*L$verbose\*O
variable to 1 (0 is the default), the debugger displays virtual table
information, structures' contents in stack traces, compiler-generated
parameters, compiler-generated member functions, and compiler-generated
temporary variables in response to subsequent queries.
.SS Debugging Mixed-Language Programs
The debugger scans the executable file being debugged and automatically sets
the
\*L$lang\*O
variable to the language appropriate for the current code
segment. When
\*L$lang\*O
is set to
\*LC\*O
the debugger interprets all
expressions using ANSI C syntax rules.  When
\*L$lang\*O
is set to
\*LC++\*O,
the debugger interprets all expressions using C++ syntax rules as defined in
\*IThe Annotated C++ Reference Manual\*O.
.SH RESTRICTIONS
.PP
The maximum command-line length
is 255 characters.
.PP
Alias commands may contain no more than 56 arguments.
.SH FILES
.PP
.VL 11m
.LI "\*La.out\*O"
Object file
.LI "\*Lcore\*O"
Core dump file
.LI "\*L.dbxinit\*O"
Initialization file
.LE
.SH RELATED INFORMATION
.PP
\*Lc89\*O1, \*Lcc\*O1, \*Lcxx\*O1, \*Lprintf\*O1, \*Lsignal\*O3, and the
\*VGuide to the DECladebug Debugger\*O.
.EQ
delim off
.EN
