.\" This manpage source uses rsml coding. 
.so /usr/share/lib/tmac/sml
.so /usr/share/lib/tmac/rsml
.\"
.\"
.\" *********************************************************************
.\" *                                                                   *
.\" *      Copyright (c) Digital Equipment Corporation, 1991, 1994      *
.\" *                                                                   *
.\" *                       All Rights Reserved.                        *
.\" *                                                                   *
.\" *********************************************************************
.\"
.\"
.\" HISTORY
.\"
.\" @(#)$RCSfile: lex.1,v $ $Revision: 3.2.5.3 $ (DEC) $Date: 1994/01/18 15:24:53 $
.\"
.\" 
.\" (c) Copyright 1991, OPEN SOFTWARE FOUNDATION, INC.
.\" ALL RIGHTS RESERVED
.\" 
.TH lex 1
.SH NAME
\*Llex\*O \- Generates a C Language program that matches patterns for simple lexical analysis of an input stream
.SH SYNOPSIS
.PP
.sS
\*Llex\*O
\*O[\*L-tnv\*O]
\*O[\*Vfile\*O
\&...]
.sE
.PP
The \*Llex\*O command reads \*Vfile\*O or standard input,
generates a C Language program, and writes it to a file named
\*Llex.yy.c\*O, which is a compilable C Language program.
.SH FLAGS
.PP
.VL 4m
.LI "\*L-n\*O"
Suppresses the statistics summary.
When you set your own table sizes for the finite state machine,
\*Llex\*O automatically produces this summary if you do not select this flag.
.LI "\*L-t\*O"
Writes \*Llex.yy.c\*O to standard output instead of to a file.
.LI "\*L-v\*O"
Provides a one-line summary of the generated finite state machine
statistics.
.LE
.SH DESCRIPTION
.iX "lex command"
.iX "programs" "C"
.iX "generating" "C programs"
.iX "C language" "generating programs"
.iX "lexical analysis"
.PP
The \*Llex\*O command uses the \*Vrules\*O and
\*Vactions\*O contained in \*Vfile\*O to generate a program,
\*Llex.yy.c\*O, which can be compiled with the \*Lcc\*O
command.  That program
can then receive input, break the input into the logical
pieces defined by the rules in \*Vfile\*O, and run
program fragments contained in the actions in \*Vfile\*O.
.\" For a more detailed discussion of \*Llex\*O and its operation, see
.\" "Creating Input Language Analyzers and Parsers" in the %\&%\&NOMAP_DNOProgEnvGde_DNOProgEnvSuppl%\&%\&.
.PP
The generated program is a C Language function called \*Lyylex()\*O.
The \*Llex\*O command stores \*Lyylex()\*O in a file named
\*Llex.yy.c\*O.  You can use \*Lyylex()\*O alone to recognize
simple, 1-word input, or you can use it with other C Language programs
to perform more difficult input analysis functions.  For example, you
can use \*Llex\*O to generate a program that tokenizes an input
stream before sending it to a parser program generated by the
\*Lyacc\*O command.
.PP
The \*Lyylex()\*O function analyzes the input stream using a
program structure called a \*Vfinite state machine\*O.
This structure allows the program to exist in only one state (or
condition) at a time.  There is a finite number of states allowed.
The rules in \*Vfile\*O determine how the program moves from one
state to another based on the input the program receives.
.PP
The \*Llex\*O command reads its skeleton finite state machine from the file
.\" \*L/usr/ccs/lib/lex/ncform\*O.  
\*L/usr/ccs/lib/ncform\*O. Use the environment variable
\*LLEXER\*O to specify another location for \*Llex\*O to read from.
.PP
If you do not specify a file, \*Llex\*O reads standard input.
It treats multiple files as a single file.
.SS Input File Format
The input file can contain three sections:  definitions, rules, and
user subroutines.
Each section must be separated from the others by a line containing only
the delimiter, \*L%\&%\&\*O.  The format is as follows:
.iS
\*Vdefinitions\*O
\*L%\&%\&\*O
\*Vrules\*O
\*L%\&%\&\*O
\*Vuser_subroutines\*O
.iE
.PP
The purpose and format of each are described in the
following sections.
.SS Definitions
If you want to use variables in rules, you must define them in this section.
The variables make up the left column, and their definitions make up the
right column.  For example, to define \*LD\*O as a numerical digit,
enter:
.iS
D	[0-9]
\*O\c
.iE
.PP
You can use a defined variable in the rules section by enclosing the
variable name in braces, \*L{D}\*O.
.PP
In the definitions section, you can also set table sizes for the resulting
finite state machine.
The default sizes are large enough for small programs.
You may want to set larger sizes for more complex programs.
.VL 8m
.LI "\*L%p  \*Vnumber\*O"
Number of positions is \*Vnumber\*O (default 5000)
.LI "\*L%n  \*Vnumber\*O"
Number of states is \*Vnumber\*O (default 2500)
.LI "\*L%e  \*Vnumber\*O"
Number of parse tree nodes is \*Vnumber\*O (default 2000)
.LI "\*L%a  \*Vnumber\*O"
Number of transitions is \*Vnumber\*O (default 5000)
.LI "\*L%k  \*Vnumber\*O"
Number of packed character classes is \*Vnumber\*O (default 1000)
.LI "\*L%o  \*Vnumber\*O"
Number of output slots is \*Vnumber\*O (default 5000)
.LE
.PP
If extended characters
appear in regular expression strings, you may need to reset the output
array size with the \*L%o\*O parameter (possibly to array sizes in
the range 10,000 to 20,000).  This reset reflects the much larger number
of characters relative to the number of ASCII characters.
.SS Rules
Once you have defined your terms, you can write the rules section.
In this section, the left column contains the pattern to be recognized
in an input file to \*Lyylex()\*O.  The right column contains
the C program fragment executed when that pattern is recognized.
This section is required, and it must be preceded by the
\*L%\&%\&\*O delimiter, whether or not you have a definitions section.  The
\*Llex\*O command does not recognize rules without this delimiter.
.PP
Patterns can include extended characters with one exception: these
characters may not appear in range specifications
within character class expressions surrounded by brackets.
.PP
The columns are separated by a tab.
For example, to search
files for the word \*LLEAD\*O and replace it with \*LGOLD\*O,
perform the following steps:
.PP
Create a file called \*Ltransmute.l\*O containing the lines:
.iS
%\&%\&
(LEAD)  printf("GOLD");
\*O\c
.iE
.PP
Then issue the following commands to the shell:
.iS
lex transmute.l
cc -o transmute lex.yy.c -ll
\*O\c
.iE
.PP
You can test the resulting program with the command:
.iS
transmute <transmute.l
\*O\c
.iE
.PP
This command echoes the contents of \*Ltransmute.l\*O, with the
occurrences of \*LLEAD\*O changed to \*LGOLD\*O.
.PP
Each pattern may have a corresponding action, that is,
a fragment of C source code to execute
when the pattern is matched.  Each statement must end with a ; (semicolon).
If you use more than one statement in an action, you must enclose all of
them in {\^} (braces).
A second delimiter, \*L%\&%\&\*O, must follow the rules section if you
have a user subroutine section.
.PP
When \*Lyylex()\*O matches a string in the input stream, it copies
the matched text to an external character array, \*Lyytext\*O,
before it executes any actions in the rules section.
.PP
You can use the following operators to form patterns that you want to
match:
.VL 4m
.LI "\*Vx\*O, \*Vy\*O"
Matches the characters written.
.LI "\*L[ ]\*O"
Matches any one character in the enclosed range
([.-.]) or the enclosed list ([...]).
[\*Labcx-z\*O] matches \*La\*O,\*Lb\*O,\*Lc\*O,\*Lx\*O,\*Ly\*O, or \*Lz\*O.
.\" PROBLEM HERE - unable to get the " " on the next line to output
.LI "\*L\&""""\0""""\*O"
Matches the enclosed character or string even if it is an operator.
\*L"$"\*O prevents \*Llex\*O from interpreting the \*L$\*O character
as an operator.
.LI "\*L\e\*O"
Acts the same as double quotes.  \*L\e$\*O prevents
\*Llex\*O from interpreting the \*L$\*O character as an operator.
.LI "\*L*\*O"
Matches zero or more occurrences of the character immediately
preceding it.  \*Vx\*L*\*O matches zero or more repeated literal characters
\*Vx\*O.
.LI "\*L\(pl\*O"
Matches one or more occurrences of the character immediately preceding it.
.LI "\*L?\*O"
Matches either zero or one occurrence of the character immediately preceding it.
.LI "\*L^\*O"
Matches the character only at the beginning of a line.
\*L^x\*O matches an \*Lx\*O at the beginning of a line.
.LI "\*L[^]\*O"
Matches any character but the ones following the \*L^\*O.  For example,
\*L[^xyz]\*O matches any character but \*Lx\*O, \*Ly\*O, or \*Lz\*O.
.\" If japanese Language Support is installed on your system, the
.\"character following the \*L^\*O (circumflex) cannot be a multi-byte character.
.LI "\*L\&.\*O"
Matches any character except the newline character.
.LI "\*L$\*O"
Matches the end of a line.
.LI "\*L|\*O"
Matches either of two characters.
\*Lx | y\*O matches either \*Lx\*O or \*Ly\*O.
.LI "\*L/\*O"
Matches one character only when followed by a second character.
It reads only the first character into \*Lyytext\*O.
\*Lx/y\*O matches \*Lx\*O when it is followed by \*Ly\*O, and reads \*Lx\*O
into \*Lyytext\*O.
.LI "\*L( )\*O"
Matches the pattern in the ( ) (parentheses).
This is used for grouping.
It reads the whole pattern into \*Lyytext\*O.
A group in parentheses can be used in place of any single character in
any other pattern.
\*L(xyz123)\*O matches the pattern \*Lxyz123\*O and reads the
whole string into \*Lyytext\*O.
.LI "\*L{}\*O"
Matches the character as defined in the \*LDefinitions\*O section.
If \*LD\*O is defined as numeric digits, \*L{D}\*O matches
all numeric digits.
.LI "\*L{\*Vm\*O,\*Vn\*O}"
Matches \*Vm\*O to \*Vn\*O occurrences of the
character.  \*Lx{2,4}\*O matches 2, 3, or 4 occurrences of \*Lx\*O.
.LE
.PP
If a line begins with only a space, \*Llex\*O copies it to the
\*Llex.yy.c\*O output file.
If the line is in the
.\" declarations 
definitions section of \*Vfile\*O,
\*Llex\*O copies it to the declarations section of
\*Llex.yy.c\*O.
If the line is in the rules section, \*Llex\*O copies it to the
program code section of \*Llex.yy.c\*O.
.SS User Subroutines
The \*Llex\*O library has three subroutines defined as
macros that you can use in the rules.
.VL
.LI "\*Linput( )\*O"
Reads a character from \*Lyyin\*O.
.LI "\*Lunput( )\*O"
Replaces a character after it is read.
.LI "\*Loutput( )\*O"
Writes an output character to \*Lyyout\*O.
.LE
.PP
You can override these three macros by writing your own code
for these routines in the user subroutines section.
But if you write your own, you must undefine these macros in the
definitions section as follows:
.iS
%{
#undef input
#undef unput
#undef output
}%
\*O\c
.iE
.PP
When you are using \*Llex\*O as a simple transformer/recognizer for
\*Lstdin\*O to \*Lstdout\*O piping, you can avoid writing the
\*Vframework\*O by using \*Llibl.a\*O (the \*Llex\*O library).  It has a
main routine that calls \*Lyylex()\*O for you.
.PP
External names generated by \*Llex\*O all begin with the
prefix \*Lyy\*O, as in \*Lyyin\*O, \*Lyyout\*O,
\*Lyylex\*O, and \*Lyytext\*O.
.SS Putting Spaces in an Expression
Normally, spaces or tabs end a rule and therefore, the expression
that defines a rule.  However, you can enclose the spaces or tab
characters in "" (double quotes) to include them in the expression.
Use quotes around all spaces in expressions that are not already
within sets of [ ] (brackets).
.SS Other Special Characters
The \*Llex\*O program recognizes many of the normal C language
special characters.  These character sequences are as follows:
.iS
Sequence		Meaning
\*L\en\*O			Newline
\*L\et\*O			Tab
\*L\eb\*O			Backspace
\*L\e\e\*O			Backslash
.iE
.PP
Do not use the actual newline character in an expression.
.PP
When using these special characters in an expression, you do not
need to enclose them in quotes.  Every character, except these
special characters and the previously described operator symbols,
is always a text character.
.SS Matching Rules
When more than one expression can match the current input,
\*Llex\*O chooses the longest match first.  Among rules that match
the same number of characters, the rule that occurs first is
chosen.  For example:
.iS
integer\*O \*Vkeyword action\*L...;\*O
\*L[a-z]+\*O \*Videntifier action\*L...;\*O\c
.iE
.PP
If the preceding rules are given in that order, and \*Lintegers\*O
is the input word, \*Llex\*O matches the input as an identifier
because \*L[a-z]+\*O matches eight characters, while
\*Linteger\*O matches only seven.  However, if the input is
\*Linteger\*O, both rules match seven characters.  \*Llex\*O
selects the \*Lkeyword\*O rule because it occurs first.
A shorter input, such as \*Lint\*O, does not match the expression
rule \*Linteger\*O and so \*Llex\*O selects the rule \*Lidentifier\*O.
.SS Matching a String with Wildcard Characters
Because \*Llex\*O chooses the longest match first, do not use rules
containing expressions like \*L\&.*\*O.  For example:
.iS
\&'\&.*\&'
\*O\c
.iE
.PP
The preceding rule might seem like a good way to recognize a string
in single quotes.  However, the lexical analyzer reads far ahead,
looking for a distant single quote to complete the long match.  If
a lexical analyzer with such a rule gets the following input,
it matches the whole string:
.iS
\&'first' quoted string here, 'second' here
\*O\c
.iE
.PP
To find the smaller strings, \*Lfirst\*O and \*Lsecond\*O, use the
following rule:
.iS
\&'[^'\en]*'
\*O\c
.iE
.PP
This rule stops after matching \*L'first'\*O.
.PP
Errors of this type are not far-reaching because the \&. (dot)
operator does not match a newline character.  Therefore,
expressions like \*L\&.*\*O stop on the current line.  Do not try
to defeat this with expressions like \*L[\&.\en] +\*O.
The lexical analyzer tries to read the entire input file and an
internal buffer overflow occurs.
.SS Finding Strings within Strings
The \*Llex\*O program partitions the input stream, and does not
search for all possible matches of each expression.  Each character
is accounted for once and only once.  For example, to count
occurrences of both \*Lshe\*O and \*Lhe\*O in an
input text, try the following rules:
.iS
she	s++;
he	h++;
\en	|
\&.	;
\*O\c
.iE
.PP
The last two rules ignore everything besides \*Lhe\*O and \*Lshe\*O.
However, because \*Lshe\*O includes \*Lhe\*O, \*Llex\*O does
not recognize the instances of \*Lhe\*O that are included in \*Lshe\*O.
.PP
To override this choice, use the \*LREJECT\*O action.  This
directive tells \*Llex\*O to go to the next rule.  \*Llex\*O then
adjusts the position of the input pointer to where it was before
the first rule was executed, and executes the second choice rule.
For example, to count the included instances of \*Lhe\*O, use the
following rules:
.iS
she	{s++; REJECT;}
he	{h++; REJECT;}
\en	|
\&.	;
\*O\c
.iE
.PP
After counting the occurrences of \*Lshe\*O, \*Llex\*O rejects the
input stream and then counts the occurrences of \*Lhe\*O.  Because
in this case, \*Lshe\*O includes \*Lhe\*O, but not vice versa, you
can omit the \*LREJECT\*O action on \*Lhe\*O.  In other cases, it
may be difficult to determine which input characters are in both
classes.
.PP
In general, \*LREJECT\*O is useful whenever the purpose of
\*Llex\*O is not to partition the input stream but to detect all
examples of some items in the input, and the instances of these
items may overlap or include each other.
.\" .SS Japanese Language Support
.\" .PP 
.\" If Japanese Language Support is enabled on your system, patterns
.\" in rules can include SJIS characters, with the following exception:
.\" these characters may not appear in range specifications
.\" within character class expressions surrounded by brackets.
.\" .PP 
.\" In addition,
.\" if Japanese Language Support is enabled on your system, the
.\" character following the \*L^\*O (circumflex) in pattern-matching
.\" operations cannot be a multi-byte character.
.SH EXAMPLES
.PP
.AL
.LI
The following command
draws \*Llex\*O instructions from the file
\*Llexcommands\*O, and places the output in
\*Llex\&.yy\&.c\*O:
.iS
lex lexcommands
\*O\c
.iE
.LI
The contents of the file \*Llexcommands\*O
are an example of a \*Llex\*O program that would be put
into a \*Llex\*O command file.  This program converts
uppercase to lowercase, removes spaces at the end of a line, and
replaces multiple spaces with single spaces:
.iS
%\&%\&
[A-Z] putchar(tolower(yytext[0]));
[ ]+$ ;
[ ]+ putchar(' ');
\*O\c
.iE
.LE
.SH NOTES
.PP
Because \*Llex\*O uses fixed names for intermediate and output files,
you can have only one \*Llex\*O-generated program in a given directory.
.SH FILES
.PP
.VL 11m
.LI "\*L/usr/ccs/lib/libl.a\*O"
Run-time library.
.\" .LI "\*L/usr/ccs/lib/lex/ncform\*O" 
.\" Begin Digital-specific information - CORRECTION
.\" Add C language to ncform, add nrform description
.LI "\*L/usr/ccs/lib/ncform\*O"
Default C language skeleton finite state machine for \*Llex\*O.
.LI "\*L/usr/ccs/lib/nrform\*O"
Default RATFOR language skeleton finite state machine for \*Llex\*O.
.\" End Digital-specific information - CORRECTION
.LE
.SH RELATED INFORMATION
.PP
Commands:  \*Lyacc\*O(1).
.\" .PP 
.\" "Creating Input Language Analyzers and Parsers" in the %\&%\&NOMAP_DNOProgEnvGde_DNOProgEnvSuppl%\&%\&.
.\" .PP 
.\" "Using Internationalization Features" in the \*E***THIS IS NOT A VALID TAG***\*O.
.\" .PP 
.\" The \*Las\*O, \*Lgcc\*O (\*Lcc\*O), \*Lgdb\*O, and \*Lld\*O
.\" commands may be available on your system, but are not provided with OSF/1.
.PP
\*EProgramming Support Tools\*O
.EQ
delim off
.EN
