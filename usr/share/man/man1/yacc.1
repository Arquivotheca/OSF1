.\" This manpage source uses rsml coding. 
.so /usr/share/lib/tmac/sml
.so /usr/share/lib/tmac/rsml
.\"
.\"
.\" *********************************************************************
.\" *                                                                   *
.\" *      Copyright (c) Digital Equipment Corporation, 1991, 1994      *
.\" *                                                                   *
.\" *                       All Rights Reserved.                        *
.\" *                                                                   *
.\" *********************************************************************
.\"
.\"
.\" HISTORY
.\"
.\" @(#)$RCSfile: yacc.1,v $ $Revision: 3.2.5.4 $ (DEC) $Date: 1993/12/03 14:41:44 $
.\"
.\" 
.\" (c) Copyright 1991, OPEN SOFTWARE FOUNDATION, INC.
.\" ALL RIGHTS RESERVED
.\" 
.TH yacc 1
.SH NAME
\*Lyacc\*O \- Generates an LR(\&1) parsing program from input consisting of a context-free grammar specification
.SH SYNOPSIS
.PP
.sS
\*Lyacc\*O
\*O[\*L\(hyvltds\*O]
\*O[\*L\(hyb\ \*Vprefix\*O]
\*O[\*L\(hyN\ \*Vnumber\*O]
\*O[\*L\(hyp\ \*Vsymbol_prefix\*O]
\*O[\*L\(hyP\ \*Vpathname\*O]
\*Vgrammar\*O
.sE
.PP
The \*Lyacc\*O command converts a context-free grammar specification into a
set of tables for a simple automaton that executes an LR(\&1) parsing algorithm.
.SH FLAGS
.PP
.VL 4m
.LI "\*L-b \*Vprefix\*O"
Uses \*Vprefix\*O instead of \*Ly\*O as the prefix for all output
filenames (\*Vprefix\*L\&.tab\&.c\*O, \*Vprefix\*L\&.tab\&.h\*O,
and \*Vprefix\*L\&.output\*O).
.LI "\*L-d\*O"
Produces the \*Ly.tab.h\*O file, which contains the
\*L#define\*O statements that associate the
\*Lyacc\*O-assigned token codes with your token names.  This allows
source files other than \*Ly.tab.c\*O to access the token codes by
including this header file.
.LI "\*L-l\*O"
Includes no \*L#line\*O constructs in
\*Ly.tab.c\*O.  Use this only after the grammar and associated
actions are fully debugged.
.LI "\*L-N \*Vnumber\*O"
Provides \*Lyacc\*O with extra storage for building its LALR tables,
which may be necessary when compiling very large grammars.  The\*Vnumber\*O
should be larger than 40,000 when you use this flag.
.LI "\*L-p \*Vsymbol_prefix\*O"
Allows multiple \*Lyacc\*O parsers to be linked together.  Use
\*Vsymbol_prefix\*O instead of \*Lyy\*O to prefix global symbols.
.LI "\*L-P \*Vpathname\*O"
Specifies an alternative parser (instead of \*L/usr/ccs/lib/yaccpar\*O).
The \*Vpathname\*O specifies the filename of the skeleton to be used in
place of \*Lyaccpar\*O).
.LI "\*L-s\*O"
Breaks the \*Lyyparse()\*O function into several smaller
functions.  Because its size is somewhat proportional to that of the
grammar, it is possible for \*Lyyparse()\*O to become too large to
compile, optimize, or execute efficiently.
.LI "\*L-t\*O"
Compiles run-time debugging code.  By default, this code is not
included when \*Ly.tab.c\*O is compiled.
If \*LYYDEBUG\*O has a nonzero value, the C compiler (\*Lcc\*O)
includes the debugging code, whether or not the \*L-t\*O flag was
used.  Without compiling this code, \*Lyyparse()\*O will
run more quickly.
.LI "\*L-v\*O"
Produces the \*Ly.output\*O file, which contains a readable
description of the parsing tables and a report on conflicts generated by
grammar ambiguities.
.LE
.SH DESCRIPTION
.iX "yacc command"
.iX "programs" "generating"
.iX "parsing" "program" "generating:
.iX "programs" "parsing"
.iX "generating" "parsing programs"
.iX "context-free grammar specification"
.iX "grammar specification, context-free"
.PP
The \*Lyacc\*O grammar can be ambiguous; specified precedence rules are
used to break ambiguities.
.PP
You must compile the \*Ly.tab.c\*O output file with a C language
compiler to produce the \*Lyyparse()\*O function.  This function must
be loaded with a \*Lyylex\*O lexical analyzer function, as well
as \*Lmain()\*O and \*Lyyerror()\*O, an error-handling routine
(you must provide these routines).  The \*Llex\*O command is useful
for creating lexical analyzers usable by \*Lyacc\*O.
.PP
The \*Lyacc\*O program reads its skeleton parser from the file
\*L/usr/ccs/lib/yaccpar\*O.  Use the environment variable
\*LPARSER\*O to specify another location for \*Lyacc\*O to read from.
.PP
.\" For more detailed discussion of \*Lyacc\*O and its operations,
.\" see "Creating Input Language Analyzers and Parsers" in the %\&%\&NOMAP_DNOProgEnvGde_DNOProgEnvSuppl%\&%\&.
.SS "Syntax for yacc Input"
.if n .PP
This section contains a formal description of the \*Lyacc\*O input
file (or grammar file), which
is normally named with a \*L\&.y\*O suffix.  The section
provides a listing of
the special values, macros, and functions recognized by \*Lyacc\*O.
.if n .PP
The general format of the \*Lyacc\*O input file is:
.iS
[ \*Vdefinitions\*O ]
\*L%\&%\&\*O
[ \*Vrules\*O ]
[ \*L%\&%\&\*O
[ \*Vuser functions\*O ] ]
.iE
where
.VL
.LI "definitions"
Is the section where you define the variables to be used later in the
grammar, such as in the
rules section.  It is also where files are included
(\*L#include\*O) and processing conditions are defined.  This section
is optional.
.LI "rules"
Is the section that contains grammar rules for the parser.  A
\*Lyacc\*O input file must have a rules section.
.LI "user functions"
Is the section that contains user-supplied functions that can be used
by the actions in the rules section.
This section is optional.
.LE
.PP
The NULL character must not be used in grammar rules or literals.
Each line in the \*Vdefinitions\*O can be:
.PP
\*L%{\*O
.VL
.LI "\*L%}\*O"
When placed on lines by themselves, these enclose C code to be passed into the
global definitions of the output file.  Such lines commonly include
preprocessor directives and declarations of external variables and functions.
.LI "\*L%token [\*Vtype\*O] \*Vtoken\*O [\*Lnumber\*O] [\*Lname\*O [\*Lnumber\*O]..."
.nL
Lists tokens or tty symbols to be used in the rest of the input file.
This line is needed for tokens that do not appear in other \*L%\*O
definitions. If \*Ltype\*O is present, the C type for all tokens on this
line is declared to be the type referenced by \*Ltype\*O. If a positive
integer \*Lnumber\*O follows a token, that value is assigned to the
token.
.LI "\*L%left [<\*Vtype\*O>] \*Vtoken\*O [ \*Vnumber\*O][\*Lname\*O[\*Lnumber\*O]]..."
.nL
Indicates that each \*Vtoken\*O is an operator, that all tokens in this
definition have equal precedence, and that a succession of the operators
listed in this definition are evaluated left to right.
.LI "\*L%right  [<\*Vtype\*O>] \*Vtoken\*O [\*Lnumber\*O] [\*Lname\*O \ [\*Lnumber\*O]]..."
.nL
Indicates that each \*Vtoken\*O is an operator, that all tokens in this
definition have equal precedence, and that a succession of the operators
listed in this definition are evaluated right to left.
.LI "\*L%nonassoc [<\*Vtype\*O>] \*Lname\*O [ \*Vnumber\*O ] [\*Lname\*O \ [ \*Lnumber\*O]]..."
.nL
Indicates that each \*Vtoken\*O is an operator, and that the operators listed
in this definition cannot appear in succession. Indicates that the token
cannot be used associatively.
.LI "\*L%start \*Vsymbol\*O"
.nL
Indicates the highest-level production rule to be reduced; in other words, the
rule where the parser can consider its work done and terminate.  If this
definition is not included, the parser uses the first production rule.
The \*Vsymbol\*O must be non-terminal (not a token).
.LI "\*L%type < \*Vtype\*O > \*Vsymbol\*O [ \*Vsymbol\*O ... ]"
.nL
Defines each \*Vsymbol\*O as data type \*Vtype\*O, to resolve
ambiguities. If this construct is present, \*Lyacc\*O performs type
checking and otherwise assumes all symbols to be of type \*Linteger\*O.
.LI "\*L%union \*Vunion-def\*O"
.nL
Defines the \*Lyylval\*O global variable as a union, where \*Vunion-def\*O
is a standard C definition in the format:
.iS
{ \*Vtype\*O \*Vmember\*O ; [ \*Vtype\*O \*Vmember\*O ; ... ] }
.iE
.IP
At least one member should be an \*Lint\*O.  Any valid C data type can be
defined, including structures.  When you run \*Lyacc\*O with the \*L\-d\*O
option, the definition of \*Lyylval\*O is placed in the \*Ly.tab.h\*O file and
can be referred to in a \*Llex\*O input file.
.LE
.PP
Every token (non-terminal symbol) must be listed in one of the preceding
\*L%\*O definitions.  Multiple tokens can be separated by white space or
.\" UNDOCUMENTED : The documentation I've seen always uses white space.  But
.\" the source code explicitly ignores commas, allowing them to be used as
.\" separators.  I bet this will work on any version of yacc.
commas.  All the tokens in \*L%left\*O, \*L%right\*O, and \*L%nonassoc\*O
definitions are assigned a precedence with tokens in later definitions having
precedence over those in earlier definitions.
.PP
In addition to symbols, a token can be literal character
enclosed in single quotes.
.\" .zA "review, R1.1.2, XPG4"
(Multibyte characters are recognized by the lexical analyzer and
returned as tokens.)
The following special characters can be used, just as in C programs:
.VL 3m
.LI "\*L\ea\*O"
Alert
.LI "\*L\en\*O"
Newline
.LI "\*L\et\*O"
Tab
.LI "\*L\ev\*O"
Vertical tab
.LI "\*L\er\*O"
Carriage Return
.LI "\*L\eb\*O"
Backspace
.LI "\*L\ef\*O"
Form Feed
.LI "\*L\e\e\*O"
Backslash
.LI "\*L\e'\*O"
Single Quote
.LI "\*L\e?\*O"
Question mark
.LI "\*L\e\*Vn\*O"
One or more octal digits specifying the integer value of the character
.LE
.\" .zZ "review, R1.1.2, XPG4"
.PP
The \*Vrules\*O section consists of a series of production rules that the
parser tries to reduce.  The format of each production rule is:
.iS
.if n .in 0
\*Vsymbol\*O : \*Vsymbol-sequence\*O [ \*Vaction\*O ] [ \(br \*Vsymbol-sequence\*O [ action ] ... ]  ;
\&.in
.iE
.PP
where \*Vsymbol-sequence\*O consists of zero or more symbols separated by
white space.  The first \*Vsymbol\*O must be the first character of the line,
but newlines and other white space can appear anywhere else in the rule.  All
terminal symbols must be declared in \*L%token\*O definitions.
.PP
Each \*Vsymbol-sequence\*O represents an alternative way of reducing the rule.
A symbol can appear recursively in its own rule.  Always use left-recursion
(where the recursive symbol appears before the terminating case in
\*Vsymbol-sequence\*O).
.PP
The specific sequence:
.oS
\*L%prec \*Vtoken\*O
.oE
indicates that the current sequence of symbols is to be preferred over others,
at the level of precedence assigned to \*Vtoken\*O in the \*Vdefinitions\*O
section.
.PP
The specially defined token \*Lerror\*O matches any unrecognized sequence of
input.  This token causes the parser to invoke the \*Lyyerror\*O function.  By
default, the parser tries to synchronize with the input and continue
processing it by reading and discarding all input up to the symbol following
\*Lerror\*O.  (You can override this behavior through the \*Lyyerrok\*O
action.)  If no \*Lerror\*O token appears in the \*Lyacc\*O input file, the
parser exits with an error message upon encountering unrecognized input.
.PP
The parser always executes \*Vaction\*O after encountering the symbol that
precedes it.  Thus, an action can appear in the middle of a
\*Vsymbol-sequence\*O, after each \*Vsymbol-sequence\*O, or after multiple
instances of \*Vsymbol-sequence\*O.  In the last case, \*Vaction\*O is
executed when the parser matches any of the sequences.
.PP
The \*Vaction\*O consists of standard C code within braces and can
also take the following values, variables, and keywords.
.VL
.LI "\*Lyylval\*O"
If the token returned by the \*Lyylex\*O function is associated with a
significant value, \*Lyylex\*O should place the value in this global variable.
By default, \*Lyylval\*O is of type \*Lint\*O.  The definitions section can
include a \*L%union\*O definition to associate with other data types,
including structures.  If you run \*Lyacc\*O with the
\*L\-d\*O option, the full \*Lyylval\*O definition is passed into the
\*Ly.tab.h\*O file for access by \*Llex\*O
.LI "\*Lyyerrok\*O"
Causes the parser to start parsing tokens immediately after an erroneous
sequence, instead of performing the default action of reading and discarding
tokens up to a synchronization token.  The \*Lyyerrok\*O action should appear
immediately after the \*Lerror\*O token.
.LI "\*L$ [ <\*Vtype\*O> ] \*Vn\*O"
Refers to symbol \*Vn\*O, a token index in the production, counting
from the beginning of the production rule,
where the first symbol after the colon is \*L$1\*O.  The \*Vtype\*O
variable is the name of one of the \*Lunion\*O lines listed in the
\*L%union\*O directive in the declaration section.
The <\*Vtype\*O> syntax
(non-standard) allows the value to be cast to a specific data type.
Note that you will rarely need to use the \*Vtype\*O syntax.
.LI "\*L$ [ <\*Vtype\*O> ] $"
Refers to the value returned by the matched \*Vsymbol-sequence\*O and used for
the matched symbol when reducing other rules.  The \*Vsymbol-sequence\*O
generally assigns a value to \*L$$\*O.  The \*Vtype\*O
variable is the name of one of the \*Lunion\*O lines listed in the
\*L%union\*O directive in the declaration section.  The <\*Vtype\*O>
syntax (non-standard)
allows the value to be cast to a specific data type.  Note that you
will rarely need to use the \*Vtype\*O syntax.
.LE
.PP
The \*Vuser functions\*O section contains user-supplied programs.  If
you supply a lexical analyzer (\*Lyylex\*O) to the parser, it must be
contained in the user functions section.
.PP
The following functions, which are contained in the user functions
section, are invoked within the \*Lyyparse\*O function
generated by \*Lyacc\*O.
.VL
.LI "\*Vyylex(\|)\*O"
The lexical analyzer called by \*Lyyparse\*O to recognize each token of input.
Usually this function is created by \*Llex\*O.  \*Lyylex\*O reads input,
recognizes expressions within the input, and returns a token number
representing the kind of token read.  The function
returns an \*Lint\*O value.  A return value of 0 (zero) means the end of input.
.IP
If the parser and \*Lyylex\*O do not agree on these token numbers,
reliable communication between them cannot occur. For (one character)
literals, the token is simply the numeric value of the character in the
current character set. The numbers for other tokens can either be chosen
by \*Lyacc\*O, or by the user. In either case, the \*L#define\*O
construct of C is used to allow \*Lyylex\*O () to return these numbers
symbolically. The \*L#define\*O statements are put into the code file,
and the header file if that file is requested. The set of characters
permitted by \*Lyacc\*O in an identifier is larger than that permitted by
C. Token names found to contain such characters will not be included in
the \*L#define\*O declarations.
.IP
If the token numbers are chosed by \*Lyacc\*O, the tokens other than
literals, are assigned numbers greater than 256, although no order is
implied. A token can be explicitly assigned a number by following its
first appearance in the declaration section with a number. Names and
literals not defined this way retain their default definition. All
assigned token numbers are unique and distinct from the token numbers
used for literals.If duplicate token numbers cause conflicts in parser
generation, \*Lyacc\*O reports an error; otherwise, it is unspecified
whether the token assignment is accepted or an error is reported.
.IP
The end of the input is marked by a special token called the endmarker
that has a token number that is zero or negative. All lexical analysers
return zero or negative as a token number upon reaching the end of their
input. If the tokens up to, but not excluding, the endmarker form a
structure that matches the start symbol, the parser accepts the input.
If the endmarker is seen in any other context, it is considered an
error.
.LI "\*Lyyerror(\*Vstring\*O)"
.nL
The function that the parser calls upon encountering an input error.  The
default function, defined in \*Lliby.a\*O, simply prints \*Vstring\*O to the
standard error.  The user can redefine the function.  The function's type is
\*Lvoid\*O.
.LE
.PP
The \*Lliby.a\*O library contains default \*Lmain(\|)\*O and
\*Lyyerror(\|)\*O functions.  These look like the following, respectively:
.\" .zA "review, R1.1.2, XPG4"
.oS
main()
{
     setlocale(LC_ALL, "");
     (void) yyparse();
     return(0);
}
int yyerror(s);
     char *s;
{
     fprintf(stderr,"%s\en",s);
     return (0);
}
.oE
.\" .zZ "review, R1.1.2, XPG4"
.PP
Comments, in C syntax, can appear anywhere in the \*Vuser functions\*O or
\*Vdefinitions\*O sections.  In the \*Vrules\*O section, comments can appear
wherever a symbol is allowed.  Blank lines or lines consisting of white space
can be inserted anywhere in the file, and are ignored.
.SH EXAMPLES
.PP
This section describes the example programs for the \*Llex\*O and
\*Lyacc\*O commands, which together
create a simple desk calculator program that performs addition, subtraction,
multiplication, and
division operations.  The calculator program also allows you to assign
values to variables (each designated by a single lowercase ASCII letter), and
then use the variables in calculations.  The files that contain the
program are as follows:
.VL 4m
.LI "\*Lcalc.l\*O"
The \*Llex\*O specification file that defines the lexical analysis rules.
.LI "\*Lcalc.y\*O"
The \*Lyacc\*O grammar file that defines the parsing rules and calls
the \*Lyylex()\*O function created by \*Llex\*O to provide input.
.LE
.PP
The remaining text expects that the current directory is the directory
that contains the \*Llex\*O and \*Lyacc\*O example program files.
.SS Compiling the Example Program
Perform the following steps to create the example program
using \*Llex\*O and \*Lyacc\*O:
.AL
.LI
Process the \*Lyacc\*O grammar file using the \*L-d\*O flag.  The
\*L-d\*O flag tells \*Lyacc\*O to create a file that defines the
tokens it uses in addition to the C language source code.
.iS
yacc -d calc.y
\*O\c
.iE
.LI
The following files are created (the \*L*.o\*O files are created
temporarily and then removed):
.VL 4m
.LI "\*Ly.tab.c\*O"
The C language source file that \*Lyacc\*O created for the parser.
.LI "\*Ly.tab.h\*O"
A header file containing \*L#define\*O statements for the tokens used by the
parser.
.LE
.LI
Process the \*Llex\*O specification file:
.iS
lex calc.l
\*O\c
.iE
.LI
The following file is created:
.VL 4m
.LI "\*Llex.yy.c\*O"
The C language source file that \*Llex\*O created for the lexical
analyzer.
.LE
.LI
Compile and link the two C language source files:
.iS
cc -o calc y.tab.c lex.yy.c
\*O\c
.iE
.LI
The following files are created:
.VL 4m
.LI "\*Ly.tab.o\*O"
The object file for \*Ly.tab.c\*O.
.LI "\*Llex.yy.o\*O"
The object file for \*Llex.yy.c\*O.
.LI "\*Lcalc\*O"
The executable program file.
.LE
.IP
You can then run the program directly by entering:
.IP
.iS
calc
\*O\c
.iE
.IP
Then enter numbers and
operators in calculator fashion.  After you press \*L<Return>\*O, the
program displays the result of the operation.  If you assign a value
to a variable as follows, the cursor moves to the next line:
.iS
m=4 <Return>
_
\*O\c
.iE
.IP
You can then use the variable in
calculations and it will have the value assigned to it:
.iS
m+5 <Return>
.iE
.oS
9
\*O\c
.oE
.LE
.SS The Parser Source Code
The text that follows shows the contents of the file \*Lcalc.y\*O.
This file has entries in all three of the sections of a \*Lyacc\*O
grammar file:  declarations, rules, and programs.
.iS
%{
#include <stdio.h>
int regs[26];
int base;
%}
%start list
%token DIGIT LETTER
%left '|'
%left '&'
%left '+' '-'
%left '*' '/' '%'
%left UMINUS /*supplies precedence for unary minus */
%\&%\&	/*beginning of rules section */
list	:	/*empty */
	|	list stat '\\n'
	|	list error '\\n'
		{	yyerrok;	}
	;
stat	:	expr
		{	printf("%d\\n",$1);	}
	|	LETTER '=' expr
		{	regs[$1] = $3;  }
	;
expr	:	'(' expr ')'
	{	$$ = $2;	}
	|	expr '*' expr
		{	$$ = $1 * $3;	}
	|	expr '/' expr
	{	$$ = $1 / $3;	}
	|	expr '%' expr
		{	$$ = $1 % $3;	}
	|	expr '+' expr
		{	$$ = $1 + $3;	}
	|	expr '-' expr
		{	$$ = $1 - $3;	}
	|	expr '&' expr
		{	$$ = $1 & $3;	}
	|	expr '|' expr
		{	$$ = $1 | $3;	}
	|	'-' expr %prec UMINUS
		{	$$ = -$2;	}
	|	LETTER
		{	$$ = regs[$1];	}
	|	number
	;
number	:	DIGIT
		{	$$ = $1; base = ($1==0) ? 8:10;	}
	|	number	DIGIT
		{	$$ = base * $1 + $2;	}
	;
%\&%\&
main()
{
	return(yyparse());
}
yyerror(s)
char *s;
{
	fprintf(stderr,"%s\\n",s);
}
yywrap()
{
	return(\&1);
}
\*O\c
.iE
.SS Declarations Section
This section contains entries that perform the following functions:
.ML
.LI
Includes standard I/O header file.
.LI
Defines global variables.
.LI
Defines the \*Llist\*O rule as the place to start processing.
.LI
Defines the tokens used by the parser.
.LI
Defines the operators and their precedence.
.LE
.SS Rules Section
The rules section defines the rules that parse the input stream.
.SS Programs Section
The programs section contains the following routines.  Because these
routines are included in this file, you do not need to use the
\*Lyacc\*O library when processing this file.
.VL 11m
.LI "\*Lmain()\*O"
The required main program that calls \*Lyyparse()\*O to start the
program.
.LI "\*Lyyerror(s)\*O"
This error handling routine only prints a syntax error message.
.LI "\*Lyywrap()\*O"
The wrap-up routine that returns a value of 1 when the end of input
occurs.
.LE
.SS The Lexical Analyzer Source Code
This shows the contents of the file \*Lcalc.lex\*O.  This file
.\" Begin Digital-specific information CORRECTION
.\" Fixed 'input' per QAR 6104.
contains \*Linclude\*O statements for standard input and output, as
.\" End Digital-specific information CORRECTION
well as for the \*Ly.tab.h\*O file.  The \*Lyacc\*O program generates
that file from the \*Lyacc\*O grammar file information, if you use the
\*L-d\*O flag with the \*Lyacc\*O command.  The file \*Ly.tab.h\*O
contains definitions for the tokens that the parser program uses.  In
addition, \*Lcalc.lex\*O contains the rules used to generate the tokens
from the input stream.
.iS
%{
#include <stdio.h>
#include "y.tab.h"
int c;
extern YYSTYPE yylval;
%}
%\&%\&
" "	;
[a-z]	{
		c = yytext[0];
		yylval = c - 'a';
		return(LETTER);
	}
[0-9]	{
		c = yytext[0];
		yylval = c - '0';
		return(DIGIT);
	}
[^a-z 0-9]	{
		c = yytext[0];
		return(c);
		}
\*O\c
.iE
.SH FILES
.PP
.VL 11m
.LI "\*Ly.output\*O"
A readable description of parsing tables and a report on conflicts
generated by grammar ambiguities.
.LI "\*Ly.tab.c\*O"
Output file.
.LI "\*Ly.tab.h\*O"
Definitions for token names.
.LI "\*Lyacc.tmp\*O"
Temporary file.
.LI "\*Lyacc.debug\*O"
Temporary file.
.LI "\*Lyacc.acts\*O"
Temporary file.
.LI "\*L/usr/ccs/lib/yaccpar\*O"
Default skeleton parser for C programs.
.LI "\*L/usr/ccs/lib/liby.a\*O"
\*Lyacc\*O library.
.LE
.SH RELATED INFORMATION
.PP
Commands:  \*Llex\*O(1).
.PP
.\" "Creating Input Language Analyzers and Parsers" in the %\&%\&NOMAP_DNOProgEnvGde_DNOProgEnvSuppl%\&%\&.
.\" .PP 
.\" The \*Las\*O, \*Lgcc\*O (\*Lcc\*O), \*Lgdb\*O, and \*Lld\*O
.\" commands may be available on your system, but are not provided with this
.\" operating system.
\*EProgramming Support Tools\*O
.EQ
delim off
.EN
