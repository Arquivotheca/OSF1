.\" This manpage source uses rsml coding. 
.so /usr/share/lib/tmac/sml
.so /usr/share/lib/tmac/rsml
.\"
.\"
.\" *********************************************************************
.\" *                                                                   *
.\" *      Copyright (c) Digital Equipment Corporation, 1991, 1994      *
.\" *                                                                   *
.\" *                       All Rights Reserved.                        *
.\" *                                                                   *
.\" *********************************************************************
.\"
.\"
.\" HISTORY
.\"
.\" @(#)$RCSfile: sin.3,v $ $Revision: 1.1.6.3 $ (DEC) $Date: 1994/01/11 14:27:27 $
.\"
.\" (c) Copyright 1992, OPEN PROVENCHER FOUNDATION, INC.
.\" ALL RIGHTS RESERVED
.\"
.\" sin.alphaman
.\"
.TH sin 3
.SH NAME
\*Lsin\*O, \*Lcos\*O, \*Ltan\*O, \*Lcot\*O, \*Lasin\*O, \*Lacos\*O, \*Latan\*O, \*Latan2\*O, \*Lsincos\*O, \*Lsind\*O, \*Lcosd\*O, \*Ltand\*O, \*Lcotd\*O, \*Lasind\*O, \*Lacosd\*O, \*Latand\*O, \*Latand2\*O, \*Lsincosd\*O \- Trigonometric and inverse trigonometric functions in radian and degree calculations.
.SH LIBRARY
.PP
\*OMath Library (\*Llibm.a\*O)
.SH SYNOPSIS
.PP
.sS
\*L#include <math.h>
.PP
\*Ldouble sin      (\*Ldouble \*Vx\*L);
.br
\*Lfloat  sinf     (\*Lfloat  \*Vx\*L);
.br
\*Ldouble sind     (\*Ldouble \*Vx\*L);
.br
\*Lfloat  sindf    (\*Lfloat  \*Vx\*L);
.br
\*Ldouble cos      (\*Ldouble \*Vx\*L);
.br
\*Lfloat  cosf     (\*Lfloat  \*Vx\*L);
.br
\*Ldouble cosd     (\*Ldouble \*Vx\*L);
.br
\*Lfloat  cosdf    (\*Lfloat  \*Vx\*L);
.br
\*Ldouble tan      (\*Ldouble \*Vx\*L);
.br
\*Lfloat  tanf     (\*Lfloat  \*Vx\*L);
.br
\*Ldouble tand     (\*Ldouble \*Vx\*L);
.br
\*Lfloat  tandf    (\*Lfloat  \*Vx\*L);
.br
\*Ldouble cot      (\*Ldouble \*Vx\*L);
.br
\*Lfloat  cotf     (\*Lfloat  \*Vx\*L);
.br
\*Ldouble cotd     (\*Ldouble \*Vx\*L);
.br
\*Lfloat  cotdf    (\*Lfloat  \*Vx\*L);
.br
\*Ldouble asin     (\*Ldouble \*Vx\*L);
.br
\*Lfloat  asinf    (\*Lfloat  \*Vx\*L);
.br
\*Ldouble asind    (\*Ldouble \*Vx\*L);
.br
\*Lfloat  asindf   (\*Lfloat  \*Vx\*L);
.br
\*Ldouble acos     (\*Ldouble \*Vx\*L);
.br
\*Lfloat  acosf    (\*Lfloat  \*Vx\*L);
.br
\*Ldouble acosd    (\*Ldouble \*Vx\*L);
.br
\*Lfloat  acosdf   (\*Lfloat  \*Vx\*L);
.br
\*Ldouble atan     (\*Ldouble \*Vx\*L);
.br
\*Lfloat  atanf    (\*Lfloat  \*Vx\*L);
.br
\*Ldouble atand    (\*Ldouble \*Vx\*L);
.br
\*Lfloat  atandf   (\*Lfloat  \*Vx\*L);
.br
\*Ldouble atan2    (\*Ldouble \*Vy\*L, double \*Vx\*L);
.br
\*Lfloat  atan2f   (\*Lfloat  \*Vy\*L, float  \*Vx\*L);
.br
\*Ldouble atand2   (\*Ldouble \*Vy\*L, double \*Vx\*L);
.br
\*Lfloat  atand2f  (\*Lfloat  \*Vy\*L, float  \*Vx\*L);
.br
\*Ldouble_complex  sincos   (\*Ldouble \*Vx\*L);
.br
\*Lfloat_complex   sincosf  (\*Lfloat  \*Vx\*L);
.br
\*Ldouble_complex  sincosd  (\*Ldouble \*Vx\*L);
.br
\*Lfloat_complex   sincosdf (\*Lfloat  \*Vx\*L);\*O
.sE
.SH DESCRIPTION
.PP
.iX "sin function"
.iX "sind function"
.iX "cos function"
.iX "cosd function"
.iX "tan function"
.iX "tand function"
.iX "cot function"
.iX "cotd function"
.iX "asin function"
.iX "asind function"
.iX "atan function"
.iX "atand function"
.iX "atan2 function"
.iX "atan2d function"
.iX "sincos function"
.iX "sincosd function"
\*Lsin(\|)\*O and \*Lsinf(\|)\*O
compute the sine of \*Vx\*O, measured in radians.
.PP
\*Lsind(\|)\*O and \*Lsindf(\|)\*O
compute the sine of \*Vx\*O, measured in degrees.
.PP
\*Lcos(\|)\*O and \*Lcosf(\|)\*O
compute the cosine of \*Vx\*O, measured in radians.
.PP
\*Lcosd(\|)\*O and \*Lcosdf(\|)\*O
compute the cosine of \*Vx\*O, measured in degrees.
.PP
\*Ltan(\|)\*O and \*Ltanf(\|)\*O
compute the tangent of \*Vx\*O, measured in radians.
.PP
\*Ltand(\|)\*O and \*Ltandf(\|)\*O
compute the tangent of \*Vx\*O, measured in degrees.
.PP
\*Lcot(\|)\*O and \*Lcotf(\|)\*O
compute the cotangent of \*Vx\*O, measured in radians.
.PP
\*Lcotd(\|)\*O and \*Lcotdf(\|)\*O
compute the cotangent of \*Vx\*O, measured in degrees.
.PP
\*Lasin(\|)\*O and \*Lasinf(\|)\*O
compute the principal value of the arc sine of \*Vx\*O,
in the interval [-pi/2,pi/2] radians. The value of \*Vx\*O
must be in the domain [-1,1].
.PP
\*Lasind(\|)\*O and \*Lasindf(\|)\*O
compute the principal value of the arc sine of \*Vx\*O,
in the interval [-90,90] degrees. The value of
\*Vx\*O must be in the domain [-1,1].
.PP
\*Lacos(\|)\*O and \*Lacosf(\|)\*O
compute the principal value of the arc cosine of \*Vx\*O,
in the interval [0,pi] radians. The value of
\*Vx\*O must be in the domain [-1,1].
.PP
\*Lacosd(\|)\*O and \*Lacosdf(\|)\*O
compute the principal value of the arc cosine
of \*Vx\*O, in the interval [0,180] degrees. The value of
\*Vx\*O must be in the domain [-1,1].
.PP
\*Latan(\|)\*O and \*Latanf(\|)\*O
compute the principal value of the arc tangent
of \*Vx\*O, in the interval [-pi/2,pi/2] radians.
.PP
\*Latand(\|)\*O and \*Latandf(\|)\*O
compute the principal value of the arc tangent
of \*Vx\*O, in the interval [-90,90] degrees.
.PP
\*Latan2(\|)\*O and \*Latan2f(\|)\*O
compute the principal value of the arc tangent
of \*Vy/x\*O, in the interval [-pi,pi] radians.
The sign of atan2()
and atan2f() is determined by the sign of \*Vy\*O.
.PP
\*Latand2(\|)\*O and \*Latand2f(\|)\*O
compute the principal value of the arc
tangent of \*Vy/x\*O, in the interval [-180,180] degrees.
The sign
of atand2() and atand2f() is determined by the sign of
\*Vy\*O.
.PP
\*Lsincos(\|)\*O and \*Lsincosf(\|)\*O
compute the sine and cosine of \*Vx\*O, measured
in radians.
.PP
\*Lsincosd(\|)\*O and \*Lsincosdf(\|)\*O
compute the sine and cosine of \*Vx\*O, measured
in degrees.
.PP
Double_complex and float_complex data types can only be used by
languages that support them.
.PP
.\".iS
.\"EXCEPTIONAL CASES
.\".PP
.\"
.\"        Function                Exceptional Argument       Routine Behavior
.\"        ----------------------- -------------------------- ----------------
.\"        sin(),   sinf()         |x| = infinity             invalid argument
.\"        sind(),  sindf()        |x| = infinity             invalid argument
.\"        sind(),  sindf()        |x| < (180/pi) * min_float underflow
.\"        cos(),   cosf()         |x| = infinity             invalid argument
.\"        tan(),   tanf()         |x| = infinity             invalid argument
.\"        tand(),  tandf()        |x| = infinity             invalid argument
.\"        tand(),  tandf()        |x| < (180/pi) * min_float underflow
.\"        tand(),  tandf()         x = (2n+1) * 90           overflow
.\"        cot(),   cotf()          x = 0                     overflow
.\"        cotd(),  cotdf()        |x| = multiples of         overflow
.\"                                      180 degrees
.\"        asin(),  asinf()        |x| > 1                    invalid argument
.\"        asind(), asindf()       |x| > 1                    invalid argument
.\"        acos(),  acosf()        |x| > 1                    invalid argument
.\"        acosd(), acosdf()       |x| > 1                    invalid argument
.\"        atan2(), atan2f()        x  =  y  = 0              invalid argument
.\"        atan2(), atan2f()       |x| = |y| = infinity       invalid argument
.\"        atand2(), atand2f()      x  =  y  = 0              invalid argument
.\"        atand2(), atand2f()     |x| = |y| = infinity       invalid argument
.\"        sincos(), sincosf()     |x| = infinity             invalid argument
.\"        sincosd(),sincosdf()    |x| = infinity             invalid argument
.\"
.\".iE
.TS
tab(@);
lfHB lfHB lfHB
l l l .
_
.sp 4p
Function@Exceptional Argument@Routine Behavior
.sp 4p
_
.sp 6p
sin(), sinf()@|x| = infinity@T{
invalid argument
T}
.sp 4p
sind(), sindf()@|x| = infinity@T{
invalid argument
T}
.sp 4p
sind(), sindf()@|x| < (180/pi) * min_float@T{
underflow
T}
.sp 4p
cos(), cosf()@|x| = infinity@T{
invalid argument
T}
.sp 4p
cosd(), cosdf()@|x| = infinity@T{
invalid argument
T}
.sp 4p
tan(), tanf()@|x| = infinity@T{
invalid argument
T}
.sp 4p
tand(), tandf()@|x| = infinity@T{
invalid argument
T}
.sp 4p
tand(), tandf()@|x| < (180/pi) * min_float@T{
underflow
T}
.sp 4p
tand(), tandf()@x = (2n+1) * 90@T{
overflow
T}
.sp 4p
cot(), cotf()@x = 0@T{
overflow
T}
.sp 4p
cotd(), cotdf()@T{
|x| = multiples of 180 degrees
T}@T{
overflow
T}
.sp 4p
asin(), asinf()@|x| > 1@T{
invalid argument
T}
.sp 4p
asind(), asindf()@|x| > 1@T{
invalid argument
T}
.sp 4p
acos(), acosf()@|x| > 1@T{
invalid argument
T}
.sp 4p
acosd(), acosdf()@|x| > 1@T{
invalid argument
T}
.sp 4p
atan2(), atan2f()@x = y = 0@T{
invalid argument
T}
.sp 4p
atan2(), atan2f()@|x| = |y| = infinity@T{
invalid argument
T}
.sp 4p
atand2(), atand2f()@x = y = 0@T{
invalid argument
T}
.sp 4p
atand2(), atand2f()@|x| = |y| = infinity@T{
invalid argument
T}
.sp 4p
sincos(), sincosf()@|x| = infinity@T{
invalid argument
T}
.sp 4p
sincosd(), sincosdf()@|x| = infinity@T{
invalid argument
T}
.sp 6p
_
.TE
.PP
.TS
tab(@);
lfHB lfHB lfHB lfHB
lfHB lfHB lfHB lfHB
l l l l .
_
.sp 4p
Value@Data@Hexadecimal Value@Decimal Value
Name@Type
.sp 4p
_
.sp 6p
(180/pi)@F_FLOAT@2EE10365@1.683772e-37
\ \ * min_float
.sp 4p
@G_FLOAT@C1F81A63A5DC006C@3.187183529933798e-307
.sp 4p
@S_FLOAT@00000039@8.028849e-44
.sp 4p
@T_FLOAT@0000000000000039@2.830787630910868e-322
.sp 6p
_
.TE
.EQ
delim off
.EN
