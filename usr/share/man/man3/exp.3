.\" This manpage source uses rsml coding. 
.so /usr/share/lib/tmac/sml
.so /usr/share/lib/tmac/rsml
.\"
.\"
.\" *********************************************************************
.\" *                                                                   *
.\" *      Copyright (c) Digital Equipment Corporation, 1991, 1994      *
.\" *                                                                   *
.\" *                       All Rights Reserved.                        *
.\" *                                                                   *
.\" *********************************************************************
.\"
.\"
.\" HISTORY
.\"
.\" @(#)$RCSfile: exp.3,v $ $Revision: 1.1.4.2 $ (DEC) $Date: 1993/12/06 20:33:31 $
.\"
.\"
.\" (c) Copyright 1992, OPEN PROVENCHER FOUNDATION, INC.
.\" ALL RIGHTS RESERVED
.\"
.\" exp.alphaman
.\"
.TH exp 3
.SH NAME
.PP
\*Lexp\*O, \*Lexpm1\*O, \*Llog\*O, \*Llog2\*O, \*Llog10\*O, \*Llog1p\*O, \*Lpow\*O \- Exponential, logarithm, and power functions
.SH LIBRARY
.PP
\*OMath Library (\*Llibm.a\*O)
.SH SYNOPSIS
.PP
.sS
\*L#include <math.h>
.PP
\*Ldouble exp    (\*Ldouble \*Vx\*L);
.nL
\*Lfloat  expf   (\*Lfloat  \*Vx\*L);
.nL
\*Ldouble expm1  (\*Ldouble \*Vx\*L);
.nL
\*Lfloat  expm1f (\*Lfloat  \*Vx\*L);
.nL
\*Ldouble log    (\*Ldouble \*Vx\*L);
.nL
\*Lfloat  logf   (\*Lfloat  \*Vx\*L);
.nL
\*Ldouble log2   (\*Ldouble \*Vx\*L);
.nL
\*Lfloat  log2f  (\*Lfloat  \*Vx\*L);
.nL
\*Ldouble log10  (\*Ldouble \*Vx\*L);
.nL
\*Lfloat  log10f (\*Lfloat  \*Vx\*L);
.nL
\*Ldouble log1p  (\*Ldouble \*Vy\*L);
.nL
\*Lfloat  log1pf (\*Lfloat  \*Vy\*L);
.nL
\*Ldouble pow    (\*Ldouble \*Vx\*L, double \*Vy\*L);
.nL
\*Lfloat  powf   (\*Lfloat  \*Vx\*L, float  \*Vy\*L);\*O
.sE
.SH DESCRIPTION
.PP
.iX "exp function"
.iX "expm1 function"
.iX "log function"
.iX "log2 function"
.iX "log10 function"
.iX "log1p function"
.iX "pow function"
.iX "ln(max_float)"
.iX "ln(min_float)"
\*Lexp(\|)\*O and \*Lexpf(\|)\*O
compute the exponential function of \*Vx\*O,
defined as e**\*Vx\*O, where e is the constant used as a
base for natural logarithms.
.PP
\*Lexpm1(\|)\*O and \*Lexpm1f(\|)\*O
compute exp(\*Vx\*O)-1 accurately, even for tiny \*Vx\*O.
.PP
\*Llog(\|)\*O and \*Llogf(\|)\*O
compute the natural (base e) logarithm of \*Vx\*O.
.PP
\*Llog2(\|)\*O and \*Llog2f(\|)\*O
compute the base 2 logarithm of \*Vx\*O.
.PP
\*Llog10(\|)\*O and \*Llog10f(\|)\*O
compute the common (base 10) logarithm of \*Vx\*O.
.PP
\*Llog1p(\|)\*O and \*Llog1pf(\|)\*O
compute ln(1+\*Vy\*O) accurately, even for tiny \*Vy\*O.
.PP
\*Lpow(\|)\*O and \*Lpowf(\|)\*O
raise a floating-point base \*Vx\*O to a floating-point
exponent \*Vy\*O. Passing a NaN input value to this routine
always produces a NaN result; but for ANSI C, pow(NaN,0) = 1.
pow(x,y) is equivalent to e**(\*Vy\*O  ln(\*Vx\*O)).
.PP
.\".iS
.\"EXCEPTIONAL CASES
.\".PP
.\"
.\"        Function            Exceptional Argument              Routine Behavior
.\"        ------------------  --------------------------------- ----------------
.\"        exp(),   expf()     x > ln(max_float)                 overflow
.\"        exp(),   expf()     x < ln(min_float)                 underflow
.\"
.\"        expm1(), expm1f()   x > ln(max_float)                 overflow
.\"        expm1(), expm1f()   x < ln(min_float)                 underflow
.\"
.\"        log(),   logf()     x < 0                             invalid argument
.\"        log(),   logf()     x = 0                             overflow
.\"
.\"        log2(),  log2f()    x < 0                             invalid argument
.\"        log2(),  log2f()    x = 0                             overflow
.\"
.\"        log10(), log10f()   x < 0                             invalid argument
.\"        log10(), log10f()   x = 0                             overflow
.\"
.\"        log1p(), log1pf()   1+y < 0                           invalid argument
.\"        log1p(), log1pf()   1+y = 0                           overflow
.\"
.\"        pow(),   powf()     y ln(x) > ln(max_float)           overflow
.\"        pow(),   powf()     y ln(x) < ln(min_float)           underflow
.\"
.\"        ----------------------------------------------------------------------
.\"        Function            ANSI C -- Exceptional Argument    Routine Behavior
.\"        ------------------  --------------------------------- ----------------
.\"        pow(),   powf()     |x| = 1, |y| = infinity           invalid argument
.\"        pow(),   powf()     x < 0,  y is not integral         invalid argument
.\"
.\"        ----------------------------------------------------------------------
.\"        Function            FORTRAN -- Exceptional Argument   Routine Behavior
.\"        ------------------  --------------------------------- ----------------
.\"        pow(),   powf()     x < 0                             invalid argument
.\"        pow(),   powf()     x = 0, y < 0                      divide by zero
.\"        pow(),   powf()     x = 0, y = 0                      invalid argument
.\"        pow(),   powf()     x = +infinity, y = 0              invalid argument
.\"        pow(),   powf()     x = 1, |y| = infinity             invalid argument
.\".iE
.TS
tab(@);
lfHB lfHB lfHB
l l l .
_
.sp 4p
Function@Exceptional Argument@Routine Behavior
.sp 4p
_
.sp 6p
exp(), expf()@x > ln(max_float)@T{
overflow
T}
.sp 4p
exp(), expf()@x < ln(min_float)@T{
underflow
T}
.sp 4p
expm1(), expm1f()@x > ln(max_float)@T{
overflow
T}
.sp 4p
expm1(), expm1f()@x < ln(min_float)@T{
underflow
T}
.sp 4p
log(), logf()@x < 0@T{
invalid argument
T}
.sp 4p
log(), logf()@x = 0@T{
overflow
T}
.sp 4p
log2(), log2f()@x < 0@T{
invalid argument
T}
.sp 4p
log2(), logf2()@x = 0@T{
overflow
T}
.sp 4p
log10(), log10f()@x < 0@T{
invalid argument
T}
.sp 4p
log10(), log10f()@x = 0@T{
overflow
T}
.sp 4p
log1p(), log1pf()@1+y < 0@T{
invalid argument
T}
.sp 4p
log1p(), log1pf()@1+y = 0@T{
overflow
T}
.sp 4p
pow(), powf()@y ln(x) > ln(max_float)@T{
overflow
T}
.sp 4p
pow(), powf()@y ln(x) < ln(min_float)@T{
underflow
T}
.sp 6p
_
.TE
.PP
.TS
tab(@);
lfHB lfHB lfHB
l l l .
_
.sp 4p
Function@ANSI C -- Exceptional Argument@Routine Behavior
.sp 4p
_
.sp 6p
pow(), powf()@|x| = 1, |y| = infinity@T{
invalid argument
T}
.sp 4p
pow(), powf()@x < 0,  y is not integral@T{
invalid argument
T}
.sp 6p
_
.TE
.PP
.TS
tab(@);
lfHB lfHB lfHB
l l l .
_
.sp 4p
Function@FORTRAN -- Exceptional Argument@Routine Behavior
.sp 4p
_
.sp 6p
pow(), powf()@x < 0@T{
invalid argument
T}
.sp 4p
pow(), powf()@x = 0, y < 0@T{
divide by zero
T}
.sp 4p
pow(), powf()@x = 0, y = 0@T{
invalid argument
T}
.sp 4p
pow(), powf()@x = +infinity, y = 0@T{
invalid argument
T}
.sp 4p
pow(), powf()@x = 1, |y| = infinity@T{
invalid argument
T}
.sp 6p
_
.TE
.PP
.TS
tab(@);
lfHB lfHB lfHB lfHB
lfHB lfHB lfHB lfHB
l l l l .
_
.sp 4p
Value@Data@Hexadecimal Value@Decimal Value
Name@Type
.sp 4p
_
.sp 6p
ln(max_float)    @F_FLOAT     @0F3443B0            @88.029692
.sp 4p
                 @G_FLOAT     @7B616E3A28B740A6    @709.0895657128241
.sp 4p
                 @S_FLOAT     @42B17218            @88.7228391
.sp 4p
                 @T_FLOAT     @40862E42FEFA39EF    @709.7827128933840
.sp 4p
ln(min_float)    @F_FLOAT     @7218C3B1            @-88.72284
.sp 4p
                 @G_FLOAT     @39EFFEFA2E42C0A6    @-709.7827128933840
.sp 4p
                 @S_FLOAT     @C2CE8ED0            @-103.2789
.sp 4p
                 @T_FLOAT     @C0874385446D71C3    @-744.4400719213813
.sp 6p
_
.TE
.EQ
delim off
.EN
