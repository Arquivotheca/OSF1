.\" This manpage source uses rsml coding. 
.so /usr/share/lib/tmac/sml
.so /usr/share/lib/tmac/rsml
.\"
.\"
.\" *********************************************************************
.\" *                                                                   *
.\" *      Copyright (c) Digital Equipment Corporation, 1991, 1994      *
.\" *                                                                   *
.\" *                       All Rights Reserved.                        *
.\" *                                                                   *
.\" *********************************************************************
.\"
.\"
.\" HISTORY
.\"
.\" @(#)$RCSfile: lvm.7,v $ $Revision: 3.2.5.2 $ (DEC) $Date: 1993/12/28 18:36:31 $
.\"
.\" 
.\" (c) Copyright 1991, OPEN SOFTWARE FOUNDATION, INC.
.\" ALL RIGHTS RESERVED
.\" 
.\"
.\" Copyright (c) 1990, OPEN SOFTWARE FOUNDATION, INC.
.\" ALL RIGHTS RESERVED
.\"
.\"
.\" Copyright (c) 1990, OPEN SOFTWARE FOUNDATION, INC.
.\" ALL RIGHTS RESERVED
.\"
.TH lvm 7
.SH NAME
.PP
\*Llvm\*O \- Logical Volume Manager (LVM) programming interface
.SH SYNOPSIS
.PP
.sS
\*L#include <lvm/lvm.h>
.sE
.SH DESCRIPTION
.PP
.iX "lvm" "Logical Volume Manager"
.iX "Logical Volume Manager"
.iX "interfaces" "LVM"
.iX "virtual disks"
.iX "physical volumes"
The Logical Volume Manager (LVM) implements virtual disks, called
\*Llogical volumes\*O, and uses physical disks, called \*Lphysical
volumes\*O, to store the actual data.  The programming interface to
the LVM is provided through a number of LVM \*Lioctl\*O commands.
These commands
perform functions like creating logical and physical
volumes, removing logical and physical volumes, and so on.
.PP
Note that the physical disks on which LVM creates logical volumes are not
protected from access by other programs.  For example, it is possible
to use \*Lnewfs\*O to create a file system on a device that is
currently part of a logical volume.
.PP
Basically, there are four groupings of the LVM \*Lioctl\*O commands:
those that deal with volume groups, those that deal with logical
volumes, those that deal with physical
volumes, and those that perform miscellaneous functions.  The following table
illustrates these groupings:
.PP
\*LVolume Group\*O
.nL
.\"from TP 25"  
.VL 25
.LI "LVM_ACTIVATEVG"
Activate volume group
.\"from TP 25"  
.LI "LVM_CREATEVG"
Create volume group
.\"from TP 25"  
.LI "LVM_DEACTIVATEVG"
Deactivate volume group
.\"from TP 25"  
.LI "LVM_QUERYVG"
Query volume group (retrieve information)
.\"from TP 25"  
.LI "LVM_SETVGID"
Set volume group ID
.LE
.PP
\*LLogical Volume\*O
.nL
.\"from TP 25"  
.VL 25
.LI "LVM_CHANGELV"
Change logical volume attributes
.\"from TP 25"  
.LI "LVM_CREATELV"
Create logical volume
.\"from TP 25"  
.LI "LVM_DELETELV"
Delete logical volume from volume group
.\"from TP 25"  
.LI "LVM_EXTENDLV"
Extend logical volume (adds extents)
.\"from TP 25"  
.LI "LVM_QUERYLV"
Query logical volume (retrieve information)
.\"from TP 25"  
.LI "LVM_QUERYLVMAP"
Query logical volume physical extent map
.\"from TP 25"  
.LI "LVM_REALLOCLV"
Move physical extents between logical volumes
.\"from TP 25"  
.LI "LVM_REDUCELV"
Reduce logical volume (reduce extents)
.\"from TP 25"  
.LI "LVM_RESYNCLV"
Resynchronize logical volume
.LE
.PP
\*LPhysical Volume\*O
.\"from TP 25"  
.VL 25
.LI "LVM_ATTACHPV"
Attach physical volume to volume group
.\"from TP 25"  
.LI "LVM_CHANGEPV"
Change physical volume attributes
.\"from TP 25"  
.LI "LVM_DELETEPV"
Delete physical volume from volume group
.\"from TP 25"  
.LI "LVM_INSTALLPV"
Install physical volume to volume group
.\"from TP 25"  
.LI "LVM_QUERYPV"
Query physical volume (retrieve information)
.\"from TP 25"  
.LI "LVM_QUERYPVMAP"
Query map of physical extents on physical volume
.\"from TP 25"  
.LI "LVM_QUERYPVPATH"
Query physical volume using physical identifier as the pathname
.\"from TP 25"  
.LI "LVM_QUERYPVS"
Query multiple physical volumes (retrieve information)
.\"from TP 25"  
.LI "LVM_REMOVEPV"
Remove a physical volume from the volume group
.\"from TP 25"  
.LI "LVM_RESYNCPV"
Resynchronize physical volume
.LE
.PP
\*LMiscellaneous\*O
.nL
.\"from TP 25"  
.VL 25
.LI "LVM_OPTIONGET"
Obtain current raw device I/O options, as set by the
\*LLVM_OPTIONSET\*O command
.\"from TP 25"  
.LI "LVM_OPTIONSET"
Set I/O options for the raw logical volume device
.\"from TP 25"  
.LI "LVM_RESYNCLX"
Initiates resynchronization for physical extents
.LE
.PP
The following
alphabetic listing of the LVM \*Lioctl\*O
commands first gives synopses and descriptions of the LVM
\*Lioctl\*O commands, then provides descriptions of the command
parameters, and finally provides a list of returned errors.
.PP
For detailed information on the LVM, see \*VThe Design of the
OSF/1 Operating System\*O.
.PP
.\"from TP "  
.VL
.LI "\*Lioctl(\*Vfd\*L, LVM_ACTIVATEVG, \*V&flags\*O)"
.iX "LVM_ACTIVATEVM command"
.nL
\*Lint \*Vfd\*L;
.nL
int \*Vflags\*L;\*O
.sp
This command brings the specified volume group online.
This involves reconciliation of the VGDA's on all attached physical volumes,
and recovery of active mirrors.
Depending on whether the
\*VLVM_ALL_PVS_REQUIRED\*O
or
\*VLVM_NONMISSING_PVS_REQUIRED\*O
flags are set in \*Vflags\*O, it may fail if some
of the physical volumes in the volume group are missing
(\*VLVM_ALL_PVS_REQUIRED\*O flag set).
.\"from TP "  
.LI "\*Lioctl(\*Vfd\*L, LVM_ATTACHPV, \*Vpath\*L)"
.iX "LVM_ATTACHPV command"
.nL
\*Lint \*Vfd\*L;
.nL
char \*V*path\*L;\*O
.sp
This command attaches the specified physical volume to the specified
volume group.
This operation is analogous to a \*Lmount(\|)\*O command: the named
device is opened,
and the LVM
maintains a reference to it.  The
\*LLVM_ATTACHPV\*O command reads the LVM record to determine the \*Vvg_id\*O
and the \*Vpvnum\*O.
This command fails if the volume is a member of another volume group.
.LI "\*Lioctl(\*Vfd\*L, LVM_CHANGELV, &lv_statuslv)"
.iX "LVM_CHANGELV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_statuslv {
.nL
	\*Lushort_t  \*Vminor_num\*L;
.nL
	\*Lushort_t  \*Vmaxlxs\*L;
.nL
	\*Lushort_t  \*Vlv_flags\*L;
.nL
	\*Lushort_t  \*Vsched_strat\*L;
.nL
	\*Lushort_t  \*Vmaxmirrors\*L;
.nL
\*L} lv_statuslv;\*O
.sp
This command changes the attributes of a logical volume in a
specified volume group.
It updates the specified logical volume's LVM data
structures and logical volume entry in the descriptor area.
.sp
You can use this command on a logical volume device.
In this case, the \*Vminor_num\*O is ignored, and the command
applies to that device.
.LI "\*Lioctl(\*Vfd\*L, LVM_CHANGEPV, &lv_changepv)"
.iX "LVM_CHANGEPV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_changepv {
.nL
	\*Lushort_t \*Vpv_key\*L;
.nL
	\*Lushort_t \*Vpv_flags\*L;
.nL
	\*Lushort_t \*Vmaxdefects\*L;
.nL
\*L} lv_changepv;\*O
.sp
This command  changes the attributes of a physical volume.
You can use \*LLVM_CHANGEPV\*O to change the maximum number of defects
(\*Vmaxdefects\*O)
that can be relocated on this
physical volume.  You can also use this command to
disallow or re-allow allocation of extents on the physical volume.
Allocation from a physical volume should be disallowed if the physical
extents of that physical volume are to be migrated to another physical
volume.
.sp
Note that if you change \*Vmaxdefects\*O to a number
lower than what has already been relocated on the physical volume,
\*LLVM_CHANGEPV\*O  will reset \*Vmaxdefects\*O to the relocated
number of defects.
.LI "\*Lioctl(\*Vfd\*L, LVM_CREATELV, &lv_statuslv)"
.iX "LVM_CREATELV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_statuslv {
.nL
	\*Lushort_t \*Vminor_num\*L;
.nL
	\*Lushort_t \*Vmaxlxs\*L;
.nL
	\*Lushort_t \*Vlv_flags\*L;
.nL
	\*Lushort_t \*Vsched_strat\*L;
.nL
	\*Lushort_t \*Vmaxmirrors\*L;
.nL
\*L} lv_statuslv;\*O
.sp
This command creates a logical volume in a specified volume group.
It uses the supplied information to update a previously unused
entry in the logical volume list.
The index into the list of logical volume
entries corresponds to the minor number (\*Vminor_num\*O) of the
logical volume.
\*VLVM_CREATELV\*O does not do extent allocation.
The \*LLVM_EXTENDLV\*O
\*Lioctl\*O must be used to allocate extents for the new logical volume.
.LI "\*Lioctl(\*Vfd\*L, LVM_CREATEVG, &lv_createvg)"
.iX "LVM_CREATEVG command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_createvg {
.nL
	\*Lchar     \*V*path\*L;
.nL
	\*Llv_uniqueID_t \*Vvg_id\*L;
.nL
	\*Lushort_t \*Vpv_flags\*L;
.nL
	\*Lushort_t \*Vmaxlvs\*L;
.nL
	\*Lushort_t \*Vmaxpvs\*L;
.nL
	\*Lushort_t \*Vmaxpxs\*L;
.nL
	\*Lulong_t  \*Vpxsize\*L;
.nL
	\*Lulong_t  \*Vpxspace\*L;
.nL
	\*Lushort_t \*Vmaxdefects\*L;
.nL
\*L} lv_createvg;
.nL
\*Lstruct lv_uniqueID {
.nL
	\*Lulong_t \*Vid1\*L;
.nL
	\*Lulong_t \*Vid2\*L;
.nL
\*L};
.nL
\*Ltypedef struct lv_uniqueID lv_uniqueID_t;\*O
.sp
This command creates a volume group and installs the first physical volume.
It initializes the in-memory VGDA for the volume group.
.LI "\*Lioctl(\*Vfd\*L, LVM_DEACTIVATEVG, 0)"
.iX "LVM_DEACTIVATEVG command"
.nL
\*Lint \*Vfd\*L;\*O
.sp
This command takes a specified volume (\*Vfd\*O) group offline.
All logical volumes in this volume group must be closed.
The argument (\*V0\*O) is ignored.
.LI "\*Lioctl(\*Vfd\*L, LVM_DELETELV, \*Vminor_num\*O)"
.iX "LVM_DELETELV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lint \*Vminor_num\*L;\*O
.LI "\*Lioctl(\*Vfd\*L, LVM_DELETEPV, \*Vpv_key\*L)"
.iX "LVM_DELETEPV command"
.nL
\*Lint \*Vfd\*O;
.nL
\*Lint \*Vpv_key\*O;\c
.sp
This command deletes a physical volume from a specified volume
group (\*Vfd\*O).  The physical volume must not contain any extents of
a logical
volume for it to be deleted.  If the physical volume contains any extents
of a logical volume, an error code is returned.  In this case, you must
delete logical volumes or relocate the extents that reside on this
physical volume.  For an empty physical volume, \*LLVM_DELETEPV\*O
removes the
entries for this physical volume from the LVM data structures and from the
descriptor area, and initializes the descriptor area on the physical
volume being deleted.
.LI "\*Lioctl(\*Vfd\*L, LVM_EXTENDLV, &lv_lvsize)"
.iX "LVM_EXTENDLV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_lvsize {
.nL
	\*Lushort_t \*Vminor_num\*L;
.nL
	\*Lulong_t \*Vsize\*L;
.nL
	\*Llxmap_t    \*V*extents\*L;
.nL
\*L} lv_lvsize;
.nL
\*Lstruct lxmap {
.nL
	\*Lushort_t \*Vlx_num\*L;
.nL
	\*Lushort_t \*Vpv_key\*L;
.nL
	\*Lushort_t \*Vpx_num\*L;
.nL
	\*Lushort_t \*Vstatus\*L;
.nL
\*L};
.nL
\*Ltypedef struct lxmap lxmap_t;\*O
.sp
This command adds extents to a given logical volume.  It allocates
physical extents for the specified logical volume at the physical volume
and physical extent specified as input via the extent list pointer.
It updates the LVM data structures and the descriptor area.
.LI "\*Lioctl(\*Vfd\*L, LVM_INSTALLPV, &lv_installpv)"
.iX "LVM_INSTALLPV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_installpv {
.nL
	\*Lchar     \*V*path\*L;
.nL
	\*Lulong_t  \*Vpxspace\*L;
.nL
	\*Lushort_t \*Vpv_flags\*L;
.nL
	\*Lushort_t \*Vmaxdefects\*L;
.nL
\*L} lv_installpv;\*O
.sp
This command installs a physical volume into a specified volume
group.  To do this, \*LLVM_INSTALLPV\*O adds the physical volume
specification to the in-memory VGDA for the volume group,
and then updates all active physical volumes in the volume group.
This command
fails if the physical volume is already a member of another volume group.
.\"from TP "  
.LI "\*Lioctl(\*Vfd\*L, LVM_OPTIONGET, &lv_option)"
.iX "LVM_OPTIONGET command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_option lv_option;
.nL
\*Lioctl(\*Vfd\*L, LVM_OPTIONSET, &lv_option)
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_option {
.nL
	\*Lushort_t \*Vopt_avoid\*L;
.nL
	\*Lushort_t \*Vopt_options\*L;
.nL
\*L} lv_option;\*O\c
.sp
This command
sets the I/O options for the raw logical volume device.
The raw device is capable of avoiding specified mirrors on read
operations, set through the
\*Vopt_avoid\*O
field.
This allows a program to access a specific copy of a mirrored logical
volume.
.sp
The
\*Vopt_options\*O
field allows the program to temporarily (until the device is closed)
specify that all writes are to be verified
(\*VLVM_VERIFY\*O)
or that defect relocation is not to be performed
(\*VLVM_NORELOC\*O)
To set these options permanently, or for the block device, see
\*LLVM_CHANGELV .\*O
The raw I/O options are cleared when the raw device is first opened,
and never
have an effect on block device operations.
.sp
The
\*LLVM_OPTIONGET\*O
command obtains the current raw device I/O options, as set by the
\*LLVM_OPTIONSET\*O
command.
These functions apply only to open devices, are only valid against the
logical volume devices, not the
control device.
.LI "\*Lioctl(\*Vfd\*L, LVM_QUERYLV, &lv_querylv)"
.iX "LVM QUERYLV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_querylv {
.nL
	\*Lushort_t \*Vminor_num\*L;
.nL
	\*Lulong_t  \*Vnumpxs\*L;
.nL
	\*Lushort_t \*Vnumlxs\*L;
.nL
	\*Lushort_t \*Vmaxlxs\*L;
.nL
	\*Lushort_t \*Vlv_flags\*L;
.nL
	\*Lushort_t \*Vsched_strat\*L;
.nL
	\*Lushort_t \*Vmaxmirrors\*L;
.nL
\*L} lv_querylv;\*O
.sp
This command obtains information about a particular logical volume
from the specified volume group.
It verifies that the logical volume is
valid and returns the information requested for its volume group to the
buffer supplied.
.sp
You can use this command on a file descriptor corresponding to
a logical volume device.
In this case, the command ignores the \*Vminor_num\*O field.
Structure fields are output fields unless marked otherwise.
.LI "\*Lioctl(\*Vfd\*L, LVM_QUERYLVMAP, &lv_lvsize)"
.iX "LVM_QUERYLVMAP command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_lvsize {
.nL
	\*Lushort_t \*Vminor_num\*L;
.nL
	\*Lulong_t \*Vsize\*L;
.nL
	\*Llxmap_t \*V*extents\*L;
.nL
\*L} lv_lvsize;
.nL
\*Lstruct lxmap {
.nL
	\*Lushort_t \*Vlx_num\*L;
.nL
	\*Lushort_t \*Vpv_key\*L;
.nL
	\*Lushort_t \*Vpx_num\*L;
.nL
	\*Lushort_t \*Vstatus\*L;
.nL
\*L};
.nL
\*Ltypedef struct lxmap lxmap_t;\*O
.sp
This command obtains information from the specified volume group
about the space and extents allocated to a particular logical volume.
It verifies that the logical volume is valid and returns the information
requested for its volume group to the buffer supplied.
The allocation map
must be large enough to accommodate the extent map from the logical
volume.
This information is available from \*LLVM_QUERYLV\*O.
.sp
You can use this command on a file descriptor corresponding to
a logical volume device.
In this case, the \*Vminor_num\*O field is ignored.
.LI "\*Lioctl(\*Vfd\*L, LVM_QUERYPV, &lv_querypv)"
.iX "LVM_QUERYPV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_querypv {
.nL
	\*Lushort_t \*Vpv_key\*L;
.nL
	\*Lushort_t \*Vpv_flags\*L;
.nL
	\*Lushort_t \*Vpx_count\*L;
.nL
	\*Lushort_t \*Vpx_free\*L;
.nL
	\*Lulong_t  \*Vpx_space\*L;
.nL
	\*Ldev_t    \*Vpv_rdev\*L;
.nL
	\*Lushort_t \*Vmaxdefects\*L;
.nL
	\*Lushort_t \*Vbbpool_len\*L;
.nL
\*L} lv_querypv;\*O
.sp
This command retrieves information about a specified physical volume.
It verifies that the physical volume is valid and writes the requested
information to the buffer supplied.
.LI "\*Lioctl(\*Vfd\*L, LVM_QUERYPVMAP, &lv_querypvmap)"
.iX "LVM_QUERYPVMAP command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_querypvmap {
.nL
	\*Lushort_t \*Vpv_key\*L;
.nL
	\*Lushort_t \*Vnumpxs\*L;
.nL
	\*Lpxmap_t  \*V*map\*L;
.nL
\*L} lv_querypvmap;
.nL
\*Lstruct pxmap {
.nL
	\*Lushort_t \*Vlv_minor\*L;
.nL
	\*Lushort_t \*Vlv_extent\*L;
.nL
	\*Lushort_t \*Vstatus\*L;
.nL
\*L};
.nL
\*Ltypedef struct pxmap pxmap_t;\*O
.sp
This command returns the map of physical extents on the specified physical
volume.   This mapping indicates the logical volume and logical
extent to which each
corresponds.
A physical extent which is not currently assigned to a logical
volume will be indicated by an \*Vlv_minor\*O value of 0 (zero).
.LI "\*Lioctl(\*Vfd\*L, LVM_QUERYPVPATH, &lv_querypvpath)"
.iX "LVM_QUERYPVPATH command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_querypvpath {
.nL
	\*Lchar     \*V*path\*L;
.nL
	\*Lushort_t \*Vpv_key\*L;
.nL
	\*Lushort_t \*Vpv_flags\*L;
.nL
	\*Lushort_t \*Vpx_count\*L;
.nL
	\*Lushort_t \*Vpx_free\*L;
.nL
	\*Lulong_t  \*Vpx_space\*L;
.nL
	\*Ldev_t    \*Vpv_rdev\*L;
.nL
	\*Lushort_t \*Vmaxdefects\*L;
.nL
	\*Lushort_t \*Vbbpool_len\*L;
.nL
\*L} lv_querypvpath;\*O
.sp
This command is identical to \*LLVM_QUERYPV\*O, except that it takes a
pathname (\*Vpath\*O) as the physical volume identifier.  Also, it
returns the \*Vpv_key\*O rather than taking it as input.
.LI "\*Lioctl(\*Vfd\*L, LVM_QUERYPVS, &lv_querypvs)"
.iX "LVM_QUERYPVS command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_querypvs {
.nL
	\*Lushort_t \*Vnumpvs\*L;
.nL
	\*Lushort_t \*V*pv_keys\*L;
.nL
\*L} lv_querypvs;\*O
.sp
This command retrieves the physical volume list from the volume group.
It requires the number of volumes in the volume group as input (as
obtained from
\*LLVM_QUERYVG\*O)
and returns the \*Vpv_key\*O for each.
.LI "\*Lioctl(\*Vfd\*L, LVM_QUERYVG, &lv_queryvg)"
.iX "LVM_QUERYVG command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_queryvg {
.nL
	\*Llv_uniqueID_t \*Vvg_id\*L;
.nL
	\*Lushort_t \*Vmaxlvs\*L;
.nL
	\*Lushort_t \*Vmaxpvs\*L;
.nL
	\*Lushort_t \*Vmaxpxs\*L;
.nL
	\*Lulong_t  \*Vpxsize\*L;
.nL
	\*Lushort_t \*Vfreepxs\*L;
.nL
	\*Lushort_t \*Vcur_lvs\*L;
.nL
	\*Lushort_t \*Vcur_pvs\*L;
.nL
	\*Lushort_t \*Vstatus\*L;
.nL
\*L} lv_queryvg;
\*O\c
.sp
This command  retrieves information about a specified volume group.  It
verifies that the specified volume group is valid and writes the information
requested to the buffer supplied.
.LE
.PP
.\"from TP "  
.VL
.LI "\*Lioctl(\*Vfd\*L, LVM_REALLOCLV, &lv_realloclv)"
.iX "LVM_REALLOCLV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_realloclv {
.nL
	\*Lushort_t \*Vsourcelv\*L;
.nL
	\*Lushort_t \*Vdestlv\*L;
.nL
	\*Lulong_t \*Vsize\*L;
.nL
	\*Llxmap_t \*V*extents\*L;
.nL
\*L} lv_realloclv;
\*O\c
.sp
This command atomically removes physical extents from one logical
volume (\*Vfd\*O)
and assigns them to another (\*Vdestlv\*O).
The logical extent number of each physical extent is preserved.
If the destination logical volume already has space allocated for the
indicated logical extents, the new extents will be marked as stale by
the reallocation.
.LI "\*Lioctl(\*Vfd\*L, LVM_REDUCELV, &lv_lvsize)"
.iX "LVM_REDUCELV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_lvsize {
.nL
	\*Lushort_t \*Vminor_num\*L;
.nL
	\*Lulong_t \*Vsize\*L;
.nL
	\*Llxmap_t  \*V*extents\*L;
.nL
\*L} lv_lvsize;
.nL
\*Lstruct lxmap {
.nL
	\*Lushort_t \*Vlx_num\*L;
.nL
	\*Lushort_t \*Vpv_key\*L;
.nL
	\*Lushort_t \*Vpx_num\*L;
.nL
	\*Lushort_t \*Vstatus\*L;
.nL
\*L};
.nL
typedef struct \*Llxmap lxmap_t;\*O
.sp
This command removes extents from a specified logical volume.
It deallocates a logical extent for the specified logical volume at the
physical volume.   The extents to be removed are specified as input via
the extent list pointer (\*V*extents\*O).
It updates the LVM data structures and the descriptor area.
.sp
You can use \*LLVM_REDUCELV\*O on a file descriptor corresponding to
a logical volume device.
In this case, the \*Vminor_num\*O field is ignored.
.LI "\*Lioctl(\*Vfd\*L, LVM_REMOVEPV, \*V&pv_key\*L)"
.iX "LVM_REMOVEPV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lint \*Vpv_key\*L;\*O
.sp
This command temporarily removes a physical volume from the
volume group by closing the physical volume device.
If the volume group is active, the physical volume state is changed to
"missing".
This command is effectively the inverse of
\*LLVM_ATTACHPV\*O.
.LI "\*Lioctl(\*Vfd\*L, LVM_RESYNCLV, \*V&minor_num\*L)"
.iX "LVM_RESYNCLV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lint \*Vminor_num\*L;\*O
.sp
This command resynchronizes a logical volume.
As a result, every logical extent in the specified logical volume
(\*Vminor_num\*O), that has a
physical extent in the LVM_PXSTALE state, will be updated from a
mirror copy.
If successful, then the corresponding physical extent's LVM_PXSTALE
state is cleared.
.sp
You can use this command on a file descriptor corresponding to
a logical volume device.
In this case, the \*Vminor_num\*O argument is ignored.
.LI "\*Lioctl(\*Vfd\*L, LVM_RESYNCLX, &lv_resynclx)"
.iX "LVM_RESYNCLX command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_resynclx {
.nL
	\*Lushort_t \*Vminor_num\*L;
.nL
	\*Lushort_t \*Vlx_num\*L;
.nL
} lv_resynclx;\*O
.sp
For each physical
extent of a logical extent, if the physical extent is in
the LVM_PXSTALE state, this command initiates mirror resynchronization
for that physical extent.
When the command is done, these extents will be in the LVM_ACTIVE
state.
.LI "\*Lioctl(\*Vfd\*L, LVM_RESYNCPV, \*V&pv_key\*L)"
.iX "LVM_RESYNCPV command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lint \*Vpv_key\*L;\*O
.sp
This command resynchronizes a physical volume.
For each physical
extent on the physical volume that is in the LVM_PXSTALE state, this command
resynchronizes the corresponding logical extent.
.LI "\*Lioctl(\*Vfd\*L, LVM_SETVGID, &lv_setvgid)"
.iX "LVM_SETVGID command"
.nL
\*Lint \*Vfd\*L;
.nL
\*Lstruct lv_setvgid {
.nL
	\*Llv_uniqueID_t \*Vvg_id\*L;
.nL
\*L} lv_setvgid;
.nL
\*Lstruct lv_uniqueID {
.nL
 	\*Lulong_t \*Vid1\*L;
.nL
	\*Lulong_t \*Vid2\*L;
.nL
\*L};
.nL
typedef struct \*Llv_uniqueID lv_uniqueID_t;\*O
.sp
This command sets the volume group ID for the volume group
implied by the file descriptor.  It fails if the volume group already has a
volume group ID and attached physical volumes.  It is a necessary precursor
to the \*LLVM_ATTACHPV ioctl\*O.  If the unique ID passed in is 0 (zero), it
is stored.
The LVM \*Lioctl\*O commands use the following parameters:
.LE
.PP
.\"from TP "  
.VL
.LI "\*Vallocmap\*O"
Allocation map for logical volume.
.\"from TP "  
.LI "\*Vcur_lvs\*O"
Allowed Values: 0 (zero) to 255
.nL
Current number of logical volumes in this volume group.
.\"from TP "  
.LI "\*Vcur_pvs\*O"
Allowed Values: 0 (zero) to LVM_MAXPVS
.nL
Current number of physical volumes in this volume group.
.\"from TP "  
.LI "\*Vcurrentsize\*O"
Allowed Values: 0 (zero) to LVM_MAXLXS
.nL
Current size for logical volume.
.\"from TP "  
.LI "\*Vextents\*O"
Pointer to the extent array.
\*Vflags\*O
Allowed Values:
.wH .RS  Can not be used in nested lists
.\"from TP .5i"  
.VL
.LI "LVM_ACTIVATE_LVS"
Allow logical volume opens.
.\"from TP .5i"  
.LI "LVM_AUTO_RESYNC"
Automatically resynchronize returned volumes.
.\"from TP .5i"  
.LI "LVM_ALL_PVS_REQUIRED"
Activate fails if any physical volumes are missing.
.\"from TP .5i"  
.LI "LVM_NONMISSING_PVS_REQUIRED"
Activate fails if any physical volumes
are missing which were
not previously known as missing.
.LE
.wH .RE
.\"from TP 1i"  
.LI "\*Vfreepxs\*O"
Allowed Values: 0 (zero) to LVM_MAXPXS
.nL
Current number of free extents.
.\"from TP "  
.LI "\*Vlv_extent\*O"
Allowed Values: 0 (zero) to MAXLXS
.nL
Logical extent number on volume.
.\"from TP "  
.LI "\*Vlv_flags\*O"
Allowed Values: Logical OR of the following constants:
.wH .RS  Can not be used in nested lists
.\"from TP .5i"  
.VL
.LI "LVM_LVDEFINED"
Logical volume entry defined.
.\"from TP .5i"  
.LI "LVM_DISABLED"
Logical volume unavailable for use.
.\"from TP .5i"  
.LI "LVM_NORELOC"
New bad blocks are not relocated.
.\"from TP .5i"  
.LI "LVM_RDONLY"
Read-only logical volume; no writes permitted.
.\"from TP .5i"  
.LI "LVM_STRICT"
Allocate mirrors on different physical volumes.
.\"from TP .5i"  
.LI "LVM_VERIFY"
Verify all writes to the logical volume.
.\"from TP .5i"  
.LI "LVM_NOMWC"
Do not perform mirror write consistency for this logical volume.
.wH .RE
.\"from TP 1i"  
.LE
.LI "\*Vlv_minor\*O"
Allowed Values: 0 (zero) to LVM_MAXLVS
.nL
Logical volume minor number.
\*Vlv_uniqueID\*O
The unique ID should be set to a globally unique number.
.\"from TP "  
.LI "\*Vlx_num\*O"
Allowed Values: 0 (zero) to LVM_MAXLXS
.nL
Logical extent number to perform command on.
.\"from TP "  
.LI "\*Vmap\*O"
Pointer to the physical extent map.
.\"from TP "  
.LI "\*Vmaxdefects\*O"
Allowed Values: 0 (zero) to bbpool_len
.nL
Maximum number of software-relocated defects.
.\"from TP "  
.LI "\*Vmaxlvs\*O"
Allowed Values: 0 (zero) to LVM_MAXLVS
.nL
Maximum number of logical volumes this volume group will contain.
.\"from TP "  
.LI "\*Vmaxlxs\*O"
Allowed Values: 0 (zero) to LVM_MAXLXS
.nL
New maximum size for logical volume, count of logical extents.
.\"from TP "  
.LI "\*Vmaxmirrors\*O"
Allowed Values: LVM_MAXCOPIES
.nL
Maximum number of mirrors allowed for this logical volume.
.\"from TP "  
.LI "\*Vmaxpvs\*O"
Allowed Values: 0 (zero) to LVM_MAXPVS
.nL
Maximum number of physical volumes this volume group will contain.
.\"from TP "  
.LI "\*Vmaxpxs\*O"
Allowed Values: 0 (zero) to LVM_MAXPXS
.nL
Maximum number of physical extents any physical volumes in this volume
group will contain.
.\"from TP "  
.LI "\*Vminor_num\*O"
Allowed Values: 1 to LVM_MAXLVS (or 255)
.nL
Logical volume minor number.
.\"from TP "  
.LI "\*Vpath\*O"
Allowed Values: PATH_MAX chars max
.nL
NULL terminated physical volume pathname.
.\"from TP "  
.LI "\*Vnumlxs\*O"
Allowed Values: 0 (zero) to LVM_MAXLXS
.nL
Current number of logical extents.
.\"from TP "  
.LI "\*Vopt_avoid\*O"
Allowed Values: 0 (zero) to LVM_MIRAVOID
.nL
Mirrors avoided during raw reads.
.\"from TP "  
.LI "\*Vopt_options\*O"
Allowed Values: Logical OR of the following constants:
.wH .RS  Can not be used in nested lists
.\"from TP .5i"  
.VL
.LI "LVM_NORELOC"
No bad block relocation performed.
.\"from TP .5i"  
.LI "LVM_VERIFY"
Verify all writes.
.wH .RE
.\"from TP 1i"  
.LE
.LI "\*Vpv_flags\*O"
Allowed Values: Logical OR of the following constants:
.wH .RS  Can not be used in nested lists
.\"from TP .5i"  
.VL
.LI "LVM_PVNOALLOC"
No extent allocation allowed from this physical volume.
.\"from TP .5i"  
.LI "LVM_PVRORELOC"
No new defects relocated on this physical volume.
.\"from TP .5i"  
.LI "LVM_NOVGDA"
No extent allocation allowed from this physical volume.
.wH .RE
.\"from TP 1i"  
.LE
.LI "\*Vpv_flags\*O"
Allowed Values: Logical OR of the following constants:
.wH .RS  Can not be used in nested lists
.\"from TP .5i"  
.VL
.LI "LVM_PVMISSING"
Physical volume is missing from the volume group.
.\"from TP .5i"  
.LI "LVM_NOTATTACHED"
Physical volume is not attached to a volume group.
.\"from TP .5i"  
.LI "LVM_NOVGDTA"
Physical volume does not contain a Volume Group Descriptor Area.
.\"from TP .5i"  
.LI "LVM_PVNOALLOC"
No extent allocation allowed from this physical volume.
.\"from TP .5i"  
.LI "LVM_PVRORELOC"
No new defects relocated on this physical volume.
.wH .RE
.\"from TP 1i"  
.LE
.LI "\*Vpv_key\*O"
Allowed Values: Internally defined
.nL
Physical volume identifier assigned by driver.
.\"from TP "  
.LI "\*Vnumpxs\*O"
Allowed Values: 0 (zero) to LVM_MAXPXS
.nL
Total number of physical extents on this physical volume.
.\"from TP "  
.LI "\*Vpv_rdev\*O"
Device number (major,minor) currently used to access this physical
volume.  Not valid if physical volume is not attached.
.\"from TP "  
.LI "\*Vpx_num\*O"
Allowed Values: 0 (zero) to LVM_MAXPXS
.nL
Physical extent number to add or remove.
.\"from TP "  
.LI "\*Vpxsize\*O"
Allowed Values: 1MB to 256MB
.nL
Physical extent size for all extents in this volume group (in bytes).
Must be a power of 2.
.\"from TP "  
.LI "\*Vpxspace\*O"
Allowed Values: 1MB to 256MB
.nL
Actual space allocated for each extent (in bytes).
This must be the same or larger than \*Vpxsize\*O.
.\"from TP "  
.LI "\*Vpx_count\*O"
Allowed Values: 0 (zero) to LVM_MAXPXS
.nL
Maximum number of physical extents this physical volume will ever contain.
.\"from TP "  
.LI "\*Vpx_free\*O"
Allowed Values: 0 (zero) to LVM_MAXPXS
.nL
Current number of free physical extents on this physical volume.
.\"from TP "  
.LI "\*Vpx_space\*O"
Allowed Values: 1MB to 256MB
.nL
Actual space allocated for each extent (in bytes).
This must be the same or larger than \*Vpxsize\*O.
.\"from TP "  
.LI "\*Vsched_strat\*O"
Allowed Values:
.wH .RS  Can not be used in nested lists
.\"from TP .5i"  
.VL
.LI "LVM_SEQUENTIAL"
Write mirror copies sequentially.
.\"from TP .5i"  
.LI "LVM_PARALLEL"
Write mirror copies in parallel.
.wH .RE
.\"from TP 1i"  
.LE
.LI "\*Vsize\*O"
Allowed Values: 1 to LVM_MAXPXS
.nL
Number of extents to add or remove.
.\"from TP "  
.LI "\*Vstatus\*O"
Allowed Values: Any
This parameter is ignored.
\*Vstatus\*O
Allowed Values: LVM_PXSTALE
.nL
Physical extent is stale.
.\"from TP "  
.LI "\*Vstatus\*O"
Allowed Values: Logical OR of the following constants:
.wH .RS  Can not be used in nested lists
.\"from TP .5i"  
.VL
.LI "LVM_PXSTALE"
Physical extent is stale (does not contain valid data).
.\"from TP .5i"  
.LI "LVM_PXMISSING"
Physical extent is on a missing physical volume.
.LE
.LI "\*Vvg_id\*O"
Allowed Values: Valid unique ID
.nL
Valid volume group unique ID.
.\"from TP "  
.LI "\*Vvg_state\*O"
Allowed Values: Logical OR of the following constants:
.wH .RS  Can not be used in nested lists
.\"from TP .5i"  
.VL
.LI "LVM_VGACTIVATED"
Volume group is activated.
.\"from TP .5i"  
.LI "LVM_LVSACTIVATED"
Logical volumes are activated.
.LE
.LE
.SH ERRORS
.PP
On failure, the LVM \*Lioctl\*O commands return the following:
.PP
\*LLVM_ACTIVATEVG\*O
.nL
.\"from TP 1i"  
.VL 1i
.LI "[ENODEV]"
No valid volume group descriptor areas (VGDA) were found on any
physical volume.
.\"from TP 1i"  
.LI "[ENODEV]"
Could not find a valid volume group status area (VGSA).
.\"from TP 1i"  
.LI "[ENOENT]"
Quorum was lost while attempting to update the volume group status area.
.\"from TP 1i"  
.LI "[EEXIST]"
LVM_ALL_PVS_REQUIRED was specified and at least one physical volume was missing.
.\"from TP 1i"  
.LI "[ENOMEM]"
Insufficient kernel memory to complete request.
.\"from TP 1i"  
.LI "[ENXIO]"
Quorum does not exist.
.\"from TP 1i"  
.LI "[EIO]"
I/O error while reading the bad block directory.
.\"from TP 1i"  
.LI "[EINVAL]"
There is an invalid physical extent in the VGDA's extent map.
.\"from TP 1i"  
.LI "[ENOTDIR]"
LVM_NONMISSING_PVS_REQUIRED was specified and a "nonmissing" physical
volume has not been
attached.
.LE
.PP
\*LLVM_ATTACHPV\*O
.nL
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The \*Vpath\*O parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[ENXIO]"
The physical volume is a member of another volume group.
.\"from TP 1i"  
.LI "[ENOENT]"
A component of the \*Vpath\*O parameter does not exist.
.\"from TP 1i"  
.LI "[ENOTDIR]"
A component of the \*Vpath\*O parameter prefix is not a directory.
.\"from TP 1i"  
.LI "[ENXIO]"
The \*Vpath\*O parameter refers to a device that does not exist, or is
not configured into the kernel.
.\"from TP 1i"  
.LI "[ENOTBLK]"
The \*Vpath\*O parameter designates a file that is not a block device.
.\"from TP 1i"  
.LI "[EACCES]"
A component of the \*Vpath\*O parameter was not accessible.
.\"from TP 1i"  
.LI "[ELOOP]"
Too many symbolic links were encountered while looking up the path.
.\"from TP 1i"  
.LI "[ENAMETOOLONG]"
The \*Vpath\*O parameter is too long, or a component exceeds the
maximum allowable size.
.\"from TP 1i"  
.LI "[EEXIST]"
A physical volume with the same physical volume number is
already attached to this volume group.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device rather than the control device.
.\"from TP 1i"  
.LI "[ENODEV]"
The physical volume is not a member of any volume group.
.\"from TP 1i"  
.LI "[EXDEV]"
The physical volume is not a member of the specified volume group.
.\"from TP 1i"  
.LI "[ENOMEM]"
Insufficient kernel memory to complete request.
.\"from TP 1i"  
.LI "[EIO]"
I/O error while reading the bad block directory or the volume group descriptor
area.
.LE
.PP
\*LLVM_CHANGELV\*O
.nL
.\"from TP 1i"  
.VL 1i
.LI "[EINVAL]"
The \*Vminor_num\*O parameter is invalid.
.\"from TP 1i"  
.LI "[EINVAL]"
The \*Vmaxmirrors\*O parameter was not in the range (0, LVM_MAXCOPIES-1).
.\"from TP 1i"  
.LI "[EINVAL]"
The \*Vlv_flags\*O parameter contains an unrecognized flag.
.\"from TP "  
.LI "[EROFS]"
The volume group is not activated.
.\"from TP 1i"  
.LI "[ENODEV]"
The \*Vminor_num\*O parameter refers to a nonexistent logical volume.
.\"from TP 1i"  
.LI "[EINVAL]"
The \*Vsched_strat\*O parameter was not one of LVM_PARALLEL or LVM_SEQUENTIAL.
[EBUSY]
The \*Vmaxlxs\*O or \*Vmaxmirrors\*O parameter is smaller than the
current allocation for
the logical volume. Must deallocate before changing the logical size.
.\"from TP 1i"  
.LI "[ENOMEM]"
Insufficient kernel memory to complete request.
.\"from TP 1i"  
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.LE
.PP
\*LLVM_CHANGEPV\*O
.nL
.\"from TP 1i"  
.VL 1i
.LI "[EINVAL]"
The \*Vpv_flags\*O parameter contains unrecognized flags.
.\"from TP 1i"  
.LI "[ENXIO]"
The \*Vpv_key\*O parameter references a nonexisting physical volume.
.\"from TP 1i"  
.LI "[EBUSY]"
There are more existing defects than could be supported with the
\*Vmax_defects\*O
parameter.
.\"from TP 1i"  
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device rather than the control device.
.LE
.PP
\*LLVM_CREATELV\*O
.nL
.\"from TP 1i"  
.VL 1i
.LI "[EINVAL]"
The \*Vminor_num\*O parameter is 0 (zero).
.\"from TP 1i"  
.LI "[EDOM]"
The \*Vminor_num\*O parameter is greater than the maximum number of logical
volumes in the
volume group.
.\"from TP 1i"  
.LI "[EEXIST]"
The \*Vminor_num\*O parameter refers to an already existing logical volume.
.\"from TP 1i"  
.LI "[ENOMEM]"
Insufficient kernel memory to satisfy the request.
.\"from TP 1i"  
.LI "[EROFS]"
The volume group is not activated.
.\"from TP 1i"  
.LI "[ENODEV]"
The \*Vminor_num\*O parameter refers to a nonexistent logical volume.
.\"from TP 1i"  
.LI "[EINVAL]"
The \*Vsched_strat\*O parameter was not one of LVM_PARALLEL or LVM_SEQUENTIAL.
.\"from TP 1i"  
.LI "[EBUSY]"
The \*Vmaxlxs\*O or \*Vmaxmirrors\*O parameter is smaller than the
current allocation for
the logical volume. Must deallocate before changing the logical size.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device rather than the control device.
.LE
.PP
\*LLVM_CREATEVG\*O
.nL
.\"from TP 1i"  
.VL 1i
.LI "[EINVAL]"
Invalid parameter structure; some field within the
structure contained an invalid value.  Specific checks are made for; 0 (zero)
volume group ID, the \*Vmaxlvs\*O parameter greater than LVM_MAXLVS,
the \*Vmaxpvs\*O parameter greater than MAXPVS,
the \*Vmaxpxs\*O parameter greater than LVM_MAXPXS, 1MB <= \*Vpxsize\*O <=
256MB, \*Vpxsize\*O <= \*Vpxspace\*O,
the \*Vpxspace\*O parameter is a multiple DEV_BSIZE, the
\*Vpv_flags\*O parameter is valid.
.\"from TP 1i"  
.LI "[EEXIST]"
The volume group already exists.
.\"from TP 1i"  
.LI "[ENOMEM]"
Insufficient kernel memory to complete request.
.\"from TP 1i"  
.LI "[ENOSPC]"
Insufficient space on the volume for the volume group reserved area (VGRA).
.\"from TP 1i"  
.LI "[ENOENT]"
The file specified by the \*Vpath\*O parameter does not exist.
.\"from TP 1i"  
.LI "[ENODEV]"
The \*Vpath\*O parameter does not specify a valid physical volume.
.\"from TP 1i"  
.LI "[EPERM]"
Permission denied on open of the \*Vpath\*O parameter.
.\"from TP 1i"  
.LI "[EIO]"
Unable to read the physical volume.
.\"from TP 1i"  
.LI "[ENOTBLK]"
The \*Vpath\*O parameter designates a file that is not a block device.
.\"from TP 1i"  
.LI "[ENXIO]"
The physical volume has no driver configured.
.\"from TP 1i"  
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device rather than the control device.
.LE
.PP
\*LLVM_DEACTIVATEVG\*O
.nL
.\"from TP 1i"  
.VL 1i
.LI "[EINVAL]"
The \*Vminor_num\*O parameter was less than or equal to zero.
.\"from TP 1i"  
.LI "[EROFS]"
The volume group is not activated.
.\"from TP 1i"  
.LI "[ENODEV]"
The \*Vminor_num\*O parameter refers to a nonexistent logical volume.
.\"from TP 1i"  
.LI "[EBUSY]"
The indicated logical volume is open.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device rather than the control device.
.LE
.PP
\*LLVM_DELETEPV\*O
.\"from TP 1i"  
.VL 1i
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device rather than the control device.
.LE
.PP
\*LLVM_EXTENDLV\*O
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[EBUSY]"
An extent described by the extent array is already in use.
.\"from TP 1i"  
.LI "[ENODEV]"
The specified logical volume does not exist.
.LE
.PP
\*LLVM_INSTALLPV\*O
.\"from TP 1i"  
.VL 1i
.LI "[EROFS]"
The volume group is not active.
.\"from TP 1i"  
.LI "[ENOMEM]"
Unable to allocate memory.
.\"from TP 1i"  
.LI "[ENODEV]"
The device is not a valid physical volume.
.\"from TP 1i"  
.LI "[EPERM]"
Write permission denied on the device.
.\"from TP 1i"  
.LI "[EACCES]"
A component of the \*Vpath\*O parameter was not accessible.
.\"from TP 1i"  
.LI "[EIO]"
Unable to read the physical volume.
.\"from TP 1i"  
.LI "[ENOTBLK]"
The \*Vpath\*O parameter designates a file that is not a block device.
.\"from TP 1i"  
.LI "[ENXIO]"
The physical volume has no driver configured.
.\"from TP 1i"  
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device rather than the control device.
.LE
.PP
\*LLVM_OPTIONSET/LVM_OPTIONGET\*O
.\"from TP 1i"  
.VL 1i
.LI "[EINVAL]"
The \*Vopt_avoid\*O parameter out of range (\*LLVM_OPTIONSET\*O only).
.\"from TP 1i"  
.LI "[EINVAL]"
The \*Vopt_options\*O parameter included invalid bit values
(\*LLVM_OPTIONSET\*O only).
.\"from TP 1i"  
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on the control device.
.LE
.PP
\*LLVM_QUERYLV\*O
.\"from TP 1i"  
.VL 1i
.LI "[EINVAL]"
The \*Vminor_num\*O parameter is 0 (zero).
.\"from TP 1i"  
.LI "[ENXIO]"
The volume group is not activated.
.\"from TP 1i"  
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.LE
.PP
\*LLVM_QUERYLVMAP\*O
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.LE
.PP
\*LLVM_QUERYPV\*O
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[ENODEV]"
The specified \*Vpv_key\*O parameter does not correspond to physical volume
attached to this volume group, that is, no such device.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on the control device.
.LE
.PP
\*LLVM_QUERYPVMAP\*O
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[ENODEV]"
The specified \*Vpv_key\*O parameter does not correspond to physical volume
attached to this volume group, that is, no such device.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on the control device.
.LE
.PP
\*LLVM_QUERYPATH\*O
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[ENOENT]"
A component of the \*Vpath\*O parameter does not exist.
.\"from TP 1i"  
.LI "[ENOTDIR]"
A component of the \*Vpath\*O parameter prefix is not a directory.
.\"from TP 1i"  
.LI "[ENXIO]"
The \*Vpath\*O parameter refers to a device that does not exist, or is
not configured into the kernel.
.\"from TP 1i"  
.LI "[ENOTBLK]"
The \*Vpath\*O parameter designates a file that is not a block device.
.\"from TP 1i"  
.LI "[EACCES]"
A component of the \*Vpath\*O parameter was not accessible.
.LI "[ELOOP]"
Too many symbolic links were encountered while looking up the path.
.\"from TP 1i"  
.LI "[ENAMETOOLONG]"
The \*Vpath\*O parameter is too long, or a component exceeds the
maximum allowable size.
.\"from TP 1i"  
.LI "[ENODEV]"
The specified \*Vpath\*O parameter does not correspond to physical volume
attached to this volume group, that is, no such device.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device.
.LE
.PP
\*LLVM_QUERYPVS\*O
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device.
.LE
.PP
\*LLVM_QUERYVG\*O
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.LE
.PP
\*LLVM_REDUCELV\*O
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.LE
.PP
\*LLVM_RESYNCLX\*O
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.LE
.PP
\*LLVM_RESYNCPV\*O
.\"from TP 1i"  
.VL 1i
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device.
.LE
.PP
\*LLVM_SETVGID\*O
.\"from TP 1i"  
.VL 1i
.LI "[EFAULT]"
The parameter does not refer to a valid memory address.
.\"from TP 1i"  
.LI "[ENOTTY]"
Inappropriate \*Lioctl\*O for device; the command was attempted
on a logical volume device rather than the control device.
.LE
.SH RELATED INFORMATION
.PP
Function:
\*Lioctl\*O(2)
.iX "lvm" "Logical Volume Manager"
.EQ
delim off
.EN
