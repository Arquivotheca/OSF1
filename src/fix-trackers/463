Path: news!news.crl.dec.com!pa.dec.com!nobody
Message-Id: <9210200009.AA19704@explain.lcs.mit.edu>
To: fix-trackers@expo.lcs.mit.edu
Subject: (seq: 2700) close XBUG #5571: Xlib: (Ximp) keyEvent dropping/dis-order problem (6 of 7)
Date: Mon, 19 Oct 92 20:09:02 EDT
From: Bob Scheifler <rws@expo.lcs.mit.edu>
Distribution: dec
X-Mailing-List: fix-trackers@expo.lcs.mit.edu
X-Disclaimer: This message originated from a mailing list outside of Digital.
Newsgroups: dec.mail.lists.x.fix-trackers
Approved: news@usenet.pa.dec.com

### bug number:   5571
### area:         Xlib
### severity:     low
### comments:     part 6 of 7

*** /tmp/d19013	Mon Oct 19 19:35:15 1992
--- lib/X/Ximp/XimpICS.c	Mon Oct 19 19:24:43 1992
***************
*** 1,38 ****
! /* $XConsortium: XimpICS.c,v 1.4 92/07/29 10:16:04 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
! provided that the above copyright notice appear in all copies and
! that both that copyright notice and this permission notice appear
! in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporaion not be used in advertising or publicity
! pertaining to distribution of the software without specific,
! written prior permission.
! FUJITSU LIMITED and Sony Corporaion make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
! SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
! OR PERFORMANCE OF THIS SOFTWARE.
  
!   Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
! #define	NEED_EVENTS
  #include "Xlibint.h"
  #include "Xlcint.h"
  
  #include "Ximplc.h"
  
--- 1,41 ----
! /* $XConsortium: XimpICS.c,v 1.5 92/10/19 19:24:39 rws Exp $ */
  /******************************************************************
  
!     Copyright 1991, 1992 by FUJITSU LIMITED.
!     Copyright 1991, 1992 by Sun Microsystems, Inc.
!     Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
! provided that the above copyright notice appear in all copies and that
! both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of FUJITSU LIMITED, Sun
! Microsystems, Inc. and Sony Corporation  not be used in advertising
! or publicity pertaining to distribution of the software without
! specific, written prior permission.
! FUJITSU LIMITED , Sun Microsystems, Inc. and Sony Corporation make no
! representations about the suitability of this software for any
! purpose.  It is provided "as is" without express or implied warranty.
  
! FUJITSU LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION DISCLAIM
! ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU
! LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION BE LIABLE FOR ANY
! SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
! RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
! CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
! CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
! Author: Takashi Fujiwara     FUJITSU LIMITED
!         Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
! #define NEED_EVENTS
  #include "Xlibint.h"
  #include "Xlcint.h"
+ #include "Xutil.h"
  
  #include "Ximplc.h"
  
***************
*** 41,58 ****
  extern void		_Ximp_SetValue_Resource();
  extern Bool		_Ximp_SetICExtension();
  
! extern void		_Ximp_SetFocusWindow();
  extern void		_Ximp_SetPreeditAtr();
  extern void		_Ximp_SetPreeditFont();
  extern void		_Ximp_SetStatusAtr();
  extern void		_Ximp_SetStatusFont();
  extern void		_Ximp_IM_SendMessage();
  extern Bool		_Ximp_XimFilter_Keypress();
  
  static Bool		_Ximp_PreSetAttributes();
  static Bool		_Ximp_StatusSetAttributes();
  
- 
  static Bool
  _Ximp_PNPredicate( d, ev, arg0 )
  Display		*d;
--- 44,66 ----
  extern void		_Ximp_SetValue_Resource();
  extern Bool		_Ximp_SetICExtension();
  
! extern void		_Ximp_SetFocusWindowProp();
! extern void		_Ximp_SetFocusWindowFilter();
  extern void		_Ximp_SetPreeditAtr();
  extern void		_Ximp_SetPreeditFont();
  extern void		_Ximp_SetStatusAtr();
  extern void		_Ximp_SetStatusFont();
  extern void		_Ximp_IM_SendMessage();
+ extern void		_Ximp_ProcError();
+ extern Bool		_Ximp_CMPredicate32();
  extern Bool		_Ximp_XimFilter_Keypress();
+ extern Bool		_Ximp_XimFilter_Keyrelease();
+ extern Bool		_Ximp_XimFilter_Client();
+ extern void		_Ximp_GetFocusWindowSelectMask();
  
  static Bool		_Ximp_PreSetAttributes();
  static Bool		_Ximp_StatusSetAttributes();
  
  static Bool
  _Ximp_PNPredicate( d, ev, arg0 )
  Display		*d;
***************
*** 67,81 ****
  	    ev->xproperty.state == PropertyDelete ) {
  	    return(True);
  	}
!     }
!     else if( ev->type == ClientMessage ) {
  	if( ev->xclient.message_type == arg->type  &&
  	    ev->xclient.format == 32  &&
  	    ev->xclient.data.l[1] == arg->icid  &&
! 	    ev->xclient.data.l[0] == XIMP_ERROR )
  	    return( True );
!     }
!     else if( ev->type == DestroyNotify ) {
  	if( ev->xdestroywindow.window == arg->owner ) {
  	    return( True );
  	}
--- 75,87 ----
  	    ev->xproperty.state == PropertyDelete ) {
  	    return(True);
  	}
!     } else if( ev->type == ClientMessage ) {
  	if( ev->xclient.message_type == arg->type  &&
  	    ev->xclient.format == 32  &&
  	    ev->xclient.data.l[1] == arg->icid  &&
! 	    ISXIMP_ERROR(ev) )
  	    return( True );
!     } else if( ev->type == DestroyNotify ) {
  	if( ev->xdestroywindow.window == arg->owner ) {
  	    return( True );
  	}
***************
*** 125,525 ****
  
  char *
  _Ximp_SetICValues(ic, values)
! 	Ximp_XIC	 ic;
! 	XIMArg		*values;
! 	{
! 	XIM		 im;
! 	char		*ret;
! 	int		 change_mask = 0;
  
! 	if((ret = _Ximp_SetICValueData(ic, values, XIMP_SET_IC, &change_mask)))
! 		return(ret);
  
! 	if(   (ic->ximp_icpart->value_mask & XIMP_RES_NAME)
! 	   || (ic->ximp_icpart->value_mask & XIMP_RES_CLASS) )
! 		_Ximp_SetValue_Resource(ic, &change_mask);
  
! 	if(ic->ximp_icpart->icid == NULL) {
! 		if(change_mask & XIMP_PROP_FOCUS) {
! 			if(ic->ximp_icpart->filter_mode & 0x1) {
! 				_XUnregisterFilter (ic->core.im->core.display,
! 						ic->ximp_icpart->back_focus_win,
! 						_Ximp_XimFilter_Keypress,
! 						(XPointer)ic);
! 				}
! 			_XRegisterFilterByType (ic->core.im->core.display,
! 						ic->core.focus_window,
! 						KeyPress, KeyPress,
! 						_Ximp_XimFilter_Keypress,
! 						(XPointer)ic);
! 			ic->ximp_icpart->filter_mode |= 0x1;
! 			}
! 		return(ret);
! 		}
  
! 	if(ic->core.input_style & XIMPreeditPosition) {
! 		if(change_mask == XIMP_PRE_SPOTL_MASK) {
! 			if(ic->ximp_icpart->input_mode)
! 			    _Ximp_IM_SendMessage(ic, XIMP_MOVE,
! 				ic->ximp_icpart->preedit_attr.SpotLocation.x,
! 				ic->ximp_icpart->preedit_attr.SpotLocation.y,
! 				NULL);
! 			return(ret);
! 		}
  	}
! 	if(change_mask & XIMP_PROP_FOCUS)
! 		_Ximp_SetFocusWindow(ic);
! 	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	     || (ic->core.input_style & XIMPreeditNone) ) ) { 
! 		if(change_mask & XIMP_PROP_PREEDIT)
! 			_Ximp_SetPreeditAtr(ic);
! 		if(change_mask & XIMP_PROP_PREFONT)
! 			_Ximp_SetPreeditFont(ic);
! 		}
! 	else {
! 		change_mask &= ~(XIMP_PROP_PREEDIT | XIMP_PROP_PREFONT);
! 		}
! 	if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	     || (ic->core.input_style & XIMStatusNone) ) ) { 
! 		if(change_mask & XIMP_PROP_STATUS)
! 			_Ximp_SetStatusAtr(ic);
! 		if(change_mask & XIMP_PROP_STSFONT)
! 			_Ximp_SetStatusFont(ic);
! 		}
! 	else {
! 		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
! 		}
! 	if(change_mask) {
! 	    XWindowAttributes		war;
! 	    long			mask;
  
! 	    XGetWindowAttributes( ic->core.im->core.display,
! 				  ic->core.client_window, &war );
! 	    XSelectInput( ic->core.im->core.display, ic->core.client_window,
! 			  war.your_event_mask | PropertyChangeMask );
! 	    _Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
! 	    if( change_mask & XIMP_PROP_FOCUS )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_PREEDIT )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_PREFONT )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_STATUS )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_STSFONT )
! 		!_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
! 	    XSelectInput( ic->core.im->core.display, ic->core.client_window,
! 			  war.your_event_mask );
  	}
  	return(ret);
  }
  
  char *
  _Ximp_SetICValueData(ic, values, mode, change_mask)
! 	Ximp_XIC	 ic;
! 	XIMArg		*values;
! 	int		 mode;
! 	int		*change_mask;
! 	{
! 	XIMArg		*p;
! 	char		*return_name = NULL;
  
! 	for(p = values; p->name != NULL; p++) {
! 		if(strcmp(p->name, XNInputStyle) == 0) {
! 			if(mode == XIMP_CREATE_IC) {
! 				ic->core.input_style = (XIMStyle)p->value;
! 				ic->ximp_icpart->value_mask |= XIMP_INPUT_STYLE;
! 				}
! 			else
! 				; /* Currently Fixed value */
! 			}
! 		else if(strcmp(p->name, XNClientWindow)==0) {
! 			if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 				if(mode == XIMP_SET_IC && (ic->ximp_icpart->icid)) {
! 					long	icid_old, icid_new;
! 					Window	client_window;
  
! 					icid_old = ic->ximp_icpart->icid;
! 					client_window = ic->core.client_window;
! 					ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
! 					ic->core.client_window = (Window)p->value;
! 					if(_Ximp_SetOpenXIMP(ic, mode) == False) {
! 						return_name = p->name;
! 						ic->ximp_icpart->value_mask &= ~XIMP_CLIENT_WIN;
! 						ic->core.client_window = client_window;
! 						break;
! 						}
! 					icid_new = ic->ximp_icpart->icid;
! 					ic->ximp_icpart->icid = icid_old;
! 					_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
! 					ic->ximp_icpart->icid = icid_new;
! 					XDestroyWindow(ic->core.im->core.display,
! 						       client_window);
! 					*change_mask = NULL;
! 					}
! 				else { /* XIMP_CREATE_IC | (XIMP_SET_IC && XIMP_START_IC) */
! 					ic->core.client_window = (Window)p->value;
! 					ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
! 					if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
! 						ic->core.focus_window = ic->core.client_window;
! 						ic->ximp_icpart->proto_mask |= XIMP_FOCUS_WIN_MASK;
! 						}
! 					}
! 				}
! 			else {
! 				return_name = p->name;
! 				break; /* Can't change this value */
! 				}
  			}
! 		else if(strcmp(p->name, XNFocusWindow)==0) {
! 			if(mode == XIMP_SET_IC && ic->ximp_icpart->input_mode) {
! 				Window	new_focus_window = (Window)p->value;
! 				unsigned long	dummy_mask;
! 				XWindowAttributes	wattr;
  
! 				XSelectInput(ic->core.im->core.display,
! 					     ic->core.focus_window,
! 					     ic->ximp_icpart->back_mask);
! 				XGetWindowAttributes(ic->core.im->core.display,
! 						     new_focus_window,
! 						     &wattr);
! 				dummy_mask = wattr.your_event_mask;
! 				ic->ximp_icpart->back_mask = dummy_mask;
! 				if(ic->ximp_icpart->is_bep_mode == XIMP_FRONTEND) {
! 					dummy_mask &= ~(KeyPressMask | KeyReleaseMask);
! 					}
! 				else {
! 					dummy_mask &= ~(KeyReleaseMask);
! 					}
! 				XSelectInput(ic->core.im->core.display,
! 					     new_focus_window,
! 					     dummy_mask);
! 				}
! 			ic->ximp_icpart->back_focus_win = ic->core.focus_window;
! 			ic->core.focus_window = (Window)p->value;
! 			ic->ximp_icpart->proto_mask |= XIMP_FOCUS_WIN_MASK;
! 			*change_mask                |= XIMP_FOCUS_WIN_MASK;
  			}
! 		else if(strcmp(p->name, XNResourceName)==0) {
! 			ic->core.im->core.res_name = (char *)p->value;
! 			ic->ximp_icpart->value_mask |= XIMP_RES_NAME;
! 			}
! 		else if(strcmp(p->name, XNResourceClass)==0) {
! 			ic->core.im->core.res_class = (char *)p->value;
! 			ic->ximp_icpart->value_mask |= XIMP_RES_CLASS;
! 			}
! 		else if(strcmp(p->name, XNGeometryCallback)==0) {
! 			ic->core.geometry_callback.client_data =
! 				((XIMCallback *)p->value)->client_data;
! 			ic->core.geometry_callback.callback =
! 				((XIMCallback *)p->value)->callback;
! 			ic->ximp_icpart->value_mask |= XIMP_GEOMETRY_CB;
! 			}
! 		else if(strcmp(p->name, XNPreeditAttributes)==0) {
! 			if( _Ximp_PreSetAttributes(ic,
! 				&(ic->ximp_icpart->preedit_attr),
! 				p->value, mode, change_mask,
! 				return_name) == False )
! 				break;
! 			}
! 		else if(strcmp(p->name, XNStatusAttributes)==0) {
! 			if( _Ximp_StatusSetAttributes(ic,
! 				&(ic->ximp_icpart->status_attr),
! 				p->value, mode, change_mask,
! 				return_name) == False )
! 				break;
! 			}
! 		else {
! 			if( _Ximp_SetICExtension(ic, p->name, p->value, mode) == False ) {
! 				return_name = p->name;
! 				break;
! 				}
! 			}
  		}
! 	return(return_name);
  	}
! 		
  static Bool
  _Ximp_PreSetAttributes(ic, attr, vl, mode, change_mask, return_name)
! 	Ximp_XIC		 ic;
! 	Ximp_PreeditPropRec	*attr;
! 	XIMArg			*vl;
! 	int			 mode;
! 	int			*change_mask;
! 	char			*return_name;
! 	{
! 	XIMArg			*p;
! 	Colormap		 colormap_ret;
! 	int			 list_ret;
! 	XFontStruct		**struct_list;
! 	char			**name_list;
! 	int 			 i, len;
! 	char 			*tmp;
  
! 
! 	for(p = vl; p->name != NULL; p++) {
! 		if(strcmp(p->name, XNArea)==0) {
! 			ic->core.preedit_attr.area.x = ((XRectangle *)p->value)->x;
! 			ic->core.preedit_attr.area.y = ((XRectangle *)p->value)->y;
! 			ic->core.preedit_attr.area.width = ((XRectangle *)p->value)->width;
! 			ic->core.preedit_attr.area.height = ((XRectangle *)p->value)->height;
! 			attr->Area.x      = ic->core.preedit_attr.area.x;
! 			attr->Area.y      = ic->core.preedit_attr.area.y;
! 			attr->Area.width  = ic->core.preedit_attr.area.width;
! 			attr->Area.height = ic->core.preedit_attr.area.height;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_AREA_MASK;
! 			*change_mask                |= XIMP_PRE_AREA_MASK;
! 			}
! 		else if(strcmp(p->name, XNAreaNeeded)==0) {
! 			ic->core.preedit_attr.area_needed.width  = ((XRectangle *)p->value)->width;
! 			ic->core.preedit_attr.area_needed.height = ((XRectangle *)p->value)->height;
! 			attr->AreaNeeded.width  = ic->core.preedit_attr.area_needed.width;
! 			attr->AreaNeeded.height = ic->core.preedit_attr.area_needed.height;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_AREANEED_MASK;
! 			*change_mask                |= XIMP_PRE_AREANEED_MASK;
! 			}
! 		else if(strcmp(p->name, XNSpotLocation)==0) {
! 			ic->core.preedit_attr.spot_location.x = ((XPoint *)p->value)->x;
! 			ic->core.preedit_attr.spot_location.y = ((XPoint *)p->value)->y;
! 			attr->SpotLocation.x = ic->core.preedit_attr.spot_location.x;
! 			attr->SpotLocation.y = ic->core.preedit_attr.spot_location.y;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_SPOTL_MASK;
! 			*change_mask                |= XIMP_PRE_SPOTL_MASK;
! 			}
! 		else if(strcmp(p->name, XNColormap)==0) {
! 			ic->core.preedit_attr.colormap = (Colormap)p->value;
! 			attr->Colormap = ic->core.preedit_attr.colormap;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_COLORMAP_MASK;
! 			*change_mask                |= XIMP_PRE_COLORMAP_MASK;
! 			}
! 		else if(strcmp(p->name, XNStdColormap)==0) {
! 			if( XGetStandardColormap(ic->core.im->core.display,
! 					ic->core.focus_window,
! 					&colormap_ret, (Atom)p->value) != 0) {
! 				ic->core.preedit_attr.colormap = colormap_ret;
! 				attr->Colormap = ic->core.preedit_attr.colormap;
! 				ic->ximp_icpart->proto_mask |= XIMP_PRE_COLORMAP_MASK;
! 				*change_mask                |= XIMP_PRE_COLORMAP_MASK;
! 				}
! 			else {
! 				return_name = p->name;
! 				return(False);
! 				}
! 			}
! 		else if(strcmp(p->name, XNBackground)==0) {
! 			ic->core.preedit_attr.background = (unsigned long)p->value;
! 			attr->Background = ic->core.preedit_attr.background;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_BG_MASK;
! 			*change_mask                |= XIMP_PRE_BG_MASK;
! 			}
! 		else if(strcmp(p->name, XNForeground)==0) {
! 			ic->core.preedit_attr.foreground = (unsigned long)p->value;
! 			attr->Foreground = ic->core.preedit_attr.foreground;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_FG_MASK;
! 			*change_mask                |= XIMP_PRE_FG_MASK;
! 			}
! 		else if(strcmp(p->name, XNBackgroundPixmap)==0) {
! 			ic->core.preedit_attr.background_pixmap = (Pixmap)p->value;
! 			attr->Bg_Pixmap = ic->core.preedit_attr.background_pixmap;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_BGPIXMAP_MASK;
! 			*change_mask                |= XIMP_PRE_BGPIXMAP_MASK;
! 			}
! 		else if(strcmp(p->name, XNFontSet)==0) {
! 			ic->core.preedit_attr.fontset = (XFontSet)p->value;
! 			if(p->value != NULL) {
! 				if(ic->ximp_icpart->preedit_font)
! 	    				Xfree(ic->ximp_icpart->preedit_font);
! 				list_ret = XFontsOfFontSet(
! 					ic->core.preedit_attr.fontset,
! 					&struct_list, &name_list);
! 				for(i = 0, len = 0; i < list_ret; i++) {
! 					len += strlen(name_list[i]);
! 					}
! 				if( (tmp = Xmalloc(len + i + 1)) == NULL ) {
! 				    return_name = p->name;
! 				    return( False );
! 				}
! 				tmp[0] = NULL;
! 				for(i = 0; i < list_ret; i++) {
! 					strcat(tmp, name_list[i]);
! 					strcat(tmp, ",");
! 					}
! 				tmp[len + i - 1] = NULL;
! 				ic->ximp_icpart->preedit_font = tmp;
! 				ic->ximp_icpart->proto_mask |= XIMP_PRE_FONT_MASK;
! 				*change_mask                |= XIMP_PRE_FONT_MASK;
! 				}
! 			else {
! 				return_name = p->name;
! 				return(False);
! 				}
! 			}
! 		else if(strcmp(p->name, XNLineSpace)==0) {
! 			ic->core.preedit_attr.line_space = (long)p->value;
! 			attr->LineSpacing = ic->core.preedit_attr.line_space;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_LINESP_MASK;
! 			*change_mask                |= XIMP_PRE_LINESP_MASK;
! 			}
! 		else if(strcmp(p->name, XNCursor)==0) {
! 			ic->core.preedit_attr.cursor = (Cursor)p->value;
! 			attr->Cursor = ic->core.preedit_attr.cursor;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_CURSOR_MASK;
! 			*change_mask                |= XIMP_PRE_CURSOR_MASK;
! 			}
! 		else if(strcmp(p->name, XNPreeditStartCallback)==0) {
! 			ic->core.preedit_attr.callbacks.start.client_data =
! 				((XIMCallback *)p->value)->client_data;
! 			ic->core.preedit_attr.callbacks.start.callback =
! 				((XIMCallback *)p->value)->callback;
! 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
! 			}
! 		else if(strcmp(p->name, XNPreeditDoneCallback)==0) {
! 			ic->core.preedit_attr.callbacks.done.client_data =
! 				((XIMCallback *)p->value)->client_data;
! 			ic->core.preedit_attr.callbacks.done.callback =
! 				((XIMCallback *)p->value)->callback;
! 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
! 			}
! 		else if(strcmp(p->name, XNPreeditDrawCallback)==0) {
! 			ic->core.preedit_attr.callbacks.draw.client_data =
! 				((XIMCallback *)p->value)->client_data;
! 			ic->core.preedit_attr.callbacks.draw.callback =
! 				((XIMCallback *)p->value)->callback;
! 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
! 			}
! 		else if(strcmp(p->name, XNPreeditCaretCallback)==0) {
! 			ic->core.preedit_attr.callbacks.caret.client_data =
! 				((XIMCallback *)p->value)->client_data;
! 			ic->core.preedit_attr.callbacks.caret.callback =
! 				((XIMCallback *)p->value)->callback;
! 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
! 			}
  		}
! 	return(True);
  	}
  
  static Bool
  _Ximp_StatusSetAttributes(ic, attr, vl, mode, change_mask, return_name)
! 	Ximp_XIC		 ic;
! 	Ximp_StatusPropRec	*attr;
! 	XIMArg			*vl;
! 	int			 mode;
! 	int			*change_mask;
! 	char			*return_name;
! 	{
  	XIMArg			*p;
! 	Colormap	 	colormap_ret;
  	int			 list_ret;
  	XFontStruct		**struct_list;
  	char			**name_list;
  	int 			 i, len;
  	char 			*tmp;
  
! 	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			ic->core.status_attr.area.x = ((XRectangle *)p->value)->x;
  			ic->core.status_attr.area.y = ((XRectangle *)p->value)->y;
--- 131,585 ----
  
  char *
  _Ximp_SetICValues(ic, values)
! Ximp_XIC	 ic;
! XIMArg		*values;
! {
!     XIM			 im;
!     char		*ret;
!     XimpChangeMaskRec	 change_mask;
  
!     XIMP_SET_NULLMASK(change_mask);
  
!     if(!IS_SERVER_CONNECTED(ic->core.im) && IS_RECONNECTABLE(ic->core.im))
! 	_Ximp_ConnectServer(ic->core.im);
!     if( IS_SERVER_CONNECTED(ic->core.im)  &&  !IS_IC_CONNECTED(ic) )
! 	if( _Ximp_ConnectIC( ic, XIMP_START_IC ) )
! 	    if( IS_RESTARTABLE(ic->core.im) )
! 		_Ximp_CallRestartCallbackExtension( ic );
  
!     if((ret = _Ximp_SetICValueData(ic, values, XIMP_SET_IC, &change_mask)))
! 	return ret;
  
!     if(   (ic->ximp_icpart->value_mask & XIMP_RES_NAME)
!        || (ic->ximp_icpart->value_mask & XIMP_RES_CLASS) )
! 	_Ximp_SetValue_Resource(ic, &change_mask);
! 
!     if(!IS_IC_CONNECTED(ic)) {
! 	if(XIMP_CHK_PROP_FOCUS(change_mask)) {
! 	    if(ic->ximp_icpart->filter_mode & 0x1) {
! 		_XUnregisterFilter (ic->core.im->core.display,
! 				    ic->ximp_icpart->back_focus_win,
! 				    _Ximp_XimFilter_Keypress,
! 				    (XPointer)ic);
! 		_XUnregisterFilter (ic->core.im->core.display,
! 				    ic->ximp_icpart->back_focus_win,
! 				    _Ximp_XimFilter_Keyrelease,
! 				    (XPointer)ic);
! 	    }
! 	    _XRegisterFilterByType (ic->core.im->core.display,
! 				    ic->core.focus_window,
! 				    KeyPress, KeyPress,
! 				    _Ximp_XimFilter_Keypress,
! 				    (XPointer)ic);
! 	    _XRegisterFilterByType (ic->core.im->core.display,
! 				    ic->core.focus_window,
! 				    KeyRelease, KeyRelease,
! 				    _Ximp_XimFilter_Keyrelease,
! 				    (XPointer)ic);
! 	    ic->ximp_icpart->filter_mode |= 0x1;
  	}
! 	return(ret);
!     }
  
!     /* IS_IC_CONNECTED == True */
!     if(XIMP_EQU_PRESPOTLMASK(change_mask)) {
! 	if( IS_BEING_PREEDITED(ic) ) {
! 	    _Ximp_IM_SendMessage(ic, XIMP_MOVE(ic),
! 				 ic->ximp_icpart->preedit_attr.SpotLocation.x,
! 				 ic->ximp_icpart->preedit_attr.SpotLocation.y,
! 				 NULL);
  	}
  	return(ret);
+     }
+     if(XIMP_CHK_PROP_FOCUS(change_mask)) {
+ 	if(ISXimp4(ic)) {
+ 	    _Ximp_SetFocusWindowFilter(ic);
+ 	    XIMP_UNSET_PROPFOCUS(change_mask);
+ 	} else {
+ 	    _Ximp_SetFocusWindowProp(ic);
+ 	    _Ximp_SetFocusWindowFilter(ic);
+ 	}
+     }
+     if(!(   (ic->core.input_style & XIMPreeditCallbacks)
+ 	 || (ic->core.input_style & XIMPreeditNone) ) ) { 
+ 	if(XIMP_CHK_PROP_PREEDIT(change_mask))
+ 	    _Ximp_SetPreeditAtr(ic);
+ 	if(XIMP_CHK_PROP_PREFONT(change_mask))
+ 	    _Ximp_SetPreeditFont(ic);
+     } else {
+ 	XIMP_UNSET_PROPPREEDIT(change_mask);
+     }
+     if(!(   (ic->core.input_style & XIMStatusCallbacks)
+ 	 || (ic->core.input_style & XIMStatusNone) ) ) { 
+ 	if(XIMP_CHK_PROP_STATUS(change_mask))
+ 	    _Ximp_SetStatusAtr(ic);
+ 	if(XIMP_CHK_PROP_STSFONT(change_mask))
+ 	    _Ximp_SetStatusFont(ic);
+     } else {
+ 	XIMP_UNSET_PROPSTATUS(change_mask);
+     }
+     if(XIMP_PROTO_MASK(ic, change_mask)) {
+ 	XWindowAttributes	war;
+ 	long			mask;
+ 	
+ 	XGetWindowAttributes( ic->core.im->core.display,
+ 			     ic->core.client_window, &war );
+ 	XSelectInput( ic->core.im->core.display, ic->core.client_window,
+ 		     war.your_event_mask | PropertyChangeMask );
+ 	_Ximp_IM_SendMessage(ic, XIMP_SETVALUE(ic), XIMP_PROTO_MASK(ic,change_mask), NULL, NULL);
+ 	if( XIMP_CHK_PROP_FOCUS(change_mask) )
+ 	    if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id ) ) {
+ 		XIMP_SET_NULLMASK(change_mask);
+ 	    }
+ 	if( XIMP_CHK_PROP_PREEDIT(change_mask) )
+ 	    if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id ) ) {
+ 		XIMP_SET_NULLMASK(change_mask);
+ 	    }
+ 	if( XIMP_CHK_PROP_PREFONT(change_mask) )
+ 	    if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id ) ) {
+ 		XIMP_SET_NULLMASK(change_mask);
+ 	    }
+ 	if( XIMP_CHK_PROP_STATUS(change_mask) )
+ 	    if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id ) ) {
+ 		XIMP_SET_NULLMASK(change_mask);
+ 	    }
+ 	if( XIMP_CHK_PROP_STSFONT(change_mask) )
+ 	    _XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
+ 	XSelectInput( ic->core.im->core.display, ic->core.client_window,
+ 		     war.your_event_mask );
+     }
+     return(ret);
  }
  
  char *
  _Ximp_SetICValueData(ic, values, mode, change_mask)
! Ximp_XIC	 ic;
! XIMArg		*values;
! int		 mode;
! XimpChangeaMask	 change_mask;
! {
!     XIMArg			*p;
!     char			*return_name = NULL;
!     XimpCMPredicateArgRec        Arg;			/* for Ximp4.0 */
!     XEvent			 event;			/* for Ximp4.0 */
  
!     for(p = values; p->name != NULL; p++) {
! 	if(strcmp(p->name, XNInputStyle) == 0) {
! 	    if(mode == XIMP_CREATE_IC) {
! 		ic->core.input_style = (XIMStyle)p->value;
! 		ic->ximp_icpart->value_mask |= XIMP_INPUT_STYLE;
! 	    } else {
! 		; /* Currently Fixed value */
! 	    }
! 	} else if(strcmp(p->name, XNClientWindow)==0) {
! 	    if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 		Window	client_window_old;
! 		unsigned long	dummy_mask;
  
! 		if(mode == XIMP_SET_IC && (IS_IC_CONNECTED(ic))) {
! 		    if(ISXimp4(ic)) {
! 			_Ximp_GetFocusWindowSelectMask(ic, (Window)p->value, &dummy_mask);
! 			_Ximp_IM_SendMessage(ic, XIMP_CLIENT_WINDOW(ic), (Window)p->value, dummy_mask, NULL);
! 			Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 			Arg.icid = ic->ximp_icpart->icid;
! 			Arg.protocol = XIMP_CLIENT_WINDOW_RETURN(ic);
! 			Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 			if(!_XimpIfEvent(ic, &event, _Ximp_CMPredicate32, (XPointer)&Arg))
! 			    return NULL;
! 			client_window_old = ic->core.client_window;
! 			ic->core.client_window = (Window)p->value;
! 			ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
! 		    } else {
! 			long	icid_old, icid_new;
! 
! 			icid_old = ic->ximp_icpart->icid;
! 			client_window_old = ic->core.client_window;
! 			ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
! 			ic->core.client_window = (Window)p->value;
! 			if(_Ximp_ConnectIC(ic, mode) == False) {
! 			    return_name = p->name;
! 			    ic->ximp_icpart->value_mask &= ~XIMP_CLIENT_WIN;
! 			    ic->core.client_window = client_window_old;
! 			    break;
  			}
! 			icid_new = ic->ximp_icpart->icid;
! 			ic->ximp_icpart->icid = icid_old;
! 			_Ximp_IM_SendMessage(ic, XIMP_DESTROY(ic), NULL, NULL, NULL);
! 			ic->ximp_icpart->icid = icid_new;
! 			XDestroyWindow(ic->core.im->core.display, client_window_old);
! 			XIMP_SET_NULLMASK2(change_mask);
! 		    }
! 		} else { /* XIMP_CREATE_IC | (XIMP_SET_IC && XIMP_START_IC) */
! 		    client_window_old = ic->core.client_window;
! 		    ic->core.client_window = (Window)p->value;
! 		    ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
! 		    if(!(XIMP_CHK_FOCUSWINMASK(ic))) {
! 			ic->core.focus_window = ic->core.client_window;
! 			XIMP_SET_FOCUSWINMASK(ic);
! 		    }
! 		}
! 		if( ic->ximp_icpart->filter_mode & 0x4 ) {
! 		    _XUnregisterFilter( ic->core.im->core.display,
! 					client_window_old,
! 					_Ximp_XimFilter_Client, (XPointer)ic);
! 		    _XRegisterFilterByType(ic->core.im->core.display,
! 					ic->core.client_window,
! 					ClientMessage, ClientMessage,
! 					_Ximp_XimFilter_Client,
! 					(XPointer)ic );
! 		}
! 	    } else {
! 		return_name = p->name;
! 		break; /* Can't change this value */
! 	    }
! 	} else if(strcmp(p->name, XNFocusWindow)==0) {
! 	    if(IS_IC_CONNECTED(ic) && (mode == XIMP_SET_IC)) {
! 		Window		new_focus_window = (Window)p->value;
! 		unsigned long	dummy_mask;
! 		unsigned long	temp_mask;
! 		XWindowAttributes	wattr;
  
! 		if(ISXimp4(ic)) {
! 		    XGetWindowAttributes(ic->core.im->core.display, new_focus_window, &wattr);
! 		    dummy_mask = wattr.your_event_mask;
! 		    temp_mask = dummy_mask;
! 		    if(ISFE2(ic) || (ISFE1(ic) && IS_BEING_PREEDITED(ic)))
! 			dummy_mask &= ~(KeyPressMask | KeyReleaseMask);                         
! 		    else if(IS_FORCESELECTKEYRELEASE(ic->core.im) && (ISBE2(ic)||(ISBE1(ic)&&IS_BEING_PREEDITED(ic))))
! 			dummy_mask |= (KeyReleaseMask);
! 		    _Ximp_IM_SendMessage(ic, XIMP_FOCUS_WINDOW(ic), new_focus_window, temp_mask, NULL);
! 		    Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 		    Arg.icid = ic->ximp_icpart->icid;
! 		    Arg.protocol = XIMP_FOCUS_WINDOW_RETURN(ic);
! 		    Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 		    if(!_XimpIfEvent(ic, &event, _Ximp_CMPredicate32, (XPointer)&Arg))
! 			return NULL;
! 		    XSelectInput(ic->core.im->core.display, new_focus_window, dummy_mask);
! 		    if(ic->ximp_icpart->back_focus_win)
! 			XSelectInput(ic->core.im->core.display, ic->core.focus_window,
! 				     ic->ximp_icpart->back_mask);
! 		    ic->ximp_icpart->back_mask = temp_mask;
! 		} else { /* Ximp 3.5 */
! 		    if(IS_BEING_PREEDITED(ic)) {
! 			if(ISXIMP3FE(ic)) {
! 			    XSelectInput(ic->core.im->core.display, ic->core.focus_window,
! 					 ic->ximp_icpart->back_mask);
! 			    XGetWindowAttributes(ic->core.im->core.display, new_focus_window, &wattr);
! 			    dummy_mask = wattr.your_event_mask;
! 			    ic->ximp_icpart->back_mask = dummy_mask;
! 			    if(ISXIMP3FE(ic)) {
! 				dummy_mask &= ~(KeyPressMask | KeyReleaseMask);
! 			    }
! 			    XSelectInput(ic->core.im->core.display, new_focus_window, dummy_mask);
  			}
! 		    }
  		}
! 		ic->ximp_icpart->back_focus_win = ic->core.focus_window;
! 		ic->core.focus_window = (Window)p->value;
! 		XIMP_SET_FOCUSWINMASK2(ic, change_mask);
! 	    } else {
! 		ic->ximp_icpart->back_focus_win = ic->core.focus_window;
! 		ic->core.focus_window = (Window)p->value;
! 		XIMP_SET_FOCUSWINMASK2(ic, change_mask);
! 	    }
! 	} else if(strcmp(p->name, XNResourceName)==0) {
! 	    ic->core.im->core.res_name = (char *)p->value;
! 	    ic->ximp_icpart->value_mask |= XIMP_RES_NAME;
! 	} else if(strcmp(p->name, XNResourceClass)==0) {
! 	    ic->core.im->core.res_class = (char *)p->value;
! 	    ic->ximp_icpart->value_mask |= XIMP_RES_CLASS;
! 	} else if(strcmp(p->name, XNGeometryCallback)==0) {
! 	    ic->core.geometry_callback.client_data =
! 		((XIMCallback *)p->value)->client_data;
! 	    ic->core.geometry_callback.callback =
! 		((XIMCallback *)p->value)->callback;
! 	    ic->ximp_icpart->value_mask |= XIMP_GEOMETRY_CB;
! 	} else if(strcmp(p->name, XNPreeditAttributes)==0) {
! 	    if( _Ximp_PreSetAttributes(ic,
! 				       &(ic->ximp_icpart->preedit_attr),
! 				       p->value, mode, change_mask,
! 				       return_name) == False )
! 		break;
! 	} else if(strcmp(p->name, XNStatusAttributes)==0) {
! 	    if( _Ximp_StatusSetAttributes(ic,
! 					  &(ic->ximp_icpart->status_attr),
! 					  p->value, mode, change_mask,
! 					  return_name) == False )
! 		break;
! 	} else {
! 	    if( _Ximp_SetICExtension(ic, p->name, p->value, mode) == False ) {
! 		return_name = p->name;
! 		break;
! 	    }
  	}
!     }
!     return(return_name);
! }
! 
  static Bool
  _Ximp_PreSetAttributes(ic, attr, vl, mode, change_mask, return_name)
! Ximp_XIC		 ic;
! Ximp_PreeditPropRec4	*attr;
! XIMArg			*vl;
! int			 mode;
! XimpChangeaMask		 change_mask;
! char			*return_name;
! {
!     XIMArg			*p;
!     XStandardColormap	*colormap_ret;
!     int			 list_ret;
!     XFontStruct		**struct_list;
!     char			**name_list;
!     int 			 i, len;
!     int			 count;
!     char 			*tmp;
  
!     for(p = vl; p && p->name != NULL; p++) {
! 	if(strcmp(p->name, XNArea)==0) {
! 	    ic->core.preedit_attr.area.x = ((XRectangle *)p->value)->x;
! 	    ic->core.preedit_attr.area.y = ((XRectangle *)p->value)->y;
! 	    ic->core.preedit_attr.area.width = ((XRectangle *)p->value)->width;
! 	    ic->core.preedit_attr.area.height = ((XRectangle *)p->value)->height;
! 	    attr->Area.x      = ic->core.preedit_attr.area.x;
! 	    attr->Area.y      = ic->core.preedit_attr.area.y;
! 	    attr->Area.width  = ic->core.preedit_attr.area.width;
! 	    attr->Area.height = ic->core.preedit_attr.area.height;
! 	    XIMP_SET_PREAREAMASK(ic, change_mask);
! 	    
! 	} else if(strcmp(p->name, XNAreaNeeded)==0) {
! 	    ic->core.preedit_attr.area_needed.width  = ((XRectangle *)p->value)->width;
! 	    ic->core.preedit_attr.area_needed.height = ((XRectangle *)p->value)->height;
! 	    attr->AreaNeeded.width  = ic->core.preedit_attr.area_needed.width;
! 	    attr->AreaNeeded.height = ic->core.preedit_attr.area_needed.height;
! 	    XIMP_SET_PREAREANEEDMASK(ic, change_mask);
! 	    
! 	} else if(strcmp(p->name, XNSpotLocation)==0) {
! 	    ic->core.preedit_attr.spot_location.x = ((XPoint *)p->value)->x;
! 	    ic->core.preedit_attr.spot_location.y = ((XPoint *)p->value)->y;
! 	    attr->SpotLocation.x = ic->core.preedit_attr.spot_location.x;
! 	    attr->SpotLocation.y = ic->core.preedit_attr.spot_location.y;
! 	    XIMP_SET_PRESPOTLMASK(ic, change_mask);
! 	    
! 	} else if(strcmp(p->name, XNColormap)==0) {
! 	    ic->core.preedit_attr.colormap = (Colormap)p->value;
! 	    attr->Colormap = ic->core.preedit_attr.colormap;
! 	    XIMP_SET_PRECOLORMAPMASK(ic, change_mask);
! 	    
! 	} else if(strcmp(p->name, XNStdColormap)==0) {
! 	    if( XGetRGBColormaps(ic->core.im->core.display,
! 				 ic->core.focus_window, &colormap_ret,
! 				 &count, (Atom)p->value) != 0) {
! 		ic->core.preedit_attr.std_colormap = (Atom)p->value;
! 		attr->StdColormap = ic->core.preedit_attr.std_colormap;
! 		XIMP_SET_PRESTDCOLORMAPMASK(ic, change_mask);
! 	    } else {
! 		return_name = p->name;
! 		return(False);
! 	    }
! 	    
! 	} else if(strcmp(p->name, XNBackground)==0) {
! 	    ic->core.preedit_attr.background = (unsigned long)p->value;
! 	    attr->Background = ic->core.preedit_attr.background;
! 	    XIMP_SET_PREBGMASK(ic, change_mask);
! 	    
! 	} else if(strcmp(p->name, XNForeground)==0) {
! 	    ic->core.preedit_attr.foreground = (unsigned long)p->value;
! 	    attr->Foreground = ic->core.preedit_attr.foreground;
! 	    XIMP_SET_PREFGMASK(ic, change_mask);
! 	    
! 	} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
! 	    ic->core.preedit_attr.background_pixmap = (Pixmap)p->value;
! 	    attr->Bg_Pixmap = ic->core.preedit_attr.background_pixmap;
! 	    XIMP_SET_PREBGPIXMAPMASK(ic, change_mask);
! 	    
! 	} else if(strcmp(p->name, XNFontSet)==0) {
! 	    ic->core.preedit_attr.fontset = (XFontSet)p->value;
! 	    if(p->value != NULL) {
! 		if(ic->ximp_icpart->preedit_font)
! 		    Xfree(ic->ximp_icpart->preedit_font);
! 		list_ret = XFontsOfFontSet(ic->core.preedit_attr.fontset,
! 					   &struct_list, &name_list);
! 		for(i = 0, len = 0; i < list_ret; i++) {
! 		    len += (strlen(name_list[i]) + sizeof(char));
  		}
! 		if((tmp = Xmalloc(len + list_ret + sizeof(char))) == NULL) {
! 		    return_name = p->name;
! 		    return False ;
! 		}
! 		tmp[0] = NULL;
! 		for(i = 0; i < list_ret; i++) {
! 		    strcat(tmp, name_list[i]);
! 		    strcat(tmp, ",");
! 		}
! 		tmp[len + i - 1] = NULL;
! 		ic->ximp_icpart->preedit_font = tmp;
! 		XIMP_SET_PREFONTMASK(ic, change_mask);
! 	    } else {
! 		return_name = p->name;
! 		return(False);
! 	    }
! 	    
! 	} else if(strcmp(p->name, XNLineSpace)==0) {
! 	    ic->core.preedit_attr.line_space = (long)p->value;
! 	    attr->LineSpacing = ic->core.preedit_attr.line_space;
! 	    XIMP_SET_PRELINESPMASK(ic, change_mask);
! 	    
! 	} else if(strcmp(p->name, XNCursor)==0) {
! 	    ic->core.preedit_attr.cursor = (Cursor)p->value;
! 	    attr->Cursor = ic->core.preedit_attr.cursor;
! 	    XIMP_SET_PRECURSORMASK(ic, change_mask);
! 	    
! 	} else if(strcmp(p->name, XNPreeditStartCallback)==0) {
! 	    ic->core.preedit_attr.callbacks.start.client_data =
! 		((XIMCallback *)p->value)->client_data;
! 	    ic->core.preedit_attr.callbacks.start.callback =
! 		((XIMCallback *)p->value)->callback;
! 	    ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
! 	    
! 	} else if(strcmp(p->name, XNPreeditDoneCallback)==0) {
! 	    ic->core.preedit_attr.callbacks.done.client_data =
! 		((XIMCallback *)p->value)->client_data;
! 	    ic->core.preedit_attr.callbacks.done.callback =
! 		((XIMCallback *)p->value)->callback;
! 	    ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
! 	    
! 	} else if(strcmp(p->name, XNPreeditDrawCallback)==0) {
! 	    ic->core.preedit_attr.callbacks.draw.client_data =
! 		((XIMCallback *)p->value)->client_data;
! 	    ic->core.preedit_attr.callbacks.draw.callback =
! 		((XIMCallback *)p->value)->callback;
! 	    ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
! 	    
! 	} else if(strcmp(p->name, XNPreeditCaretCallback)==0) {
! 	    ic->core.preedit_attr.callbacks.caret.client_data =
! 		((XIMCallback *)p->value)->client_data;
! 	    ic->core.preedit_attr.callbacks.caret.callback =
! 		((XIMCallback *)p->value)->callback;
! 	    ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
  	}
+     }
+     return(True);
+ }
  
  static Bool
  _Ximp_StatusSetAttributes(ic, attr, vl, mode, change_mask, return_name)
! Ximp_XIC		 ic;
! Ximp_StatusPropRec4	*attr;
! XIMArg			*vl;
! int			 mode;
! XimpChangeaMask		 change_mask;
! char			*return_name;
! {
  	XIMArg			*p;
! 	XStandardColormap 	*colormap_ret;
  	int			 list_ret;
  	XFontStruct		**struct_list;
  	char			**name_list;
  	int 			 i, len;
+ 	int			 count;
  	char 			*tmp;
  
! 	for(p = vl; p && p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			ic->core.status_attr.area.x = ((XRectangle *)p->value)->x;
  			ic->core.status_attr.area.y = ((XRectangle *)p->value)->y;
***************
*** 529,646 ****
  			attr->Area.y      = ic->core.status_attr.area.y;
  			attr->Area.width  = ic->core.status_attr.area.width;
  			attr->Area.height = ic->core.status_attr.area.height;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_AREA_MASK;
! 			*change_mask                |= XIMP_STS_AREA_MASK;
! 			}
! 		else if(strcmp(p->name, XNAreaNeeded)==0) {
  			ic->core.status_attr.area_needed.width  = ((XRectangle *)p->value)->width;
  			ic->core.status_attr.area_needed.height = ((XRectangle *)p->value)->height;
  			attr->AreaNeeded.width  = ic->core.status_attr.area_needed.width;
  			attr->AreaNeeded.height = ic->core.status_attr.area_needed.height;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_AREANEED_MASK;
! 			*change_mask                |= XIMP_STS_AREANEED_MASK;
! 			}
! 		else if(strcmp(p->name, XNColormap)==0) {
  			ic->core.status_attr.colormap = (Colormap)p->value;
  			attr->Colormap = ic->core.status_attr.colormap;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_COLORMAP_MASK;
! 			*change_mask                |= XIMP_STS_COLORMAP_MASK;
! 			}
! 		else if(strcmp(p->name, XNStdColormap)==0) {
! 			if(XGetStandardColormap(ic->core.im->core.display,
! 					ic->core.focus_window,
! 					&colormap_ret, (Atom)p->value) !=0) {
! 				ic->core.status_attr.colormap = colormap_ret;
! 				attr->Colormap = ic->core.status_attr.colormap;
! 				ic->ximp_icpart->proto_mask |= XIMP_STS_COLORMAP_MASK;
! 				*change_mask                |= XIMP_STS_COLORMAP_MASK;
! 				}
! 			else {
  				return_name = p->name;
  				return(False);
- 				}
  			}
! 		else if(strcmp(p->name, XNBackground)==0) {
  			ic->core.status_attr.background = (unsigned long)p->value;
  			attr->Background = ic->core.status_attr.background;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_BG_MASK;
! 			*change_mask                |= XIMP_STS_BG_MASK;
! 			}
! 		else if(strcmp(p->name, XNForeground)==0) {
  			ic->core.status_attr.foreground = (unsigned long)p->value;
  			attr->Foreground = ic->core.status_attr.foreground;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_FG_MASK;
! 			*change_mask                |= XIMP_STS_FG_MASK;
! 			}
! 		else if(strcmp(p->name, XNBackgroundPixmap)==0) {
  			ic->core.status_attr.background_pixmap = (Pixmap)p->value;
  			attr->Bg_Pixmap = ic->core.status_attr.background_pixmap;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_BGPIXMAP_MASK;
! 			*change_mask                |= XIMP_STS_BGPIXMAP_MASK;
! 			}
! 		else if(strcmp(p->name, XNFontSet)==0) {
  			ic->core.status_attr.fontset = (XFontSet)p->value;
  			if (p->value != NULL) {
  				if(ic->ximp_icpart->status_font)
! 	    				Xfree(ic->ximp_icpart->status_font);
! 				list_ret = XFontsOfFontSet(
! 					ic->core.status_attr.fontset,
! 					&struct_list, &name_list);
  				for(i = 0, len = 0; i < list_ret; i++) {
! 					len += strlen(name_list[i]);
! 					}
! 				if( (tmp = Xmalloc(len + i + 1)) == NULL ) {
  				    return_name = p->name;
! 				    return( False );
  				}
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
  					strcat(tmp, ",");
! 					}
  				tmp[len + i - 1] = NULL;
  				ic->ximp_icpart->status_font = tmp;
! 				ic->ximp_icpart->proto_mask |= XIMP_STS_FONT_MASK;
! 				*change_mask                |= XIMP_STS_FONT_MASK;
! 				}
! 			else {
  				return_name = p->name;
  				return(False);
- 				}
  			}
! 		else if(strcmp(p->name, XNLineSpace)==0) {
  			ic->core.status_attr.line_space = (long)p->value;
  			attr->LineSpacing = ic->core.status_attr.line_space;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_LINESP_MASK;
! 			*change_mask                |= XIMP_STS_LINESP_MASK;
! 			}
! 		else if(strcmp(p->name, XNCursor)==0) {
  			ic->core.status_attr.cursor = (Cursor)p->value;
  			attr->Cursor = ic->core.status_attr.cursor;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_CURSOR_MASK;
! 			*change_mask                |= XIMP_STS_CURSOR_MASK;
! 			}
! 		else if(strcmp(p->name, XNStatusStartCallback)==0) {
  			ic->core.status_attr.callbacks.start.client_data =
  				((XIMCallback *)p->value)->client_data;
  			ic->core.status_attr.callbacks.start.callback =
  				((XIMCallback *)p->value)->callback;
  			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
! 			}
! 		else if(strcmp(p->name, XNStatusDoneCallback)==0) {
  			ic->core.status_attr.callbacks.done.client_data =
  				((XIMCallback *)p->value)->client_data;
  			ic->core.status_attr.callbacks.done.callback =
  				((XIMCallback *)p->value)->callback;
  			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
! 			}
! 		else if(strcmp(p->name, XNStatusDrawCallback)==0) {
  			ic->core.status_attr.callbacks.draw.client_data =
  				((XIMCallback *)p->value)->client_data;
  			ic->core.status_attr.callbacks.draw.callback =
  				((XIMCallback *)p->value)->callback;
  			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
- 			}
  		}
- 	return(True);
  	}
--- 589,694 ----
  			attr->Area.y      = ic->core.status_attr.area.y;
  			attr->Area.width  = ic->core.status_attr.area.width;
  			attr->Area.height = ic->core.status_attr.area.height;
! 			XIMP_SET_STSAREAMASK(ic, change_mask);
! 
! 		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			ic->core.status_attr.area_needed.width  = ((XRectangle *)p->value)->width;
  			ic->core.status_attr.area_needed.height = ((XRectangle *)p->value)->height;
  			attr->AreaNeeded.width  = ic->core.status_attr.area_needed.width;
  			attr->AreaNeeded.height = ic->core.status_attr.area_needed.height;
! 			XIMP_SET_STSAREANEEDMASK(ic, change_mask);
! 
! 		} else if(strcmp(p->name, XNColormap)==0) {
  			ic->core.status_attr.colormap = (Colormap)p->value;
  			attr->Colormap = ic->core.status_attr.colormap;
! 			XIMP_SET_STSCOLORMAPMASK(ic, change_mask);
! 
! 		} else if(strcmp(p->name, XNStdColormap)==0) {
! 			if(XGetRGBColormaps(ic->core.im->core.display,
! 					ic->core.focus_window, &colormap_ret,
! 					&count, (Atom)p->value) !=0) {
! 				ic->core.status_attr.std_colormap = (Atom)p->value;
! 				attr->StdColormap = ic->core.status_attr.std_colormap;
! 				XIMP_SET_STSSTDCOLORMAPMASK(ic, change_mask);
! 			} else {
  				return_name = p->name;
  				return(False);
  			}
! 
! 		} else if(strcmp(p->name, XNBackground)==0) {
  			ic->core.status_attr.background = (unsigned long)p->value;
  			attr->Background = ic->core.status_attr.background;
! 			XIMP_SET_STSBGMASK(ic, change_mask);
! 
! 		} else if(strcmp(p->name, XNForeground)==0) {
  			ic->core.status_attr.foreground = (unsigned long)p->value;
  			attr->Foreground = ic->core.status_attr.foreground;
! 			XIMP_SET_STSFGMASK(ic, change_mask);
! 
! 		} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
  			ic->core.status_attr.background_pixmap = (Pixmap)p->value;
  			attr->Bg_Pixmap = ic->core.status_attr.background_pixmap;
! 			XIMP_SET_STSBGPIXMAPMASK(ic, change_mask);
! 
! 		} else if(strcmp(p->name, XNFontSet)==0) {
  			ic->core.status_attr.fontset = (XFontSet)p->value;
  			if (p->value != NULL) {
  				if(ic->ximp_icpart->status_font)
! 					Xfree(ic->ximp_icpart->status_font);
! 				list_ret = XFontsOfFontSet(ic->core.status_attr.fontset,
! 								&struct_list, &name_list);
  				for(i = 0, len = 0; i < list_ret; i++) {
! 					len += (strlen(name_list[i]) + sizeof(char));
! 				}
! 				if((tmp = Xmalloc(len + list_ret + sizeof(char))) == NULL){
  				    return_name = p->name;
! 				    return False ;
  				}
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
  					strcat(tmp, ",");
! 				}
  				tmp[len + i - 1] = NULL;
  				ic->ximp_icpart->status_font = tmp;
! 				XIMP_SET_STSFONTMASK(ic, change_mask);
! 			} else {
  				return_name = p->name;
  				return(False);
  			}
! 
! 		} else if(strcmp(p->name, XNLineSpace)==0) {
  			ic->core.status_attr.line_space = (long)p->value;
  			attr->LineSpacing = ic->core.status_attr.line_space;
! 			XIMP_SET_STSLINESPMASK(ic, change_mask);
! 
! 		} else if(strcmp(p->name, XNCursor)==0) {
  			ic->core.status_attr.cursor = (Cursor)p->value;
  			attr->Cursor = ic->core.status_attr.cursor;
! 			XIMP_SET_STSCURSORMASK(ic, change_mask);
! 
! 		} else if(strcmp(p->name, XNStatusStartCallback)==0) {
  			ic->core.status_attr.callbacks.start.client_data =
  				((XIMCallback *)p->value)->client_data;
  			ic->core.status_attr.callbacks.start.callback =
  				((XIMCallback *)p->value)->callback;
  			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
! 
! 		} else if(strcmp(p->name, XNStatusDoneCallback)==0) {
  			ic->core.status_attr.callbacks.done.client_data =
  				((XIMCallback *)p->value)->client_data;
  			ic->core.status_attr.callbacks.done.callback =
  				((XIMCallback *)p->value)->callback;
  			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
! 
! 		} else if(strcmp(p->name, XNStatusDrawCallback)==0) {
  			ic->core.status_attr.callbacks.draw.client_data =
  				((XIMCallback *)p->value)->client_data;
  			ic->core.status_attr.callbacks.draw.callback =
  				((XIMCallback *)p->value)->callback;
  			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
  		}
  	}
+ 
+ 	return(True);
+ }
*** /tmp/d19042	Mon Oct 19 19:35:35 1992
--- lib/X/Ximp/XimpMPer.c	Mon Oct 19 19:25:52 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpMPer.c,v 1.2 92/04/14 13:29:43 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpMPer.c,v 1.3 92/10/19 19:25:49 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
*** /tmp/d19061	Mon Oct 19 19:35:49 1992
--- lib/X/Ximp/XimpMPrTxt.c	Mon Oct 19 19:25:55 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpMPrTxt.c,v 1.3 92/04/14 13:29:46 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpMPrTxt.c,v 1.4 92/10/19 19:25:52 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
***************
*** 70,79 ****
  #include <X11/Xutil.h>
  #include <X11/Xatom.h>
  
! extern int _Ximp_strcpy(), _Ximp_cttombs();
  
  int
  XmbTextPropertyToTextList(dpy, text_prop, list_ret, count_ret)
      Display *dpy;
      XTextProperty *text_prop;
      char ***list_ret;
--- 70,84 ----
  #include <X11/Xutil.h>
  #include <X11/Xatom.h>
  
! extern int _Xlc_strcpy(), _Ximp_cttombs();
  
  int
+ #ifndef DYNAMICLIB
  XmbTextPropertyToTextList(dpy, text_prop, list_ret, count_ret)
+ #else
+ _XimpmbTextPropertyToTextList(lcd, dpy, text_prop, list_ret, count_ret)
+     XLCd     lcd;
+ #endif
      Display *dpy;
      XTextProperty *text_prop;
      char ***list_ret;
***************
*** 82,90 ****
      unsigned char **list;
      unsigned char *buf, *buf_ptr, *str_ptr;
      int i, count, unconv_num, tmp_len, buf_len;
! #define CNV_STR_FUNC	_Ximp_strcpy
  #define CNV_CTEXT_FUNC	_Ximp_cttombs
! #define CNV_TEXT_FUNC	_Ximp_strcpy
  
      /* XXX */
      buf_len = text_prop->nitems + 1;
--- 87,95 ----
      unsigned char **list;
      unsigned char *buf, *buf_ptr, *str_ptr;
      int i, count, unconv_num, tmp_len, buf_len;
! #define CNV_STR_FUNC	_Xlc_strcpy
  #define CNV_CTEXT_FUNC	_Ximp_cttombs
! #define CNV_TEXT_FUNC	_Xlc_strcpy
  
      /* XXX */
      buf_len = text_prop->nitems + 1;
*** /tmp/d19080	Mon Oct 19 19:36:01 1992
--- lib/X/Ximp/XimpMTxtPr.c	Mon Oct 19 19:25:59 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpMTxtPr.c,v 1.3 92/04/14 13:29:49 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpMTxtPr.c,v 1.4 92/10/19 19:25:56 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
***************
*** 70,80 ****
  #include <X11/Xutil.h>
  #include <X11/Xatom.h>
  
! extern int _Ximp_mbstostring(), _Ximp_mbstoct(), _Ximp_strcpy();
  
  
  int
  XmbTextListToTextProperty(dpy, list, count, style, text_prop)
      Display *dpy;
      char **list;
      int count;
--- 70,85 ----
  #include <X11/Xutil.h>
  #include <X11/Xatom.h>
  
! extern int _Ximp_mbstostring(), _Ximp_mbstoct(), _Xlc_strcpy();
  
  
  int
+ #ifndef DYNAMICLIB
  XmbTextListToTextProperty(dpy, list, count, style, text_prop)
+ #else
+ _XimpmbTextListToTextProperty(lcd, dpy, list, count, style, text_prop)
+     XLCd     lcd;
+ #endif
      Display *dpy;
      char **list;
      int count;
***************
*** 86,92 ****
  
  #define CNV_STR_FUNC	_Ximp_mbstostring
  #define CNV_CTEXT_FUNC	_Ximp_mbstoct
! #define CNV_TEXT_FUNC	_Ximp_strcpy
  #define STRLEN_FUNC	strlen
  
      /* XXX */
--- 91,97 ----
  
  #define CNV_STR_FUNC	_Ximp_mbstostring
  #define CNV_CTEXT_FUNC	_Ximp_mbstoct
! #define CNV_TEXT_FUNC	_Xlc_strcpy
  #define STRLEN_FUNC	strlen
  
      /* XXX */
*** /tmp/d19099	Mon Oct 19 19:36:13 1992
--- lib/X/Ximp/XimpPrTxt.c	Mon Oct 19 19:26:16 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpPrTxt.c,v 1.3 92/04/14 13:29:53 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpPrTxt.c,v 1.4 92/10/19 19:26:02 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
***************
*** 70,76 ****
   */
  
  {
!     Ximp_XLCd lcd;
      Atom encoding;
      unsigned char *last_ptr;
      int nitems, tmp_num;
--- 70,76 ----
   */
  
  {
!     XLCd lcd;
      Atom encoding;
      unsigned char *last_ptr;
      int nitems, tmp_num;
***************
*** 86,92 ****
  	Xfree(buf);
  	return XConverterNotFound;
      }
!     if ((lcd = (Ximp_XLCd) _XlcCurrentLC()) == NULL) {
  	Xfree(buf);
  	return XLocaleNotSupported;
      }
--- 86,92 ----
  	Xfree(buf);
  	return XConverterNotFound;
      }
!     if ((lcd = _XlcCurrentLC()) == NULL) {
  	Xfree(buf);
  	return XLocaleNotSupported;
      }
*** /tmp/d19118	Mon Oct 19 19:36:26 1992
--- lib/X/Ximp/XimpRm.c	Mon Oct 19 19:26:21 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpRm.c,v 1.5 92/07/29 10:16:22 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
                Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
--- 1,8 ----
! /* $XConsortium: XimpRm.c,v 1.6 92/10/19 19:26:16 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
+ 	      Copyright 1991, 1992 by Sun Microsystems, Inc.
                Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
***************
*** 8,32 ****
  and its documentation for any purpose is hereby granted without fee,
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
! in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporaion not be used in advertising or publicity
! pertaining to distribution of the software without specific,
  written prior permission.
! FUJITSU LIMITED and Sony Corporation make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
! SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
! OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
--- 9,35 ----
  and its documentation for any purpose is hereby granted without fee,
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
! in supporting documentation, and that the name of FUJITSU LIMITED,
! Sun Microsystems, Inc. and Sony Corporation not be used in advertising 
! or publicity pertaining to distribution of the software without specific,
  written prior permission.
! FUJITSU LIMITED, Sun Microsystems, Inc. and Sony Corporation make no 
! representations about the suitability of this software for any purpose.
! It is provided "as is" without express or implied warranty.
  
! FUJITSU LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION DISCLAIM 
! ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED 
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU
! LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION BE LIABLE FOR ANY
! SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
! RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
! CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
! CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Hiromu Inukai        Sun Microsystems, Inc.
!           Hideki Hiura         Sun Microsystems, Inc.
! 	  Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
***************
*** 37,67 ****
  #include "Ximplc.h"
  #include "Xresource.h"
  
! extern void		_Ximp_OpenIMResourceExtension();
  
- void
- _Ximp_Get_resource_name(im, res_name, res_class)
- 	Ximp_XIM	 im;
- 	char		*res_name;
- 	char		*res_class;
- 	{
- 	if(im->core.res_name == NULL)
- 		strcpy(res_name, "*");
- 	else	{
- 		strcpy(res_name, im->core.res_name);
- 		strcat(res_name, ".");
- 		}
- 	if(im->core.res_class == NULL)
- 		strcpy(res_class, "*");
- 	else	{
- 		strcpy(res_class, im->core.res_class);
- 		strcat(res_class, ".");
- 		}
- 	strcat(res_name, "ximp.");
- 	strcat(res_class, "Ximp.");
- 	}
- 
- 
  #ifndef	isalnum
  #define	isalnum(c)	\
      (('0' <= (c) && (c) <= '9')  || \
--- 40,47 ----
  #include "Ximplc.h"
  #include "Xresource.h"
  
! extern void	_Ximp_OpenIMResourceExtension();
  
  #ifndef	isalnum
  #define	isalnum(c)	\
      (('0' <= (c) && (c) <= '9')  || \
***************
*** 69,79 ****
       ('a' <= (c) && (c) <= 'z'))
  #endif
  
! static void	_Ximp_parse( im, event )
  Ximp_XIM	 im;
  char		*event;
  {
!     static Ximp_Key	key;
      char		*modifier, *detail;
      char		*ss;
      int			ii;
--- 49,108 ----
       ('a' <= (c) && (c) <= 'z'))
  #endif
  
! static void
! _Ximp_Get_resource_name(im, res_name, res_class)
  Ximp_XIM	 im;
+ char		*res_name;
+ char		*res_class;
+ {
+     if(im->core.res_name == NULL) {
+ 	strcpy(res_name, "*");
+     } else {
+ 	strcpy(res_name, im->core.res_name);
+ 	strcat(res_name, ".");
+     }
+     if(im->core.res_class == NULL) {
+ 	strcpy(res_class, "*");
+     } else {
+ 	strcpy(res_class, im->core.res_class);
+ 	strcat(res_class, ".");
+     }
+     strcat(res_name, "ximp.");
+     strcat(res_class, "Ximp.");
+ }
+ 
+ static void
+ _Ximp_Local_Processing(im)
+ Ximp_XIM	 im;
+ {
+     char		 res_name[256];
+     char		 res_class[256];
+     char		*str_type;
+     XrmValue		 value;
+ 
+     _Ximp_Get_resource_name(im, res_name, res_class);
+     strcat(res_name, "localProcessing");
+     strcat(res_class, "LocalProcessing");
+     if(XrmGetResource(im->core.rdb, res_name, res_class,
+ 		      &str_type, &value) == True) { 
+ 	if(strcmp(value.addr, "True") == 0 || 
+ 	   strcmp(value.addr, "true") == 0 || 
+ 	   strcmp(value.addr, "Yes") == 0 || 
+ 	   strcmp(value.addr, "yes") == 0 || 
+ 	   strcmp(value.addr, "ON") == 0 || 
+ 	   strcmp(value.addr, "on") == 0) {
+ 	    IS_LOCAL_PROCESSING(im) = True;
+ 	}
+     }
+     return;
+ }
+ 
+ static void
+ _Ximp_parse( im, event )
+ Ximp_XIM	 im;
  char		*event;
  {
!     Ximp_Key		key;
      char		*modifier, *detail;
      char		*ss;
      int			ii;
***************
*** 114,121 ****
  		return;
  	    key.modifier_mask = AllMask;
  	    modifier += 4;
! 	}
! 	else {
  	    if( *modifier == '!' ) {
  		if( key.modifier_mask != 0  ||  exclamation )
  		    return;
--- 143,149 ----
  		return;
  	    key.modifier_mask = AllMask;
  	    modifier += 4;
! 	} else {
  	    if( *modifier == '!' ) {
  		if( key.modifier_mask != 0  ||  exclamation )
  		    return;
***************
*** 155,162 ****
  		Xfree( keylist );
  		return;
  	    }
! 	}
! 	else {
  	    Ximp_Key	*keys_list;
  	    if( (keys_list = (Ximp_Key *)Xrealloc(keylist->keys_list, sizeof(Ximp_Key) * (keylist->count_keys + 1))) == NULL )
  		return;
--- 183,189 ----
  		Xfree( keylist );
  		return;
  	    }
! 	} else {
  	    Ximp_Key	*keys_list;
  	    if( (keys_list = (Ximp_Key *)Xrealloc(keylist->keys_list, sizeof(Ximp_Key) * (keylist->count_keys + 1))) == NULL )
  		return;
***************
*** 166,399 ****
  	keylist->count_keys++;
  	im->ximp_impart->process_start_keys = keylist;
      }
  }
  
  
! Bool
! _Ximp_OpenIM_Resource(im)
! 	Ximp_XIM	 im;
! 	{
! 	char		 res_name[256];
! 	char		 res_class[256];
! 	char		*str_type;
! 	XrmValue	 value;
! 	Bool		 ret = False;
! 	KeySym		 keysym = NoSymbol;
! 	Ximp_KeyList	*keylist;
  
! 	if(im->core.rdb == NULL)
! 		return(ret);
  
! 	/* Inputserver */
! 	_Ximp_Get_resource_name(im, res_name, res_class);
! 	strcat(res_name, "inputserver");
! 	strcat(res_class, "Inputserver");
! 	if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				&str_type, &value) == True) { 
! 		if(strcmp(value.addr, "off") == 0) {
! 			/* Keysym */
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "startkeysym");
! 			strcat(res_class, "Startkeysym");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				&str_type, &value) == True) { 
! 				keysym = XStringToKeysym(value.addr);
! 				}
! 			ret = False;
! 			if(keysym != NoSymbol) {
! 				if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) != NULL ) {
! 					if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key)))!= NULL) {
! 						keylist->count_keys = 1;
! 						keylist->keys_list[0].modifier = 0;
! 						keylist->keys_list[0].modifier_mask = 0;
! 						keylist->keys_list[0].keysym = keysym;
! 						im->ximp_impart->process_start_keys = keylist;
! 						ret = True;
! 						}
! 					else
! 						Xfree(keylist);
! 					}
! 				}
  
! 			/* ProcessStartKeys */
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "processStartKeys");
! 			strcat(res_class, "ProcessStartKeys");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 						&str_type, &value)  == True) {
! 				char	*string, *ss, c;
! 				char	*line;
  
! 				if( (line = Xmalloc(value.size)) != NULL ) {
! 					string = value.addr;
! 					do {
! 						ss = line;
! 						while( (c = *string) != NULL ) {
! 							string++;
! 							if( c == '\n' )
! 								break;
! 							*ss++ = c;
! 							}
! 						*ss = NULL;
! 						_Ximp_parse( im, line );
! 					} while( *string != NULL );
! 					Xfree( line );
! 					if( im->ximp_impart->process_start_keys )
! 						ret = True;
! 					}
! 				}
! 			}
  		}
! 	/* Call Back */
  	_Ximp_Get_resource_name(im, res_name, res_class);
! 	strcat(res_name, "callbackEncoding");
! 	strcat(res_class, "CallbackEncoding");
! 	if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				&str_type, &value) == True) { 
! 		if(strcmp(value.addr, "wchar") == 0) {
! 			im->ximp_impart->use_wchar = True;
! 			}
! 		}
! 	/* Extension : XOpenIM(, rdb, res_name, res_class) */
! 	_Ximp_OpenIMResourceExtension(im);
! 	return(ret);
  	}
  
  void
  _Ximp_SetValue_Resource(ic, mask)
! 	Ximp_XIC	 ic;
! 	long		*mask;
! 	{
! 	Ximp_XIM	 im;
! 	char		 res_name[256];
! 	char		 res_class[256];
! 	char		*str_type;
! 	XrmValue	 value;
! 	Colormap	 default_colormap;
! 	XColor		 screen_def, exact_def;
! 	int		 num;
  
! 	im = (Ximp_XIM)XIMOfIC((XIC)ic);
! 	if(im->core.rdb == NULL)
! 		return;
  
! 	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	     || (ic->core.input_style & XIMPreeditNone) ) ) {
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_PRE_BG_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "preedit.background");
! 			strcat(res_class, "Preedit.Background");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
! 				default_colormap = DefaultColormap(
! 						im->core.display,
! 						DefaultScreen(im->core.display) );
! 				if( XAllocNamedColor(im->core.display, default_colormap,
! 					     value.addr,
! 					     &screen_def, &exact_def) ) {
! 					ic->core.preedit_attr.background = screen_def.pixel;
! 					ic->ximp_icpart->preedit_attr.Background = 
! 						ic->core.preedit_attr.background;
! 					ic->ximp_icpart->proto_mask |= XIMP_PRE_BG_MASK;
! 					*mask                       |= XIMP_PRE_BG_MASK;
! 					}
! 				}
! 			}
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_PRE_FG_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "preedit.foreground");
! 			strcat(res_class, "Preedit.Foreground");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
! 				default_colormap = DefaultColormap(
! 						im->core.display,
! 						DefaultScreen(im->core.display) );
! 				if( XAllocNamedColor(im->core.display, default_colormap,
! 					     value.addr,
! 					     &screen_def, &exact_def) ) {
! 					ic->core.preedit_attr.foreground = screen_def.pixel;
! 					ic->ximp_icpart->preedit_attr.Foreground = 
! 						ic->core.preedit_attr.foreground;
! 					ic->ximp_icpart->proto_mask |= XIMP_PRE_FG_MASK;
! 					*mask                       |= XIMP_PRE_FG_MASK;
! 					}
! 				}
! 			}
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_PRE_LINESP_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "preedit.linespacing");
! 			strcat(res_class, "Preedit.Linespacing");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
! 				num = atoi(value.addr);
! 				ic->core.preedit_attr.line_space = num;
! 				ic->ximp_icpart->preedit_attr.LineSpacing = 
! 					ic->core.preedit_attr.line_space;
! 				ic->ximp_icpart->proto_mask |= XIMP_PRE_LINESP_MASK;
! 				*mask                       |= XIMP_PRE_LINESP_MASK;
! 				}
! 			}
  		}
! 	if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	     || (ic->core.input_style & XIMStatusNone) ) ) {
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_STS_BG_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "status.background");
! 			strcat(res_class, "Status.Background");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
! 				default_colormap = DefaultColormap(
! 						im->core.display,
! 						DefaultScreen(im->core.display) );
! 				if( XAllocNamedColor(im->core.display, default_colormap,
! 					     value.addr,
! 					     &screen_def, &exact_def) ) {
! 					ic->core.status_attr.background = screen_def.pixel;
! 					ic->ximp_icpart->status_attr.Background = 
! 						ic->core.status_attr.background;
! 					ic->ximp_icpart->proto_mask |= XIMP_STS_BG_MASK;
! 					*mask                       |= XIMP_STS_BG_MASK;
! 					}
! 				}
  
! 			}
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_STS_FG_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "status.foreground");
! 			strcat(res_class, "Status.Foreground");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
! 				default_colormap = DefaultColormap(
! 						im->core.display,
! 						DefaultScreen(im->core.display) );
! 				if( XAllocNamedColor(im->core.display, default_colormap,
! 					     value.addr,
! 					     &screen_def, &exact_def) ) {
! 					ic->core.status_attr.foreground = screen_def.pixel;
! 					ic->ximp_icpart->status_attr.Foreground = 
! 						ic->core.status_attr.foreground;
! 					ic->ximp_icpart->proto_mask |= XIMP_STS_FG_MASK;
! 					*mask                       |= XIMP_STS_FG_MASK;
! 					}
! 				}
! 			}
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_STS_LINESP_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "status.linespacing");
! 			strcat(res_class, "Status.Linespacing");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
! 				num = atoi(value.addr);
! 				ic->core.status_attr.line_space = num;
! 				ic->ximp_icpart->status_attr.LineSpacing = 
! 					ic->core.status_attr.line_space;
! 				ic->ximp_icpart->proto_mask |= XIMP_STS_LINESP_MASK;
! 				*mask                       |= XIMP_STS_LINESP_MASK;
! 				}
! 			}
  		}
! 	if(   (ic->ximp_icpart->value_mask & XIMP_RES_NAME)
!            || (ic->ximp_icpart->value_mask & XIMP_RES_CLASS) )
! 		ic->ximp_icpart->value_mask &= ~(XIMP_RES_NAME | XIMP_RES_CLASS);
! 	return;
  	}
--- 193,620 ----
  	keylist->count_keys++;
  	im->ximp_impart->process_start_keys = keylist;
      }
+     return;
  }
  
+ static void
+ _Ximp_InputServerMode(im)
+ Ximp_XIM	 im;
+ {
+     char		 res_name[256];
+     char		 res_class[256];
+     char		*str_type;
+     XrmValue		 value;
+     KeySym		 keysym = NoSymbol;
+     Ximp_KeyList	*keylist;
+     XIMStyles		*imstyles;
+     XIMStyle		 imstyle1, imstyle2;
  
!     _Ximp_Get_resource_name(im, res_name, res_class);
!     strcat(res_name, "inputserver");
!     strcat(res_class, "Inputserver");
!     if((XrmGetResource(im->core.rdb, res_name, res_class,&str_type, &value) == True)
!        && (strcmp(value.addr, "off") == 0) ) {
! 	MAKE_CONNECTABLE(im) ;
!     }
  
!     _Ximp_Get_resource_name(im, res_name, res_class);
!     strcat(res_name, "delaybinding");
!     strcat(res_class, "Delaybinding");
!     if(XrmGetResource(im->core.rdb, res_name, res_class, &str_type, &value) == True) { 
! 	if(strcmp(value.addr, "ON") == 0 || 
! 	   strcmp(value.addr, "on") == 0) {
! 	    MAKE_DELAYBINDABLE(im);
! 	}
!     }
  
!     _Ximp_Get_resource_name(im, res_name, res_class);
!     strcat(res_name, "reconnect");
!     strcat(res_class, "Reconnect");
!     if(XrmGetResource(im->core.rdb, res_name, res_class, &str_type, &value) == True) { 
! 	if(strcmp(value.addr, "ON") == 0 || 
! 	   strcmp(value.addr, "on") == 0) {
! 	    MAKE_RECONNECTABLE(im) ;
! 	}
!     }
  
!     _Ximp_Get_resource_name(im, res_name, res_class);
!     strcat(res_name, "restart");
!     strcat(res_class, "Restart");
!     if(XrmGetResource(im->core.rdb, res_name, res_class, &str_type, &value) == True) { 
! 	if(strcmp(value.addr, "ON") == 0 || 
! 	   strcmp(value.addr, "on") == 0) {
! 	    MAKE_RESTARTABLE(im) ;
! 	}
!     }
  
!     if(IS_UNCONNECTABLE(im))
! 	return; 
! 
!     /* Keysym */
!     _Ximp_Get_resource_name(im, res_name, res_class);
!     strcat(res_name, "startkeysym");
!     strcat(res_class, "Startkeysym");
!     if(XrmGetResource(im->core.rdb, res_name, res_class, &str_type, &value) == True) { 
! 	keysym = XStringToKeysym(value.addr);
!     }
!     if(keysym != NoSymbol) {
! 	if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) != NULL ) {
! 	    if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key)))!= NULL) {
! 		keylist->count_keys = 1;
! 		keylist->keys_list[0].modifier = 0;
! 		keylist->keys_list[0].modifier_mask = 0;
! 		keylist->keys_list[0].keysym = keysym;
! 		im->ximp_impart->process_start_keys = keylist;
! 	    } else
! 		Xfree(keylist);
! 	}
!     }
! 
!     /* ProcessStartKeys */
!     _Ximp_Get_resource_name(im, res_name, res_class);
!     strcat(res_name, "processStartKeys");
!     strcat(res_class, "ProcessStartKeys");
!     if(XrmGetResource(im->core.rdb, res_name, res_class, &str_type, &value)  == True) {
! 	char	*string, *ss, c;
! 	char	*line;
! 
! 	if( (line = Xmalloc(value.size)) != NULL ) {
! 	    string = value.addr;
! 	    do {
! 		ss = line;
! 		while( (c = *string) != NULL ) {
! 		    string++;
! 		    if( c == '\n' )
! 			break;
! 		    *ss++ = c;
  		}
! 		*ss = NULL;
! 		_Ximp_parse( im, line );
! 	    } while( *string != NULL );
! 	    Xfree( line );
! 	}
!     }
! 
!     if(im->ximp_impart->process_start_keys == (Ximp_KeyList *)NULL)
! 	MAKE_UNCONNECTABLE(im) ;
! 
!     if(IS_DELAYBINDABLE(im)) {
! 	imstyle1 = imstyle2 = 0;
  	_Ximp_Get_resource_name(im, res_name, res_class);
! 	strcat(res_name, "preeditDefaultStyle");
! 	strcat(res_class, "PreeditDefaultStyle");
! 	if(XrmGetResource(im->core.rdb, res_name, res_class, &str_type, &value) == True) { 
! 	    if(strcmp(value.addr, "XIMPreeditArea") == 0)
! 		imstyle1 = XIMPreeditArea;
! 	    else if(strcmp(value.addr, "XIMPreeditCallbacks") == 0)
! 		imstyle1 = XIMPreeditCallbacks;
! 	    else if(strcmp(value.addr, "XIMPreeditPosition") == 0)
! 		imstyle1 = XIMPreeditPosition;
! 	    else if(strcmp(value.addr, "XIMPreeditNothing") == 0)
! 		imstyle1 = XIMPreeditNothing;
! 	    else if(strcmp(value.addr, "XIMPreeditNone") == 0)
! 		imstyle1 = XIMPreeditNone;
  	}
+ 	if(imstyle1 == 0)
+ 	    imstyle1 = XIMPreeditNothing;
+ 	_Ximp_Get_resource_name(im, res_name, res_class);
+ 	strcat(res_name, "statusDefaultStyle");
+ 	strcat(res_class, "StatusDefaultStyle");
+ 	if(XrmGetResource(im->core.rdb, res_name, res_class, &str_type, &value) == True) { 
+ 	    if(strcmp(value.addr, "XIMStatusArea") == 0)
+ 		imstyle2 = XIMStatusArea;
+ 	    else if(strcmp(value.addr, "XIMStatusCallbacks") == 0)
+ 		imstyle2 = XIMStatusCallbacks;
+ 	    else if(strcmp(value.addr, "XIMStatusNothing") == 0)
+ 		imstyle2 = XIMStatusNothing;
+ 	    else if(strcmp(value.addr, "XIMStatusNone") == 0)
+ 		imstyle2 = XIMStatusNone;
+ 	}
+ 	if(imstyle2 == 0)
+ 	    imstyle2 = XIMStatusNothing;
  
+ 	if((imstyles = (XIMStyles *)Xmalloc(sizeof(XIMStyles) + sizeof(XIMStyle))) == NULL)
+ 	    return;
+ 	imstyles->count_styles = 1;
+ 	imstyles->supported_styles = (XIMStyle *)((char *)imstyles + sizeof(XIMStyles));
+ 	imstyles->supported_styles[0] = imstyle1 | imstyle2;
+ 	im->ximp_impart->delaybind_styles = imstyles;
+     }
+     return;
+ }
+ 
+ static void
+ _Ximp_CallBackWchar(im)
+ Ximp_XIM	 im;
+ {
+     char		 res_name[256];
+     char		 res_class[256];
+     char		*str_type;
+     XrmValue		 value;
+ 
+     _Ximp_Get_resource_name(im, res_name, res_class);
+     strcat(res_name, "callbackEncoding");
+     strcat(res_class, "CallbackEncoding");
+     if(XrmGetResource(im->core.rdb, res_name, res_class, &str_type, &value) == True) {
+ 	if(strcmp(value.addr, "wchar") == 0) {
+ 	    im->ximp_impart->use_wchar = True;
+ 	}
+     }
+     return;
+ }
+ 
+ static void
+ _Ximp_ForceSelectKeyRelease(im)
+ Ximp_XIM	 im;
+ {
+     char		 res_name[256];
+     char		 res_class[256];
+     char		*str_type;
+     XrmValue		 value;
+ 
+     _Ximp_Get_resource_name(im, res_name, res_class);
+     strcat(res_name, "forceSelectKeyRelease");
+     strcat(res_class, "ForceSelectKeyRelease");
+     if(XrmGetResource(im->core.rdb, res_name, res_class, &str_type, &value) == True) {
+ 	if(strcmp(value.addr, "yes") == 0) {          /* Ximp 4.0 */
+ 	    im->ximp_impart->is_forceselectkeyrelease = True;
+ 	}
+     }
+     return;
+ }
+ 
+ static int
+ _Ximp_Environ()
+ {
+     char	*env_p;
+ #ifdef sun
+     int		 ret = XIMP_FE_TYPE3;
+ #else
+     int		 ret = XIMP_FE_TYPE1;
+ #endif    
+     if((env_p = (char *)getenv("XIMP_TYPE")) != (char *)NULL) {
+ 	if(strcmp(env_p, "XIMP_FE_TYPE1") == 0)
+ 	    ret = XIMP_FE_TYPE1;
+ 	else if(strcmp(env_p, "XIMP_FE_TYPE2") == 0)
+ 	    ret = XIMP_FE_TYPE2;
+ 	else if(strcmp(env_p, "XIMP_FE_TYPE3") == 0)
+ 	    ret = XIMP_FE_TYPE3;
+ 	else if(strcmp(env_p, "XIMP_BE_TYPE1") == 0)
+ 	    ret = XIMP_BE_TYPE1;
+ 	else if(strcmp(env_p, "XIMP_BE_TYPE2") == 0)
+ 	    ret = XIMP_BE_TYPE2;
+ 	else if(strcmp(env_p, "XIMP_SYNC_BE_TYPE1") == 0)
+ 	    ret = XIMP_SYNC_BE_TYPE1;
+ 	else if(strcmp(env_p, "XIMP_SYNC_BE_TYPE2") == 0)
+ 	    ret = XIMP_SYNC_BE_TYPE2;
+     }
+     return(ret);
+ }
+ 
+ static int
+ _Ximp_InputTypeResource(im)
+ Ximp_XIM	 im;
+ {
+     char		 res_name[256];
+     char		 res_class[256];
+     char		*str_type;
+     XrmValue		 value;
+ #ifdef sun
+     int		 ret = XIMP_FE_TYPE3;
+ #else
+     int		 ret = XIMP_FE_TYPE1;
+ #endif    
+ 
+     _Ximp_Get_resource_name(im, res_name, res_class);
+     strcat(res_name, "immode");
+     strcat(res_class, "Immode");
+     if(XrmGetResource(im->core.rdb, res_name, res_class, &str_type, &value) == True) {
+ 	if(strcmp(value.addr, "XIMP_FE_TYPE1") == 0)
+ 	    ret = XIMP_FE_TYPE1;
+ 	else if(strcmp(value.addr, "XIMP_FE_TYPE2") == 0)
+ 	    ret = XIMP_FE_TYPE2;
+ 	else if(strcmp(value.addr, "XIMP_FE_TYPE3") == 0)
+ 	    ret = XIMP_FE_TYPE3;
+ 	else if(strcmp(value.addr, "XIMP_BE_TYPE1") == 0)
+ 	    ret = XIMP_BE_TYPE1;
+ 	else if(strcmp(value.addr, "XIMP_BE_TYPE2") == 0)
+ 	    ret = XIMP_BE_TYPE2;
+ 	else if(strcmp(value.addr, "XIMP_SYNC_BE_TYPE1") == 0)
+ 	    ret = XIMP_SYNC_BE_TYPE1;
+ 	else if(strcmp(value.addr, "XIMP_SYNC_BE_TYPE2") == 0)
+ 	    ret = XIMP_SYNC_BE_TYPE2;
+ 	return(ret);
+     }
+     return(-1);
+ }
+ 
  void
+ _Ximp_OpenIM_Resource(im)
+ Ximp_XIM	 im;
+ {
+     int		 mode;
+ 
+     im->ximp_impart->def_svr_mode = _Ximp_Environ(); /* server input type */ 
+ 
+     if(im->core.rdb == NULL)
+ 	return;
+ 
+     /* Local Processing */
+     _Ximp_Local_Processing(im);
+ 
+     /* Inputserver */
+     _Ximp_InputServerMode(im);
+ 
+     /* Input Type */
+     if((mode = _Ximp_InputTypeResource(im)) != -1)
+ 	im->ximp_impart->def_svr_mode = mode;
+ 
+     /* Call Back */
+     _Ximp_CallBackWchar(im);
+ 
+     /* Force Select KeyRelease support */
+     _Ximp_ForceSelectKeyRelease(im);
+ 
+     /* Extension Resource */
+     _Ximp_OpenIMResourceExtension(im);
+     return;
+ }
+ 
+ void
  _Ximp_SetValue_Resource(ic, mask)
! Ximp_XIC	 ic;
! XimpChangeaMask	 mask;
! {
!     Ximp_XIM	 im;
!     char	 res_name[256];
!     char	 res_class[256];
!     char	*str_type ;
!     XrmValue	 value;
!     Colormap	 default_colormap;
!     XColor	 screen_def, exact_def;
!     int		 num, mode;
!     
!     im = (Ximp_XIM)XIMOfIC((XIC)ic);
!     if(im->core.rdb == NULL)
! 	return;
  
!     if(!(XIMP_CHK_SERVERTYPEMASK(ic))) {
! 	if((mode = _Ximp_InputTypeResource(im)) != -1) {
! 	    ic->ximp_icpart->svr_mode = mode;
! 	    XIMP_SET_SERVERTYPEMASK(ic, mask);
! 	}
!     }
  
!     if(!(   (ic->core.input_style & XIMPreeditCallbacks)
!          || (ic->core.input_style & XIMPreeditNone) ) ) {
! 	if(!(XIMP_CHK_PREBGMASK(ic))) {
! 	    _Ximp_Get_resource_name(im, res_name, res_class);
! 	    strcat(res_name, "preedit.background");
! 	    strcat(res_class, "Preedit.Background");
! 	    if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				  &str_type, &value) == True) { 
! 		default_colormap = DefaultColormap(
! 					       im->core.display,
! 					       DefaultScreen(im->core.display) );
! 		if( XAllocNamedColor(im->core.display, default_colormap,
! 					 value.addr,
! 					 &screen_def, &exact_def) ) {
! 		    ic->core.preedit_attr.background = screen_def.pixel;
! 		    ic->ximp_icpart->preedit_attr.Background = 
! 				ic->core.preedit_attr.background;
! 		    XIMP_SET_PREBGMASK(ic, mask);
  		}
! 	    }
! 	}
! 	if(!(XIMP_CHK_PREFGMASK(ic))) {
! 	    _Ximp_Get_resource_name(im, res_name, res_class);
! 	    strcat(res_name, "preedit.foreground");
! 	    strcat(res_class, "Preedit.Foreground");
! 	    if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				  &str_type, &value) == True) { 
! 		default_colormap = DefaultColormap(
! 					       im->core.display,
! 					       DefaultScreen(im->core.display) );
! 		if( XAllocNamedColor(im->core.display, default_colormap,
! 					 value.addr,
! 					 &screen_def, &exact_def) ) {
! 		    ic->core.preedit_attr.foreground = screen_def.pixel;
! 		    ic->ximp_icpart->preedit_attr.Foreground = 
! 				ic->core.preedit_attr.foreground;
! 		    XIMP_SET_PREBGMASK(ic, mask);
! 		}
! 	    }
! 	}
! 	if(!(XIMP_CHK_PRELINESPMASK(ic))) {
! 	    _Ximp_Get_resource_name(im, res_name, res_class);
! 	    strcat(res_name, "preedit.linespacing");
! 	    strcat(res_class, "Preedit.Linespacing");
! 	    if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				  &str_type, &value) == True) { 
! 		num = atoi(value.addr);
! 		ic->core.preedit_attr.line_space = num;
! 		ic->ximp_icpart->preedit_attr.LineSpacing = 
! 			ic->core.preedit_attr.line_space;
! 		XIMP_SET_PRELINESPMASK(ic, mask);
! 	    }
! 	}
!     }
  
!     if(!(   (ic->core.input_style & XIMStatusCallbacks)
!          || (ic->core.input_style & XIMStatusNone) ) ) {
! 	if(!(XIMP_CHK_STSBGMASK(ic))) {
! 	    _Ximp_Get_resource_name(im, res_name, res_class);
! 	    strcat(res_name, "status.background");
! 	    strcat(res_class, "Status.Background");
! 	    if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				  &str_type, &value) == True) { 
! 	    default_colormap = DefaultColormap(im->core.display,
! 					       DefaultScreen(im->core.display) );
! 	    if( XAllocNamedColor(im->core.display, default_colormap,
! 				 value.addr,
! 				 &screen_def, &exact_def) ) {
! 		ic->core.status_attr.background = screen_def.pixel;
! 		ic->ximp_icpart->status_attr.Background = 
! 			ic->core.status_attr.background;
! 		XIMP_SET_STSBGMASK(ic, mask);
  		}
! 	    }
  	}
+ 	if(!(XIMP_CHK_STSFGMASK(ic))) {
+ 	    _Ximp_Get_resource_name(im, res_name, res_class);
+ 	    strcat(res_name, "status.foreground");
+ 	    strcat(res_class, "Status.Foreground");
+ 	    if(XrmGetResource(im->core.rdb, res_name, res_class,
+ 				  &str_type, &value) == True) { 
+ 	    default_colormap = DefaultColormap(im->core.display,
+ 					       DefaultScreen(im->core.display) );
+ 	    if( XAllocNamedColor(im->core.display, default_colormap,
+ 				 value.addr,
+ 				 &screen_def, &exact_def) ) {
+ 		ic->core.status_attr.foreground = screen_def.pixel;
+ 		ic->ximp_icpart->status_attr.Foreground = 
+ 			ic->core.status_attr.foreground;
+ 		XIMP_SET_STSFGMASK(ic, mask);
+ 		}
+ 	    }
+ 	}
+ 	if(!(XIMP_CHK_STSLINESPMASK(ic))) {
+ 	    _Ximp_Get_resource_name(im, res_name, res_class);
+ 	    strcat(res_name, "status.linespacing");
+ 	    strcat(res_class, "Status.Linespacing");
+ 	    if(XrmGetResource(im->core.rdb, res_name, res_class,
+ 				  &str_type, &value) == True) { 
+ 		num = atoi(value.addr);
+ 		ic->core.status_attr.line_space = num;
+ 		ic->ximp_icpart->status_attr.LineSpacing = 
+ 			ic->core.status_attr.line_space;
+ 		XIMP_SET_STSLINESPMASK(ic, mask);
+ 	    }
+ 	}
+     }
+ 
+     if(   (ic->ximp_icpart->value_mask & XIMP_RES_NAME)
+        || (ic->ximp_icpart->value_mask & XIMP_RES_CLASS) )
+ 	ic->ximp_icpart->value_mask &= ~(XIMP_RES_NAME | XIMP_RES_CLASS);
+     return;
+ }
*** /tmp/d19137	Mon Oct 19 19:36:41 1992
--- lib/X/Ximp/XimpSJIS.c	Mon Oct 19 19:26:24 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpSJIS.c,v 1.4 92/04/14 13:29:59 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 Sony Corporation
--- 1,4 ----
! /* $XConsortium: XimpSJIS.c,v 1.5 92/10/19 19:26:21 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 Sony Corporation
***************
*** 23,28 ****
--- 23,29 ----
  PERFORMANCE OF THIS SOFTWARE.
  
    Author: Masaki Takeuchi       Sony Corporation
+           Makoto Wakamatsu      Sony Corporation
  
  ******************************************************************/
  
***************
*** 34,49 ****
  
  #ifdef USE_SJIS
  
- static Bool sjis_initialize();
- static void null_proc();
  static char sjis_mbchar();
  static int sjis_mbstocs(), sjis_wcstocs(), sjis_cstombs(), sjis_cstowcs();
  
! XLCdXimpMethods sjis_lc_methods =
  {
!     sjis_initialize,
!     null_proc,
!     null_proc,
      sjis_mbchar,
      sjis_mbstocs,
      sjis_wcstocs,
--- 35,56 ----
  
  #ifdef USE_SJIS
  
  static char sjis_mbchar();
  static int sjis_mbstocs(), sjis_wcstocs(), sjis_cstombs(), sjis_cstowcs();
  
! static XLCdMethodsRec lcd_methods = {
!     _XlcDefaultMapModifiers,
!     _XDefaultCreateFontSet,
!     _Ximp_OpenIM,
! };
! 
! LCMethodsRec sjis_lc_methods =
  {
!     _XlcDestroyLC,
!     _XlcCreateState,
!     _XlcDestroyState,
!     _XlcCnvStart,
!     _XlcCnvEnd,
      sjis_mbchar,
      sjis_mbstocs,
      sjis_wcstocs,
***************
*** 51,60 ****
--- 58,76 ----
      sjis_cstowcs,
  };
  
+ #ifdef	SVR4
+ #define WC_MASK		0x30000000
+ #define CS1_WC_MASK	0x30000000
+ #define CS2_WC_MASK	0x10000000
+ #define CS3_WC_MASK	0x20000000
+ #define SHIFT_BITS	7
+ #else
  #define WC_MASK		0x8080
  #define CS1_WC_MASK	0x8080
  #define CS2_WC_MASK	0x0080
  #define CS3_WC_MASK	0x8000
+ #define SHIFT_BITS	8
+ #endif
  
  #ifndef iskanji
  #define iskanji(x)	((0x81<=(x) && (x)<=0x9f) || (0xe0<=(x) && (x)<=0xfc))
***************
*** 63,87 ****
  #define iskana(x)	(0xa1<=(x) && (x)<=0xdf)
  #endif /* !iskana */
  
- static void
- null_proc(lcd)
-     Ximp_XLCd lcd;
- {
- }
  
! static Bool
! sjis_initialize(lcd)
!     Ximp_XLCd lcd;
  {
!     lcd->ximp_lcpart->mb_cur_max = 2;
!     lcd->ximp_lcpart->state_dependent = False;
  
!     return True;
  }
  
  static char
! sjis_mbchar(lcd, str, lenp)
!     Ximp_XLCd lcd;
      register char *str;
      register int *lenp;
  {
--- 79,112 ----
  #define iskana(x)	(0xa1<=(x) && (x)<=0xdf)
  #endif /* !iskana */
  
  
! XLCd
! _XlcSJISLoader(name)
!     char *name;
  {
!     XimpLCd lcd;
  
!     lcd = _XlcCreateLC(name, &lcd_methods, &sjis_lc_methods);
!     if (lcd == NULL)
!         return (XLCd) NULL;
!     
!     if (strcmp(lcd->locale.codeset, "SJIS"))
! 	goto error;
! 
!     if (_XlcLoadCodeSet(lcd) == False)
!         goto error;
! 
!     return (XLCd) lcd;
! 
! error:
!     _XlcDestroyLC(lcd);
! 
!     return (XLCd) NULL;
  }
  
  static char
! sjis_mbchar(state, str, lenp)
!     State state;
      register char *str;
      register int *lenp;
  {
***************
*** 96,109 ****
  }
  
  static int
! sjis_mbstocs(lcd, mbstr, mbstr_len, csbuf, csbuf_len, cs_number, char_length)
!     Ximp_XLCd lcd;
      unsigned char *mbstr;
      int mbstr_len;
      unsigned char *csbuf;
      int *csbuf_len;
-     int *cs_number;
-     int *char_length;
  {
      register unsigned char *mbptr = mbstr;
      register unsigned char *bufptr = csbuf;
--- 121,132 ----
  }
  
  static int
! sjis_mbstocs(state, mbstr, mbstr_len, csbuf, csbuf_len)
!     State state;
      unsigned char *mbstr;
      int mbstr_len;
      unsigned char *csbuf;
      int *csbuf_len;
  {
      register unsigned char *mbptr = mbstr;
      register unsigned char *bufptr = csbuf;
***************
*** 115,132 ****
  	buf_len = *csbuf_len;
      else
  	buf_len = MAXINT;
-     if (char_length)
- 	*char_length = 1;
-     
      ch = *mbptr;
      if (ch & 0x80) {
! 	if (iskanji(ch)) {
      	    codeset_number = 1;
! 	    if (char_length)
! 		*char_length = 2;
! 	} else if (iskana(ch))
      	    codeset_number = 2;
      }
  
      while (mbstr_len > 0 && buf_len > 0) {
  	ch = *mbptr;
--- 138,151 ----
  	buf_len = *csbuf_len;
      else
  	buf_len = MAXINT;
      ch = *mbptr;
      if (ch & 0x80) {
! 	if (iskanji(ch))
      	    codeset_number = 1;
! 	else if (iskana(ch))
      	    codeset_number = 2;
      }
+     state->codeset = state->lcd->locale.codeset_list[codeset_number];
  
      while (mbstr_len > 0 && buf_len > 0) {
  	ch = *mbptr;
***************
*** 162,169 ****
  
      if (csbuf_len)
  	*csbuf_len = bufptr - csbuf;
-     if (cs_number)
- 	*cs_number = codeset_number;
  
      return mbptr - mbstr;
  }
--- 181,186 ----
***************
*** 170,183 ****
  
  
  static int
! sjis_wcstocs(lcd, wcstr, wcstr_len, csbuf, csbuf_len, cs_number, char_length)
!     Ximp_XLCd lcd;
      wchar_t *wcstr;
      int wcstr_len;
      unsigned char *csbuf;
      int *csbuf_len;
-     int *cs_number;
-     int *char_length;
  {
      wchar_t *wcptr = wcstr, wc_mask;
      register unsigned char *bufptr = csbuf;
--- 187,198 ----
  
  
  static int
! sjis_wcstocs(state, wcstr, wcstr_len, csbuf, csbuf_len)
!     State state;
      wchar_t *wcstr;
      int wcstr_len;
      unsigned char *csbuf;
      int *csbuf_len;
  {
      wchar_t *wcptr = wcstr, wc_mask;
      register unsigned char *bufptr = csbuf;
***************
*** 184,190 ****
      register wchar_t wch;
      int buf_len;
      int codeset_number = 0;
! #ifdef sony_news
      unsigned char ch, ch2;
  #endif
  
--- 199,205 ----
      register wchar_t wch;
      int buf_len;
      int codeset_number = 0;
! #if defined(sony_news)  &&  !defined(__svr4)
      unsigned char ch, ch2;
  #endif
  
***************
*** 192,210 ****
  	buf_len = *csbuf_len;
      else
  	buf_len = MAXINT;
-     if (char_length)
- 	*char_length = 1;
- 
      wch = *wcptr;
! #ifdef sony_news
      ch = (unsigned char) (wch >> 8);
      ch2 = (unsigned char) wch;
      if (ch) {
  	codeset_number = 1;
- 	if (char_length)
- 	    *char_length = 2;
      } else if (iskana(ch2))
  	codeset_number = 2;
      
      for ( ; wcstr_len > 0 && buf_len > 0; wcptr++, wcstr_len--) {
  	wch = *wcptr;
--- 207,221 ----
  	buf_len = *csbuf_len;
      else
  	buf_len = MAXINT;
      wch = *wcptr;
! #if defined(sony_news)  &&  !defined(__svr4)
      ch = (unsigned char) (wch >> 8);
      ch2 = (unsigned char) wch;
      if (ch) {
  	codeset_number = 1;
      } else if (iskana(ch2))
  	codeset_number = 2;
+     state->codeset = state->lcd->locale.codeset_list[codeset_number];
      
      for ( ; wcstr_len > 0 && buf_len > 0; wcptr++, wcstr_len--) {
  	wch = *wcptr;
***************
*** 238,247 ****
      wc_mask = wch & WC_MASK;
      if (wc_mask == CS1_WC_MASK) {
  	codeset_number = 1;
- 	if (char_length)
- 	    *char_length = 2;
      } else if (wc_mask == CS2_WC_MASK)
  	codeset_number = 2;
  
      for ( ; wcstr_len > 0 && buf_len > 0; wcptr++, wcstr_len--) {
  	wch = *wcptr;
--- 249,257 ----
      wc_mask = wch & WC_MASK;
      if (wc_mask == CS1_WC_MASK) {
  	codeset_number = 1;
      } else if (wc_mask == CS2_WC_MASK)
  	codeset_number = 2;
+     state->codeset = state->lcd->locale.codeset_list[codeset_number];
  
      for ( ; wcstr_len > 0 && buf_len > 0; wcptr++, wcstr_len--) {
  	wch = *wcptr;
***************
*** 268,293 ****
  
      if (csbuf_len)
  	*csbuf_len = bufptr - csbuf;
-     if (cs_number)
- 	*cs_number = codeset_number;
- 
      return wcptr - wcstr;
  }
  
  
  static int
! sjis_cstombs(lcd, csstr, csstr_len, mbbuf, mbbuf_len, cs_number)
!     Ximp_XLCd lcd;
      unsigned char *csstr;
      int csstr_len;
      unsigned char *mbbuf;
      int *mbbuf_len;
-     int cs_number;
  {
      register unsigned char *csptr = csstr;
      register unsigned char *bufptr = mbbuf;
      unsigned char high, low, ch1, ch2;
      register buf_len;
  
      if (mbbuf_len)
  	buf_len = *mbbuf_len;
--- 278,300 ----
  
      if (csbuf_len)
  	*csbuf_len = bufptr - csbuf;
      return wcptr - wcstr;
  }
  
  
  static int
! sjis_cstombs(state, csstr, csstr_len, mbbuf, mbbuf_len)
!     State state;
      unsigned char *csstr;
      int csstr_len;
      unsigned char *mbbuf;
      int *mbbuf_len;
  {
      register unsigned char *csptr = csstr;
      register unsigned char *bufptr = mbbuf;
      unsigned char high, low, ch1, ch2;
      register buf_len;
+     int cs_num = state->codeset->cs_num;
  
      if (mbbuf_len)
  	buf_len = *mbbuf_len;
***************
*** 296,302 ****
      if (csstr_len < buf_len)
  	buf_len = csstr_len;
  
!     if (cs_number == 1) {
  	buf_len >>= 1;
  	while (buf_len--) {
  	    high = *csptr++ & 0x7f;
--- 303,309 ----
      if (csstr_len < buf_len)
  	buf_len = csstr_len;
  
!     if (cs_num == 1) {
  	buf_len >>= 1;
  	while (buf_len--) {
  	    high = *csptr++ & 0x7f;
***************
*** 314,320 ****
  	    *bufptr++ = ch1;
  	    *bufptr++ = ch2;
  	}
!     } else if(cs_number == 2) {
  	while (buf_len--)
  	    *bufptr++ = *csptr++ | 0x80;
      } else
--- 321,327 ----
  	    *bufptr++ = ch1;
  	    *bufptr++ = ch2;
  	}
!     } else if(cs_num == 2) {
  	while (buf_len--)
  	    *bufptr++ = *csptr++ | 0x80;
      } else
***************
*** 329,347 ****
  
  
  static int
! sjis_cstowcs(lcd, csstr, csstr_len, wcbuf, wcbuf_len, cs_number)
!     Ximp_XLCd lcd;
      unsigned char *csstr;
      int csstr_len;
      wchar_t *wcbuf;
      int *wcbuf_len;
-     int cs_number;
  {
      register unsigned char *csptr = csstr;
      wchar_t *bufptr = wcbuf;
      register wchar_t wch;
      register buf_len;
! #ifdef sony_news
      unsigned char high, low, ch1, ch2;
  #endif
  
--- 336,354 ----
  
  
  static int
! sjis_cstowcs(state, csstr, csstr_len, wcbuf, wcbuf_len)
!     State state;
      unsigned char *csstr;
      int csstr_len;
      wchar_t *wcbuf;
      int *wcbuf_len;
  {
      register unsigned char *csptr = csstr;
      wchar_t *bufptr = wcbuf;
      register wchar_t wch;
      register buf_len;
!     int cs_num = state->codeset->cs_num;
! #if defined(sony_news)  &&  !defined(__svr4)
      unsigned char high, low, ch1, ch2;
  #endif
  
***************
*** 350,357 ****
      else
  	buf_len = MAXINT;
  
! #ifdef sony_news
!     if (cs_number == 1) {
  	csstr_len >>= 1;
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
--- 357,364 ----
      else
  	buf_len = MAXINT;
  
! #if defined(sony_news)  &&  !defined(__svr4)
!     if (cs_num == 1) {
  	csstr_len >>= 1;
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
***************
*** 370,376 ****
  		ch2 = low + 0x7e;
  	    *bufptr++ = (ch1 << 8) | ch2;
  	}
!     } else if (cs_number == 2) {
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
  	while (buf_len--)
--- 377,383 ----
  		ch2 = low + 0x7e;
  	    *bufptr++ = (ch1 << 8) | ch2;
  	}
!     } else if (cs_num == 2) {
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
  	while (buf_len--)
***************
*** 381,388 ****
  	while (buf_len--)
  	    *bufptr++ = (wchar_t) (*csptr++ & 0x7f);
      }
! #else
!     if (cs_number == 1) {
  	csstr_len >>= 1;
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
--- 388,395 ----
  	while (buf_len--)
  	    *bufptr++ = (wchar_t) (*csptr++ & 0x7f);
      }
! #else /* defined(sony_news)  &&  !defined(__svr4) */
!     if (cs_num == 1) {
  	csstr_len >>= 1;
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
***************
*** 389,402 ****
  
  	while (buf_len--) {
  	    wch = *csptr++;
! 	    wch = (wch << 8) | *csptr++;
  	    *bufptr++ = wch | CS1_WC_MASK;
  	}
!     } else if (cs_number == 2) {
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
  	while (buf_len--)
! 	    *bufptr++ = (wchar_t) (*csptr++ | CS2_WC_MASK);
      } else {
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
--- 396,409 ----
  
  	while (buf_len--) {
  	    wch = *csptr++;
! 	    wch = (wch << SHIFT_BITS) | *csptr++;
  	    *bufptr++ = wch | CS1_WC_MASK;
  	}
!     } else if (cs_num == 2) {
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
  	while (buf_len--)
! 	    *bufptr++ = (wchar_t) ((*csptr++ & 0x7f) | CS2_WC_MASK);
      } else {
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
***************
*** 403,409 ****
  	while (buf_len--)
  	    *bufptr++ = (wchar_t) (*csptr++ & 0x7f);
      }
! #endif
  
      if (wcbuf_len)
  	*wcbuf_len = bufptr - wcbuf;
--- 410,416 ----
  	while (buf_len--)
  	    *bufptr++ = (wchar_t) (*csptr++ & 0x7f);
      }
! #endif /* defined(sony_news)  &&  !defined(__svr4) */
  
      if (wcbuf_len)
  	*wcbuf_len = bufptr - wcbuf;
*** /tmp/d19156	Mon Oct 19 19:36:57 1992
--- lib/X/Ximp/XimpTxtEsc.c	Mon Oct 19 19:26:28 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpTxtEsc.c,v 1.2 92/04/14 13:30:02 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpTxtEsc.c,v 1.3 92/10/19 19:26:24 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
***************
*** 71,95 ****
   */
  
  {
!     Ximp_XLCd lcd = (Ximp_XLCd) xfont_set->core.lcd;
      unsigned char *strptr, strbuf[BUFSIZE];
      unsigned char xchar_buf[BUFSIZE];
      XChar2b xchar2b_buf[BUFSIZE];
-     FontSetRec *fontset;
      XFontStruct *font;
      int (*cnv_func)();
-     int cset_num, char_length;
      int count, length, tmp_len;
      int width = 0;
  
!     cnv_func = lcd->ximp_lcpart->methods->CNV_FUNC;
  
!     (*lcd->ximp_lcpart->methods->cnv_start)(lcd);
  
      while (text_length > 0) {
          length = BUFSIZE;
! 	count = (*cnv_func)(lcd, text, text_length, strbuf, &length,
! 			    &cset_num, &char_length);
  	if (count <= 0)
  	    break;
  
--- 71,95 ----
   */
  
  {
!     XLCd lcd = xfont_set->core.lcd;
      unsigned char *strptr, strbuf[BUFSIZE];
      unsigned char xchar_buf[BUFSIZE];
      XChar2b xchar2b_buf[BUFSIZE];
      XFontStruct *font;
      int (*cnv_func)();
      int count, length, tmp_len;
      int width = 0;
+     LCMethods methods = LC_METHODS(lcd);
+     State state;
  
!     cnv_func = methods->CNV_FUNC;
  
!     state = (*methods->create_state)(lcd);
!     (*methods->cnv_start)(state);
  
      while (text_length > 0) {
          length = BUFSIZE;
! 	count = (*cnv_func)(state, text, text_length, strbuf, &length);
  	if (count <= 0)
  	    break;
  
***************
*** 97,117 ****
  	text_length -= count;
  
  	strptr = strbuf;
- 	fontset = ((Ximp_XFontSet) xfont_set)->ximp_fspart->fontset + cset_num;
- 	if (fontset == NULL)
- 	    continue;
  	while (length > 0) {
  	    tmp_len = BUFSIZE;
! 	    if (char_length < 2)
! 	    	count = _Ximp_cstoxchar(fontset, strptr, length,
! 					xchar_buf, &tmp_len, &font);
  	    else
! 		count = _Ximp_cstoxchar2b(fontset, strptr, length,
! 					  xchar2b_buf, &tmp_len, &font);
  	    if (count <= 0)
  		break;
  
! 	    if (char_length < 2)
  		width += XTextWidth(font, (char *)xchar_buf, tmp_len);
              else
  		width += XTextWidth16(font, xchar2b_buf, tmp_len);
--- 97,114 ----
  	text_length -= count;
  
  	strptr = strbuf;
  	while (length > 0) {
  	    tmp_len = BUFSIZE;
! 	    if (state->codeset->length < 2)
! 	    	count = _Ximp_cstoxchar(xfont_set, strptr, length, xchar_buf,
! 					&tmp_len, state->codeset, &font);
  	    else
! 		count = _Ximp_cstoxchar2b(xfont_set, strptr, length, xchar2b_buf,
! 					  &tmp_len, state->codeset, &font);
  	    if (count <= 0)
  		break;
  
! 	    if (state->codeset->length < 2)
  		width += XTextWidth(font, (char *)xchar_buf, tmp_len);
              else
  		width += XTextWidth16(font, xchar2b_buf, tmp_len);
***************
*** 121,127 ****
  	}
      }
  
!     (*lcd->ximp_lcpart->methods->cnv_end)(lcd);
  
      return width;
  }
--- 118,125 ----
  	}
      }
  
!     (*methods->cnv_end)(state);
!     (*methods->destroy_state)(state);
  
      return width;
  }
