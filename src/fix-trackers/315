Path: news!news.crl.dec.com!pa.dec.com!nobody
Message-Id: <9205151639.AA13974@alex.lcs.mit.edu>
To: fix-trackers@expo.lcs.mit.edu
Subject: (seq: 2543) Font Service protocol version 2 sample implementation, part 1 of 2
Date: Fri, 15 May 92 12:39:36 EDT
From: Stephen Gildea <gildea@expo.lcs.mit.edu>
Distribution: dec
X-Mailing-List: fix-trackers@expo.lcs.mit.edu
X-Disclaimer: This message originated from a mailing list outside of Digital.
Newsgroups: dec.mail.lists.x.fix-trackers
Approved: news@usenet.pa.dec.com

        Subject: fontlib: fontserver and fontlib have fsChar2B backwards
        ### bug number:   4757
        ### area:         fontlib
        ### severity:     low

        Subject: font server: returns bogus metrics for TE fonts
        ### bug number:   5170
        ### area:         fontlib
        ### severity:     high

        Subject: fontserver: ListFontsWithXInfo reply incorrectly formatted
        ### bug number:   5173
        ### area:         fontserver
        ### severity:     high

        Subject: fontlib: ListFontsWithXInfo reply incorrectly parsed
        ### bug number:   5174
        ### area:         fontlib
        ### severity:     high

        Subject: fontserver: ListFontsWithXInfo reply length field incorrect
        ### bug number:   5002
        ### area:         fontserver
        ### severity:     low

        Subject: fontserver: Last ListFontsWithXInfo reply length not to spec
        ### bug number:   5003
        ### area:         fontserver
        ### severity:     low


This patch fixes all known fs protocol problems.  The fixed protocol
is called version 2.0 and matches the version 1.0 specification.
Version 1.0 support is also provided, and is unchanged from before.
That is, it continues to differ from the version 1.0 specification.

In addition to applying this patch, you should delete these two files:
fonts/lib/font/util/fsfuncs.c
fonts/lib/font/bitmap/fsfuncs.c
The functionality here has been moved into a new file
fonts/server/difs/charinfo.c, included in the patch below.
Each of the three directories affected has a new Imakefile;
you will need to run "make Makefile" there.

Due to the size of this patch, I am sending it out as two mail messages.

*** /tmp/da12984	Fri May 15 12:02:25 1992
--- fonts/include/FS.h	Tue May 12 18:07:08 1992
***************
*** 1,4 ****
! /* $XConsortium: FS.h,v 1.4 91/05/13 16:45:26 gildea Exp $ */
  /* 
   * Copyright 1990, 1991 Network Computing Devices; 
   * Portions Copyright 1987 by Digital Equipment Corporation and the 
--- 1,4 ----
! /* $XConsortium: FS.h,v 1.5 92/05/12 18:07:12 gildea Exp $ */
  /* 
   * Copyright 1990, 1991 Network Computing Devices; 
   * Portions Copyright 1987 by Digital Equipment Corporation and the 
***************
*** 20,28 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)FS.h	3.2	91/04/11
-  *
   */
  #ifndef _FS_H_
  #define	_FS_H_
--- 20,25 ----
***************
*** 29,35 ****
  
  #include <fsmasks.h>
  
! #define	FS_PROTOCOL		1
  #define	FS_PROTOCOL_MINOR	0
  
  typedef unsigned long FSID;
--- 26,32 ----
  
  #include <fsmasks.h>
  
! #define	FS_PROTOCOL		2
  #define	FS_PROTOCOL_MINOR	0
  
  typedef unsigned long FSID;
*** /tmp/da13003	Fri May 15 12:02:26 1992
--- fonts/include/FSproto.h	Tue May 12 18:07:11 1992
***************
*** 1,4 ****
! /* $XConsortium: FSproto.h,v 1.5 91/07/26 21:00:24 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: FSproto.h,v 1.6 92/05/12 18:07:14 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 20,28 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * $NCDId: @(#)FSproto.h,v 4.3 1991/06/27 16:30:07 lemke Exp $
-  *
   */
  
  #ifndef _FS_PROTO_H_
--- 20,25 ----
***************
*** 114,122 ****
  }           fsCharInfo;
  
  typedef struct {
      CARD8       low,
                  high;
! }           fsChar2b;
  
  typedef struct {
      fsChar2b    min_char,
--- 111,124 ----
  }           fsCharInfo;
  
  typedef struct {
+     CARD8       high;
+     CARD8       low;
+ }           fsChar2b;
+ 
+ typedef struct {
      CARD8       low,
                  high;
! }           fsChar2b_version1;
  
  typedef struct {
      fsChar2b    min_char,
*** /tmp/da13022	Fri May 15 12:02:28 1992
--- fonts/include/fontstruct.h	Tue May 12 18:07:13 1992
***************
*** 1,4 ****
! /* $Header: /alphabits/u3/x11/ode/rcs/x11/src/fix-trackers/315,v 1.1.2.2 92/06/08 13:58:55 Jim_Ludwig Exp $ */
  /***********************************************************
  Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
  and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
--- 1,4 ----
! /* $XConsortium: fontstruct.h,v 1.11 92/05/12 18:07:16 gildea Exp $ */
  /***********************************************************
  Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
  and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
***************
*** 21,28 ****
  ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  SOFTWARE.
  
- 	@(#)fontstruct.h	3.2	91/04/15
- 
  ******************************************************************/
  
  #ifndef FONTSTR_H
--- 21,26 ----
***************
*** 115,124 ****
      fsBitmapFormat format;
      int         (*get_glyphs) ( /* font, count, chars, encoding, count, glyphs */ );
      int         (*get_metrics) ( /* font, count, chars, encoding, count, glyphs */ );
-     int         (*get_bitmaps) (/* client, font, flags, ranges, nranges,
- 				    nextents, extents */ );
-     int         (*get_extents) (/* client, font, format, flags, ranges,
- 				    nranges, nglyphs, offsets, glyphs */ );
      void        (*unload_font) ( /* font */ );
      FontPathElementPtr fpe;
      pointer     svrPrivate;
--- 113,118 ----
*** /tmp/da13041	Fri May 15 12:02:31 1992
--- fonts/lib/fs/FSFontInfo.c	Wed May 13 15:42:00 1992
***************
*** 1,6 ****
! /* $XConsortium: FSFontInfo.c,v 1.2 91/05/13 15:11:37 gildea Exp $ */
! 
! /* @(#)FSFontInfo.c	4.1	91/05/02
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
--- 1,5 ----
! /* $XConsortium: FSFontInfo.c,v 1.4 92/05/13 15:41:58 gildea Exp $ */
! /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
***************
*** 47,52 ****
--- 46,52 ----
      char      **flist = NULL;
      fsListFontsWithXInfoReply reply;
      fsListFontsWithXInfoReq *req;
+     Status status;
  
      GetReq(ListFontsWithXInfo, req);
      req->maxNames = maxNames;
***************
*** 55,63 ****
      _FSSend(svr, pattern, nbytes);
  
      for (i = 0;; i++) {
! 	if (!_FSReply(svr, (fsReply *) & reply,
! 		      ((SIZEOF(fsListFontsWithXInfoReply) -
! 			SIZEOF(fsGenericReply)) >> 2), fsFalse)) {
  	    for (j = (i - 1); j >= 0; j--) {
  		FSfree((char *) fhdr[j]);
  		FSfree((char *) pi[j]);
--- 55,75 ----
      _FSSend(svr, pattern, nbytes);
  
      for (i = 0;; i++) {
! 	if (FSProtocolVersion(svr) > 1)
! 	{
! 	    status = _FSReply(svr, (fsReply *) &reply, 0, fsFalse);
! 	    if (status != 0  &&  reply.nameLength == 0)	/* got last reply */
! 		break;
! 	    if (status)
! 		_FSRead(svr, (char *) &reply.nReplies,
! 			SIZEOF(fsListFontsWithXInfoReply) -
! 			SIZEOF(fsGenericReply));
! 	} else {
! 	    status = _FSReply(svr, (fsReply *) & reply,
! 			      ((SIZEOF(fsListFontsWithXInfoReply) -
! 				SIZEOF(fsGenericReply)) >> 2), fsFalse);
! 	}
! 	if (!status) {
  	    for (j = (i - 1); j >= 0; j--) {
  		FSfree((char *) fhdr[j]);
  		FSfree((char *) pi[j]);
***************
*** 79,85 ****
  	    SyncHandle();
  	    return (char **) NULL;
  	}
! 	if (reply.nameLength == 0)	/* got last reply */
  	    break;
  	if ((i + reply.nReplies) >= size) {
  	    size = i + reply.nReplies + 1;
--- 91,97 ----
  	    SyncHandle();
  	    return (char **) NULL;
  	}
! 	if (reply.nameLength == 0)	/* got last reply in version 1 */
  	    break;
  	if ((i + reply.nReplies) >= size) {
  	    size = i + reply.nReplies + 1;
***************
*** 172,187 ****
  	    goto badmem;
  	}
  	bcopy((char *) &reply.header, (char *) fhdr[i], sizeof(fsFontHeader));
  
! 	/* get the name */
  	flist[i] = (char *) FSmalloc((unsigned int) (reply.nameLength + 1));
! 	if (!flist[i]) {
! 	    nbytes = reply.nameLength + 3 & ~3;
! 	    _FSEatData(svr, (unsigned long) nbytes);
! 	    goto badmem;
  	}
- 	_FSReadPad(svr, flist[i], (long) reply.nameLength);
- 	flist[i][reply.nameLength] = '\0';
  
  	pi[i] = (fsPropInfo *) FSmalloc(sizeof(fsPropInfo));
  	if (!pi[i]) {
--- 184,212 ----
  	    goto badmem;
  	}
  	bcopy((char *) &reply.header, (char *) fhdr[i], sizeof(fsFontHeader));
+ 	if (FSProtocolVersion(svr) == 1)
+ 	{
+ 	    fhdr[i]->char_range.min_char.high = reply.header.char_range.min_char.low;
+ 	    fhdr[i]->char_range.min_char.low = reply.header.char_range.min_char.high;
+ 	    fhdr[i]->char_range.max_char.high = reply.header.char_range.max_char.low;
+ 	    fhdr[i]->char_range.max_char.low = reply.header.char_range.max_char.high;
+ 	    fhdr[i]->default_char.high = reply.header.default_char.low;
+ 	    fhdr[i]->default_char.low = reply.header.default_char.high;
+ 	}
  
! 	/* alloc space for the name */
  	flist[i] = (char *) FSmalloc((unsigned int) (reply.nameLength + 1));
! 	if (FSProtocolVersion(svr) == 1)
! 	{
! 	    /* get the name */
! 	    if (!flist[i]) {
! 		nbytes = reply.nameLength + 3 & ~3;
! 		_FSEatData(svr, (unsigned long) nbytes);
! 		goto badmem;
! 	    }
! 	    _FSReadPad(svr, flist[i], (long) reply.nameLength);
! 	    flist[i][reply.nameLength] = '\0';
  	}
  
  	pi[i] = (fsPropInfo *) FSmalloc(sizeof(fsPropInfo));
  	if (!pi[i]) {
***************
*** 208,215 ****
  	_FSReadPad(svr, (char *) po[i],
  		   (pi[i]->num_offsets * sizeof(fsPropOffset)));
  	/* get prop data */
! 	_FSReadPad(svr, (char *) pd[i], pi[i]->data_len);
  
      }
      *info = fhdr;
      *count = i;
--- 233,257 ----
  	_FSReadPad(svr, (char *) po[i],
  		   (pi[i]->num_offsets * sizeof(fsPropOffset)));
  	/* get prop data */
! 	if (FSProtocolVersion(svr) == 1)
! 	    _FSReadPad(svr, (char *) pd[i], pi[i]->data_len);
! 	else
! 	    _FSRead(svr, (char *) pd[i], pi[i]->data_len);
  
+ 	if (FSProtocolVersion(svr) != 1)
+ 	{
+ 	    /* get the name */
+ 	    if (!flist[i]) {
+ 		nbytes = reply.nameLength + 3 & ~3;
+ 		_FSEatData(svr, (unsigned long) nbytes);
+ 		goto badmem;
+ 	    }
+ 	    _FSRead(svr, flist[i], (long) reply.nameLength);
+ 	    flist[i][reply.nameLength] = '\0';
+ 
+ 	    nbytes = pi[i]->data_len + reply.nameLength;
+ 	    _FSEatData(svr, (unsigned long) (((nbytes+3)&~3) - nbytes));
+ 	}
      }
      *info = fhdr;
      *count = i;
*** /tmp/da13060	Fri May 15 12:02:33 1992
--- fonts/lib/fs/FSQGlyphs.c	Tue May 12 18:07:17 1992
***************
*** 1,6 ****
! /* $XConsortium: FSQGlyphs.c,v 1.2 91/05/13 15:11:49 gildea Exp $ */
! 
! /* @(#)FSQGlyphs.c	4.1	91/05/02
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
--- 1,5 ----
! /* $XConsortium: FSQGlyphs.c,v 1.3 92/05/12 18:07:20 gildea Exp $ */
! /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
***************
*** 98,104 ****
      req->format = format;
      req->num_ranges = str_len;
      req->length += ((str_len * sizeof(fsChar2b)) + 3) >> 2;
!     _FSSend(svr, (char *) str, (str_len * sizeof(fsChar2b)));
  
      /* get back the info */
      if (!_FSReply(svr, (fsReply *) & reply,
--- 97,119 ----
      req->format = format;
      req->num_ranges = str_len;
      req->length += ((str_len * sizeof(fsChar2b)) + 3) >> 2;
!     if (FSProtocolVersion(svr) == 1)
!     {
! 	int i;
! 	fsChar2b_version1 *swapped_str;
! 
! 	swapped_str = (fsChar2b_version1 *)
! 	    FSmalloc(sizeof(fsChar2b_version1) * str_len);
! 	if (!swapped_str)
! 	    return FSBadAlloc;
! 	for (i = 0; i < str_len; i++) {
! 	    swapped_str[i].low = str->low;
! 	    swapped_str[i].high = str->high;
! 	}
! 	_FSSend(svr, (char *)swapped_str, (str_len*sizeof(fsChar2b_version1)));
! 	FSfree(swapped_str);
!     } else
! 	_FSSend(svr, (char *) str, (str_len * sizeof(fsChar2b)));
  
      /* get back the info */
      if (!_FSReply(svr, (fsReply *) & reply,
*** /tmp/da13079	Fri May 15 12:02:35 1992
--- fonts/lib/fs/FSQXExt.c	Tue May 12 18:07:18 1992
***************
*** 1,6 ****
! /* $XConsortium: FSQXExt.c,v 1.2 91/05/13 15:11:50 gildea Exp $ */
! 
! /* @(#)FSQXExt.c	4.1	91/05/02
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
--- 1,5 ----
! /* $XConsortium: FSQXExt.c,v 1.3 92/05/12 18:07:22 gildea Exp $ */
! /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
***************
*** 83,89 ****
      req->range = range_type;
      req->num_ranges = str_len;
      req->length += ((str_len * sizeof(fsChar2b)) + 3) >> 2;
!     _FSSend(svr, (char *) str, (str_len * sizeof(fsChar2b)));
  
      /* get back the info */
      if (!_FSReply(svr, (fsReply *) & reply,
--- 82,103 ----
      req->range = range_type;
      req->num_ranges = str_len;
      req->length += ((str_len * sizeof(fsChar2b)) + 3) >> 2;
!     if (FSProtocolVersion(svr) == 1)
!     {
! 	fsChar2b_version1 *swapped_str;
! 
! 	swapped_str = (fsChar2b_version1 *)
! 	    FSmalloc(sizeof(fsChar2b_version1) * str_len);
! 	if (!swapped_str)
! 	    return FSBadAlloc;
! 	for (i = 0; i < str_len; i++) {
! 	    swapped_str[i].low = str->low;
! 	    swapped_str[i].high = str->high;
! 	}
! 	_FSSend(svr, (char *)swapped_str, (str_len*sizeof(fsChar2b_version1)));
! 	FSfree(swapped_str);
!     } else
! 	_FSSend(svr, (char *) str, (str_len * sizeof(fsChar2b)));
  
      /* get back the info */
      if (!_FSReply(svr, (fsReply *) & reply,
*** /tmp/da13098	Fri May 15 12:02:36 1992
--- fonts/lib/fs/FSQXInfo.c	Tue May 12 18:07:21 1992
***************
*** 1,6 ****
! /* $XConsortium: FSQXInfo.c,v 1.2 91/05/13 15:11:51 gildea Exp $ */
! 
! /* @(#)FSQXInfo.c	4.1	91/05/02
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
--- 1,5 ----
! /* $XConsortium: FSQXInfo.c,v 1.3 92/05/12 18:07:24 gildea Exp $ */
! /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
***************
*** 53,58 ****
--- 52,66 ----
  	return FSBadAlloc;
      }
      bcopy((char *) &reply.header, (char *) info, sizeof(fsFontHeader));
+     if (FSProtocolVersion(svr) == 1)
+     {
+ 	info->char_range.min_char.high = reply.header.char_range.min_char.low;
+ 	info->char_range.min_char.low = reply.header.char_range.min_char.high;
+ 	info->char_range.max_char.high = reply.header.char_range.max_char.low;
+ 	info->char_range.max_char.low = reply.header.char_range.max_char.high;
+ 	info->default_char.high = reply.header.default_char.low;
+ 	info->default_char.low = reply.header.default_char.high;
+     }
      /* get the prop header */
      _FSReadPad(svr, (char *) props, sizeof(fsPropInfo));
      /* prepare for prop data */
*** /tmp/da13117	Fri May 15 12:02:39 1992
--- fonts/lib/font/fc/fserve.c	Wed May 13 15:41:54 1992
***************
*** 1,6 ****
! /* $XConsortium: fserve.c,v 1.20 92/04/26 16:26:57 rws Exp $ */
  /*
-  *
   * Copyright 1990 Network Computing Devices
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
--- 1,5 ----
! /* $XConsortium: fserve.c,v 1.22 92/05/13 15:41:49 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
***************
*** 23,30 ****
   * OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
-  *
-  * $NCDId: @(#)fserve.c,v 1.19 1991/07/10 14:20:31 lemke Exp $
   */
  /*
   * font server specific font access
--- 22,27 ----
***************
*** 603,609 ****
  	return StillWorking;
      }
      /* move the data over */
!     (void) fs_convert_header(&rep.header, &bfont->pfont->info);
      if (bfont->pfont->info.terminalFont)
      {
  	bfont->format =
--- 600,606 ----
  	return StillWorking;
      }
      /* move the data over */
!     (void) fs_convert_header(conn, &rep.header, &bfont->pfont->info);
      if (bfont->pfont->info.terminalFont)
      {
  	bfont->format =
***************
*** 659,666 ****
--- 656,666 ----
      FSFpePtr    conn = (FSFpePtr) fpe->private;
      fsQueryXExtents8Reply rep;
      int         i;
+     int		numInfos;
+     Bool	haveInk = FALSE; /* need separate ink metrics? */
      CharInfoPtr ci,
                  pCI;
+     xCharInfo	teInfo;
      FSFontPtr   fsfont = (FSFontPtr) bfont->pfont->fontPrivate;
      fsCharInfo *fsci,
                 *fscip;
***************
*** 673,679 ****
  	return StillWorking;
      }
      /* move the data over */
!     ci = pCI = (CharInfoPtr) xalloc(sizeof(CharInfoRec) * rep.num_extents);
  /* XXX this could be done with an ALLOCATE_LOCAL */
      fsci = (fsCharInfo *) xalloc(sizeof(fsCharInfo) * rep.num_extents);
      if (!pCI || !fsci) {
--- 673,686 ----
  	return StillWorking;
      }
      /* move the data over */
!     /* need  separate inkMetrics for fixed font server protocol version */
!     numInfos =  rep.num_extents;
!     if (bfont->pfont->info.terminalFont && conn->fsMajorVersion > 1)
!     {
! 	numInfos *= 2;
! 	haveInk = TRUE;
!     }
!     ci = pCI = (CharInfoPtr) xalloc(sizeof(CharInfoRec) * numInfos);
  /* XXX this could be done with an ALLOCATE_LOCAL */
      fsci = (fsCharInfo *) xalloc(sizeof(fsCharInfo) * rep.num_extents);
      if (!pCI || !fsci) {
***************
*** 685,690 ****
--- 692,701 ----
  	return AllocError;
      }
      fsfont->encoding = pCI;
+     if (haveInk)
+ 	fsfont->inkMetrics = pCI + rep.num_extents;
+     else
+         fsfont->inkMetrics = pCI;
  /* XXX - hack - use real default char */
      fsfont->pDefault = &pCI[0];
  
***************
*** 693,703 ****
--- 704,731 ----
  	fs_free_font(bfont);
  	return StillWorking;
      }
+     ci = fsfont->inkMetrics;
      for (i = 0, fscip = fsci; i < rep.num_extents; i++, ci++, fscip++) {
  	fs_convert_char_info(fscip, ci);
      }
  
      xfree(fsci);
+ 
+     /* build bitmap metrics, ImageRectMax style */
+     if (haveInk)
+     {
+ 	FontInfoRec *fi = &bfont->pfont->info;
+ 
+ 	ci = fsfont->encoding;
+ 	for (i = 0; i < rep.num_extents; i++, ci++)
+ 	{
+ 	    ci->metrics.leftSideBearing = FONT_MIN_LEFT(fi);
+ 	    ci->metrics.rightSideBearing = FONT_MAX_RIGHT(fi);
+ 	    ci->metrics.ascent = FONT_MAX_ASCENT(fi);
+ 	    ci->metrics.descent = FONT_MAX_DESCENT(fi);
+ 	    ci->metrics.characterWidth = FONT_MAX_WIDTH(fi);
+ 	}
+     }
      bfont->state = FS_GLYPHS_REPLY;
  
      if (bfont->flags & FontLoadBitmaps) {
***************
*** 1505,1594 ****
      return Successful;
  }
  
- static int
- fs_send_load_extents(client, pfont, flags, nranges, range)
-     pointer     client;
-     FontPtr     pfont;
-     int         nranges;
-     fsRange    *range;
- {
-     FSBlockDataPtr blockrec;
-     FSBlockedExtentPtr blockedextent;
-     int         res;
-     fsQueryXExtents8Req req;
-     FSFontDataPtr fsd = (FSFontDataPtr) (pfont->fpePrivate);
-     FontPathElementPtr fpe = fsd->fpe;
-     FSFpePtr    conn = (FSFpePtr) fpe->private;
  
-     /* make a new block record, and add it to the end of the list */
-     blockrec = fs_new_block_rec(fpe, client, FS_LOAD_EXTENTS);
-     if (!blockrec)
- 	return AllocError;
-     blockedextent = (FSBlockedExtentPtr) blockrec->data;
-     blockedextent->pfont = pfont;
-     blockedextent->expected_ranges = range;
-     blockedextent->nranges = nranges;
-     blockedextent->done = FALSE;
- 
-     /*
-      * see if the desired extents already exist, and return Successful if they
-      * do, otherwise build up character range/character string
-      */
-     res = fs_check_extents(pfont, flags, nranges, range, blockrec);
-     if (res == AccessDone)
- 	return Successful;
- 
-     /* send the request */
-     req.reqType = FS_QueryXExtents8;
-     req.fid = ((FSFontDataPtr) pfont->fpePrivate)->fontid;
-     req.range = TRUE;
-     req.length = (sizeof(fsQueryXExtents8Req) + sizeof(fsRange) * nranges) >> 2;
-     req.num_ranges = nranges;
-     _fs_add_req_log(conn, FS_QueryXExtents8);
-     _fs_write(conn, (char *) &req, sizeof(fsQueryXExtents8Req));
-     if (nranges)
- 	_fs_write(conn, (char *) range, sizeof(fsRange) * nranges);
- 
-     return Suspended;
- }
- 
- int
- fs_load_extents(client, pfont, flags, nranges, range,
- 		nextents, extents)
-     pointer     client;
-     FontPtr     pfont;
-     int         nranges;
-     fsRange    *range;
-     unsigned long *nextents;
-     fsCharInfo **extents;
- {
-     FSBlockDataPtr blockrec;
-     FSBlockedExtentPtr blockedextent;
-     FSFpePtr    conn = (FSFpePtr) pfont->fpe->private;
- 
-     /* see if the result is already there */
-     blockrec = (FSBlockDataPtr) conn->blocked_requests;
-     while (blockrec) {
- 	if (blockrec->type == FS_LOAD_EXTENTS && blockrec->client == client) {
- 	    blockedextent = (FSBlockedExtentPtr) blockrec->data;
- 	    if (blockedextent->pfont == pfont && blockedextent->done) {
- 
- 		/* copy the data */
- 		*nextents = blockedextent->nextents;
- 		*extents = blockedextent->extents;
- 
- 		fs_remove_blockrec(conn, blockrec);
- 		return Successful;
- 	    }
- 	}
- 	blockrec = blockrec->next;
-     }
- 
-     /* didn't find waiting record, so send a new one */
-     return fs_send_load_extents(client, pfont, flags, nranges, range);
- }
- 
- 
  /*
   * almost identical to the above, but meant for FS chaining
   */
--- 1533,1539 ----
***************
*** 1651,1745 ****
  }
  
  static int
- fs_send_load_bitmaps(client, pfont, format, flags, nranges, range)
-     pointer     client;
-     FontPtr     pfont;
-     fsBitmapFormat format;
-     int         nranges;
-     fsRange    *range;
- {
-     FSBlockDataPtr blockrec;
-     FSBlockedBitmapPtr blockedbitmap;
-     int         res;
-     fsQueryXBitmaps16Req req;
-     FSFontDataPtr fsd = (FSFontDataPtr) (pfont->fpePrivate);
-     FontPathElementPtr fpe = fsd->fpe;
-     FSFpePtr    conn = (FSFpePtr) fpe->private;
- 
-     /* make a new block record, and add it to the end of the list */
-     blockrec = fs_new_block_rec(fpe, client, FS_LOAD_BITMAPS);
-     if (!blockrec)
- 	return AllocError;
-     blockedbitmap = (FSBlockedBitmapPtr) blockrec->data;
-     blockedbitmap->pfont = pfont;
-     blockedbitmap->expected_ranges = range;
-     blockedbitmap->nranges = nranges;
-     blockedbitmap->done = FALSE;
- 
-     /*
-      * see if the desired glyphs already exist, and return Successful if they
-      * do, otherwise build up character range/character string
-      */
-     res = fs_check_bitmaps(pfont, format, flags, nranges, range, blockrec);
-     if (res == AccessDone)
- 	return Successful;
- 
-     /* send the request */
-     req.reqType = FS_QueryXBitmaps16;
-     req.fid = ((FSFontDataPtr) pfont->fpePrivate)->fontid;
-     req.format = format;
-     req.range = TRUE;
-     req.length = (sizeof(fsQueryXBitmaps16Req) + sizeof(fsRange) * nranges) >> 2;
-     req.num_ranges = nranges;
-     _fs_add_req_log(conn, FS_QueryXBitmaps16);
-     _fs_write(conn, (char *) &req, sizeof(fsQueryXBitmaps16Req));
-     _fs_write(conn, (char *) range, sizeof(fsRange) * nranges);
- 
-     return Suspended;
- }
- 
- int
- fs_load_bitmaps(client, pfont, format, flags, nranges, range,
- 		size, nglyphs, offsets, gdata)
-     pointer     client;
-     FontPtr     pfont;
-     fsBitmapFormat format;
-     int         nranges;
-     fsRange    *range;
-     unsigned long *size;
-     unsigned long *nglyphs;
-     fsOffset  **offsets;
-     pointer    *gdata;
- {
-     FSBlockDataPtr blockrec;
-     FSBlockedBitmapPtr blockedbitmap;
-     FSFpePtr    conn = (FSFpePtr) pfont->fpe->private;
- 
-     /* see if the result is already there */
-     blockrec = (FSBlockDataPtr) conn->blocked_requests;
-     while (blockrec) {
- 	if (blockrec->type == FS_LOAD_BITMAPS && blockrec->client == client) {
- 	    blockedbitmap = (FSBlockedBitmapPtr) blockrec->data;
- 	    if (blockedbitmap->pfont == pfont && blockedbitmap->done) {
- 
- 		/* copy the data */
- 		*size = blockedbitmap->size;
- 		*nglyphs = blockedbitmap->nglyphs;
- 		*offsets = blockedbitmap->offsets;
- 		*gdata = blockedbitmap->gdata;
- 
- 		fs_remove_blockrec(conn, blockrec);
- 		return Successful;
- 	    }
- 	}
- 	blockrec = blockrec->next;
-     }
- 
-     /* didn't find waiting record, so send a new one */
-     return fs_send_load_bitmaps(client, pfont, format, flags, nranges, range);
- }
- 
- static int
  fs_read_list(fpe, blockrec)
      FontPathElementPtr fpe;
      FSBlockDataPtr blockrec;
--- 1596,1601 ----
***************
*** 1873,1878 ****
--- 1729,1736 ----
      return fs_send_list_fonts(client, fpe, pattern, patlen, maxnames, newnames);
  }
  
+ static int  padlength[4] = {0, 3, 2, 1};
+ 
  static int
  fs_read_list_info(fpe, blockrec)
      FontPathElementPtr fpe;
***************
*** 1885,1890 ****
--- 1743,1749 ----
      fsPropOffset *po;
      char       *name;
      pointer     pd;
+     int		err;
  
      /* clean up anything from the last trip */
      if (binfo->name)
***************
*** 1906,1911 ****
--- 1765,1774 ----
  	binfo->errcode = AllocError;
  	return AllocError;
      }
+     if (conn->fsMajorVersion > 1)
+ 	if (rep.nameLength == 0)
+ 	    goto done;
+     /* old protocol sent a full-length reply even for the last one */
      if (_fs_read(conn, (char *) &rep + sizeof(fsReplyHeader),
  	  sizeof(fsListFontsWithXInfoReply) - sizeof(fsReplyHeader)) == -1) {
  	goto done;
***************
*** 1926,1935 ****
  	binfo->errcode = AllocError;
  	return AllocError;
      }
!     if (_fs_read_pad(conn, name, rep.nameLength) == -1 ||
! 	    _fs_read_pad(conn, (char *) &pi, sizeof(fsPropInfo)) == -1) {
! 	goto done;
!     }
      po = (fsPropOffset *) xalloc(sizeof(fsPropOffset) * pi.num_offsets);
      pd = (pointer) xalloc(pi.data_len);
      if (!po || !pd) {
--- 1789,1800 ----
  	binfo->errcode = AllocError;
  	return AllocError;
      }
!     if (conn->fsMajorVersion == 1)
! 	if (_fs_read_pad(conn, name, rep.nameLength) == -1)
! 	    goto done;
!     if (_fs_read_pad(conn, (char *) &pi, sizeof(fsPropInfo)) == -1)
! 	    goto done;
! 
      po = (fsPropOffset *) xalloc(sizeof(fsPropOffset) * pi.num_offsets);
      pd = (pointer) xalloc(pi.data_len);
      if (!po || !pd) {
***************
*** 1941,1949 ****
  	binfo->errcode = AllocError;
  	return AllocError;
      }
!     if (_fs_read_pad(conn, (char *) po,
! 		     (pi.num_offsets * sizeof(fsPropOffset))) == -1 ||
! 	    _fs_read_pad(conn, (char *) pd, pi.data_len) == -1) {
  	xfree(name);
  	xfree(po);
  	xfree(pd);
--- 1806,1828 ----
  	binfo->errcode = AllocError;
  	return AllocError;
      }
!     err = _fs_read_pad(conn, (char *) po,
! 		       (pi.num_offsets * sizeof(fsPropOffset)));
!     if (err != -1)
!     {
! 	if (conn->fsMajorVersion > 1)
! 	    err = _fs_read(conn, (char *) pd, pi.data_len);
! 	else
! 	    err = _fs_read_pad(conn, (char *) pd, pi.data_len);
!     }
!     if (err != -1  &&  conn->fsMajorVersion != 1)
!     {
! 	err = _fs_read(conn, name, rep.nameLength);
! 	if (err != -1)
! 	    err = _fs_drain_bytes(conn, padlength[(pi.data_len+rep.nameLength)&3]);
!     }
! 
!     if (err == -1) {
  	xfree(name);
  	xfree(po);
  	xfree(pd);
***************
*** 1951,1957 ****
  	binfo->pfi = NULL;
  	goto done;
      }
!     if (fs_convert_lfwi_reply(binfo->pfi, &rep, &pi, po, pd) != Successful)
      {
  	xfree(name);
  	xfree(po);
--- 1830,1837 ----
  	binfo->pfi = NULL;
  	goto done;
      }
! 
!     if (fs_convert_lfwi_reply(conn, binfo->pfi, &rep, &pi, po, pd) != Successful)
      {
  	xfree(name);
  	xfree(po);
*** /tmp/da13149	Fri May 15 12:02:43 1992
--- fonts/lib/font/fc/fsconvert.c	Tue May 12 18:07:29 1992
***************
*** 1,4 ****
! /* $XConsortium: fsconvert.c,v 1.8 92/03/17 15:45:47 keith Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
--- 1,4 ----
! /* $XConsortium: fsconvert.c,v 1.9 92/05/12 18:07:31 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
***************
*** 22,32 ****
   * OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
-  *
-  *	@(#)fsconvert.c	4.2	91/05/14
-  *
-  * $NCDId: @(#)fsconvert.c,v 1.3 1991/06/10 13:21:52 lemke Exp $
-  *
   */
  /*
   * FS data conversion
--- 22,27 ----
***************
*** 59,65 ****
  }
  
  int
! fs_convert_header(hdr, pfi)
      fsFontHeader *hdr;
      FontInfoPtr pfi;
  {
--- 54,61 ----
  }
  
  int
! fs_convert_header(conn, hdr, pfi)
!     FSFpePtr    conn;
      fsFontHeader *hdr;
      FontInfoPtr pfi;
  {
***************
*** 69,80 ****
      pfi->drawDirection = (hdr->draw_direction == LeftToRightDrawDirection) ?
  	LeftToRight : RightToLeft;
      pfi->inkInside = (hdr->flags & FontInfoInkInside) != 0;
-     pfi->firstCol = hdr->char_range.min_char.low;
-     pfi->firstRow = hdr->char_range.min_char.high;
-     pfi->lastCol = hdr->char_range.max_char.low;
-     pfi->lastRow = hdr->char_range.max_char.high;
  
!     pfi->defaultCh = hdr->default_char.low + (hdr->default_char.high << 8);
  
      pfi->fontDescent = hdr->font_descent;
      pfi->fontAscent = hdr->font_ascent;
--- 65,84 ----
      pfi->drawDirection = (hdr->draw_direction == LeftToRightDrawDirection) ?
  	LeftToRight : RightToLeft;
      pfi->inkInside = (hdr->flags & FontInfoInkInside) != 0;
  
!     if (conn->fsMajorVersion > 1) {
! 	pfi->firstCol = hdr->char_range.min_char.low;
! 	pfi->firstRow = hdr->char_range.min_char.high;
! 	pfi->lastCol = hdr->char_range.max_char.low;
! 	pfi->lastRow = hdr->char_range.max_char.high;
! 	pfi->defaultCh = hdr->default_char.low + (hdr->default_char.high << 8);
!     } else {
! 	pfi->firstCol = hdr->char_range.min_char.high;
! 	pfi->firstRow = hdr->char_range.min_char.low;
! 	pfi->lastCol = hdr->char_range.max_char.high;
! 	pfi->lastRow = hdr->char_range.max_char.low;
! 	pfi->defaultCh = hdr->default_char.high + (hdr->default_char.low << 8);
!     }
  
      pfi->fontDescent = hdr->font_descent;
      pfi->fontAscent = hdr->font_ascent;
***************
*** 151,157 ****
  }
  
  int
! fs_convert_lfwi_reply(pfi, fsrep, pi, po, pd)
      FontInfoPtr pfi;
      fsListFontsWithXInfoReply *fsrep;
      fsPropInfo *pi;
--- 155,162 ----
  }
  
  int
! fs_convert_lfwi_reply(conn, pfi, fsrep, pi, po, pd)
!     FSFpePtr    conn;
      FontInfoPtr pfi;
      fsListFontsWithXInfoReply *fsrep;
      fsPropInfo *pi;
***************
*** 160,166 ****
  {
      fsFontHeader *hdr = &fsrep->header;
  
!     fs_convert_header(hdr, pfi);
      if (fs_convert_props(pi, po, pd, pfi) == -1)
  	return AllocError;
  
--- 165,171 ----
  {
      fsFontHeader *hdr = &fsrep->header;
  
!     fs_convert_header(conn, hdr, pfi);
      if (fs_convert_props(pi, po, pd, pfi) == -1)
  	return AllocError;
  
***************
*** 337,343 ****
      return Successful;
  }
  
! CharInfoRec junkDefault;
  
  static int
  _fs_get_metrics(pFont, count, chars, charEncoding, glyphCount, glyphs)
--- 342,348 ----
      return Successful;
  }
  
! static CharInfoRec junkDefault;
  
  static int
  _fs_get_metrics(pFont, count, chars, charEncoding, glyphCount, glyphs)
***************
*** 351,362 ****
      int         ret;
      FSFontPtr   fsfont;
      int         i;
! 
      fsfont = (FSFontPtr) pFont->fontPrivate;
      if (!fsfont->pDefault)
  	fsfont->pDefault = &junkDefault;
      ret = _fs_get_glyphs(pFont, count, chars, charEncoding,
  			 glyphCount, (CharInfoPtr *) glyphs);
  
      if (ret == Successful) {
  	if (fsfont->pDefault == &junkDefault) {
--- 356,373 ----
      int         ret;
      FSFontPtr   fsfont;
      int         i;
!     CharInfoPtr encoding;
!     
      fsfont = (FSFontPtr) pFont->fontPrivate;
      if (!fsfont->pDefault)
  	fsfont->pDefault = &junkDefault;
+ 
+     /* sleeze - smash the encoding so we get ink metrics */
+     encoding = fsfont->encoding;
+     fsfont->encoding = fsfont->inkMetrics;
      ret = _fs_get_glyphs(pFont, count, chars, charEncoding,
  			 glyphCount, (CharInfoPtr *) glyphs);
+     fsfont->encoding = encoding;
  
      if (ret == Successful) {
  	if (fsfont->pDefault == &junkDefault) {
***************
*** 389,400 ****
      FontPtr     pfont;
  {
      /* set font function pointers */
-     extern int  fs_load_bitmaps();
-     extern int  fs_load_extents();
- 
      pfont->get_glyphs = _fs_get_glyphs;
      pfont->get_metrics = _fs_get_metrics;
-     pfont->get_bitmaps = fs_load_bitmaps;
-     pfont->get_extents = fs_load_extents;
      pfont->unload_font = fs_unload_font;
  }
--- 400,406 ----
*** /tmp/da13168	Fri May 15 12:02:44 1992
--- fonts/lib/font/fc/fsio.c	Thu May 14 16:53:00 1992
***************
*** 1,6 ****
! /* $XConsortium: fsio.c,v 1.21 91/07/19 20:55:30 rws Exp $ */
  /*
-  *
   * Copyright 1990 Network Computing Devices
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
--- 1,5 ----
! /* $XConsortium: fsio.c,v 1.23 92/05/14 16:52:27 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
***************
*** 23,30 ****
   * OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
-  *
-  * $NCDId: @(#)fsio.c,v 1.7 1991/07/02 13:13:43 lemke Exp $
   */
  /*
   * font server i/o routines
--- 22,27 ----
***************
*** 213,220 ****
      conn->fs_fd = _fs_connect(servername, 5);
      if (conn->fs_fd < 0)
  	return FALSE;
-     conn->servername = (char *) xalloc(strlen(servername) + 1);
-     strcpy(conn->servername, servername);
  
      conn->generation = ++generationCount;
  
--- 210,215 ----
***************
*** 239,244 ****
--- 234,243 ----
      if (_fs_read(conn, (char *) &rep, sizeof(fsConnSetup)) == -1)
  	return FALSE;
  
+     conn->fsMajorVersion = rep.major_version;
+     if (rep.major_version > FS_PROTOCOL)
+ 	return FALSE;
+ 
      alts = 0;
      /* parse alternate list */
      if (nalts = rep.num_alternates) {
***************
*** 308,313 ****
--- 307,317 ----
      xfree(auth_data);
      xfree(vendor_string);
  
+     conn->servername = (char *) xalloc(strlen(servername) + 1);
+     if (conn->servername == NULL)
+ 	return FALSE;
+     strcpy(conn->servername, servername);
+ 
      return TRUE;
  }
  
***************
*** 392,397 ****
--- 396,402 ----
  		errno = EPIPE;
  		return -1;
  	    }
+ 	    errno = 0;
  	} else if (errno == EINTR) {
  	    continue;
  	} else {		/* something bad happened */
*** /tmp/da13187	Fri May 15 12:02:46 1992
--- fonts/lib/font/fc/fservestr.h	Tue May 12 18:07:33 1992
***************
*** 1,4 ****
! /* $XConsortium: fservestr.h,v 1.6 91/06/21 18:15:45 keith Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
--- 1,4 ----
! /* $XConsortium: fservestr.h,v 1.7 92/05/12 18:07:36 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
***************
*** 22,29 ****
   * OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
-  *
-  * $NCDId: @(#)fservestr.h,v 1.2 1991/05/24 15:03:06 lemke Exp $
   */
  
  #ifndef _FSERVESTR_H_
--- 22,27 ----
***************
*** 48,53 ****
--- 46,52 ----
  typedef struct _fs_font {
      CharInfoPtr pDefault;
      CharInfoPtr encoding;
+     CharInfoPtr inkMetrics;	/* pointer to bitmap unused */
      pointer     bitmaps;
  }           FSFontRec, *FSFontPtr;
  
*** /tmp/da13206	Fri May 15 12:02:48 1992
--- fonts/lib/font/fc/fsio.h	Tue May 12 18:07:35 1992
***************
*** 1,4 ****
! /* $XConsortium: fsio.h,v 1.9 91/07/18 22:40:50 keith Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
--- 1,4 ----
! /* $XConsortium: fsio.h,v 1.10 92/05/12 18:07:38 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
***************
*** 22,29 ****
   * OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
-  *
-  * $NCDId: @(#)fsio.h,v 1.4 1991/07/03 17:52:30 lemke Exp $
   */
  
  #ifndef	_FSIO_H_
--- 22,27 ----
***************
*** 56,61 ****
--- 54,60 ----
  
      int         generation;
      int         numAlts;
+     int		fsMajorVersion; /* font server major version number */
      FSFpeAltPtr alts;
  
      FSClientPtr	clients;
*** /tmp/da13225	Fri May 15 12:02:49 1992
--- fonts/lib/font/bitmap/bdfread.c	Tue May 12 18:07:39 1992
***************
*** 22,28 ****
  
  ************************************************************************/
  
! /* $XConsortium: bdfread.c,v 1.12 92/04/16 09:20:54 gildea Exp $ */
  
  #include <ctype.h>
  #include "fontfilest.h"
--- 22,28 ----
  
  ************************************************************************/
  
! /* $XConsortium: bdfread.c,v 1.13 92/05/12 18:07:40 gildea Exp $ */
  
  #include <ctype.h>
  #include "fontfilest.h"
***************
*** 808,815 ****
      if (state.weightProp && (state.weightProp->value == -1))
  	state.weightProp->value = bitmapComputeWeight(pFont);
  
-     pFont->get_bitmaps = bitmapGetBitmaps;
-     pFont->get_extents = bitmapGetExtents;
      pFont->get_glyphs = bitmapGetGlyphs;
      pFont->get_metrics = bitmapGetMetrics;
      pFont->unload_font = bdfUnloadFont;
--- 808,813 ----
*** /tmp/da13244	Fri May 15 12:02:52 1992
--- fonts/lib/font/bitmap/bitscale.c	Tue May 12 18:07:41 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: bitscale.c,v 1.10 92/03/20 14:34:06 keith Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: bitscale.c,v 1.11 92/05/12 18:07:44 gildea Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
***************
*** 434,441 ****
      pf->glyph = opf->glyph;
      pf->scan = opf->scan;
  
-     pf->get_bitmaps = bitmapGetBitmaps;
-     pf->get_extents = bitmapGetExtents;
      pf->get_glyphs = bitmapGetGlyphs;
      pf->get_metrics = bitmapGetMetrics;
      pf->unload_font = bitmapUnloadScalable;
--- 434,439 ----
***************
*** 479,486 ****
      pfi->anamorphic = FALSE;
      if (heightMult != widthMult)
  	pfi->anamorphic = TRUE;
!     pfi->fontDescent *= heightMult;
!     pfi->fontAscent *= heightMult;
      pfi->minbounds.leftSideBearing = MAXSHORT;
      pfi->minbounds.rightSideBearing = MAXSHORT;
      pfi->minbounds.ascent = MAXSHORT;
--- 477,487 ----
      pfi->anamorphic = FALSE;
      if (heightMult != widthMult)
  	pfi->anamorphic = TRUE;
! 
!     newHeight = (opfi->fontAscent + opfi->fontDescent) * heightMult;
!     pfi->fontAscent = opfi->fontAscent * heightMult;
!     pfi->fontDescent = newHeight - pfi->fontAscent;
! 
      pfi->minbounds.leftSideBearing = MAXSHORT;
      pfi->minbounds.rightSideBearing = MAXSHORT;
      pfi->minbounds.ascent = MAXSHORT;
***************
*** 616,621 ****
--- 617,623 ----
  	    	glyphBytes += BYTES_FOR_GLYPH(pci, glyph);
  	    }
      	}
+ 	FontComputeInfoAccelerators (pfi);
      	xfree(scratch);
      }
  
***************
*** 728,735 ****
      if (pink) {
  	pink->leftSideBearing = MAXSHORT;
  	pink->rightSideBearing = MINSHORT;
! 	pink->ascent = 0;
! 	pink->descent = 0;
  	pink->characterWidth = pci->metrics.characterWidth;
  	pink->attributes = pci->metrics.attributes;
      }
--- 730,737 ----
      if (pink) {
  	pink->leftSideBearing = MAXSHORT;
  	pink->rightSideBearing = MINSHORT;
! 	pink->ascent = MINSHORT;
! 	pink->descent = MINSHORT;
  	pink->characterWidth = pci->metrics.characterWidth;
  	pink->attributes = pci->metrics.attributes;
      }
***************
*** 851,866 ****
  		if (newHeight >= pink->ascent)
  		    pink->ascent = newHeight;
  		pink->descent = newHeight;
  	    }
- 	    newBit = pci->metrics.leftSideBearing + newWidth - newBit - 1;
- 	    if (newBit < pink->leftSideBearing)
- 		pink->leftSideBearing = newBit;
  	    for (acc = scratch + newWidth, newBit = newWidth;
  		    --newBit >= 0 && *--acc >= 0;
  		);
! 	    newBit = pci->metrics.leftSideBearing + newBit + 1;
! 	    if (newBit > pink->rightSideBearing)
! 		pink->rightSideBearing = newBit;
  	}
      }
  #define MINMAX(field) \
--- 853,871 ----
  		if (newHeight >= pink->ascent)
  		    pink->ascent = newHeight;
  		pink->descent = newHeight;
+ 		newBit = pci->metrics.leftSideBearing + newWidth - newBit - 1;
+ 		if (newBit < pink->leftSideBearing)
+ 		    pink->leftSideBearing = newBit;
  	    }
  	    for (acc = scratch + newWidth, newBit = newWidth;
  		    --newBit >= 0 && *--acc >= 0;
  		);
! 	    if (newBit >= 0)
! 	    {
! 	    	newBit = pci->metrics.leftSideBearing + newBit + 1;
! 	    	if (newBit > pink->rightSideBearing)
! 		    pink->rightSideBearing = newBit;
! 	    }
  	}
      }
  #define MINMAX(field) \
***************
*** 870,875 ****
--- 875,889 ----
  	pFont->info.ink_maxbounds.field = pink->field
  
      if (pink) {
+ 	if (pink->ascent == MINSHORT)
+ 	{
+ 	    /* hack to make computation below work */
+ 	    pink->ascent = pci->metrics.descent;
+ 	    /* these would also have not been set as this character is empty */
+ 	    pink->descent = pink->ascent + 1;
+ 	    pink->leftSideBearing = 0;
+ 	    pink->rightSideBearing = 0;
+ 	}
  	height = pink->ascent - pink->descent + 1;
  	pink->ascent = pci->metrics.ascent -
  	    (GLYPHHEIGHTPIXELS(pci) - pink->ascent);
*** /tmp/da13263	Fri May 15 12:02:53 1992
--- fonts/lib/font/bitmap/pcfread.c	Tue May 12 18:07:44 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: pcfread.c,v 1.9 92/03/20 14:34:37 keith Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: pcfread.c,v 1.10 92/05/12 18:07:47 gildea Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
***************
*** 558,565 ****
      }
      bitmapFont->bitmapExtra = (BitmapExtraPtr) 0;
      pFont->fontPrivate = (pointer) bitmapFont;
-     pFont->get_bitmaps = bitmapGetBitmaps;
-     pFont->get_extents = bitmapGetExtents;
      pFont->get_glyphs = bitmapGetGlyphs;
      pFont->get_metrics = bitmapGetMetrics;
      pFont->unload_font = pcfUnloadFont;
--- 558,563 ----
*** /tmp/da13282	Fri May 15 12:02:56 1992
--- fonts/lib/font/bitmap/snfread.c	Tue May 12 18:07:46 1992
***************
*** 22,28 ****
  
  ************************************************************************/
  
! /* $XConsortium: snfread.c,v 1.10 91/07/22 22:59:00 keith Exp $ */
  
  #include <ctype.h>
  #include "fontfilest.h"
--- 22,28 ----
  
  ************************************************************************/
  
! /* $XConsortium: snfread.c,v 1.11 92/05/12 18:07:49 gildea Exp $ */
  
  #include <ctype.h>
  #include "fontfilest.h"
***************
*** 358,365 ****
      }
      bitmapFont->bitmapExtra = (BitmapExtraPtr) 0;
      pFont->fontPrivate = (pointer) bitmapFont;
-     pFont->get_bitmaps = bitmapGetBitmaps;
-     pFont->get_extents = bitmapGetExtents;
      pFont->get_glyphs = bitmapGetGlyphs;
      pFont->get_metrics = bitmapGetMetrics;
      pFont->unload_font = snfUnloadFont;
--- 358,363 ----
*** /tmp/da13301	Fri May 15 12:02:57 1992
--- fonts/lib/font/bitmap/Imakefile	Wed May 13 14:13:17 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.5 91/07/22 22:20:44 rws Exp $
  #include <Server.tmpl>
  
          INCLUDES = -I$(FONTSRC)/include -I../include -I$(FONTSERVERSRC)/include
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.6 92/05/13 14:12:15 gildea Exp $
  #include <Server.tmpl>
  
          INCLUDES = -I$(FONTSRC)/include -I../include -I$(FONTSERVERSRC)/include
***************
*** 7,17 ****
       FORMAT_DEFS = FontFormatDefines
  #endif
              SRCS = bdfread.c bdfutils.c bitmap.c bitmaputils.c bitscale.c \
! 		   bitmapfuncs.c fsfuncs.c pcfread.c pcfwrite.c snfread.c \
  		   fontink.c
  
              OBJS = bdfread.o bdfutils.o bitmap.o bitmaputils.o bitscale.o \
! 		   bitmapfuncs.o fsfuncs.o pcfread.o pcfwrite.o snfread.o \
  		   fontink.o
  
  SubdirLibraryRule($(OBJS))
--- 7,17 ----
       FORMAT_DEFS = FontFormatDefines
  #endif
              SRCS = bdfread.c bdfutils.c bitmap.c bitmaputils.c bitscale.c \
! 		   bitmapfuncs.c pcfread.c pcfwrite.c snfread.c \
  		   fontink.c
  
              OBJS = bdfread.o bdfutils.o bitmap.o bitmaputils.o bitscale.o \
! 		   bitmapfuncs.o pcfread.o pcfwrite.o snfread.o \
  		   fontink.o
  
  SubdirLibraryRule($(OBJS))
*** /tmp/da13320	Fri May 15 12:02:59 1992
--- fonts/lib/font/Speedo/spglyph.c	Wed May 13 16:03:34 1992
***************
*** 1,4 ****
! /* $XConsortium: spglyph.c,v 1.11 92/04/15 16:12:09 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: spglyph.c,v 1.12 92/05/13 16:03:30 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 292,297 ****
--- 292,301 ----
      ret = CheckFSFormat(format, fmask,
  			&bit_order, &byte_order, &scan, &glyph, &image);
  
+     pfont->bit = bit_order;
+     pfont->byte = byte_order;
+     pfont->glyph = glyph;
+     pfont->scan = scan;
      if (ret != Successful)
  	return BadFontFormat;
  
*** /tmp/da13339	Fri May 15 12:03:01 1992
--- fonts/lib/font/Speedo/spfont.c	Tue May 12 18:07:49 1992
***************
*** 1,4 ****
! /* $XConsortium: spfont.c,v 1.15 92/04/15 14:37:12 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: spfont.c,v 1.16 92/05/12 18:07:52 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 44,52 ****
  
  extern void SpeedoCloseFont();
  static int  get_sp_glyphs(),
!             get_sp_bitmaps(),
!             get_sp_metrics(),
!             get_sp_extents();
  static int load_sp_font();
  
  static CharInfoRec junkDefault;
--- 44,50 ----
  
  extern void SpeedoCloseFont();
  static int  get_sp_glyphs(),
!             get_sp_metrics();
  static int load_sp_font();
  
  static CharInfoRec junkDefault;
***************
*** 66,452 ****
      dst->attributes = 0;
  }
  
- /* XXX -- may have to add in some work for setting default metrics values */
- 
- /* ARGSUSED */
  static int
- get_sp_extents(client, pfont, flags, num_ranges, range, num_extents, data)
-     pointer     client;
-     FontPtr     pfont;
-     Mask        flags;
-     unsigned long num_ranges;
-     fsRange    *range;
-     unsigned long *num_extents;
-     fsCharInfo **data;
- {
-     int         start,
-                 end,
-                 i,
-                 j;
-     unsigned long size;
-     fsCharInfo *ci,
-                *pci;
-     fsRange    *rp;
-     FontInfoPtr pinfo;
-     SpeedoFontPtr spf;
-     SpeedoMasterFontPtr master;
-     CharInfoRec src;
-     int		firstChar;
- 
-     assert(pfont);
-     pinfo = &pfont->info;
-     spf = (SpeedoFontPtr) pfont->fontPrivate;
-     master = spf->master;
- 
-     firstChar = master->first_char_id;
-     if (flags & LoadAll) {
- 	start = master->first_char_id;
- 	end = master->max_id;
- 
- 	*num_extents = end - start + 1;
- 	size = sizeof(fsCharInfo) * (*num_extents);
- 	pci = ci = (fsCharInfo *) xalloc(size);
- 	if (!ci)
- 	    return AllocError;
- 
- 	/* copy all the extents */
- 	for (i = start; i <= end; i++) {
- 	    src = spf->encoding[i - firstChar];
- 	    CopyCharInfo(&src, pci);
- 	    pci++;
- 	}
- 
- 	/* make sure it didn't go off the end */
- 	assert(pci == (fsCharInfo *) ((char *) ci + size));
- 	assert(pci == (ci + (end - start + 1)));
- 
- 	*data = ci;
- 	return Successful;
-     }
-     /* normal case */
-     /* figure out how big everything has to be */
-     *num_extents = 0;
-     for (i = 0, rp = range; i < num_ranges; i++, rp++) {
- 	start = (rp->min_char.high << 8) + rp->min_char.low;
- 	end = (rp->max_char.high << 8) + rp->max_char.low;
- 
- 	/* range check */
- 	if (end < start ||
- 		(end > (pinfo->lastRow << 8) + pinfo->lastCol)
- 		|| (end < (pinfo->firstRow << 8) + pinfo->firstCol)
- 		|| (start > (pinfo->lastRow << 8) + pinfo->lastCol)
- 		|| (start < (pinfo->firstRow << 8) + pinfo->firstCol))
- 	    return BadCharRange;
- 
- 	*num_extents += end - start + 1;
-     }
- 
-     size = sizeof(fsCharInfo) * (*num_extents);
-     pci = ci = (fsCharInfo *) xalloc(size);
-     if (!ci)
- 	return AllocError;
- 
-     /* copy all the extents */
-     for (i = 0, rp = range; i < num_ranges; i++, rp++) {
- 	start = (rp->min_char.high << 8) + rp->min_char.low;
- 	end = (rp->max_char.high << 8) + rp->max_char.low;
- 
- 	/* copy all the extents */
- 	for (j = start; j <= end; j++) {
- 	    src = spf->encoding[j - firstChar];
- 	    CopyCharInfo(&src, pci);
- 	    pci++;
- 	}
- 
- 	/* make sure it didn't go off the end */
- 	assert(pci == (fsCharInfo *) ((char *) ci + size));
- 	assert(pci == (ci + (end - start + 1)));
-     }
- 
-     *data = ci;
- 
-     return Successful;
- }
- 
- /*
-  * packs up the glyphs as requested by the format
-  */
- 
- static int
- pack_sp_glyphs(pfont, format, flags, num_ranges, range, tsize, num_glyphs,
- 	       offsets, data, freeData)
-     FontPtr     pfont;
-     int         format;
-     Mask        flags;
-     unsigned long num_ranges;
-     fsRange    *range;
-     unsigned long *tsize;
-     unsigned long *num_glyphs;
-     fsOffset  **offsets;
-     pointer    *data;
-     int		*freeData;
- {
-     unsigned long start,
-                 end;
-     int         i;
-     fsOffset   *lengths = (fsOffset *) 0,
-                *l;
-     unsigned long size = 0;
-     pointer     gdata,
-                 gd;
-     unsigned long ch;
-     int         bitorder,
-                 byteorder,
-                 scanlinepad,
-                 scanlineunit,
-                 mappad;
-     int         bpr,
-                 skiprows = 0;
-     fsRange    *rp;
-     FontInfoPtr pinfo = &pfont->info;
-     SpeedoFontPtr spf = (SpeedoFontPtr) pfont->fontPrivate;
-     SpeedoMasterFontPtr master = spf->master;
-     int         err;
-     int         src_glyph_pad;
-     int         src_bit_order;
-     int         src_byte_order;
-     int		firstChar;
-     int         max_ascent, max_descent;
-     int         min_left, max_right;
- 	
-     err = CheckFSFormat(format, (fsBitmapFormatMask) ~ 0,
- 		&bitorder, &byteorder, &scanlineunit, &scanlinepad, &mappad);
-     if (err != Successful)
- 	return err;
-     (void) CheckFSFormat(pfont->format, (fsBitmapFormatMask) ~ 0,
- 		&src_bit_order, &src_byte_order, &err, &src_glyph_pad, &err);
- 
-     if (!spf->pDefault)
- 	spf->pDefault = &junkDefault;
- 
-     *freeData = TRUE;
-     firstChar = master->first_char_id;
-     /* special case for all glyphs first */
-     if (flags & LoadAll) {
- 	start = master->first_char_id;
- 	end = master->max_id;
- 	*num_glyphs = end - start + 1;
- 	size = compute_sp_data_size(pfont, mappad, scanlinepad, start, end);;
- 	num_ranges = 1;
-     } else {
- 	*num_glyphs = 0;
- 	for (i = 0, rp = range; i < num_ranges; i++, rp++) {
- 	    start = (rp->min_char.high << 8) + rp->min_char.low;
- 	    end = (rp->max_char.high << 8) + rp->max_char.low;
- 
- 	    /* range check */
- 	    if (end < start ||
- 		    (end > (pinfo->lastRow << 8) + pinfo->lastCol)
- 		    || (end < (pinfo->firstRow << 8) + pinfo->firstCol)
- 		    || (start > (pinfo->lastRow << 8) + pinfo->lastCol)
- 		    || (start < (pinfo->firstRow << 8) + pinfo->firstCol))
- 		return BadCharRange;
- 
- 	    *num_glyphs += end - start + 1;
- 	    size += compute_sp_data_size(pfont, mappad, scanlinepad, start, end);
- 	}
-     }
- 
-     gd = gdata = (pointer) xalloc(size);
-     if (!gdata)
- 	return AllocError;
-     if (mappad == BitmapFormatImageRectMax)
- 	bzero((char *) gdata, size);
- 
-     /* get space for glyph offsets */
-     l = lengths = (fsOffset *) xalloc(sizeof(fsOffset) *
- 				      *num_glyphs);
-     if (!lengths) {
- 	xfree((char *) gdata);
- 	return AllocError;
-     }
-     /* compute bpr for padded out fonts */
-     switch (mappad)
-     {
-     case BitmapFormatImageRectMax:
- 	max_ascent = FONT_MAX_ASCENT(pinfo);
- 	max_descent = FONT_MAX_DESCENT(pinfo);
- 	/* fall through */
-     case BitmapFormatImageRectMaxWidth:
- 	min_left = FONT_MIN_LEFT(pinfo);
- 	max_right = FONT_MAX_RIGHT(pinfo);
- 	bpr = GLWIDTHBYTESPADDED(max_right - min_left, scanlinepad);
- 	break;
-     case BitmapFormatImageRectMin:
- 	break;
-     }
-     /* finally do the work */
-     for (i = 0, rp = range; i < num_ranges; i++, rp++) {
- 	/*
- 	 * compute start & end.  if all_glyphs is set, we still have them
- 	 * laying around
- 	 */
- 	if (!(flags & LoadAll)) {
- 	    start = (rp->min_char.high << 8) + rp->min_char.low;
- 	    end = (rp->max_char.high << 8) + rp->max_char.low;
- 	}
- 	for (ch = start; ch <= end; ch++) {
- 	    CharInfoPtr ci;
- 	    xCharInfo  *cim;
- 	    int         srcbpr;
- 	    unsigned char	*src, *dst;
- 	    unsigned int	bits1, bits2;
- 	    int         r,
- 			lshift = 0,
- 			rshift = 0,
- 			width,
- 			w,
- 			src_extra,
- 			dst_extra;
- 
- 	    l->position = gd - gdata;
- 	    ci = &spf->encoding[ch - firstChar];
- 
- 	    /* ignore missing chars */
- 	    if (!ci) 
- 	    {
- 		l->length = 0;
- 		l++;
- 		continue;
- 	    }
- 
- 	    cim = &ci->metrics;
- 
- 	    /* sanity check */
- 	    assert((cim->rightSideBearing - cim->leftSideBearing) <= (pinfo->maxbounds.rightSideBearing - pinfo->minbounds.leftSideBearing));
- 
- 	    srcbpr = GLWIDTHBYTESPADDED(cim->rightSideBearing -
- 					cim->leftSideBearing, src_glyph_pad);
- 
- 
- 	    /*
- 	     * caculate bytes-per-row for PadNone (others done in allocation
- 	     * phase), what (if anything) to ignore or add as padding
- 	     */
- 	    switch (mappad) {
- 	    case BitmapFormatImageRectMin:
- 		bpr = GLYPH_SIZE(ci, scanlinepad);
- 		break;
- 	    case BitmapFormatImageRectMax:
- 		/* leave the first padded rows blank */
- 		gd += bpr * (max_ascent - cim->ascent);
- 		skiprows = bpr * (max_descent - cim->descent);
- 		/* fall thru */
- 	    case BitmapFormatImageRectMaxWidth:
- 		rshift = cim->leftSideBearing - min_left;
- 		lshift = 8 - lshift;
- 		break;
- 	    }
- 	    src = (unsigned char *) ci->bits;
- 	    dst = gd;
- 
- 	    width = srcbpr;
- 	    if (srcbpr > bpr)
- 		width = bpr;
- 	    src_extra = srcbpr - width;
- 	    dst_extra = bpr - width;
- 
- #if (DEFAULTBITORDER == MSBFirst)
- #define BitLeft(b,c)	((b) << (c))
- #define BitRight(b,c)	((b) >> (c))
- #else
- #define BitLeft(b,c)	((b) >> (c))
- #define BitRight(b,c)	((b) << (c))
- #endif
- 
- 	    if (!rshift)
- 	    {
- 		if (srcbpr == bpr)
- 		{
- 		    r = (cim->ascent + cim->descent) * width;
- 		    bcopy (src, dst, r);
- 		    dst += r;
- 		}
- 		else
- 		{
- 		    for (r = cim->ascent + cim->descent; r; r--)
- 		    {
- 			for (w = width; w; w--)
- 			    *dst++ = *src++;
- 			dst += dst_extra;
- 			src += src_extra;
- 		    }
- 		}
- 	    }
- 	    else
- 	    {
- 		for (r = cim->ascent + cim->descent; r; r--)
- 		{
- 		    bits2 = 0;
- 		    for (w = width; w; w--)
- 		    {
- 			bits1 = *src++;
- 			*dst++ = BitRight(bits1, rshift) |
- 				 BitLeft (bits2, lshift);
- 			bits2 = bits1;
- 		    }
- 		    dst += dst_extra;
- 		    src += src_extra;
- 		}
- 	    }
- 	    dst += skiprows;
- 	    l->length = dst - gd;
- 	    gd = dst;
- 	    l++;
- 	}
-     }
- 
- 
-     bitorder = (bitorder == BitmapFormatBitOrderLSB) ?
- 	LSBFirst : MSBFirst;
-     byteorder = (byteorder == BitmapFormatByteOrderLSB) ?
- 	LSBFirst : MSBFirst;
- 
-     /* now do the bit, byte, word swapping */
-     if (bitorder != src_bit_order)
- 	BitOrderInvert(gdata, size);
-     if (byteorder != src_byte_order) {
- 	if (scanlineunit == 2)
- 	    TwoByteSwap(gdata, size);
- 	else if (scanlineunit == 4)
- 	    FourByteSwap(gdata, size);
-     }
-     *data = gdata;
-     *tsize = size;
-     *offsets = lengths;
- 
-     return Successful;
- }
- 
- /* ARGSUSED */
- static int
- get_sp_bitmaps(client, pfont, format, flags, num_ranges, range,
- 	       size, num_glyphs, offsets, data, freeData)
-     pointer     client;
-     FontPtr     pfont;
-     fsBitmapFormat format;
-     Mask        flags;
-     unsigned long num_ranges;
-     fsRange    *range;
-     unsigned long *size;
-     unsigned long *num_glyphs;
-     fsOffset  **offsets;
-     pointer    *data;
-     int		*freeData;
- {
-     *size = 0;
-     *data = (pointer) 0;
-     *num_glyphs = 0;
-     return pack_sp_glyphs(pfont, format, flags,
- 		  num_ranges, range, size, num_glyphs, offsets, data, freeData);
- }
- 
- static int
  get_sp_glyphs(pFont, count, chars, charEncoding, glyphCount, glyphs)
      FontPtr     pFont;
      unsigned long count;
--- 64,70 ----
***************
*** 769,778 ****
  
      pfont->format = format;
  
-     pfont->get_bitmaps = get_sp_bitmaps;
      pfont->get_metrics = get_sp_metrics;
      pfont->get_glyphs = get_sp_glyphs;
-     pfont->get_extents = get_sp_extents;
      pfont->unload_font = SpeedoCloseFont;
      pfont->refcnt = 0;
      pfont->maxPrivate = -1;
--- 387,394 ----
