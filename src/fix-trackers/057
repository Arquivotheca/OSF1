Path: news.crl.dec.com!hollie.rdg.dec.com!decvax.dec.com!pa.dec.com!nobody
Message-Id: <9112202353.AA03812@rsx.lcs.mit.edu>
To: fix-trackers@expo.lcs.mit.edu
Subject: (seq: 2280) close XBUG #4816: ibmddx: faster FillRect and CopyArea (Part 2/3)
Date: Fri, 20 Dec 91 18:53:53 -0500
From: Eng-Shien Wu <eswu@expo.lcs.mit.edu>
Distribution: dec
X-Mailing-List: fix-trackers@expo.lcs.mit.edu
X-Disclaimer: This message originated from a mailing list outside of Digital.
Newsgroups: dec.mail.lists.x.fix-trackers
Approved: news@usenet.pa.dec.com


[Part 2/3]

	Subject: ibmddx: faster FillRect and CopyArea
	### bug number:   4816
	### area:         ibmddx
	### severity:     enhancement
	### comments:     

Code cleanup and performance enhancements for
skyway adapter on IBM RISC System/6000.

Note: cut portion should be 2351 lines (wc -l).

---------------------------------------------------------------------------
*** /tmp/,RCSt1KQoDFW	Wed Dec 11 21:42:15 1991
--- server/ddx/ibm/skyway/skyInfo.c	Wed Dec 11 21:31:44 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: skyInfo.c,v 1.3 91/07/16 13:15:33 jap Exp $
   *
   * Copyright IBM Corporation 1987,1988,1989,1990,1991
   *
--- 1,5 ----
  /*
!  * $XConsortium: skyInfo.c,v 1.4 91/12/11 21:25:09 eswu Exp $
   *
   * Copyright IBM Corporation 1987,1988,1989,1990,1991
   *
***************
*** 45,55 ****
  
  PixmapFormatRec skyPixmapFormats[]= { { 8, 8, 32 } };
  
! ibmPerScreenInfo skywayScreenInfoStruct = {
! 	{ 0, 0, SKYWAY_WIDTH - 1, SKYWAY_HEIGHT - 1 },
  	1,
  	skyPixmapFormats,       /* pixmap formats */
! 	skyScreenIO,
  	skyProbe,
  	skyRemoveCursor,    /*(*ibm_HideCursor)()*/
  	"-colorgda",
--- 45,56 ----
  
  PixmapFormatRec skyPixmapFormats[]= { { 8, 8, 32 } };
  
! ibmPerScreenInfo skywayScreenInfoStruct =
! {
! 	{ 0, 0, SKY_WIDTH - 1, SKY_HEIGHT - 1 },
  	1,
  	skyPixmapFormats,       /* pixmap formats */
! 	skyScreenInit,
  	skyProbe,
  	skyRemoveCursor,    /*(*ibm_HideCursor)()*/
  	"-colorgda",
*** /tmp/,RCSt1KRoCAI	Wed Dec 11 21:42:17 1991
--- server/ddx/ibm/skyway/skyProbe.c	Wed Dec 11 21:31:44 1991
***************
*** 1,32 ****
  /*
!  * $XConsortium: skyProbe.c,v 1.2 91/07/16 13:15:46 jap Exp $
   *
!  * Copyright IBM Corporation 1987,1988,1989,1990,1991
   *
!  * All Rights Reserved
   *
   * License to use, copy, modify, and distribute this software and its
!  * documentation for any purpose and without fee is hereby granted,
!  * provided that the above copyright notice appear in all copies and that
!  * both that copyright notice and this permission notice appear in
!  * supporting documentation, and that the name of IBM not be
!  * used in advertising or publicity pertaining to distribution of the
!  * software without specific, written prior permission.
   *
!  * IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
!  * ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS, AND 
!  * NONINFRINGEMENT OF THIRD PARTY RIGHTS, IN NO EVENT SHALL
!  * IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
!  * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
!  * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
!  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
!  * SOFTWARE.
   *
! */
  
  /*
!  *  skyProbe.c - probe for display
!  *               copied from ibm/GAI/gaiOsd.c
   */
  
  #include "OSio.h"
--- 1,30 ----
  /*
!  * $XConsortium: skyProbe.c,v 1.3 91/12/11 21:25:30 eswu Exp $ 
   *
!  * Copyright IBM Corporation 1987,1988,1989,1990,1991 
   *
!  * All Rights Reserved 
   *
   * License to use, copy, modify, and distribute this software and its
!  * documentation for any purpose and without fee is hereby granted, provided
!  * that the above copyright notice appear in all copies and that both that
!  * copyright notice and this permission notice appear in supporting
!  * documentation, and that the name of IBM not be used in advertising or
!  * publicity pertaining to distribution of the software without specific,
!  * written prior permission. 
   *
!  * IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
!  * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS, AND NONINFRINGEMENT OF
!  * THIRD PARTY RIGHTS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,
!  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
!  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
!  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
!  * PERFORMANCE OF THIS SOFTWARE. 
   *
!  */
  
  /*
!  * skyProbe.c - probe for display copied from ibm/GAI/gaiOsd.c 
   */
  
  #include "OSio.h"
***************
*** 36,84 ****
  #include "ibmTrace.h"
  
  extern unsigned hftQueryCurrentDevice();
! extern void ibmInfoMsg() ;
! extern int hftQFD;
  
  /* adapter number */
  
! /* put this in          */
! /* #include "X_msg.h"        */
! /*      aixErrMsg(M_MSG_9); */
  
  int
  skyProbe(atype, anumber)
! 	/* adapter type (like HFT_SKYWAY_ID) */
!     unsigned  atype;
! 	/* adapter number */
!     int  anumber;
  {
!     unsigned int  devid;
!     int  fd;
  
!     TRACE(("skyProbe(atype=0x%x, anumber=%d)\n", atype, anumber)) ;
  
! /**** added so that console can be used in debugging ****/
!     AIXDefaultDisplay= HFT_SKYWAY_ID;
!     TRACE(("AIXDefaultDisplay is %x\n",AIXDefaultDisplay)) ;
! /********************************************************/
  
!     if ( (devid=hftHasAnAttachedNumber(atype,anumber)) ) {
  	ibmInfoMsg("Found an IBM Graphics Adapter \n");
  
! 	TRACE(("found Adp 0x%x number %d\n",devid, (devid & HFT_DEVNUM_MASK)));
  
! 	if( (fd=hftOpenOnDevice(devid)) < 0 ){
  	    ibmInfoMsg("Couldn't open a HFTVT on an IBM Graphics Adapter\n");
  	    return -1;
  	}
  	hftSetQFDOrNoHotkey(fd);
! 	if( hftQFD == fd ){
! 	    AIXDefaultDisplay= devid;
! 	    TRACE(("AIXDefaultDisplay is %x\n",AIXDefaultDisplay)) ;
  	}
  	return fd;
      }
!     else  {
  	ibmInfoMsg("Didn't find an IBM Graphics Adapter\n");
  	return -1;
      }
--- 34,86 ----
  #include "ibmTrace.h"
  
  extern unsigned hftQueryCurrentDevice();
! extern void
!                 ibmInfoMsg();
! extern int      hftQFD;
  
  /* adapter number */
  
! /* put this in         */
! /* #include "X_msg.h"  */
! /* aixErrMsg(M_MSG_9); */
  
  int
  skyProbe(atype, anumber)
!     unsigned        atype;	/* adapter type (like HFT_SKYWAY_ID) */
!     int             anumber;	/* adapter number */
  {
!     unsigned int    devid;
!     int             fd;
  
!     TRACE(("skyProbe(atype=0x%x, anumber=%d)\n", atype, anumber));
  
!     /**** added so that console can be used in debugging ****/
!     AIXDefaultDisplay = HFT_SKYWAY_ID;
!     TRACE(("AIXDefaultDisplay is %x\n", AIXDefaultDisplay));
!     /********************************************************/
  
!     if ((devid = hftHasAnAttachedNumber(atype, anumber)))
!     {
  	ibmInfoMsg("Found an IBM Graphics Adapter \n");
  
! 	TRACE(("found Adp 0x%x number %d\n",
! 	       devid, (devid & HFT_DEVNUM_MASK)));
  
! 	if ((fd = hftOpenOnDevice(devid)) < 0)
! 	{
  	    ibmInfoMsg("Couldn't open a HFTVT on an IBM Graphics Adapter\n");
  	    return -1;
  	}
  	hftSetQFDOrNoHotkey(fd);
! 	if (hftQFD == fd)
! 	{
! 	    AIXDefaultDisplay = devid;
! 	    TRACE(("AIXDefaultDisplay is %x\n", AIXDefaultDisplay));
  	}
  	return fd;
      }
!     else
!     {
  	ibmInfoMsg("Didn't find an IBM Graphics Adapter\n");
  	return -1;
      }
*** /tmp/,RCSt1KSQCrx	Wed Dec 11 21:42:18 1991
--- server/ddx/ibm/skyway/skyProcs.h	Wed Dec 11 21:31:45 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: skyProcs.h,v 1.3 91/07/16 13:15:59 jap Exp $
   *
   * Copyright IBM Corporation 1987,1988,1989,1990,1991
   *
--- 1,5 ----
  /*
!  * $XConsortium: skyProcs.h,v 1.4 91/12/11 21:25:38 eswu Exp $
   *
   * Copyright IBM Corporation 1987,1988,1989,1990,1991
   *
***************
*** 31,59 ****
  #ifndef _SKYPROCS_H
  #define _SKYPROCS_H
  
- extern int  skyProbe();
- extern void skySetColor();
  extern Bool skyScreenInit();
- extern int  skyHdwrInit();
- extern Bool skyScreenIO();
- extern void skySaveState();
- extern void skyRestoreState();
  extern Bool skyScreenClose();
  
  extern void skyQueryBestSize();
  extern void skyStoreColors();
- extern int  skyListInstalledColormaps();
  extern void skyInstallColormap();
  extern void skyUninstallColormap();
  extern void skyRefreshColormaps();
  
- extern void SkywaySetColor();
- extern void SkywayBitBlt();
- extern void SkywayFillSolid();
- extern void SkywayTileRect();
- extern void skywayReadColorImage();
- extern void skywayDrawColorImage();
- 
  extern Bool cfbScreenInit();
  
  #endif /* _SKYPROC_H */
--- 31,74 ----
  #ifndef _SKYPROCS_H
  #define _SKYPROCS_H
  
  extern Bool skyScreenInit();
  extern Bool skyScreenClose();
  
+ extern int  skyProbe();
+ 
+ extern void skySaveState();
+ extern void skyRestoreState();
  extern void skyQueryBestSize();
+ 
+ extern Bool skyRealizeCursor();
+ extern Bool skyUnrealizeCursor();
+ extern Bool skyDisplayCursor();
+ 
  extern void skyStoreColors();
  extern void skyInstallColormap();
  extern void skyUninstallColormap();
+ extern int  skyListInstalledColormaps();
  extern void skyRefreshColormaps();
  
  extern Bool cfbScreenInit();
+ extern void skyDoBitbltCopy();
+ extern void skyCopyWindow();
+ 
+ extern Bool skyCreateGC();
+ extern RegionPtr skyCopyArea();
+ 
+ extern void skyPolyFillRect();
+ /*
+ extern void skyPolyFillRectSolid_1Rect();
+ extern void skyPolyFillRectTile_1Rect();
+ extern void skyPolyFillRectStipple_1Rect();
+ */
+ 
+ /* ----------------- internal helper functions ----------------- */
+ extern int  skyHdwrInit();
+ 
+ extern unsigned long skySetTileStip();
+ extern unsigned long skySetSolid();
+ extern void skyNewTileStipID();
  
  #endif /* _SKYPROC_H */
*** /tmp/,RCSt1KS4BiI	Wed Dec 11 21:42:19 1991
--- server/ddx/ibm/skyway/skyReg.h	Wed Dec 11 21:31:46 1991
***************
*** 1,110 ****
  /*
!  * $XConsortium: skyReg.h,v 1.2 91/07/16 13:16:14 jap Exp $
   *
   * Copyright IBM Corporation 1987,1988,1989,1990,1991
   *
   * All Rights Reserved
   *
!  * License to use, copy, modify, and distribute this software and its
   * documentation for any purpose and without fee is hereby granted,
   * provided that the above copyright notice appear in all copies and that
!  * both that copyright notice and this permission notice appear in
   * supporting documentation, and that the name of IBM not be
!  * used in advertising or publicity pertaining to distribution of the
   * software without specific, written prior permission.
   *
!  * IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
   * ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS, AND 
!  * NONINFRINGEMENT OF THIRD PARTY RIGHTS, IN NO EVENT SHALL
   * IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
   * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
!  * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
!  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
   * SOFTWARE.
   *
  */
  
  /*
!  * skyReg.h - hardware register support
   */
  
- #ifndef SKYREG_H
- #define SKYREG_H
  
! #define SKYWAYSetMode(index,m)  \
! 	SKYWAY_MODE_REG(index) = (m) ; \
! 	SKYWAY_WINCTRL_REG(index) = 0x00
  
! #define SKYWAYSetRGBColor(index,r,g,b)  \
! 	{ SKYWAY_SINDEX_REG(index)   =  (PALETTESEQ  << 8) ; \
! 	  SKYWAY_SINDEX_REG(index)   =  (PALETTEDATA << 8) | ((r) >> 8) ; \
! 	  SKYWAY_SINDEX_REG(index)  =  (PALETTEDATA << 8) | ((g) >> 8) ; \
! 	  SKYWAY_SINDEX_REG(index)  =  (PALETTEDATA << 8) | ((b) >> 8) ; }
  
! #define SKYWAYSetColorIndex(index,n)            \
! 	{ SKYWAY_SINDEX_REG(index) = (PALETTEMASK << 8) | 0xff ; \
! 	  SKYWAY_SINDEX_REG(index) = (SPINDEXLO << 8) | (0xff & (n)) ; \
! 	  SKYWAY_SINDEX_REG(index) =  (SPINDEXHI << 8) | 0x00 ;}
  
! #define SKYWAYSetWidth(index,d)         SKYWAY_DM1_REG(index) = (short)(d)
! #define SKYWAYSetHeight(index,d)                SKYWAY_DM2_REG(index) = (short)(d)
! #define SKYWAYSetForegroundColor(index,f)       SKYWAY_FC_REG(index) = (int)(f)
! #define SKYWAYSetBackgroundColor(index,b)       SKYWAY_BC_REG(index) = (int)(b)
! #define SKYWAYSetCarryChain(index,c)            SKYWAY_CC_REG(index) = (unsigned int)(c)
! #define SKYWAYSetCCV(index,c)                   SKYWAY_CCV_REG(index) = (int) (c)
! #define SKYWAYSetCCC(index,c)                   SKYWAY_CCC_REG(index) = (unsigned short)(c)
  
! #define SKYWAYSetForegroundMix(index,f) SKYWAY_FM_REG(index) = (f)
! #define SKYWAYSetBackgroundMix(index,b) SKYWAY_BM_REG(index) = (b)
  
- #define SKYWAYSetPixmapWidth(index,w)     SKYWAY_PMW_REG(index) = (short)(w)
- #define SKYWAYSetPixmapHeight(index,h)  SKYWAY_PMH_REG(index) = (short)(h)
- #define SKYWAYSetPixmapBase(index,b)    SKYWAY_PMB_REG(index) = (unsigned int)(b)
- #define SKYWAYSetPixmapIndex(index,i)   SKYWAY_PMI_REG(index) = (short)(i)
- #define SKYWAYSetPixmapControl(index,c) SKYWAY_PMC_REG(index) = (unsigned char)(c)
- #define SKYWAYSetPixmapFormat(index,f)  SKYWAY_PMF_REG(index) = (short)(f)
  
! #define SKYWAYSetBresenhamError(index,e)    SKYWAY_BME_REG(index) = (int) (e)
! #define SKYWAYSetBresenhamErrorK1(index,k1) SKYWAY_BMK1_REG(index) = (int) (k1)
! #define SKYWAYSetBresenhamErrorK2(index,k2) SKYWAY_BMK2_REG(index) = (int) (k2)
! #define SKYWAYSetDirectionSteps(index,d)    SKYWAY_DRT_REG(index) = (int) (d)
! #define SKYWAYSetPixelOp(index,p)             SKYWAY_PO_REG(index) = (unsigned int) (p)
  
! #define SKYWAYSetDimension(index,w,h) \
! 	{ SKYWAY_DM1_REG(index) = (short) (w) ; \
! 	  SKYWAY_DM2_REG(index) = (short) (h) ; }
  
- #define SKYWAYSetPixmapMaskOffset(index,x,y) \
- 	{ SKYWAY_MASKX_REG(index) = (short) (x) ; \
- 	  SKYWAY_MASKY_REG(index) = (short) (y) ; }
  
! #define SKYWAYSetPixmapSrcOffset(index,x,y) \
! 	{ SKYWAY_SRCX_REG(index) = (short) (x) ; \
! 	  SKYWAY_SRCY_REG(index) = (short) (y) ; }
  
! #define SKYWAYSetPixmapDstOffset(index,x,y) \
! 	{ SKYWAY_DSTX_REG(index) = (short) (x) ; \
! 	  SKYWAY_DSTY_REG(index) = (short) (y) ; }
  
! #define SKYWAYSetPixmapPatOffset(index,x,y) \
! 	{ SKYWAY_PATX_REG(index) = (short) (x) ; \
! 	  SKYWAY_PATY_REG(index) = (short) (y) ; }
  
! #define SKYWAYSetPageDirBase(index,p)       SKYWAY_PD_REG(index) = (unsigned int) (p)
! #define SKYWAYSetVirtualAddr(index,v)       SKYWAY_VA_REG(index) = (unsigned int) (v)
! #define SKYWAYGetStateALength(index,a)    (a) = SKYWAY_LA_REG(index)
! #define SKYWAYGetStateBLength(index,b)    (b) = SKYWAY_LB_REG (index)
  
- #define SKYWAYSetPlaneMask(index,p)   SKYWAY_PM_REG (index)= (p)
- #define SKYWAYSetALU(index,a)   \
- 	{ SKYWAYSetForegroundMix(index,a) ; \
- 	  SKYWAYSetBackgroundMix(index,a) ; }
  
! #define SKYWAYSetupScreenPixmap(index,pixsize) \
!  { SKYWAYSetPixmapIndex(index,PixMapC) ; \
!    SKYWAYSetPixmapBase(index,SKYWAY_COP_START) ; \
!    SKYWAYSetPixmapWidth(index,1280 - 1) ; \
!    SKYWAYSetPixmapHeight(index,1024 - 1) ; \
!    SKYWAYSetPixmapFormat(index,MI1 | pixsize) ; }
  
  #endif /* SKYREG_H */
--- 1,423 ----
  /*
!  * $XConsortium: skyReg.h,v 1.3 91/12/11 21:25:42 eswu Exp $
   *
   * Copyright IBM Corporation 1987,1988,1989,1990,1991
   *
   * All Rights Reserved
   *
!  * License to use, copy, modify, and distribute	this software and its
   * documentation for any purpose and without fee is hereby granted,
   * provided that the above copyright notice appear in all copies and that
!  * both	that copyright notice and this permission notice appear	in
   * supporting documentation, and that the name of IBM not be
!  * used	in advertising or publicity pertaining to distribution of the
   * software without specific, written prior permission.
   *
!  * IBM DISCLAIMS ALL WARRANTIES	WITH REGARD TO THIS SOFTWARE, INCLUDING
   * ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS, AND 
!  * NONINFRINGEMENT OF THIRD PARTY RIGHTS, IN NO	EVENT SHALL
   * IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
   * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
!  * WHETHER IN AN ACTION	OF CONTRACT, NEGLIGENCE	OR OTHER TORTIOUS ACTION,
!  * ARISING OUT OF OR IN	CONNECTION WITH	THE USE	OR PERFORMANCE OF THIS
   * SOFTWARE.
   *
  */
  
  /*
!  * skyReg.h - Skyway coprocessor registers, constants, and macros.
!  *            You should use the macros to set the registers.
   */
  
  
! #ifndef	SKYREG_H
! #define	SKYREG_H
  
! #include <sys/types.h>
  
! /*****************************************************************************
! *                                                                            *
! *                        Skyway Coprocessor Registers                        *
! *                                                                            *
! *****************************************************************************/
  
! /* Use macros below: don't set hardware registers directly */
  
! typedef volatile struct	_skyCopReg
! {
!     ulong  page_dir_base;     /*			      */
!     ulong  cur_virt_addr;     /*			      */
!     uchar  resvd1;	      /* Unused	space		      */
!     uchar  pollreg;	      /* Polling register for pass 2  */
!     ushort resvd1a;	      /* Unused	space		      */
!     ushort resvd2;	      /* Unused	space		      */
!     uchar  state_a_len;	      /*			      */
!     uchar  state_b_len;	      /*			      */
!     ushort pix_index;	      /*			      */
!     uchar  pi_control;	      /*			      */
!     uchar  resvd3;	      /* Unused	space		      */
!     uchar *pixmap_base;	      /* VRAM addr of Pixmap start    */
!     ulong  pix_hw;	      /* pixmap	height and width      */
!     ushort resvd4;	      /* Unused	space		      */
!     uchar  resvd4a;	      /* Unused	space		      */
!     uchar  pixmap_fmt;	      /*			      */
!     ulong  bres_errterm;      /* Bressenham Error Term	      */
!     ulong  bres_k1;	      /* Bressenham K1 consant	      */
!     ulong  bres_k2;	      /* Bressenham K2 consant	      */
!     ulong  dir_steps;	      /* Draw and Step codes	      */
!     ulong  resvd5;	      /* Unused	space		      */
!     ulong  resvd6;	      /* Unused	space		      */
!     ulong  resvd7;	      /* Unused	space		      */
!     ulong  resvd8;	      /* Unused	space		      */
!     ulong  resvd9;	      /* Unused	space		      */
!     ulong  resvdrpw;	      /* Unused	space		      */
!     ushort color_comp;	      /* Color compare condition      */
!     ushort bgfgmix;	      /* bg and	fg alu		      */
!     ulong  color_compval;     /* Color compare value	      */
!     ulong  plane_mask;	      /* Mask reg for color masking   */
!     ulong  car_chainmsk;      /* Carry chain for arith mixes  */
!     ulong  fgd_color;	      /* Foreground color	      */
!     ulong  bgd_color;	      /* Background color	      */
!     long   opdim21;	      /* Height	& Width	for PixBlits  */
!     ulong  resvda;	      /* Unused	space		      */
!     ulong  resvdb;	      /* Unused	space		      */
!     long   maskyx;	      /* Y,X Coordinate	in Clip	Mask  */
!     long   src_yx;	      /* Source	Y,X start in Pixmap   */
!     long   pat_yx;	      /* Pattern Y,X start in Pixmap  */
!     long   dst_yx;	      /* Destination Y,X start in Pix */
!     ulong  pixel_op_reg;      /* Pixel Operation: starts cmds */
! } skyCopRegRec, *skyCopRegPtr;
  
  
! /*****************************************************************************
! *                                                                            *
! *                      Address of Coprocessor and Shadow                     *
! *                                                                            *
! *****************************************************************************/
  
! extern skyCopRegPtr	COPREG[];		/* Coprocessor address       */
! extern skyCopRegRec	COPREG_SHADOW[];	/* Coprocessor shadow struct */
  
  
! /*****************************************************************************
! *                                                                            *
! *                 Utility Macros to Set Coprocessor Registers                *
! *                         (Don't use these directly)                         *
! *                                                                            *
! *****************************************************************************/
  
! #define PackDim(w,h)			(((h) - 1) << 16 | (ushort) ((w) - 1))
! #define PackCoord(x,y)			((y) << 16 | (short) (x))
  
! #define SKYSetCopShort(i,reg,v)		COPREG[i]->reg = (v)
! #define SKYSetCopByte(i,reg,v)		COPREG[i]->reg = (v)
  
! #define SKYSetCop(i,reg,v)		COPREG[i]->reg = (v)
! #define SKYSetCop2(i,reg,v1,v2)		copyword2(&COPREG[i]->reg,v1,v2)
! #define SKYSetCop3(i,reg,v1,v2,v3)	copyword3(&COPREG[i]->reg,v1,v2,v3)
! #define SKYSetCop4(i,reg,v1,v2,v3,v4)	copyword4(&COPREG[i]->reg,v1,v2,v3,v4)
  
  
! /* Shadow coprocessor value, don't set coprocessor if value has not changed */
! 
! #define SHDSetCop(i,reg,v) 				\
! {							\
!     register ulong temp = (v);				\
!     if (COPREG_SHADOW[i].reg != temp)			\
! 	COPREG[i]->reg = COPREG_SHADOW[i].reg = temp;	\
! }
! 
! #define SHDSetCopShort(i,reg,v) 			\
! {							\
!     register ushort temp = (v);				\
!     if (COPREG_SHADOW[i].reg != temp)			\
! 	COPREG[i]->reg = COPREG_SHADOW[i].reg = temp;	\
! }
! 
! 
! /*****************************************************************************
! *                                                                            *
! *      Macros to Set/Poll Coprocessor Registers:  Please Use These!!!        *
! *                                                                            *
! *****************************************************************************/
! 
! /* Set Skyway Coprocessor Registers:  Use these to talk to coprocessor */
! 
! #define SKYSetPageDirBase(i,base)	SKYSetCop(i,page_dir_base,(base))
! #define SKYSetVirtualAddr(i,addr)	SKYSetCop(i,cur_virt_addr,(addr))
! #define SKYGetPollReg(i)		(COPREG[i]->pollreg)
! 
! #define SKYSetPixmap(i,index,base,w,h,fmt)			\
! {								\
! 	SKYSetCopShort(i, pix_index, index);			\
! 	SKYSetCop3(i, pixmap_base, base, PackDim(w,h), fmt);	\
! }
! 
! #define SKYSetBresenConst(i,e,k1,k2)	SKYSetCop3(i,bres_errterm,(e),(k1),(k2))
! #define SKYStepAndDraw(i, code)		SKYSetCop(i,dir_steps, (code))
! 
! #define SKYSetColorCompCond(i,cond)	SKYSetCopShort(i,color_comp, (cond))
! #define SKYSetMix(i,mix)		SHDSetCopShort(i,bgfgmix, mix);
! #define SKYSetFgBgMix(i,FgMix,BgMix)	SHDSetCopShort(i,bgfgmix, \
! 					(((BgMix) << 8) | (FgMix)))
! 
! #define SKYSetColorCompValue(i,val)	SKYSetCop(i,color_compval, (val))
! #define SKYSetPlaneMask(i,mask)		SHDSetCop(i,plane_mask,0xff & (mask))
! #define SKYSetCarryChain(i,cc)		SKYSetCop(i,car_chainmsk, (cc))
! #define SKYSetFgColor(i,fg)		SHDSetCop(i,fgd_color, (fg))
! #define SKYSetBgColor(i,bg)		SHDSetCop(i,bgd_color, (bg))
! #define SKYSetOpDim21(i,w,h)		SHDSetCop(i,opdim21, PackDim(w,h))
! 
! /* Note that the following macros use XY instead of YX: more intuitive */
! 
! #define SKYSetMaskXY(i,x,y)		SKYSetCop(i,maskyx, PackCoord(x,y))
! #define SKYSetSrcXY(i,x,y)		SKYSetCop(i,src_yx, PackCoord(x,y))
! #define SKYSetPatXY(i,x,y)		SKYSetCop(i,pat_yx, PackCoord(x,y))
! #define SKYSetDstXY(i,x,y)		SKYSetCop(i,dst_yx, PackCoord(x,y))
! 
! #define SKYPixelOp(i,op)		SKYSetCop(i,pixel_op_reg, (op))
! 
! 
! 
! /*****************************************************************************
! *                                                                            *
! *      More Utility Macros to Set/Poll Coprocessor:  Please use them!!!      *
! *                                                                            *
! *****************************************************************************/
! 
! #define SKYSyncCoprocessorShadow(i)	COPREG_SHADOW[i] = *COPREG[index]
! 
! #define SKYBusyWait(i)			while (SKYGetPollReg(i) & 0x80)
! #define SKYIsBusy(i)			(SKYGetPollReg(i) & 0x80)
! #define SKYTurnOffColorComp(i)		SKYSetColorCompCond(i,Color_Cmp_Fal)
! 
! #define SKYSetALU(i,alu)		SKYSetFgBgMix(i,alu,alu)
! 
! #define SKYSetFgBgColor(i,fg,bg)	\
! {					\
!     SHDSetCop(i,fgd_color, (fg));	\
!     SHDSetCop(i,bgd_color, (bg));	\
! }
! 
! #define SKYSetPatXY_DstXY_PixelOp(i, px,py, dx,dy, op) \
! 	SKYSetCop3(i,pat_yx,		\
! 		PackCoord(px,py),	\
! 		PackCoord(dx,dy),	\
! 		(op))
! 
! #define SKYSetSrcXY_PatXY_DstXY_PixelOp(i, sx,sy, px,py, dx,dy, op) \
! 	SKYSetCop4(i,src_yx,		\
! 		PackCoord(sx,sy),	\
! 		PackCoord(px,py),	\
! 		PackCoord(dx,dy),	\
! 		(op))
! 
! #define SKYSetDstXY_PixelOp(i,x,y,op)	SKYSetCop2(i,dst_yx, \
! 					PackCoord(x,y), (op))
! 
! #define SKYSetupScreenPix(i,pixsize)	\
! 	SKYSetPixmap(i,PixMapC,SC_VRAM_BASE,1280,1024, pixsize)
! 
! 
! /* Initiates a pixel operation that uses a tile.
!  *    Tiles need the pattern offset written to SrcYX register. The PatYX
!  *    register does not need to be set, but it is faster to write across
!  *    all four registers with one store-string than individually.
!  */
! 
! #define SKYTilePixelOp(i, PixelOp, x,y, w,h, pat_x,pat_y, pat_w,pat_h)	\
! {									\
!     int src_x;								\
!     int src_y;								\
! 									\
!     /* modulus from misc.h */						\
!     modulus(x - pat_x, pat_w, src_x);					\
!     modulus(y - pat_y, pat_h, src_y);					\
! 									\
!     SKYBusyWait(i);							\
!     SKYSetOpDim21(i, w,h);						\
!     SKYSetSrcXY_PatXY_DstXY_PixelOp(i, src_x,src_y, 0,0, x,y, PixelOp);	\
! }
! 
! 
! /* Initiates a pixel operation that uses a stipple.
!  *    Stipples need the pattern offset written to PatYX register.
!  */
! 
! #define SKYStipplePixelOp(i, PixelOp, x,y, w,h, pat_x,pat_y, pat_w,pat_h) \
! {									\
!     int src_x;								\
!     int src_y;								\
! 									\
!     /* modulus from misc.h */						\
!     modulus(x - pat_x, pat_w, src_x);					\
!     modulus(y - pat_y, pat_h, src_y);					\
! 									\
!     SKYBusyWait(i);							\
!     SKYSetOpDim21(i, w,h);						\
!     SKYSetPatXY_DstXY_PixelOp(i, src_x,src_y, x,y, PixelOp);		\
! }
! 
! 
! /* Initiates a solid-color pixel operation
!  */
! 
! #define SKYSolidPixelOp(i, PixelOp, x,y, w,h)				\
! {									\
!     SKYBusyWait(i);							\
!     SKYSetOpDim21(i, w,h);						\
!     SKYSetDstXY_PixelOp(i, x,y, PixelOp);				\
! }
! 
! /*****************************************************************************
! *                                                                            *
! *                         Coprocessor Constants                              *
! *                                                                            *
! *****************************************************************************/
! 
! /* Pixel Map Index Register */
! 
! #define MaskMap   0
! #define PixMapA   1
! #define PixMapB   2
! #define PixMapC   3
! 
! /* Pixel Map n Format */
! /* M/I Format */
! 
! #define MI0  0		/* Little-Endian Format */
! #define MI1  0x8	/* Big-Endian Format    */
! 
! /* Pixel Size */
! 
! #define PixSize1  (0 | MI1)
! #define PixSize2  (1 | MI1)
! #define PixSize4  (2 | MI1)
! #define PixSize8  (3 | MI1)
! #define PixSize16 (4 | MI1)
! 
! 
! /*  Color Compare Condition         */
! 
! #define  Color_Cmp_True  0x0        /* Always True (disable updates)  */
! #define  Color_Grt_Col   0x1        /* Dest > Col value               */
! #define  Color_Equ_Col   0x2        /* Dest = Col value               */
! #define  Color_Les_Col   0x3        /* Dest < Col value               */
! #define  Color_Cmp_Fal   0x4        /* Always False (enable updates)  */
! #define  Color_GtEq_Col  0x5        /* Dest >= Col value              */
! #define  Color_NtEq_Col  0x6        /* Dest <> Col value              */
! #define  Color_LsEq_Col  0x7        /* Dest <= Col value              */
! 
! #define  Plane_Mask_All  0xFFFF
! #define  Carry_Mask      0x3FFF
! 
! 
! /******************************************************************************
! *                                                                             *
! *      The Pixel Operations Register is defined as follows:                   *
! *                                                                             *
! *      +--------+--------+--------+--------+                                  *
! *      | byte 0 | byte 1 | byte 2 | byte 3 |                                  *
! *      +--------+--------+--------+--------+                                  *
! *                                                                             *
! *                                                                             *
! *      Byte 0 - XX|XX|X|XXX                                                   *
! *               __ __ _ ___                                                   *
! *                |  | |  +---------- Direction for PixBlts and Lines          *
! *                |  | +------------- Unused                                   *
! *                |  +--------------- Draw Mode (end point semantics)          *
! *                +------------------ Mask Mode                                *
! *                                                                             *
! *      Byte 1 - XXXX|XXXX                                                     *
! *               ____ ____                                                     *
! *                 |    +------------ Unused                                   *
! *                 +----------------- Pattern                                  *
! *                                                                             *
! *      Byte 2 - XXXX|XXXX                                                     *
! *               ____ ____                                                     *
! *                 |    +------------ Destination Pixel Map                    *
! *                 +----------------- Source Pixel Map                         *
! *                                                                             *
! *      Byte 3 - XX|XX|XXXX                                                    *
! *               __ __ ____                                                    *
! *                |  |   +----------- Step - specifies drawing operation       *
! *                |  +--------------- Foreground color source                  *
! *                +------------------ Background color source                  *
! *                                                                             *
! ******************************************************************************/
! 
! /* Background color source */
! 
! #define POBackReg 0                /* Background color  (register)   */
! #define POBackSrc 0x80             /* Source Pixel Map               */
! 
! /* Foreground color source */
! 
! #define POForeReg 0                /* Foreground  color (register)   */
! #define POForeSrc 0x20             /* Source Pixel Map               */
! 
! /* Step */
! 
! #define POStepDSR 0x2              /* Draw & Step Read               */
! #define POStepLDR 0x3              /* Line Draw   Read               */
! #define POStepDSW 0x4              /* Draw & Step Write              */
! #define POStepLDW 0x5              /* Line Draw   Write              */
! #define POStepBlt 0x8              /* Pxblt                          */
! #define POStepIBlt 0x9             /* Inverting Pxblt                */
! #define POStepAFBlt 0xa            /* Area Fill Pxblt                */
! 
! /* Source */
! 
! #define POSrcA 0x1000              /* Pixel Map A                    */
! #define POSrcB 0x2000              /* Pixel Map B                    */
! #define POSrcC 0x3000              /* Pixel Map C                    */
! #define POSrcD 0x0000              /* Mask Map  D                    */
! 
! /* Destination */
! 
! #define PODestA 0x100              /* Pixel Map A                    */
! #define PODestB 0x200              /* Pixel Map B                    */
! #define PODestC 0x300              /* Pixel Map C                    */
! #define PODestD 0x000              /* Mask Map  D                    */
! 
! /* Pattern */
! 
! #define POPatA 0x100000            /* Pixel Map A                    */
! #define POPatB 0x200000            /* Pixel Map B                    */
! #define POPatC 0x300000            /* Pixel Map C                    */
! #define POPatD 0x000000            /* Mask Map  D                    */
! 
! #define POPatFore 0x800000         /* Foreground (Fixed)             */
! #define POPatSrc 0x900000          /* Generated from Source          */
! 
! /* Mask */
! 
! #define POMaskDis 0                /* Mask Map Disabled             */
! #define POMaskBEn 0x40000000       /* Mask Map Boundary Enabled     */
! #define POMaskEn  0x80000000       /* Mask Map Enabled              */
! 
! /* Drawing Mode */
! 
! #define POModeAll 0                /* Draw All Pixels                */
! #define POModeLast 0x10000000      /* Draw 1s Pixel Null             */
! #define POModeFirst 0x20000000     /* Draw Last Pixel Null           */
! #define POModeArea 0x30000000      /* Draw Area Boundary             */
! 
! /* Direction Octant */
! 
! #define POOct0 0
! #define POOct1 0x1000000
! #define POOct2 0x2000000
! #define POOct3 0x3000000
! #define POOct4 0x4000000
! #define POOct5 0x5000000
! #define POOct6 0x6000000
! #define POOct7 0x7000000
! 
! /*  Octant fields      */
! 
! #define  DX              0x4000000
! #define  DY              0x2000000
! #define  DZ              0x1000000
  
  #endif /* SKYREG_H */
*** /tmp/,RCSt1KTgCkR	Wed Dec 11 21:42:21 1991
--- server/ddx/ibm/skyway/skySGC.c	Wed Dec 11 21:41:22 1991
***************
*** 1,32 ****
  /*
!  * $XConsortium: skySGC.c,v 1.4 91/11/08 18:10:05 eswu Exp $
   *
!  * Copyright IBM Corporation 1987,1988,1989,1990,1991
   *
!  * All Rights Reserved
   *
   * License to use, copy, modify, and distribute this software and its
!  * documentation for any purpose and without fee is hereby granted,
!  * provided that the above copyright notice appear in all copies and that
!  * both that copyright notice and this permission notice appear in
!  * supporting documentation, and that the name of IBM not be
!  * used in advertising or publicity pertaining to distribution of the
!  * software without specific, written prior permission.
   *
!  * IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
!  * ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS, AND 
!  * NONINFRINGEMENT OF THIRD PARTY RIGHTS, IN NO EVENT SHALL
!  * IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
!  * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
!  * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
!  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
!  * SOFTWARE.
   *
! */
  
  #include "X.h"
  #include "Xmd.h"
  #include "Xproto.h"
  #include "gcstruct.h"
  #include "windowstr.h"
  #include "pixmapstr.h"
--- 1,59 ----
  /*
!  * $XConsortium: skySGC.c,v 1.6 91/12/11 21:40:54 eswu Exp $
   *
!  * Copyright IBM Corporation 1987,1988,1989,1990,1991 
   *
!  * All Rights Reserved 
   *
   * License to use, copy, modify, and distribute this software and its
!  * documentation for any purpose and without fee is hereby granted, provided
!  * that the above copyright notice appear in all copies and that both that
!  * copyright notice and this permission notice appear in supporting
!  * documentation, and that the name of IBM not be used in advertising or
!  * publicity pertaining to distribution of the software without specific,
!  * written prior permission. 
   *
!  * IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
!  * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS, AND NONINFRINGEMENT OF
!  * THIRD PARTY RIGHTS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,
!  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
!  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
!  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
!  * PERFORMANCE OF THIS SOFTWARE. 
   *
!  */
  
+ /***********************************************************
+ Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
+ and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
+ 
+                         All Rights Reserved
+ 
+ Permission to use, copy, modify, and distribute this software and its 
+ documentation for any purpose and without fee is hereby granted, 
+ provided that the above copyright notice appear in all copies and that
+ both that copyright notice and this permission notice appear in 
+ supporting documentation, and that the names of Digital or MIT not be
+ used in advertising or publicity pertaining to distribution of the
+ software without specific, written prior permission.  
+ 
+ DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ SOFTWARE.
+ 
+ ******************************************************************/
+ 
+ 
  #include "X.h"
  #include "Xmd.h"
  #include "Xproto.h"
+ #include "cfb.h"
+ #include "fontstruct.h"
+ #include "dixfontstr.h"
  #include "gcstruct.h"
  #include "windowstr.h"
  #include "pixmapstr.h"
***************
*** 33,52 ****
  #include "scrnintstr.h"
  #include "region.h"
  
! #include "cfb.h"
  
! extern RegionPtr skyCopyArea();
  
  void
  skyValidateGC(pGC, changes, pDrawable)
      register GCPtr  pGC;
      Mask	    changes;
      DrawablePtr	    pDrawable;
  {
!   cfbValidateGC(pGC,changes,pDrawable);
  
!   /* XXX - What if the ops is static? */
  
!   if (pGC->depth == 8)
!     pGC->ops->CopyArea = skyCopyArea ;
  }
--- 60,1449 ----
  #include "scrnintstr.h"
  #include "region.h"
  
! #include "mistruct.h"
! #include "mibstore.h"
  
! #include "cfbmskbits.h"
! #include "cfb8bit.h"
  
+ /* ---- */
+ #include "skyPriv.h"
+ #include "skyHdwr.h"
+ #include "skyProcs.h"
+ #include <stdio.h>
+ /* ---- */
+ 
+ 
+ void skyValidateGC(), skyChangeGC(), skyCopyGC(), skyDestroyGC();
+ void skyChangeClip(), skyDestroyClip(), skyCopyClip();
+ 
+ GCFuncs skyGCFuncs = {
+     skyValidateGC,
+     skyChangeGC,
+     skyCopyGC,
+     skyDestroyGC,
+     skyChangeClip,
+     skyDestroyClip,
+     skyCopyClip,
+ };
+ 
+ #ifdef NOCLIP_TEST
+ GCOps	skyTEOps1Rect_Win = {
+     cfbSolidSpansCopy,
+     cfbSetSpans,
+     cfbPutImage,
+     skyCopyArea,
+     cfbCopyPlane,
+     cfbPolyPoint,
+ #if PPW == 4
+     cfb8LineSS1Rect,
+     cfb8SegmentSS1Rect,
+ #else
+     cfbLineSS,
+     cfbSegmentSS,
+ #endif
+     miPolyRectangle,
+ #if PPW == 4
+     cfbZeroPolyArcSS8Copy,
+ #else
+     miZeroPolyArc,
+ #endif
+     cfbFillPoly1RectCopy,
+     skyPolyFillRectSolid_1Rect,
+     cfbPolyFillArcSolidCopy,
+     miPolyText8,
+     miPolyText16,
+     miImageText8,
+     miImageText16,
+ #if PPW == 4
+     cfbTEGlyphBlt8,
+     cfbPolyGlyphBlt8,
+     cfbPushPixels8,
+ #else
+     cfbTEGlyphBlt,
+     miPolyGlyphBlt,
+     mfbPushPixels,
+ #endif
+     NULL,
+ };
+ #endif
+ 
+ GCOps	skyTEOps1Rect = {
+     cfbSolidSpansCopy,
+     cfbSetSpans,
+     cfbPutImage,
+     skyCopyArea,
+     cfbCopyPlane,
+     cfbPolyPoint,
+ #if PPW == 4
+     cfb8LineSS1Rect,
+     cfb8SegmentSS1Rect,
+ #else
+     cfbLineSS,
+     cfbSegmentSS,
+ #endif
+     miPolyRectangle,
+ #if PPW == 4
+     cfbZeroPolyArcSS8Copy,
+ #else
+     miZeroPolyArc,
+ #endif
+     cfbFillPoly1RectCopy,
+     skyPolyFillRect,
+     cfbPolyFillArcSolidCopy,
+     miPolyText8,
+     miPolyText16,
+     miImageText8,
+     miImageText16,
+ #if PPW == 4
+     cfbTEGlyphBlt8,
+     cfbPolyGlyphBlt8,
+     cfbPushPixels8,
+ #else
+     cfbTEGlyphBlt,
+     miPolyGlyphBlt,
+     mfbPushPixels,
+ #endif
+     NULL,
+ };
+ 
+ GCOps	skyTEOps = {
+     cfbSolidSpansCopy,
+     cfbSetSpans,
+     cfbPutImage,
+     skyCopyArea,
+     cfbCopyPlane,
+     cfbPolyPoint,
+     cfbLineSS,
+     cfbSegmentSS,
+     miPolyRectangle,
+ #if PPW == 4
+     cfbZeroPolyArcSS8Copy,
+ #else
+     miZeroPolyArc,
+ #endif
+     miFillPolygon,
+     skyPolyFillRect,
+     cfbPolyFillArcSolidCopy,
+     miPolyText8,
+     miPolyText16,
+     miImageText8,
+     miImageText16,
+ #if PPW == 4
+     cfbTEGlyphBlt8,
+     cfbPolyGlyphBlt8,
+     cfbPushPixels8,
+ #else
+     cfbTEGlyphBlt,
+     miPolyGlyphBlt,
+     mfbPushPixels,
+ #endif
+     NULL,
+ };
+ 
+ #ifdef NOCLIP_TEST
+ GCOps	skyNonTEOps1Rect_Win = {
+     cfbSolidSpansCopy,
+     cfbSetSpans,
+     cfbPutImage,
+     skyCopyArea,
+     cfbCopyPlane,
+     cfbPolyPoint,
+ #if PPW == 4
+     cfb8LineSS1Rect,
+     cfb8SegmentSS1Rect,
+ #else
+     cfbLineSS,
+     cfbSegmentSS,
+ #endif
+     miPolyRectangle,
+ #if PPW == 4
+     cfbZeroPolyArcSS8Copy,
+ #else
+     miZeroPolyArc,
+ #endif
+     cfbFillPoly1RectCopy,
+     skyPolyFillRectSolid_1Rect,
+     cfbPolyFillArcSolidCopy,
+     miPolyText8,
+     miPolyText16,
+     miImageText8,
+     miImageText16,
+     cfbImageGlyphBlt8,
+     cfbPolyGlyphBlt8,
+     cfbPushPixels8,
+     NULL,
+ };
+ #endif
+ 
+ GCOps	skyNonTEOps1Rect = {
+     cfbSolidSpansCopy,
+     cfbSetSpans,
+     cfbPutImage,
+     skyCopyArea,
+     cfbCopyPlane,
+     cfbPolyPoint,
+ #if PPW == 4
+     cfb8LineSS1Rect,
+     cfb8SegmentSS1Rect,
+ #else
+     cfbLineSS,
+     cfbSegmentSS,
+ #endif
+     miPolyRectangle,
+ #if PPW == 4
+     cfbZeroPolyArcSS8Copy,
+ #else
+     miZeroPolyArc,
+ #endif
+     cfbFillPoly1RectCopy,
+     skyPolyFillRect,
+     cfbPolyFillArcSolidCopy,
+     miPolyText8,
+     miPolyText16,
+     miImageText8,
+     miImageText16,
+     cfbImageGlyphBlt8,
+     cfbPolyGlyphBlt8,
+     cfbPushPixels8,
+     NULL,
+ };
+ 
+ GCOps	skyNonTEOps = {
+     cfbSolidSpansCopy,
+     cfbSetSpans,
+     cfbPutImage,
+     skyCopyArea,
+     cfbCopyPlane,
+     cfbPolyPoint,
+     cfbLineSS,
+     cfbSegmentSS,
+     miPolyRectangle,
+ #if PPW == 4
+     cfbZeroPolyArcSS8Copy,
+ #else
+     miZeroPolyArc,
+ #endif
+     miFillPolygon,
+     skyPolyFillRect,
+     cfbPolyFillArcSolidCopy,
+     miPolyText8,
+     miPolyText16,
+     miImageText8,
+     miImageText16,
+ #if PPW == 4
+     cfbImageGlyphBlt8,
+     cfbPolyGlyphBlt8,
+     cfbPushPixels8,
+ #else
+     miImageGlyphBlt,
+     miPolyGlyphBlt,
+     mfbPushPixels,
+ #endif
+     NULL,
+ };
+ 
+ GCOps *
+ skyMatchCommon (pDrawable, pGC, devPriv)
+     DrawablePtr     pDrawable;
+     GCPtr	    pGC;
+     cfbPrivGCPtr    devPriv;
+ {
+     if (pGC->lineWidth != 0)
+ 	return 0;
+     if (pGC->lineStyle != LineSolid)
+ 	return 0;
+     if (pGC->fillStyle != FillSolid)
+ 	return 0;
+     if (devPriv->rop != GXcopy)
+ 	return 0;
+     if (pGC->font &&
+ 	FONTMAXBOUNDS(pGC->font,rightSideBearing) -
+         FONTMINBOUNDS(pGC->font,leftSideBearing) <= 32 &&
+ 	FONTMINBOUNDS(pGC->font,characterWidth) >= 0)
+     {
+ 	if (TERMINALFONT(pGC->font)
+ #if PPW == 4
+ 	    && FONTMAXBOUNDS(pGC->font,characterWidth) >= 4
+ #endif
+ 	)
+ 	    if (devPriv->oneRect)
+ 	    {
+ #ifdef NOCLIP_TEST
+ 		if (pDrawable->type == DRAWABLE_WINDOW)
+ 		    return &skyTEOps1Rect_Win;
+ 		else
+ #endif
+ 		    return &skyTEOps1Rect;
+ 	    }
+ 	    else
+ 		return &skyTEOps;
+ 	else
+ 	    if (devPriv->oneRect)
+ 	    {
+ #ifdef SKYWAY_CLIP
+ 		if (pDrawable->type == DRAWABLE_WINDOW)
+ 		    return &skyNonTEOps1Rect_Win;
+ 		else
+ #endif
+ 		    return &skyNonTEOps1Rect;
+ 	    }
+ 	    else
+ 		return &skyNonTEOps;
+     }
+     return 0;
+ }
+ 
+ Bool
+ skyCreateGC(pGC)
+     register GCPtr pGC;
+ {
+     cfbPrivGC    *pPriv;
+     /* ---- */
+     skyPrivGCPtr  pSkyPriv = skyGetGCPrivate(pGC);
+     /* ---- */
+ 
+     if (pGC->depth == 1)
+ 	return (mfbCreateGC(pGC));
+     pGC->clientClip = NULL;
+     pGC->clientClipType = CT_NONE;
+ 
+     /*
+      * some of the output primitives aren't really necessary, since they
+      * will be filled in ValidateGC because of dix/CreateGC() setting all
+      * the change bits.  Others are necessary because although they depend
+      * on being a color frame buffer, they don't change 
+      */
+ 
+     pGC->ops = &skyNonTEOps;
+     pGC->funcs = &skyGCFuncs;
+ 
+     /* cfb wants to translate before scan conversion */
+     pGC->miTranslate = 1;
+ 
+     pPriv = (cfbPrivGC *)(pGC->devPrivates[cfbGCPrivateIndex].ptr);
+     pPriv->rop = pGC->alu;
+     pPriv->oneRect = FALSE;
+     pPriv->fExpose = TRUE;
+     pPriv->freeCompClip = FALSE;
+     pPriv->pRotatedPixmap = (PixmapPtr) NULL;
+ 
+     /* ---- */
+     pSkyPriv->fillMode         = punt;
+     pSkyPriv->BgFgMix          = pGC->alu << 8 | pGC->alu;
+     pSkyPriv->tileStipID       = 0;
+     pSkyPriv->stipple.size     = 0;
+     pSkyPriv->stipple.bits     = NULL;
+     pSkyPriv->stipple.freeBits = FALSE;
+     /* ---- */
+ 
+     return TRUE;
+ }
+ 
+ /*ARGSUSED*/
  void
+ skyChangeGC(pGC, mask)
+     GC		    *pGC;
+     BITS32	    mask;
+ {
+     return;
+ }
+ 
+ void
+ skyDestroyGC(pGC)
+     GC 			*pGC;
+ {
+     cfbPrivGC *pPriv;
+ 
+     pPriv = (cfbPrivGC *)(pGC->devPrivates[cfbGCPrivateIndex].ptr);
+     if (pPriv->pRotatedPixmap)
+ 	cfbDestroyPixmap(pPriv->pRotatedPixmap);
+     if (pPriv->freeCompClip)
+ 	(*pGC->pScreen->RegionDestroy)(pPriv->pCompositeClip);
+     skyDestroyOps (pGC->ops);
+ }
+ 
+ /*
+  * create a private op array for a gc
+  */
+ 
+ GCOps *
+ skyCreateOps (prototype)
+     GCOps	*prototype;
+ {
+     GCOps	*ret;
+     extern Bool	Must_have_memory;
+ 
+     /* XXX */ Must_have_memory = TRUE;
+     ret = (GCOps *) xalloc (sizeof(GCOps));
+     /* XXX */ Must_have_memory = FALSE;
+     if (!ret)
+ 	return 0;
+     *ret = *prototype;
+     ret->devPrivate.val = 1;
+     return ret;
+ }
+ 
+ skyDestroyOps (ops)
+     GCOps   *ops;
+ {
+     if (ops->devPrivate.val)
+ 	xfree (ops);
+ }
+ 
+ 
+ /* ---- */
+ #define FreeStippleData(stipple)					\
+ {									\
+     if (stipple->freeBits)						\
+     {									\
+ 	xfree(stipple->bits);						\
+ 									\
+ 	stipple->size     = 0;						\
+ 	stipple->bits     = NULL;					\
+ 	stipple->freeBits = TRUE;					\
+     }									\
+ }
+ 
+ #if PPW == 4
+ /* See if Tile is can be represented as OpaqueStipple. If so, convert tile
+  * to a packed stipple (no scanline pad).  Code borrowed from sunGX.c.
+  *
+  * XXX - Only works for depth 8 pixmaps currently.
+  */
+ 
+ skyCheckDegenerateTile (pPixmap, pGC)
+     PixmapPtr	    pPixmap;
+     GCPtr           pGC;
+ {
+     skyPrivGCPtr    pSkyPriv = skyGetGCPrivate(pGC);
+     skyStipplePtr   stipple = &pSkyPriv->stipple;
+ 
+     unsigned int    fg = (unsigned int)~0, bg = (unsigned int)~0;
+     unsigned char   *tilebitsLine, *tilebits, tilebit;
+     int		    nbwidth;
+     int		    w, h;
+     int		    x, y;
+     int		    size;
+     Bool            expandTile;
+ 
+     w = pPixmap->drawable.width;
+     h = pPixmap->drawable.height;
+ 
+ 
+     /* If tile width is less than 32 and evenly divisible into 32,
+      * expand the tile to width of 32. Skyway fills faster if tile
+      * is 32 or wider.
+      */
+ 
+ #ifndef NOEXPAND_TEST
+     expandTile = ((w < 32) && !(w & (w - 1)));
+ #else
+     expandTile = FALSE;
+ #endif
+ 
+     if (expandTile)
+ 	size = h*4;
+     else
+ 	size = (h*w + 7) >> 3;
+ 
+     if (size > SKY_MAX_TILESTIP_SIZE) 
+ 	return FALSE;
+ 
+     if (size > stipple->size)
+     {
+ 	if (stipple->freeBits)
+ 	    stipple->bits = (unsigned char *) xrealloc(stipple->bits, size);
+ 	else
+ 	    stipple->bits = (unsigned char *) xalloc(size);
+ 
+ 	if (stipple->bits == NULL)
+ 	{
+ 	    stipple->size     = 0;
+ 	    stipple->freeBits = FALSE;
+ 	    return (FALSE);
+ 	}
+ 
+ 	stipple->size     = size;
+ 	stipple->freeBits = TRUE;
+     }
+ 
+     tilebitsLine = (unsigned char *) pPixmap->devPrivate.ptr;
+     nbwidth = pPixmap->devKind;
+ 
+     if (expandTile)
+     {
+ 	/* Code from sunGXCheckTile() */
+ 
+ 	unsigned long  *sbits = (unsigned long *) stipple->bits;
+ 	unsigned long   sbit, mask;
+ 	int             s_y, s_x;
+ 
+ 	for (y = 0; y < h; y++)
+ 	{
+ 	    tilebits = tilebitsLine;
+ 	    tilebitsLine += nbwidth;
+ 	    sbit = 0;
+ 	    mask = 1 << 31;
+ 	    for (x = 0; x < w; x++)
+ 	    {
+ 		tilebit = *tilebits++;
+ 		if (tilebit == fg)
+ 		    sbit |=  mask;
+ 		else if (tilebit != bg)
+ 		{
+ 		    if (fg == ~0)
+ 		    {
+ 			fg = tilebit;
+ 			sbit |= mask;
+ 		    }
+ 		    else if (bg == ~0)
+ 		    {
+ 			bg = tilebit;
+ 		    }
+ 		    else
+ 		    {
+ 			return FALSE;
+ 		    }
+ 		}
+ 		mask >>= 1;
+ 	    }
+ 	    for (s_x = w; s_x < 32; s_x <<= 1)
+ 		sbit = sbit | (sbit >> s_x);
+ 	    sbits[y] = sbit;
+ 	    /*
+ 	    for (s_y = y; s_y < 32; s_y += h)
+ 		sbits[s_y] = sbit;
+ 	    */
+ 	}
+     }
+     else
+     {
+ 	unsigned char  *dstBits = (unsigned char *) stipple->bits;
+ 	unsigned char   mask;
+ 
+ 	memset(dstBits, 0, size);
+ 
+ 	mask = 1 << 7;
+ 
+ 	for (y = 0; y < h; y++)
+ 	{
+ 	    tilebits = tilebitsLine;
+ 	    tilebitsLine += nbwidth;
+ 	    for (x = 0; x < w; x++)
+ 	    {
+ 		tilebit = *tilebits++;
+ 		if (tilebit == fg)
+ 		    *dstBits |=  mask;
+ 		else if (tilebit != bg)
+ 		{
+ 		    if (bg == ~0)
+ 		    {
+ 			bg = tilebit;
+ 		    }
+ 		    else if (fg == ~0)
+ 		    {
+ 			fg = tilebit;
+ 			*dstBits |= mask;
+ 		    }
+ 		    else
+ 		    {
+ 			FreeStippleData(stipple);
+ 			return FALSE;
+ 		    }
+ 		}
+ 
+ 		mask >>= 1;
+ 		if (mask == 0)
+ 		{
+ 		    mask = 1 << 7;
+ 		    dstBits++;
+ 		}
+ 	    }
+ 	}
+     } /* ! expandTile */
+ 
+     stipple->fgPixel = fg;
+     stipple->bgPixel = bg;
+     stipple->width   = expandTile ? 32 : w;
+     stipple->height  = h;
+     stipple->packed = TRUE;
+ 
+     return TRUE;
+ }
+ #endif /* PPW == 4 */
+ 
+ 
+ /* See if tile is not too big. */
+ 
+ skyCheckTile(pPixmap, pGC)
+     PixmapPtr	    pPixmap;
+     GCPtr           pGC;
+ {
+     skyPrivGCPtr    pSkyPriv = skyGetGCPrivate(pGC);
+     skyStipplePtr   stipple = &pSkyPriv->stipple;
+     int		    size;
+ 
+     if (pGC->tileIsPixel)
+     {
+ 	pSkyPriv->fillMode = fill_solid;
+ 	FreeStippleData(stipple);
+ 	return (TRUE);
+     }
+ 
+ #ifndef NO_DEGEN_TEST
+ #if PPW == 4
+     if (skyCheckDegenerateTile(pPixmap, pGC, stipple))
+     {
+ 	pSkyPriv->fillMode = fill_stipple;
+ 	return (TRUE);
+     }
+ #endif
+ #endif
+ 
+     FreeStippleData(stipple);
+ 
+     size = pPixmap->devKind * pPixmap->drawable.height;
+     if (size <= SKY_MAX_TILESTIP_SIZE)
+     {
+ 	pSkyPriv->fillMode = fill_tile;
+ 	return (TRUE);
+     }
+ 
+     return (FALSE);
+ }
+ 
+ 
+ /* See if stipple is not too big. */
+ 
+ skyCheckStipple (pPixmap, pGC)
+     PixmapPtr	    pPixmap;
+     GCPtr           pGC;
+ {
+     skyPrivGCPtr    pSkyPriv = skyGetGCPrivate(pGC);
+     skyStipplePtr   stipple = &pSkyPriv->stipple;
+ 
+     int		    w, h;
+ 
+     w = pPixmap->drawable.width;
+     h = pPixmap->drawable.height;
+ 
+     stipple->packed = (w & 31) == 0;
+ 
+     if (pPixmap->devKind*h > SKY_MAX_TILESTIP_SIZE)
+ 	return FALSE;
+ 
+     FreeStippleData(stipple);
+ 
+     pSkyPriv->fillMode = fill_stipple;
+ 
+     stipple->bits     = (uchar *) pPixmap->devPrivate.ptr; 
+     stipple->size     = pPixmap->devKind*h;
+ 
+     stipple->fgPixel  = pGC->fgPixel;
+     stipple->bgPixel  = pGC->bgPixel;
+     stipple->width    = w;
+     stipple->height   = h;
+     stipple->freeBits = FALSE;
+ 
+     return TRUE;
+ }
+ 
+ 
+ static  skyStipplePtr tmpStipple = NULL;
+ 
+ skyCheckFill (pGC, pDrawable)
+     GCPtr           pGC;
+     DrawablePtr     pDrawable;
+ {
+     skyPrivGCPtr    pSkyPriv = skyGetGCPrivate(pGC);
+     skyStipplePtr   stipple = &pSkyPriv->stipple;
+ 
+     pSkyPriv->fillMode = punt;	/* punt == Hardware can't handle */
+ 
+     if (pDrawable->type != DRAWABLE_WINDOW)
+ 	return (FALSE);
+ 
+     pSkyPriv->BgFgMix = pGC->alu << 8 | pGC->alu;
+ 
+     switch (pGC->fillStyle)
+     {
+ 	case FillSolid:
+ 	    pSkyPriv->fillMode = fill_solid;
+ 	    FreeStippleData(stipple);
+ 	    return TRUE;
+ 
+ 	case FillTiled:
+ 	    return skyCheckTile (pGC->tile.pixmap, pGC);
+ 	    break;
+ 
+ 	case FillStippled:
+ 	    pSkyPriv->BgFgMix = GXnoop << 8 | pGC->alu;
+ 	    /* Fall Thru */
+ 
+ 	case FillOpaqueStippled:
+ 	    return skyCheckStipple (pGC->stipple, pGC);
+ 	    break;
+     }
+ 
+     return FALSE;
+ }
+ /* ---- */
+ 
+ 
+ 
+ /* Clipping conventions
+ 	if the drawable is a window
+ 	    CT_REGION ==> pCompositeClip really is the composite
+ 	    CT_other ==> pCompositeClip is the window clip region
+ 	if the drawable is a pixmap
+ 	    CT_REGION ==> pCompositeClip is the translated client region
+ 		clipped to the pixmap boundary
+ 	    CT_other ==> pCompositeClip is the pixmap bounding box
+ */
+ 
+ void
  skyValidateGC(pGC, changes, pDrawable)
      register GCPtr  pGC;
      Mask	    changes;
      DrawablePtr	    pDrawable;
  {
!     WindowPtr   pWin;
!     int         mask;		/* stateChanges */
!     int         index;		/* used for stepping through bitfields */
!     int		new_rrop;
!     int         new_line, new_text, new_fillspans, new_fillarea;
!     int		new_rotate;
!     int		xrot, yrot;
!     /* flags for changing the proc vector */
!     cfbPrivGCPtr devPriv;
!     /* ---- */
!     skyPrivGCPtr pSkyPriv = skyGetGCPrivate(pGC);
!     int          scrnNum  = pGC->pScreen->myNum;
!     int          new_tile_id, new_stipple_id;
!     /* ---- */
!     int		oneRect;
  
!     new_rotate = pGC->lastWinOrg.x != pDrawable->x ||
! 		 pGC->lastWinOrg.y != pDrawable->y;
  
!     pGC->lastWinOrg.x = pDrawable->x;
!     pGC->lastWinOrg.y = pDrawable->y;
!     if (pDrawable->type == DRAWABLE_WINDOW)
!     {
! 	pWin = (WindowPtr) pDrawable;
!     }
!     else
!     {
! 	pWin = (WindowPtr) NULL;
!     }
! 
!     devPriv = ((cfbPrivGCPtr) (pGC->devPrivates[cfbGCPrivateIndex].ptr));
! 
!     new_rrop = FALSE;
!     new_line = FALSE;
!     new_text = FALSE;
!     new_fillspans = FALSE;
!     new_fillarea = FALSE;
! 
!     /*
!      * if the client clip is different or moved OR the subwindowMode has
!      * changed OR the window's clip has changed since the last validation
!      * we need to recompute the composite clip 
!      */
! 
!     if ((changes & (GCClipXOrigin|GCClipYOrigin|GCClipMask|GCSubwindowMode)) ||
! 	(pDrawable->serialNumber != (pGC->serialNumber & DRAWABLE_SERIAL_BITS))
! 	)
!     {
! 	ScreenPtr pScreen = pGC->pScreen;
! 
! 	if (pWin) {
! 	    RegionPtr   pregWin;
! 	    Bool        freeTmpClip, freeCompClip;
! 
! 	    if (pGC->subWindowMode == IncludeInferiors) {
! 		pregWin = NotClippedByChildren(pWin);
! 		freeTmpClip = TRUE;
! 	    }
! 	    else {
! 		pregWin = &pWin->clipList;
! 		freeTmpClip = FALSE;
! 	    }
! 	    freeCompClip = devPriv->freeCompClip;
! 
! 	    /*
! 	     * if there is no client clip, we can get by with just keeping
! 	     * the pointer we got, and remembering whether or not should
! 	     * destroy (or maybe re-use) it later.  this way, we avoid
! 	     * unnecessary copying of regions.  (this wins especially if
! 	     * many clients clip by children and have no client clip.) 
! 	     */
! 	    if (pGC->clientClipType == CT_NONE) {
! 		if (freeCompClip)
! 		    (*pScreen->RegionDestroy) (devPriv->pCompositeClip);
! 		devPriv->pCompositeClip = pregWin;
! 		devPriv->freeCompClip = freeTmpClip;
! 	    }
! 	    else {
! 		/*
! 		 * we need one 'real' region to put into the composite
! 		 * clip. if pregWin the current composite clip are real,
! 		 * we can get rid of one. if pregWin is real and the
! 		 * current composite clip isn't, use pregWin for the
! 		 * composite clip. if the current composite clip is real
! 		 * and pregWin isn't, use the current composite clip. if
! 		 * neither is real, create a new region. 
! 		 */
! 
! 		(*pScreen->TranslateRegion)(pGC->clientClip,
! 					    pDrawable->x + pGC->clipOrg.x,
! 					    pDrawable->y + pGC->clipOrg.y);
! 						  
! 		if (freeCompClip)
! 		{
! 		    (*pGC->pScreen->Intersect)(devPriv->pCompositeClip,
! 					       pregWin, pGC->clientClip);
! 		    if (freeTmpClip)
! 			(*pScreen->RegionDestroy)(pregWin);
! 		}
! 		else if (freeTmpClip)
! 		{
! 		    (*pScreen->Intersect)(pregWin, pregWin, pGC->clientClip);
! 		    devPriv->pCompositeClip = pregWin;
! 		}
! 		else
! 		{
! 		    devPriv->pCompositeClip = (*pScreen->RegionCreate)(NullBox,
! 								       0);
! 		    (*pScreen->Intersect)(devPriv->pCompositeClip,
! 					  pregWin, pGC->clientClip);
! 		}
! 		devPriv->freeCompClip = TRUE;
! 		(*pScreen->TranslateRegion)(pGC->clientClip,
! 					    -(pDrawable->x + pGC->clipOrg.x),
! 					    -(pDrawable->y + pGC->clipOrg.y));
! 						  
! 	    }
! 	}			/* end of composite clip for a window */
! 	else {
! 	    BoxRec      pixbounds;
! 
! 	    /* XXX should we translate by drawable.x/y here ? */
! 	    pixbounds.x1 = 0;
! 	    pixbounds.y1 = 0;
! 	    pixbounds.x2 = pDrawable->width;
! 	    pixbounds.y2 = pDrawable->height;
! 
! 	    if (devPriv->freeCompClip)
! 		(*pScreen->RegionReset)(devPriv->pCompositeClip, &pixbounds);
! 	    else {
! 		devPriv->freeCompClip = TRUE;
! 		devPriv->pCompositeClip = (*pScreen->RegionCreate)(&pixbounds,
! 								   1);
! 	    }
! 
! 	    if (pGC->clientClipType == CT_REGION)
! 	    {
! 		(*pScreen->TranslateRegion)(devPriv->pCompositeClip,
! 					    -pGC->clipOrg.x, -pGC->clipOrg.y);
! 		(*pScreen->Intersect)(devPriv->pCompositeClip,
! 				      devPriv->pCompositeClip,
! 				      pGC->clientClip);
! 		(*pScreen->TranslateRegion)(devPriv->pCompositeClip,
! 					    pGC->clipOrg.x, pGC->clipOrg.y);
! 	    }
! 	}			/* end of composute clip for pixmap */
! 	oneRect = REGION_NUM_RECTS(devPriv->pCompositeClip) == 1;
! 	if (oneRect != devPriv->oneRect)
! 	    new_line = TRUE;
! 	devPriv->oneRect = oneRect;
!     }
! 
!     mask = changes;
!     while (mask) {
! 	index = lowbit (mask);
! 	mask &= ~index;
! 
! 	/*
! 	 * this switch acculmulates a list of which procedures might have
! 	 * to change due to changes in the GC.  in some cases (e.g.
! 	 * changing one 16 bit tile for another) we might not really need
! 	 * a change, but the code is being paranoid. this sort of batching
! 	 * wins if, for example, the alu and the font have been changed,
! 	 * or any other pair of items that both change the same thing. 
! 	 */
! 	switch (index) {
! 	case GCFunction:
! 	case GCForeground:
! 	    new_rrop = TRUE;
! 	    break;
! 	case GCPlaneMask:
! 	    new_rrop = TRUE;
! 	    new_text = TRUE;
! 	    break;
! 	case GCBackground:
! 	    break;
! 	case GCLineStyle:
! 	case GCLineWidth:
! 	    new_line = TRUE;
! 	    break;
! 	case GCJoinStyle:
! 	case GCCapStyle:
! 	    break;
! 	case GCFillStyle:
! 	    new_text = TRUE;
! 	    new_fillspans = TRUE;
! 	    new_line = TRUE;
! 	    new_fillarea = TRUE;
! 	    break;
! 	case GCFillRule:
! 	    break;
! 	case GCTile:
! 	    new_fillspans = TRUE;
! 	    new_fillarea = TRUE;
! 	    /* ---- */
! 	    new_tile_id = (pGC->fillStyle == FillTiled);
! 	    /* ---- */
! 	    break;
! 
! 	case GCStipple:
! 	    if (pGC->stipple)
! 	    {
! 		int width = pGC->stipple->drawable.width;
! 		PixmapPtr nstipple;
! 
! 		if ((width <= 32) && !(width & (width - 1)) &&
! 		    (nstipple = cfbCopyPixmap(pGC->stipple)))
! 		{
! 		    cfbPadPixmap(nstipple);
! 		    cfbDestroyPixmap(pGC->stipple);
! 		    pGC->stipple = nstipple;
! 		}
! 	    }
! 	    new_fillspans = TRUE;
! 	    new_fillarea = TRUE;
! 	    /* ---- */
! 	    new_stipple_id = (pGC->fillStyle==FillStippled ||
! 			    pGC->fillStyle==FillOpaqueStippled);
! 	    /* ---- */
! 	    break;
! 
! 	case GCTileStipXOrigin:
! 	    new_rotate = TRUE;
! 	    break;
! 
! 	case GCTileStipYOrigin:
! 	    new_rotate = TRUE;
! 	    break;
! 
! 	case GCFont:
! 	    new_text = TRUE;
! 	    break;
! 	case GCSubwindowMode:
! 	    break;
! 	case GCGraphicsExposures:
! 	    break;
! 	case GCClipXOrigin:
! 	    break;
! 	case GCClipYOrigin:
! 	    break;
! 	case GCClipMask:
! 	    break;
! 	case GCDashOffset:
! 	    break;
! 	case GCDashList:
! 	    break;
! 	case GCArcMode:
! 	    break;
! 	default:
! 	    break;
! 	}
!     }
! 
! 
! 
!     /* ---- */
!     /* If there is a new tile, assign it a new (unique) ID. */
! 
!     if (new_tile_id)
!     {
! 	if ((!pGC->tileIsPixel) && (pGC->tile.pixmap))
! 	    skyNewTileStipID(scrnNum, &pSkyPriv->tileStipID);
!     }
! 
!   
!     /* If there is a new stipple, assign it a new (unique) ID. */
! 
!     if (new_stipple_id)
!     {
! 	if (pGC->stipple)
! 	    skyNewTileStipID(scrnNum, &pSkyPriv->tileStipID);
!     }
!     /* ---- */
! 
! 
!     /*
!      * If the drawable has changed,  ensure suitable
!      * entries are in the proc vector. 
!      */
!     if (pDrawable->serialNumber != (pGC->serialNumber & (DRAWABLE_SERIAL_BITS))) {
! 	new_fillspans = TRUE;	/* deal with FillSpans later */
!     }
! 
!     if (new_rotate || new_fillspans)
!     {
! 	Bool new_pix = FALSE;
! 
! 	xrot = pGC->patOrg.x + pDrawable->x;
! 	yrot = pGC->patOrg.y + pDrawable->y;
! 
! 	if (!skyCheckFill(pGC,pDrawable))
! 	{
! 	switch (pGC->fillStyle)
! 	{
! 	case FillTiled:
! 	    if (!pGC->tileIsPixel)
! 	    {
! 		int width = pGC->tile.pixmap->drawable.width * PSZ;
! 
! 		if ((width <= 32) && !(width & (width - 1)))
! 		{
! 		    cfbCopyRotatePixmap(pGC->tile.pixmap,
! 					&devPriv->pRotatedPixmap,
! 					xrot, yrot);
! 		    new_pix = TRUE;
! 		}
! 	    }
! 	    break;
! #if (PPW == 4)
! 	case FillStippled:
! 	case FillOpaqueStippled:
! 	    {
! 		int width = pGC->stipple->drawable.width;
! 
! 		if ((width <= 32) && !(width & (width - 1)))
! 		{
! 		    mfbCopyRotatePixmap(pGC->stipple,
! 					&devPriv->pRotatedPixmap, xrot, yrot);
! 		    new_pix = TRUE;
! 		}
! 	    }
! 	    break;
! #endif
! 	}
! 	}
! 
! 	if (!new_pix && devPriv->pRotatedPixmap)
! 	{
! 	    cfbDestroyPixmap(devPriv->pRotatedPixmap);
! 	    devPriv->pRotatedPixmap = (PixmapPtr) NULL;
! 	}
!     }
! 
!     if (new_rrop)
!     {
! 	int old_rrop;
! 
! 	/* ---- */
! 	if (pGC->fillStyle == FillStippled)
! 	    pSkyPriv->BgFgMix = GXnoop << 8 | pGC->alu;
! 	else
! 	    pSkyPriv->BgFgMix = pGC->alu << 8 | pGC->alu;
! 
! 	if (pSkyPriv->fillMode == fill_stipple)
! 	{
! 	    if (pGC->fillStyle != FillTiled)
! 	    {
! 		pSkyPriv->stipple.fgPixel = pGC->fgPixel;
! 		pSkyPriv->stipple.bgPixel = pGC->bgPixel;
! 	    }
! 	}
! 	/* ---- */
! 
! 	old_rrop = devPriv->rop;
! 	devPriv->rop = cfbReduceRasterOp (pGC->alu, pGC->fgPixel,
! 					   pGC->planemask,
! 					   &devPriv->and, &devPriv->xor);
! 	if (old_rrop == devPriv->rop)
! 	    new_rrop = FALSE;
! 	else
! 	{
! #if PPW ==  4
! 	    new_line = TRUE;
! 	    new_text = TRUE;
! #endif
! 	    new_fillspans = TRUE;
! 	    new_fillarea = TRUE;
! 	}
!     }
! 
!     if (new_rrop || new_fillspans || new_text || new_fillarea || new_line)
!     {
! 	GCOps	*newops;
! 
! 	if (newops = skyMatchCommon (pDrawable, pGC, devPriv))
!  	{
! 	    if (pGC->ops->devPrivate.val)
! 		skyDestroyOps (pGC->ops);
! 	    pGC->ops = newops;
! 	    new_rrop = new_line = new_fillspans = new_text = new_fillarea = 0;
! 	}
!  	else
!  	{
! 	    if (!pGC->ops->devPrivate.val)
! 	    {
! 		pGC->ops = skyCreateOps (pGC->ops);
! 		pGC->ops->devPrivate.val = 1;
! 	    }
! 	}
!     }
! 
!     /* deal with the changes we've collected */
!     if (new_line)
!     {
! 	pGC->ops->FillPolygon = miFillPolygon;
! 	if (devPriv->oneRect && pGC->fillStyle == FillSolid)
! 	{
! 	    switch (devPriv->rop) {
! 	    case GXcopy:
! 		pGC->ops->FillPolygon = cfbFillPoly1RectCopy;
! 		break;
! 	    default:
! 		pGC->ops->FillPolygon = cfbFillPoly1RectGeneral;
! 		break;
! 	    }
! 	}
! 	if (pGC->lineWidth == 0)
! 	{
! #if PPW == 4
! 	    if ((pGC->lineStyle == LineSolid) && (pGC->fillStyle == FillSolid))
! 	    {
! 		switch (devPriv->rop)
! 		{
! 		case GXxor:
! 		    pGC->ops->PolyArc = cfbZeroPolyArcSS8Xor;
! 		    break;
! 		case GXcopy:
! 		    pGC->ops->PolyArc = cfbZeroPolyArcSS8Copy;
! 		    break;
! 		default:
! 		    pGC->ops->PolyArc = cfbZeroPolyArcSS8General;
! 		    break;
! 		}
! 	    }
! 	    else
! #endif
! 		pGC->ops->PolyArc = miZeroPolyArc;
! 	}
! 	else
! 	    pGC->ops->PolyArc = miPolyArc;
! 	pGC->ops->PolySegment = miPolySegment;
! 	switch (pGC->lineStyle)
! 	{
! 	case LineSolid:
! 	    if(pGC->lineWidth == 0)
! 	    {
! 		if (pGC->fillStyle == FillSolid)
! 		{
! #if PPW == 4
! 		    if (devPriv->oneRect)
! 		    {
! 			pGC->ops->Polylines = cfb8LineSS1Rect;
! 			pGC->ops->PolySegment = cfb8SegmentSS1Rect;
! 		    } else
! #endif
! 		    {
! 		    	pGC->ops->Polylines = cfbLineSS;
! 		    	pGC->ops->PolySegment = cfbSegmentSS;
! 		    }
! 		}
!  		else
! 		    pGC->ops->Polylines = miZeroLine;
! 	    }
! 	    else
! 		pGC->ops->Polylines = miWideLine;
! 	    break;
! 	case LineOnOffDash:
! 	case LineDoubleDash:
! 	    if (pGC->lineWidth == 0 && pGC->fillStyle == FillSolid)
! 	    {
! 		pGC->ops->Polylines = cfbLineSD;
! 		pGC->ops->PolySegment = cfbSegmentSD;
! 	    } else
! 		pGC->ops->Polylines = miWideDash;
! 	    break;
! 	}
!     }
! 
!     if (new_text && (pGC->font))
!     {
!         if (FONTMAXBOUNDS(pGC->font,rightSideBearing) -
!             FONTMINBOUNDS(pGC->font,leftSideBearing) > 32 ||
! 	    FONTMINBOUNDS(pGC->font,characterWidth) < 0)
!         {
!             pGC->ops->PolyGlyphBlt = miPolyGlyphBlt;
!             pGC->ops->ImageGlyphBlt = miImageGlyphBlt;
!         }
!         else
!         {
! #if PPW == 4
! 	    if (pGC->fillStyle == FillSolid)
! 	    {
! 		if (devPriv->rop == GXcopy)
! 		    pGC->ops->PolyGlyphBlt = cfbPolyGlyphBlt8;
! 		else
! 		    pGC->ops->PolyGlyphBlt = cfbPolyGlyphRop8;
! 	    }
! 	    else
! #endif
! 		pGC->ops->PolyGlyphBlt = miPolyGlyphBlt;
!             /* special case ImageGlyphBlt for terminal emulator fonts */
!             if (TERMINALFONT(pGC->font) &&
! 		(pGC->planemask & PMSK) == PMSK
! #if PPW == 4
! 		&& FONTMAXBOUNDS(pGC->font,characterWidth) >= 4
! #endif
! 		)
! 	    {
! #if PPW == 4
!                 pGC->ops->ImageGlyphBlt = cfbTEGlyphBlt8;
! #else
!                 pGC->ops->ImageGlyphBlt = cfbTEGlyphBlt;
! #endif
! 	    }
!             else
! 	    {
! #if PPW == 4
! 		if (devPriv->rop == GXcopy &&
! 		    pGC->fillStyle == FillSolid &&
! 		    (pGC->planemask & PMSK) == PMSK)
! 		    pGC->ops->ImageGlyphBlt = cfbImageGlyphBlt8;
! 		else
! #endif
! 		    pGC->ops->ImageGlyphBlt = miImageGlyphBlt;
! 	    }
!         }
!     }    
! 
! 
!     if (new_fillspans) {
! 	switch (pGC->fillStyle) {
! 	case FillSolid:
! 	    switch (devPriv->rop) {
! 	    case GXcopy:
! 		pGC->ops->FillSpans = cfbSolidSpansCopy;
! 		break;
! 	    case GXxor:
! 		pGC->ops->FillSpans = cfbSolidSpansXor;
! 		break;
! 	    default:
! 		pGC->ops->FillSpans = cfbSolidSpansGeneral;
! 		break;
! 	    }
! 	    break;
! 	case FillTiled:
! 	    if (devPriv->pRotatedPixmap)
! 	    {
! 		if (pGC->alu == GXcopy && (pGC->planemask & PMSK) == PMSK)
! 		    pGC->ops->FillSpans = cfbTile32FSCopy;
! 		else
! 		    pGC->ops->FillSpans = cfbTile32FSGeneral;
! 	    }
! 	    else
! 		pGC->ops->FillSpans = cfbUnnaturalTileFS;
! 	    break;
! 	case FillStippled:
! #if PPW == 4
! 	    if (devPriv->pRotatedPixmap)
! 		pGC->ops->FillSpans = cfb8Stipple32FS;
! 	    else
! #endif
! 		pGC->ops->FillSpans = cfbUnnaturalStippleFS;
! 	    break;
! 	case FillOpaqueStippled:
! #if PPW == 4
! 	    if (devPriv->pRotatedPixmap)
! 		pGC->ops->FillSpans = cfb8OpaqueStipple32FS;
! 	    else
! #endif
! 		pGC->ops->FillSpans = cfbUnnaturalStippleFS;
! 	    break;
! 	default:
! 	    FatalError("skyValidateGC: illegal fillStyle\n");
! 	}
!     } /* end of new_fillspans */
! 
!     if (new_fillarea) {
! #if PPW != 4
! 	pGC->ops->PolyFillRect = miPolyFillRect;
! 	if (pGC->fillStyle == FillSolid || pGC->fillStyle == FillTiled
! 		|| pSkyPriv->fillMode != punt)
! 	{
! 	    pGC->ops->PolyFillRect = skyPolyFillRect;
! 	}
! #endif
! #if PPW == 4
! 	pGC->ops->PushPixels = mfbPushPixels;
! 	if (pGC->fillStyle == FillSolid && devPriv->rop == GXcopy)
! 	    pGC->ops->PushPixels = cfbPushPixels8;
! #endif
! 	pGC->ops->PolyFillArc = miPolyFillArc;
! 	if (pGC->fillStyle == FillSolid)
! 	{
! 	    switch (devPriv->rop)
! 	    {
! 	    case GXcopy:
! 		pGC->ops->PolyFillArc = cfbPolyFillArcSolidCopy;
! 		break;
! 	    default:
! 		pGC->ops->PolyFillArc = cfbPolyFillArcSolidGeneral;
! 		break;
! 	    }
! 	}
!     }
! }
! 
! void
! skyDestroyClip(pGC)
!     GCPtr	pGC;
! {
!     if(pGC->clientClipType == CT_NONE)
! 	return;
!     else if (pGC->clientClipType == CT_PIXMAP)
!     {
! 	cfbDestroyPixmap((PixmapPtr)(pGC->clientClip));
!     }
!     else
!     {
! 	/* we know we'll never have a list of rectangles, since
! 	   ChangeClip immediately turns them into a region 
! 	*/
!         (*pGC->pScreen->RegionDestroy)(pGC->clientClip);
!     }
!     pGC->clientClip = NULL;
!     pGC->clientClipType = CT_NONE;
! }
! 
! void
! skyChangeClip(pGC, type, pvalue, nrects)
!     GCPtr	pGC;
!     int		type;
!     pointer	pvalue;
!     int		nrects;
! {
!     skyDestroyClip(pGC);
!     if(type == CT_PIXMAP)
!     {
! 	pGC->clientClip = (pointer) (*pGC->pScreen->BitmapToRegion)((PixmapPtr)pvalue);
! 	(*pGC->pScreen->DestroyPixmap)(pvalue);
!     }
!     else if (type == CT_REGION) {
! 	/* stuff the region in the GC */
! 	pGC->clientClip = pvalue;
!     }
!     else if (type != CT_NONE)
!     {
! 	pGC->clientClip = (pointer) (*pGC->pScreen->RectsToRegion)(nrects,
! 						    (xRectangle *)pvalue,
! 						    type);
! 	xfree(pvalue);
!     }
!     pGC->clientClipType = (type != CT_NONE && pGC->clientClip) ? CT_REGION :
! 								 CT_NONE;
!     pGC->stateChanges |= GCClipMask;
! }
! 
! void
! skyCopyClip (pgcDst, pgcSrc)
!     GCPtr pgcDst, pgcSrc;
! {
!     RegionPtr prgnNew;
! 
!     switch(pgcSrc->clientClipType)
!     {
!       case CT_PIXMAP:
! 	((PixmapPtr) pgcSrc->clientClip)->refcnt++;
! 	/* Fall through !! */
!       case CT_NONE:
!         skyChangeClip(pgcDst, (int)pgcSrc->clientClipType, pgcSrc->clientClip,
! 		      0);
!         break;
!       case CT_REGION:
!         prgnNew = (*pgcSrc->pScreen->RegionCreate)(NULL, 1);
!         (*pgcSrc->pScreen->RegionCopy)(prgnNew,
!                                        (RegionPtr)(pgcSrc->clientClip));
!         skyChangeClip(pgcDst, CT_REGION, (pointer)prgnNew, 0);
!         break;
!     }
! }
! 
! /*ARGSUSED*/
! void
! skyCopyGC (pGCSrc, changes, pGCDst)
!     GCPtr	pGCSrc;
!     Mask 	changes;
!     GCPtr	pGCDst;
! {
!     return;
  }
