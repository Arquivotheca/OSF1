Path: news.crl.dec.com!pa.dec.com!nobody
Message-Id: <9202251954.AA28281@explain.lcs.mit.edu>
To: fix-trackers@expo.lcs.mit.edu
Subject: (seq: 2380) first version of XTEST extension
Date: Tue, 25 Feb 92 14:54:09 EST
From: Bob Scheifler <rws@expo.lcs.mit.edu>
Distribution: dec
X-Mailing-List: fix-trackers@expo.lcs.mit.edu
X-Disclaimer: This message originated from a mailing list outside of Digital.
Newsgroups: dec.mail.lists.x.fix-trackers
Approved: news@usenet.pa.dec.com

the following is a first version of the XTEST extension we expect
UniSoft to use for the new test suite work.  the extension may
change as work proceeds, but we are shipping it now so you can
begin to integrate in your environment and review it.


*** /tmp/,RCSt1025716	Tue Feb 25 11:19:31 1992
--- config/Project.tmpl	Tue Feb 25 11:19:32 1992
***************
*** 1,6 ****
  XCOMM -------------------------------------------------------------------------
  XCOMM X Window System Build Parameters
! XCOMM $XConsortium: Project.tmpl,v 1.139 91/10/10 19:39:06 rws Exp $
  
  /*****************************************************************************
   *                                                                           *
--- 1,6 ----
  XCOMM -------------------------------------------------------------------------
  XCOMM X Window System Build Parameters
! XCOMM $XConsortium: Project.tmpl,v 1.142 92/01/25 16:44:02 rws Exp $
  
  /*****************************************************************************
   *                                                                           *
***************
*** 44,49 ****
--- 44,55 ----
  #ifndef BuildXInputLib
  #define BuildXInputLib		YES
  #endif
+ #ifndef BuildXTrapExt
+ #define BuildXTrapExt		NO
+ #endif
+ #ifndef BuildXTrapLib
+ #define BuildXTrapLib		NO
+ #endif
  #ifndef InstallLibManPages
  #define InstallLibManPages	YES
  #endif
***************
*** 123,128 ****
--- 129,152 ----
  #ifndef ProfileLibXdmcp
  #define ProfileLibXdmcp		NO	/* profiled XDMCP library */
  #endif
+ #ifndef DebugLibXinput
+ #define DebugLibXinput		NO	/* debugged Xi library */
+ #endif
+ #ifndef ProfileLibXinput
+ #define ProfileLibXinput	NO	/* profiled Xi library */
+ #endif
+ #ifndef DebugLibXTest
+ #define DebugLibXTest		NO	/* debugged XTest library */
+ #endif
+ #ifndef ProfileLibXTest
+ #define ProfileLibXTest		NO	/* profiled XTest library */
+ #endif
+ #ifndef DebugLibXTrap
+ #define DebugLibXTrap		NO	/* debugged XTrap library */
+ #endif
+ #ifndef ProfileLibXTrap
+ #define ProfileLibXTrap		NO	/* profiled XTrap library */
+ #endif
  #ifndef ManDirectoryRoot
  #ifdef ProjectRoot
  #define ManDirectoryRoot Concat(ProjectRoot,/man)
***************
*** 212,219 ****
  #define XInputDefines /**/
  #endif
  #endif
  #ifndef BaseExtensionDefines
! #define BaseExtensionDefines -DSHAPE -DMULTIBUFFER -DMITMISC PexDefines ShmDefines XInputDefines
  #endif
  #define ExtensionDefines BaseExtensionDefines ExtensionOSDefines
  #endif
--- 236,250 ----
  #define XInputDefines /**/
  #endif
  #endif
+ #ifndef XTrapDefines
+ #if BuildXTrapExt
+ #define XTrapDefines -DXTRAP
+ #else
+ #define XTrapDefines /**/
+ #endif
+ #endif
  #ifndef BaseExtensionDefines
! #define BaseExtensionDefines -DSHAPE -DMULTIBUFFER -DMITMISC -DXTEST PexDefines ShmDefines XInputDefines XTrapDefines
  #endif
  #define ExtensionDefines BaseExtensionDefines ExtensionOSDefines
  #endif
***************
*** 434,439 ****
--- 465,482 ----
  #ifndef NormalLibXinput
  #define NormalLibXinput (!SharedLibXinput | ForceNormalLib)
  #endif
+ #ifndef SharedLibXTest
+ #define SharedLibXTest HasSharedLibraries
+ #endif
+ #ifndef NormalLibXTest
+ #define NormalLibXTest (!SharedLibXTest | ForceNormalLib)
+ #endif
+ #ifndef SharedLibXTrap
+ #define SharedLibXTrap 	HasSharedLibaries
+ #endif
+ #ifndef NormalLibXTrap
+ #define NormalLibXTrap 	(!SharedLibXTrap | ForceNormalLib)
+ #endif
  #ifndef SharedLibPhigs
  #define SharedLibPhigs NO	/* XXX - haven't made it sharable yet */
  #endif
***************
*** 530,543 ****
         AWIDGETSRC = $(LIBSRC)/Xaw
         OLDXLIBSRC = $(LIBSRC)/oldX
        XDMCPLIBSRC = $(LIBSRC)/Xdmcp
!       BDFTOSNFSRC = $(FONTSRC)/bdftosnf
        BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
        BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
       MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
           FSLIBSRC = $(FONTSRC)/lib/fs
      FONTSERVERSRC = $(FONTSRC)/server
       EXTENSIONSRC = $(TOP)/extensions
           XILIBSRC = $(EXTENSIONSRC)/lib/xinput
        PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
  
  /*
--- 573,589 ----
         AWIDGETSRC = $(LIBSRC)/Xaw
         OLDXLIBSRC = $(LIBSRC)/oldX
        XDMCPLIBSRC = $(LIBSRC)/Xdmcp
! #ifdef SnfFonts
        BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
+ #else
        BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
+ #endif
       MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
           FSLIBSRC = $(FONTSRC)/lib/fs
      FONTSERVERSRC = $(FONTSRC)/server
       EXTENSIONSRC = $(TOP)/extensions
           XILIBSRC = $(EXTENSIONSRC)/lib/xinput
+       XTESTLIBSRC = $(EXTENSIONSRC)/lib/xtest
        PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
  
  /*
***************
*** 586,591 ****
--- 632,639 ----
           SOXMUREV = SharedXmuRev
          SOXEXTREV = SharedXextRev
        SOXINPUTREV = SharedXinputRev
+        SOXTESTREV = SharedXTestRev
+        SOXTRAPREV = SharedXTrapRev
  #endif
  
  #if !SharedLibXext
***************
*** 619,624 ****
--- 667,676 ----
  #if !SharedLibXinput
          DEPXILIB = _UseCat($(USRLIBDIR),$(XILIBSRC),/libXi.a)
             XILIB = LoaderLibPrefix _Use(-lXi,$(DEPXILIB))
+ #endif
+ #if !SharedLibXTest
+      DEPXTESTLIB = _UseCat($(USRLIBDIR),$(XTESTLIBSRC),/libXtst.a)
+         XTESTLIB = LoaderLibPrefix _Use(-lXtst,$(DEPXTESTLIB))
  #endif
  #if !SharedLibPhigs
          DEPPHIGSLIB = _UseCat($(USRLIBDIR),$(PHIGSLIBSRC),/libphigs.a)
*** /tmp/,RCSt1024874	Tue Feb 25 09:42:31 1992
--- config/sunLib.tmpl	Tue Feb 25 09:42:32 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: sunLib.tmpl,v 1.14 91/12/20 11:19:05 rws Exp $
  
  /*
   * SunOS shared library template
--- 1,4 ----
! XCOMM $XConsortium: sunLib.tmpl,v 1.15 92/01/25 16:46:49 rws Exp $
  
  /*
   * SunOS shared library template
***************
*** 25,30 ****
--- 25,33 ----
  #ifndef SharedXinputRev
  #define SharedXinputRev 4.10
  #endif
+ #ifndef SharedXTestRev
+ #define SharedXTestRev 1.0
+ #endif
  #ifndef SharedXTrapRev
  #define SharedXTrapRev 1.0
  #endif
***************
*** 68,71 ****
--- 71,78 ----
  #if SharedLibXinput
          DEPXILIB = /* _UseCat($(USRLIBDIR),$(XILIBSRC),/libXi.sa.$(SOXINPUTREV)) */
             XILIB = _Use(-lXi,-L$(XILIBSRC) -lXi)
+ #endif
+ #if SharedLibXTest
+         DEPXTESTLIB = /* _UseCat($(USRLIBDIR),$(XTESTLIBSRC),/libXtst.sa.$(SOXTESTREV)) */
+            XTESTLIB = _Use(-lXtst,-L$(XTESTLIBSRC) -lXtst)
  #endif
*** /tmp/d24841	Tue Feb 25 09:40:05 1992
--- config/sv4Lib.tmpl	Sat Jan 25 16:48:12 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: sv4Lib.tmpl,v 1.4 91/07/19 15:38:11 rws Exp $
  
  /*
   * SVR4 shared library template
--- 1,4 ----
! XCOMM $XConsortium: sv4Lib.tmpl,v 1.6 92/01/25 16:46:55 rws Exp $
  
  /*
   * SVR4 shared library template
***************
*** 25,30 ****
--- 25,36 ----
  #ifndef SharedXinputRev
  #define SharedXinputRev 5.0
  #endif
+ #ifndef SharedXTestRev
+ #define SharedXTestRev 1.0
+ #endif
+ #ifndef SharedXTrapRev
+ #define SharedXTrapRev 1.0
+ #endif
  
  SHLIBLDFLAGS = SharedLibraryLoadFlags
  PICFLAGS = PositionIndependentCFlags
***************
*** 66,69 ****
--- 72,79 ----
  #if SharedLibXinput
          DEPXILIB = /* _UseCat($(USRLIBDIR),$(XILIBSRC),/libXi.sa.$(SOXINPUTREV)) */
             XILIB = _Use(-lXi,-L$(XILIBSRC) -lXi)
+ #endif
+ #if SharedLibXTest
+         DEPXTESTLIB = /* _UseCat($(USRLIBDIR),$(XTESTLIBSRC),/libXtst.sa.$(SOXTESTREV)) */
+            XTESTLIB = _Use(-lXtst,-L$(XTESTLIBSRC) -lXtst)
  #endif
*** /tmp/d24860	Tue Feb 25 09:40:17 1992
--- config/ibmLib.tmpl	Tue Feb 25 09:37:15 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: ibmLib.tmpl,v 1.2 91/05/04 11:49:00 rws Exp $
  
  /*
   * AIX shared library template
--- 1,4 ----
! XCOMM $XConsortium: ibmLib.tmpl,v 1.3 92/02/25 09:36:32 rws Exp $
  
  /*
   * AIX shared library template
***************
*** 37,40 ****
--- 37,44 ----
  #if SharedLibXinput
          DEPXILIB = /* _UseCat($(USRLIBDIR),$(XILIBSRC),/libXi.a) */
             XILIB = _Use(-lXi,-L$(XILIBSRC) -lXi)
+ #endif
+ #if SharedLibXTest
+         DEPXTESTLIB = /* _UseCat($(USRLIBDIR),$(XTESTLIBSRC),/libXtst.sa.$(SOXTESTREV)) */
+            XTESTLIB = _Use(-lXtst,-L$(XTESTLIBSRC) -lXtst)
  #endif
*** /tmp/d24900	Tue Feb 25 09:49:48 1992
--- extensions/include/Imakefile	Sat Jan 25 16:34:36 1992
***************
*** 1,12 ****
! XCOMM $XConsortium: Imakefile,v 1.24 91/07/16 23:08:47 gildea Exp $
  #if BuildPexClients || BuildPexExt
  #define IHaveSubdirs
  #define PassCDebugFlags 'CDEBUGFLAGS=$(CDEBUGFLAGS)'
-       SUBDIRS = PEX
  #endif
  
  HEADERS = Xext.h multibuf.h shape.h XShm.h MITMisc.h XI.h XInput.h XIproto.h \
! 	xtestext1.h
  INSTALLFLAGS = $(INSTINCFLAGS)
  
  all::
--- 1,20 ----
! XCOMM $XConsortium: Imakefile,v 1.26 92/01/25 16:33:13 rws Exp $
  #if BuildPexClients || BuildPexExt
  #define IHaveSubdirs
+       PEXDIRS = PEX
+ #endif
+ #if BuildXTrapExt || BuildXTrapLib
+ #define IHaveSubdirs
+     XTRAPDIRS = xtrap
+ #endif
+ 
+ #ifdef IHaveSubdirs
  #define PassCDebugFlags 'CDEBUGFLAGS=$(CDEBUGFLAGS)'
  #endif
+ SUBDIRS = $(PEXDIRS) $(XTRAPDIRS)
  
  HEADERS = Xext.h multibuf.h shape.h XShm.h MITMisc.h XI.h XInput.h XIproto.h \
! 	XTest.h xtestext1.h
  INSTALLFLAGS = $(INSTINCFLAGS)
  
  all::
*** /dev/null	Tue Feb 25 09:49:49 1992
--- extensions/include/XTest.h	Sat Feb  1 15:08:49 1992
***************
*** 0 ****
--- 1,100 ----
+ /* $XConsortium: XTest.h,v 1.2 92/02/01 15:05:45 rws Exp $ */
+ /*
+ 
+ Copyright 1992 by the Massachusetts Institute of Technology
+ 
+ Permission to use, copy, modify, distribute, and sell this software and its
+ documentation for any purpose is hereby granted without fee, provided that
+ the above copyright notice appear in all copies and that both that
+ copyright notice and this permission notice appear in supporting
+ documentation, and that the name of M.I.T. not be used in advertising or
+ publicity pertaining to distribution of the software without specific,
+ written prior permission.  M.I.T. makes no representations about the
+ suitability of this software for any purpose.  It is provided "as is"
+ without express or implied warranty.
+ 
+ */
+ 
+ #ifndef _XTEST_H_
+ #define _XTEST_H_
+ 
+ #include <X11/Xfuncproto.h>
+ 
+ _XFUNCPROTOBEGIN
+ 
+ Bool XTestQueryExtension(
+ #if NeedFunctionPrototypes
+     Display*		/* dpy */,
+     int*		/* event_basep */,
+     int*		/* error_basep */,
+     int*		/* majorp */,
+     int*		/* minorp */
+ #endif
+ );
+ 
+ Bool XTestCompareCursorWithWindow(
+ #if NeedFunctionPrototypes
+     Display*		/* dpy */,
+     Window		/* window */,
+     Cursor		/* cursor */
+ #endif
+ );
+ 
+ Bool XTestCompareCurrentCursorWithWindow(
+ #if NeedFunctionPrototypes
+     Display*		/* dpy */,
+     Window		/* window */
+ #endif
+ );
+ 
+ extern XTestFakeKeyEvent(
+ #if NeedFunctionPrototypes
+     Display*		/* dpy */,
+     unsigned int	/* keycode */,
+     Bool		/* is_press */,
+     unsigned long	/* delay */
+ #endif
+ );
+ 
+ extern XTestFakeButtonEvent(
+ #if NeedFunctionPrototypes
+     Display*		/* dpy */,
+     unsigned int	/* button */,
+     Bool		/* is_press */,
+     unsigned long	/* delay */
+ #endif
+ );
+ 
+ extern XTestFakeMotionEvent(
+ #if NeedFunctionPrototypes
+     Display*		/* dpy */,
+     int			/* screen */,
+     int			/* x */,
+     int			/* y */,
+     unsigned long	/* delay */
+ #endif
+ );
+ 
+ void XTestSetGContextOfGC(
+ #if NeedFunctionPrototypes
+     GC			/* gc */,
+     GContext		/* gid */
+ #endif
+ );
+ 
+ void XTestSetVisualIDOfVisual(
+ #if NeedFunctionPrototypes
+     Visual*		/* visual */,
+     VisualID		/* visualid */
+ #endif
+ );
+ 
+ Status XTestDiscard(
+ #if NeedFunctionPrototypes
+     Display*		/* dpy */
+ #endif
+ );
+ 
+ _XFUNCPROTOEND
+ 
+ #endif
*** /dev/null	Tue Feb 25 09:49:59 1992
--- extensions/include/xteststr.h	Wed Feb  5 16:21:02 1992
***************
*** 0 ****
--- 1,97 ----
+ /* $XConsortium: xteststr.h,v 1.3 92/02/05 16:18:15 rws Exp $ */
+ /*
+ 
+ Copyright 1992 by the Massachusetts Institute of Technology
+ 
+ Permission to use, copy, modify, distribute, and sell this software and its
+ documentation for any purpose is hereby granted without fee, provided that
+ the above copyright notice appear in all copies and that both that
+ copyright notice and this permission notice appear in supporting
+ documentation, and that the name of M.I.T. not be used in advertising or
+ publicity pertaining to distribution of the software without specific,
+ written prior permission.  M.I.T. makes no representations about the
+ suitability of this software for any purpose.  It is provided "as is"
+ without express or implied warranty.
+ 
+ */
+ 
+ #define X_XTestGetVersion	0
+ #define X_XTestCompareCursor	1
+ #define X_XTestFakeInput	2
+ 
+ #define XTestNumberEvents	0
+ 
+ #define XTestNumberErrors	0
+ 
+ #define XTEST_MAJOR	1
+ #define XTEST_MINOR	0
+ 
+ #define XTestCurrentCursor ((Cursor)1)
+ 
+ #define XTESTNAME "XTEST"
+ 
+ typedef struct {
+     CARD8	reqType;	/* always XTestReqCode */
+     CARD8	xtReqType;	/* always X_XTestGetVersion */
+     CARD16	length B16;
+     CARD8	majorVersion;
+     CARD8	pad;
+     CARD16	minorVersion B16;
+ } xXTestGetVersionReq;
+ #define sz_xXTestGetVersionReq 8
+ 
+ typedef struct {
+     BYTE	type;			/* X_Reply */
+     CARD8	majorVersion;
+     CARD16	sequenceNumber B16;
+     CARD32	length B32;
+     CARD16	minorVersion B16;
+     CARD16	pad0 B16;
+     CARD32	pad1 B32;
+     CARD32	pad2 B32;
+     CARD32	pad3 B32;
+     CARD32	pad4 B32;
+     CARD32	pad5 B32;
+ } xXTestGetVersionReply;
+ #define sz_xXTestGetVersionReply 32
+ 
+ typedef struct {
+     CARD8	reqType;	/* always XTestReqCode */
+     CARD8	xtReqType;	/* always X_XTestCompareCursor */
+     CARD16	length B16;
+     Window	window B32;
+     Cursor	cursor B32;
+ } xXTestCompareCursorReq;
+ #define sz_xXTestCompareCursorReq 12
+ 
+ typedef struct {
+     BYTE	type;			/* X_Reply */
+     BOOL	same;
+     CARD16	sequenceNumber B16;
+     CARD32	length B32;
+     CARD32	pad0 B32;
+     CARD32	pad1 B32;
+     CARD32	pad2 B32;
+     CARD32	pad3 B32;
+     CARD32	pad4 B32;
+     CARD32	pad5 B32;
+ } xXTestCompareCursorReply;
+ #define sz_xXTestCompareCursorReply 32
+ 
+ /* used only on the client side */
+ typedef struct {
+     CARD8	reqType;	/* always XTestReqCode */
+     CARD8	xtReqType;	/* always X_XTestFakeInput */
+     CARD16	length B16;
+     BYTE	type;
+     BYTE	detail;
+     CARD16	pad0 B16;
+     Time	time B32;
+     Window	root B32;
+     CARD32	pad1 B32;
+     CARD32	pad2 B32;
+     INT16	rootX B16, rootY B16;
+     CARD32	pad3 B32;
+     CARD32	pad4 B32;
+ } xXTestFakeInputReq;
+ #define sz_xXTestFakeInputReq 36
*** /tmp/d24958	Tue Feb 25 09:50:39 1992
--- extensions/lib/Imakefile	Sat Jan 25 16:14:05 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.33 91/07/22 22:56:37 rws Exp $
  #define DoNormalLib NormalLibXext
  #define DoSharedLib SharedLibXext
  #define DoDebugLib DebugLibXext
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.36 92/01/25 16:12:44 rws Exp $
  #define DoNormalLib NormalLibXext
  #define DoSharedLib SharedLibXext
  #define DoDebugLib DebugLibXext
***************
*** 9,17 ****
  REQUIREDLIBS = $(XLIBSRC)/libX11.a
  #endif
  
- #if BuildXInputLib || BuildPexClients
  #define IHaveSubdirs
  #define PassCDebugFlags 'CDEBUGFLAGS=$(CDEBUGFLAGS)'
  #if BuildXInputLib
        XINPUTDIRS = xinput
  #endif
--- 9,17 ----
  REQUIREDLIBS = $(XLIBSRC)/libX11.a
  #endif
  
  #define IHaveSubdirs
  #define PassCDebugFlags 'CDEBUGFLAGS=$(CDEBUGFLAGS)'
+ 
  #if BuildXInputLib
        XINPUTDIRS = xinput
  #endif
***************
*** 18,25 ****
  #if BuildPexClients
        PEXDIRS = PEX
  #endif
!       SUBDIRS = $(XINPUTDIRS) $(PEXDIRS)
  #endif
  
  #if HasShm
        SHMSRCS = XShm.c
--- 18,27 ----
  #if BuildPexClients
        PEXDIRS = PEX
  #endif
! #if BuildXTrapLib
!       XTRAPDIRS = xtrap
  #endif
+       SUBDIRS = $(XINPUTDIRS) $(PEXDIRS) $(XTRAPDIRS) xtest
  
  #if HasShm
        SHMSRCS = XShm.c
*** /dev/null	Tue Feb 25 09:50:41 1992
--- extensions/lib/xtest/Imakefile	Tue Feb 25 09:35:03 1992
***************
*** 0 ****
--- 1,46 ----
+ XCOMM $XConsortium: Imakefile,v 1.2 92/02/25 09:34:18 rws Exp $
+ #define DoNormalLib NormalLibXTest
+ #define DoSharedLib SharedLibXTest
+ #define DoDebugLib DebugLibXTest
+ #define DoProfileLib ProfileLibXTest
+ #include <Library.tmpl>
+ 
+ #ifdef RsArchitecture
+ REQUIREDLIBS = $(EXTENSIONSRC)/lib/libXext.a $(XLIBSRC)/libX11.a
+ #endif
+ 
+ INCLUDES = -I$(TOP) -I$(XLIBSRC) -I../../include
+ 
+ SRCS = XTest.c
+ OBJS = XTest.o
+ 
+ LINTLIBS = $(LINTXLIB)
+ 
+ LibraryObjectRule()
+ 
+ #if DoSharedLib
+ #if DoNormalLib
+ SharedLibraryTarget(Xtst,$(SOXTESTREV),$(OBJS),shared,..)
+ #else
+ SharedLibraryTarget(Xtst,$(SOXTESTREV),$(OBJS),.,.)
+ #endif
+ InstallSharedLibrary(Xtst,$(SOXTESTREV),$(USRLIBDIR))
+ #endif
+ #if DoNormalLib
+ NormalLibraryTarget(Xtst,$(OBJS))
+ InstallLibrary(Xtst,$(USRLIBDIR))
+ #endif
+ #if DoProfileLib
+ ProfiledLibraryTarget(Xtst,$(OBJS))
+ InstallLibrary(Xtst_p,$(USRLIBDIR))
+ #endif
+ #if DoDebugLib
+ DebuggedLibraryTarget(Xtst,$(OBJS))
+ #endif
+ 
+ LintLibraryTarget(Xtst,$(SRCS))
+ InstallLintLibrary(Xtst,$(LINTLIBDIR))
+ 
+ DependTarget()
+ 
+ NormalLintTarget($(SRCS))
*** /dev/null	Tue Feb 25 09:51:09 1992
--- extensions/lib/xtest/XTest.c	Wed Feb  5 16:20:39 1992
***************
*** 0 ****
--- 1,244 ----
+ /* $XConsortium: XTest.c,v 1.5 92/02/05 16:17:47 rws Exp $ */
+ /*
+ 
+ Copyright 1990, 1991 by UniSoft Group Limited
+ Copyright 1992 by the Massachusetts Institute of Technology
+ 
+ Permission to use, copy, modify, distribute, and sell this software and its
+ documentation for any purpose is hereby granted without fee, provided that
+ the above copyright notice appear in all copies and that both that
+ copyright notice and this permission notice appear in supporting
+ documentation, and that the name of M.I.T. not be used in advertising or
+ publicity pertaining to distribution of the software without specific,
+ written prior permission.  M.I.T. makes no representations about the
+ suitability of this software for any purpose.  It is provided "as is"
+ without express or implied warranty.
+ 
+ */
+ 
+ #define NEED_REPLIES
+ #include "Xlibint.h"
+ #include "XTest.h"
+ #include "xteststr.h"
+ #include "Xext.h"
+ #include "extutil.h"
+ 
+ static XExtensionInfo _xtest_info_data;
+ static XExtensionInfo *xtest_info = &_xtest_info_data;
+ static /* const */ char *xtest_extension_name = XTESTNAME;
+ 
+ #define XTestCheckExtension(dpy,i,val) \
+   XextCheckExtension (dpy, i, xtest_extension_name, val)
+ 
+ /*****************************************************************************
+  *                                                                           *
+  *			   private utility routines                          *
+  *                                                                           *
+  *****************************************************************************/
+ 
+ static int close_display();
+ static /* const */ XExtensionHooks xtest_extension_hooks = {
+     NULL,				/* create_gc */
+     NULL,				/* copy_gc */
+     NULL,				/* flush_gc */
+     NULL,				/* free_gc */
+     NULL,				/* create_font */
+     NULL,				/* free_font */
+     close_display,			/* close_display */
+     NULL,				/* wire_to_event */
+     NULL,				/* event_to_wire */
+     NULL,				/* error */
+     NULL				/* error_string */
+ };
+ 
+ static XEXT_GENERATE_FIND_DISPLAY (find_display, xtest_info,
+ 				   xtest_extension_name, 
+ 				   &xtest_extension_hooks, XTestNumberEvents,
+ 				   NULL)
+ 
+ static XEXT_GENERATE_CLOSE_DISPLAY (close_display, xtest_info)
+ 
+ /*****************************************************************************
+  *                                                                           *
+  *		    public routines               			     *
+  *                                                                           *
+  *****************************************************************************/
+ 
+ Bool
+ XTestQueryExtension (dpy, event_basep, error_basep, majorp, minorp)
+     Display *dpy;
+     int *event_basep, *error_basep;
+     int *majorp, *minorp;
+ {
+     XExtDisplayInfo *info = find_display (dpy);
+     register xXTestGetVersionReq *req;
+     xXTestGetVersionReply rep;
+ 
+     if (XextHasExtension(info)) {
+ 	LockDisplay(dpy);
+ 	GetReq(XTestGetVersion, req);
+ 	req->reqType = info->codes->major_opcode;
+ 	req->xtReqType = X_XTestGetVersion;
+ 	req->majorVersion = XTEST_MAJOR;
+ 	req->minorVersion = XTEST_MINOR;
+ 	if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+ 	    UnlockDisplay(dpy);
+ 	    SyncHandle();
+ 	    return False;
+ 	}
+ 	UnlockDisplay(dpy);
+ 	SyncHandle();
+ 	*event_basep = info->codes->first_event;
+ 	*error_basep = info->codes->first_error;
+ 	*majorp = rep.majorVersion;
+ 	*minorp = rep.minorVersion;
+ 	return True;
+     } else {
+ 	return False;
+     }
+ }
+ 
+ Bool
+ XTestCompareCursorWithWindow(dpy, window, cursor)
+     Display *dpy;
+     Window window;
+     Cursor cursor;
+ {
+     XExtDisplayInfo *info = find_display (dpy);
+     register xXTestCompareCursorReq *req;
+     xXTestCompareCursorReply rep;
+ 
+     XTestCheckExtension (dpy, info, 0);
+ 
+     LockDisplay(dpy);
+     GetReq(XTestCompareCursor, req);
+     req->reqType = info->codes->major_opcode;
+     req->xtReqType = X_XTestCompareCursor;
+     req->window = window;
+     req->cursor = cursor;
+     if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
+ 	UnlockDisplay(dpy);
+ 	SyncHandle();
+ 	return False;
+     }
+     UnlockDisplay(dpy);
+     SyncHandle();
+     return rep.same;
+ }
+ 
+ Bool
+ XTestCompareCurrentCursorWithWindow(dpy, window)
+     Display *dpy;
+     Window window;
+ {
+     return XTestCompareCursorWithWindow(dpy, window, XTestCurrentCursor);
+ }
+ 
+ XTestFakeKeyEvent(dpy, keycode, is_press, delay)
+     Display *dpy;
+     unsigned int keycode;
+     Bool is_press;
+     unsigned long delay;
+ {
+     XExtDisplayInfo *info = find_display (dpy);
+     register xXTestFakeInputReq *req;
+ 
+     XTestCheckExtension (dpy, info, 0);
+ 
+     LockDisplay(dpy);
+     GetReq(XTestFakeInput, req);
+     req->reqType = info->codes->major_opcode;
+     req->xtReqType = X_XTestFakeInput;
+     req->type = is_press ? KeyPress : KeyRelease;
+     req->detail = keycode;
+     req->time = delay;
+     UnlockDisplay(dpy);
+     SyncHandle();
+ }
+ 
+ XTestFakeButtonEvent(dpy, button, is_press, delay)
+     Display *dpy;
+     unsigned int button;
+     Bool is_press;
+     unsigned long delay;
+ {
+     XExtDisplayInfo *info = find_display (dpy);
+     register xXTestFakeInputReq *req;
+ 
+     XTestCheckExtension (dpy, info, 0);
+ 
+     LockDisplay(dpy);
+     GetReq(XTestFakeInput, req);
+     req->reqType = info->codes->major_opcode;
+     req->xtReqType = X_XTestFakeInput;
+     req->type = is_press ? ButtonPress : ButtonRelease;
+     req->detail = button;
+     req->time = delay;
+     UnlockDisplay(dpy);
+     SyncHandle();
+ }
+ 
+ XTestFakeMotionEvent(dpy, screen, x, y, delay)
+     Display *dpy;
+     int screen;
+     int x, y;
+     unsigned long delay;
+ {
+     XExtDisplayInfo *info = find_display (dpy);
+     register xXTestFakeInputReq *req;
+ 
+     XTestCheckExtension (dpy, info, 0);
+ 
+     LockDisplay(dpy);
+     GetReq(XTestFakeInput, req);
+     req->reqType = info->codes->major_opcode;
+     req->xtReqType = X_XTestFakeInput;
+     req->type = MotionNotify;
+     req->root = RootWindow(dpy, screen);
+     req->rootX = x;
+     req->rootY = y;
+     req->time = delay;
+     UnlockDisplay(dpy);
+     SyncHandle();
+ }
+ 
+ void
+ XTestSetGContextOfGC(gc, gid)
+     GC gc;
+     GContext gid;
+ {
+     gc->gid = gid;
+ }
+ 
+ void
+ XTestSetVisualIDOfVisual(visual, visualid)
+     Visual *visual;
+     VisualID visualid;
+ {
+     visual->visualid = visualid;
+ }
+ 
+ static xReq _dummy_request = {
+ 	0, 0, 0
+ };
+ 
+ Status
+ XTestDiscard(dpy)
+     Display *dpy;
+ {
+     Bool something;
+     register char *ptr;
+ 
+     LockDisplay(dpy);
+     if (something = (dpy->bufptr != dpy->buffer)) {
+ 	for (ptr = dpy->buffer;
+ 	     ptr < dpy->bufptr;
+ 	     ptr += (((xReq *)ptr)->length << 2))
+ 	    dpy->request--;
+ 	dpy->bufptr = dpy->buffer;
+ 	dpy->last_req = (char *)&_dummy_request;
+     }
+     UnlockDisplay(dpy);
+     SyncHandle();
+     return something;
+ }
*** /tmp/,RCSt1028239	Tue Feb 25 14:31:31 1992
--- extensions/server/Imakefile	Tue Feb 25 14:30:38 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 5.15 91/07/16 23:09:51 gildea Exp $
  #include <Server.tmpl>
  
  #if BuildXInputExt || BuildPexExt || BuildPexClients
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 5.18 92/02/25 14:29:04 eswu Exp $
  #include <Server.tmpl>
  
  #if BuildXInputExt || BuildPexExt || BuildPexClients
***************
*** 15,29 ****
    PEXDIRS = PEX/dipex/swap
  #endif
  #endif
  #if HasShm
    SHMSRCS = shm.c
    SHMOBJS = shm.o
  #endif
!        SRCS = shape.c $(SHMSRCS) multibuf.c mitmisc.c xtest1di.c xtest1dd.c
!        OBJS = shape.o $(SHMOBJS) multibuf.o mitmisc.o xtest1di.o xtest1dd.o
     INCLUDES = -I../include -I$(INCLUDESRC) -I$(SERVERSRC)/include
     LINTLIBS = ../../server/dix/llib-ldix.ln ../../server/os/4.2bsd/llib-los.ln
!         SUBDIRS = $(XINPUTDIRS) $(PEXDIRS)
  
  NormalLibraryObjectRule()
  NormalLibraryTarget(ext,$(OBJS))
--- 15,34 ----
    PEXDIRS = PEX/dipex/swap
  #endif
  #endif
+ #if BuildXTrapExt
+   XTRAPDIRS = xtrap
+ #endif
  #if HasShm
    SHMSRCS = shm.c
    SHMOBJS = shm.o
  #endif
!        SRCS = shape.c $(SHMSRCS) multibuf.c mitmisc.c xtest.c \
! 		xtest1di.c xtest1dd.c sleepuntil.c
!        OBJS = shape.o $(SHMOBJS) multibuf.o mitmisc.o xtest.o \
! 		xtest1di.o xtest1dd.o sleepuntil.o
     INCLUDES = -I../include -I$(INCLUDESRC) -I$(SERVERSRC)/include
     LINTLIBS = ../../server/dix/llib-ldix.ln ../../server/os/4.2bsd/llib-los.ln
!         SUBDIRS = $(XINPUTDIRS) $(PEXDIRS) $(XTRAPDIRS)
  
  NormalLibraryObjectRule()
  NormalLibraryTarget(ext,$(OBJS))
*** /dev/null	Tue Feb 25 09:51:19 1992
--- extensions/server/sleepuntil.c	Mon Feb 24 19:02:47 1992
***************
*** 0 ****
--- 1,199 ----
+ /*
+  * $XConsortium: sleepuntil.c,v 1.1 92/02/24 19:02:27 keith Exp $
+  *
+  * Copyright 1992 Massachusetts Institute of Technology
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and its
+  * documentation for any purpose is hereby granted without fee, provided that
+  * the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of M.I.T. not be used in advertising or
+  * publicity pertaining to distribution of the software without specific,
+  * written prior permission.  M.I.T. makes no representations about the
+  * suitability of this software for any purpose.  It is provided "as is"
+  * without express or implied warranty.
+  *
+  * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.
+  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * Author:  Keith Packard, MIT X Consortium
+  */
+ 
+ /* dixsleep.c - implement millisecond timeouts for X clients */
+ 
+ #include "X.h"
+ #include "Xmd.h"
+ #include "misc.h"
+ #include "windowstr.h"
+ #include "dixstruct.h"
+ #include "pixmapstr.h"
+ #include "scrnintstr.h"
+ 
+ typedef struct _Sertafied {
+     struct _Sertafied	*next;
+     TimeStamp		revive;
+     ClientPtr		pClient;
+     XID			id;
+     void		(*notifyFunc)();
+     pointer		closure;
+ } SertafiedRec, *SertafiedPtr;
+ 
+ static SertafiedPtr pPending;
+ static RESTYPE	    SertafiedResType;
+ static Bool	    BlockHandlerRegistered;
+ static int	    SertafiedGeneration;
+ static void	    WachetAuf();
+ static void	    SertafiedDelete();
+ static void	    SertafiedBlockHandler();
+ static void	    SertafiedWakeupHandler();
+ 
+ ClientSleepUntil (client, revive, notifyFunc, closure)
+     ClientPtr	client;
+     TimeStamp	*revive;
+     void	(*notifyFunc)();
+     pointer	closure;
+ {
+     SertafiedPtr	pRequest, pReq, pPrev;
+ 
+     if (SertafiedGeneration != serverGeneration)
+     {
+ 	SertafiedResType = CreateNewResourceType (SertafiedDelete);
+ 	if (!SertafiedResType)
+ 	    return FALSE;
+ 	SertafiedGeneration = serverGeneration;
+ 	BlockHandlerRegistered = FALSE;
+     }
+     pRequest = (SertafiedPtr) xalloc (sizeof (SertafiedRec));
+     if (!pRequest)
+ 	return FALSE;
+     pRequest->pClient = client;
+     pRequest->revive = *revive;
+     pRequest->id = FakeClientID (client->index);
+     pRequest->closure = closure;
+     if (!BlockHandlerRegistered)
+     {
+ 	if (!RegisterBlockAndWakeupHandlers (SertafiedBlockHandler,
+ 					     SertafiedWakeupHandler,
+ 					     (pointer) 0))
+ 	{
+ 	    xfree (pRequest);
+ 	    return FALSE;
+ 	}
+ 	BlockHandlerRegistered = TRUE;
+     }
+     pRequest->notifyFunc = 0;
+     if (!AddResource (pRequest->id, SertafiedResType, (pointer) pRequest))
+ 	return FALSE;
+     if (!notifyFunc)
+ 	notifyFunc = WachetAuf;
+     pRequest->notifyFunc = notifyFunc;
+     /* Insert into time-ordered queue, with earliest activation time coming first. */
+     pPrev = 0;
+     for (pReq = pPending; pReq; pReq = pReq->next)
+     {
+ 	if (CompareTimeStamps (pReq->revive, *revive) == LATER)
+ 	    break;
+ 	pPrev = pReq;
+     }
+     if (pPrev)
+ 	pPrev->next = pRequest;
+     else
+ 	pPending = pRequest;
+     pRequest->next = pReq;
+     IgnoreClient (client);
+     return TRUE;
+ }
+ 
+ static void
+ WachetAuf (client, closure)
+     ClientPtr	client;
+     pointer	closure;
+ {
+     if (!client->clientGone)
+ 	AttendClient (client);
+ }
+ 
+ 
+ static void
+ SertafiedDelete (pRequest)
+     SertafiedPtr	pRequest;
+ {
+     SertafiedPtr	pReq, pPrev;
+ 
+     pPrev = 0;
+     for (pReq = pPending; pReq; pReq = pReq->next)
+ 	if (pReq == pRequest)
+ 	{
+ 	    if (pPrev)
+ 		pPrev->next = pReq->next;
+ 	    else
+ 		pPending = pReq->next;
+ 	    break;
+ 	}
+     if (pRequest->notifyFunc)
+ 	(*pRequest->notifyFunc) (pRequest->pClient, pRequest->closure);
+     xfree (pRequest);
+ }
+ 
+ static void
+ SertafiedBlockHandler (data, wt, LastSelectMask)
+     pointer	    data;		/* unused */
+     pointer	    wt;			/* wait time */
+     long	    *LastSelectMask;
+ {
+     SertafiedPtr	    pReq, pNext;
+     unsigned long	    newdelay, olddelay;
+     TimeStamp		    now;
+ 
+     if (!pPending)
+ 	return;
+     now.milliseconds = GetTimeInMillis ();
+     now.months = currentTime.months;
+     if ((int) (now.milliseconds - currentTime.milliseconds) < 0)
+ 	now.months++;
+     for (pReq = pPending; pReq; pReq = pNext)
+     {
+ 	pNext = pReq->next;
+ 	if (CompareTimeStamps (pReq->revive, now) == LATER)
+ 	    break;
+ 	FreeResource (pReq->id, RT_NONE);
+     }
+     pReq = pPending;
+     if (!pReq)
+ 	return;
+     newdelay = pReq->revive.milliseconds - now.milliseconds;
+     AdjustWaitForDelay (wt, newdelay);
+ }
+ 
+ static void
+ SertafiedWakeupHandler (data, i, LastSelectMask)
+     pointer	    data;
+     int		    i;
+     long	    *LastSelectMask;
+ {
+     SertafiedPtr	pReq, pNext;
+     TimeStamp		now;
+ 
+     now.milliseconds = GetTimeInMillis ();
+     now.months = currentTime.months;
+     if ((int) (now.milliseconds - currentTime.milliseconds) < 0)
+ 	now.months++;
+     for (pReq = pPending; pReq; pReq = pNext)
+     {
+ 	pNext = pReq->next;
+ 	if (CompareTimeStamps (pReq->revive, now) == LATER)
+ 	    break;
+ 	FreeResource (pReq->id, RT_NONE);
+     }
+     if (!pPending)
+     {
+ 	RemoveBlockAndWakeupHandlers (SertafiedBlockHandler,
+ 				      SertafiedWakeupHandler,
+ 				      (pointer) 0);
+ 	BlockHandlerRegistered = FALSE;
+     }
+ }
*** /dev/null	Tue Feb 25 14:22:13 1992
--- extensions/server/xtest.c	Tue Feb 25 14:22:09 1992
***************
*** 0 ****
--- 1,344 ----
+ /* $XConsortium: xtest.c,v 1.8 92/02/25 14:21:31 rws Exp $ */
+ /*
+ 
+ Copyright 1992 by the Massachusetts Institute of Technology
+ 
+ Permission to use, copy, modify, distribute, and sell this software and its
+ documentation for any purpose is hereby granted without fee, provided that
+ the above copyright notice appear in all copies and that both that
+ copyright notice and this permission notice appear in supporting
+ documentation, and that the name of M.I.T. not be used in advertising or
+ publicity pertaining to distribution of the software without specific,
+ written prior permission.  M.I.T. makes no representations about the
+ suitability of this software for any purpose.  It is provided "as is"
+ without express or implied warranty.
+ 
+ */
+ 
+ #include "X.h"
+ #define NEED_EVENTS
+ #include "Xproto.h"
+ #include "misc.h"
+ #include "os.h"
+ #include "dixstruct.h"
+ #include "extnsionst.h"
+ #include "windowstr.h"
+ #include "inputstr.h"
+ #include "scrnintstr.h"
+ #include "xteststr.h"
+ 
+ static unsigned char XTestReqCode;
+ static int ProcXTestDispatch(), SProcXTestDispatch();
+ static void XTestResetProc();
+ static int XTestSwapFakeInput();
+ CursorPtr GetSpriteCursor();
+ WindowPtr GetCurrentRootWindow();
+ 
+ void
+ XTestExtensionInit()
+ {
+     ExtensionEntry *extEntry, *AddExtension();
+ 
+     if (extEntry = AddExtension(XTESTNAME, 0, 0,
+ 				 ProcXTestDispatch, SProcXTestDispatch,
+ 				 XTestResetProc, StandardMinorOpcode))
+ 	XTestReqCode = (unsigned char)extEntry->base;
+ }
+ 
+ /*ARGSUSED*/
+ static void
+ XTestResetProc (extEntry)
+ ExtensionEntry	*extEntry;
+ {
+ }
+ 
+ static int
+ ProcXTestGetVersion(client)
+     register ClientPtr client;
+ {
+     REQUEST(xXTestGetVersionReq);
+     xXTestGetVersionReply rep;
+     register int n;
+ 
+     REQUEST_SIZE_MATCH(xXTestGetVersionReq);
+     rep.type = X_Reply;
+     rep.length = 0;
+     rep.sequenceNumber = client->sequence;
+     rep.majorVersion = XTEST_MAJOR;
+     rep.minorVersion = XTEST_MINOR;
+     if (client->swapped) {
+     	swaps(&rep.sequenceNumber, n);
+ 	swaps(&rep.minorVersion, n);
+     }
+     WriteToClient(client, sizeof(xXTestGetVersionReply), (char *)&rep);
+     return(client->noClientException);
+ }
+ 
+ static int
+ ProcXTestCompareCursor(client)
+     register ClientPtr client;
+ {
+     REQUEST(xXTestCompareCursorReq);
+     xXTestCompareCursorReply rep;
+     WindowPtr pWin;
+     CursorPtr pCursor;
+     register int n;
+ 
+     REQUEST_SIZE_MATCH(xXTestCompareCursorReq);
+     pWin = (WindowPtr)LookupWindow(stuff->window, client);
+     if (!pWin)
+         return(BadWindow);
+     if (stuff->cursor == None)
+ 	pCursor = NullCursor;
+     else if (stuff->cursor == XTestCurrentCursor)
+ 	pCursor = GetSpriteCursor();
+     else {
+ 	pCursor = (CursorPtr)LookupIDByType(stuff->cursor, RT_CURSOR);
+ 	if (!pCursor) 
+ 	{
+ 	    client->errorValue = stuff->cursor;
+ 	    return (BadCursor);
+ 	}
+     }
+     rep.type = X_Reply;
+     rep.length = 0;
+     rep.sequenceNumber = client->sequence;
+     rep.same = (wCursor(pWin) == pCursor);
+     if (client->swapped) {
+     	swaps(&rep.sequenceNumber, n);
+     }
+     WriteToClient(client, sizeof(xXTestCompareCursorReply), (char *)&rep);
+     return(client->noClientException);
+ }
+ 
+ static int
+ ProcXTestFakeInput(client)
+     register ClientPtr client;
+ {
+     REQUEST(xReq);
+     int nev;
+     int	n;
+     xEvent *ev;
+     DeviceIntPtr dev;
+     WindowPtr root;
+ 
+     nev = (stuff->length << 2) - sizeof(xReq);
+     if (nev % sizeof(xEvent))
+ 	return BadLength;
+     nev /= sizeof(xEvent);
+     if (nev != 1)
+ 	return BadLength; /* for now */
+     UpdateCurrentTime();
+     ev = (xEvent *)&stuff[1];
+     switch (ev->u.u.type & 0177)
+     {
+     case KeyPress:
+     case KeyRelease:
+     case MotionNotify:
+     case ButtonPress:
+     case ButtonRelease:
+ 	break;
+     default:
+ 	client->errorValue = ev->u.u.type;
+ 	return BadValue;
+     }
+     if (ev->u.keyButtonPointer.time)
+     {
+ 	TimeStamp activateTime;
+ 	CARD32 ms;
+ 
+ 	activateTime = currentTime;
+ 	ms = activateTime.milliseconds + ev->u.keyButtonPointer.time;
+ 	if (ms < activateTime.milliseconds)
+ 	    activateTime.months++;
+ 	activateTime.milliseconds = ms;
+ 	ev->u.keyButtonPointer.time = 0;
+ 	/* swap the request back so we can simply re-execute it */
+ 	if (client->swapped)
+ 	{
+     	    (void) XTestSwapFakeInput(client, stuff);
+ 	    swaps(&stuff->length, n);
+ 	}
+ 	ResetCurrentRequest (client);
+ 	client->sequence--;
+ 	if (!ClientSleepUntil(client, &activateTime, NULL, NULL))
+ 	{
+ 	    /* 
+ 	     * flush this request - must be in this order because
+ 	     * ResetCurrentRequest adds the client back to 
+ 	     * clientsWithInput which will cause the client to
+ 	     * keep going, instead of waiting for the timeout.
+ 	     */
+ 	    (void) ReadRequestFromClient (client);
+ 	    client->sequence++;
+ 	    return BadAlloc;
+ 	}
+ 	return Success;
+     }
+     switch (ev->u.u.type & 0177)
+     {
+     case KeyPress:
+     case KeyRelease:
+ 	dev = (DeviceIntPtr)LookupKeyboardDevice();
+ 	if (ev->u.u.detail < dev->key->curKeySyms.minKeyCode ||
+ 	    ev->u.u.detail > dev->key->curKeySyms.maxKeyCode)
+ 	{
+ 	    client->errorValue = ev->u.u.detail;
+ 	    return BadValue;
+ 	}
+ 	break;
+     case MotionNotify:
+ 	dev = (DeviceIntPtr)LookupPointerDevice();
+ 	root = LookupWindow(ev->u.keyButtonPointer.root, client);
+ 	if (!root)
+ 	    return BadWindow;
+ 	if (root->parent)
+ 	{
+ 	    client->errorValue = ev->u.keyButtonPointer.root;
+ 	    return BadValue;
+ 	}
+ 	if (ev->u.keyButtonPointer.rootX < 0 ||
+ 	    ev->u.keyButtonPointer.rootX > root->drawable.width)
+ 	{
+ 	    client->errorValue = ev->u.keyButtonPointer.rootX;
+ 	    return BadValue;
+ 	}
+ 	if (ev->u.keyButtonPointer.rootY < 0 ||
+ 	    ev->u.keyButtonPointer.rootY > root->drawable.height)
+ 	{
+ 	    client->errorValue = ev->u.keyButtonPointer.rootY;
+ 	    return BadValue;
+ 	}
+ 	if (root != GetCurrentRootWindow())
+ 	{
+ 	    NewCurrentScreen(root->drawable.pScreen,
+ 			     ev->u.keyButtonPointer.rootX,
+ 			     ev->u.keyButtonPointer.rootY);
+ 	    return client->noClientException;
+ 	}
+ 	(*root->drawable.pScreen->SetCursorPosition)
+ 	    (root->drawable.pScreen,
+ 	     ev->u.keyButtonPointer.rootX,
+ 	     ev->u.keyButtonPointer.rootY, FALSE);
+ 	break;
+     case ButtonPress:
+     case ButtonRelease:
+ 	dev = (DeviceIntPtr)LookupPointerDevice();
+ 	for (n = 1; n <= dev->button->numButtons; n++)
+ 	    if (dev->button->map[n] == ev->u.u.detail)
+ 		break;
+ 	if (n > dev->button->numButtons)
+ 	{
+ 	    client->errorValue = ev->u.u.detail;
+ 	    return BadValue;
+ 	}
+ 	ev->u.u.detail = n;
+ 	break;
+     }
+     ev->u.keyButtonPointer.time = currentTime.milliseconds;
+     (*dev->public.processInputProc)(ev, (DevicePtr)dev, 1); 
+     return client->noClientException;
+ }
+ 
+ static int
+ ProcXTestDispatch (client)
+     register ClientPtr	client;
+ {
+     REQUEST(xReq);
+     switch (stuff->data)
+     {
+     case X_XTestGetVersion:
+ 	return ProcXTestGetVersion(client);
+     case X_XTestCompareCursor:
+ 	return ProcXTestCompareCursor(client);
+     case X_XTestFakeInput:
+ 	return ProcXTestFakeInput(client);
+     default:
+ 	return BadRequest;
+     }
+ }
+ 
+ static int
+ SProcXTestGetVersion(client)
+     register ClientPtr	client;
+ {
+     register int n;
+     REQUEST(xXTestGetVersionReq);
+ 
+     swaps(&stuff->length, n);
+     REQUEST_SIZE_MATCH(xXTestGetVersionReq);
+     swaps(&stuff->minorVersion, n);
+     return ProcXTestGetVersion(client);
+ }
+ 
+ static int
+ SProcXTestCompareCursor(client)
+     register ClientPtr	client;
+ {
+     register int n;
+     REQUEST(xXTestCompareCursorReq);
+ 
+     swaps(&stuff->length, n);
+     REQUEST_SIZE_MATCH(xXTestCompareCursorReq);
+     swapl(&stuff->window, n);
+     swapl(&stuff->cursor, n);
+     return ProcXTestCompareCursor(client);
+ }
+ 
+ static int
+ XTestSwapFakeInput(client, req)
+     register ClientPtr	client;
+     xReq *req;
+ {
+     register int nev;
+     register xEvent *ev;
+     xEvent sev;
+     void (*proc)(), NotImplemented();
+ 
+     nev = ((req->length << 2) - sizeof(xReq)) / sizeof(xEvent);
+     for (ev = (xEvent *)&req[1]; --nev >= 0; ev++)
+     {
+     	/* Swap event */
+     	proc = EventSwapVector[ev->u.u.type & 0177];
+ 	/* no swapping proc; invalid event type? */
+     	if (!proc || (int (*)()) proc == (int (*)()) NotImplemented) {
+ 	    client->errorValue = ev->u.u.type;
+ 	    return BadValue;
+ 	}
+     	(*proc)(ev, &sev);
+ 	*ev = sev;
+     }
+     return Success;
+ }
+ 
+ static int
+ SProcXTestFakeInput(client)
+     register ClientPtr	client;
+ {
+     register int n;
+     REQUEST(xReq);
+ 
+     swaps(&stuff->length, n);
+     n = XTestSwapFakeInput(client, stuff);
+     if (n != Success)
+ 	return n;
+     return ProcXTestFakeInput(client);
+ }
+ 
+ static int
+ SProcXTestDispatch (client)
+     register ClientPtr	client;
+ {
+     REQUEST(xReq);
+     switch (stuff->data)
+     {
+     case X_XTestGetVersion:
+ 	return SProcXTestGetVersion(client);
+     case X_XTestCompareCursor:
+ 	return SProcXTestCompareCursor(client);
+     case X_XTestFakeInput:
+ 	return SProcXTestFakeInput(client);
+     default:
+ 	return BadRequest;
+     }
+ }
*** /tmp/d25085	Tue Feb 25 09:56:19 1992
--- extensions/test/Imakefile	Mon Jan 27 11:22:31 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.22 91/08/22 12:26:06 rws Exp $
  
  #if BuildXInputLib
  #define IHaveSubdirs
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.24 92/01/27 11:20:39 rws Exp $
  
  #if BuildXInputLib
  #define IHaveSubdirs
***************
*** 6,13 ****
        SUBDIRS = xinput
  #endif
  
-     DEFINES = ExtensionDefines
- IMAKE_DEFINES = $(DEFINES)
    SHAPESRCS = shapetest.c
    SHAPEOBJS = shapetest.o
  #if HasShm
--- 6,11 ----
***************
*** 16,29 ****
  #endif
     MBUFSRCS = xmbufinfo.c
     MBUFOBJS = xmbufinfo.o
     INCLUDES = -I../include
!        SRCS = $(SHAPESRCS) $(SHMSRCS) $(MBUFSRCS)
!        OBJS = $(SHAPEOBJS) $(SHMOBJS) $(MBUFOBJS)
  
  #if HasShm
! all:: shapetest shmtest xmbufinfo
  #else
! all:: shapetest xmbufinfo
  #endif
  
  NormalProgramTarget(xmbufinfo,$(MBUFOBJS),$(DEPXLIB),$(XLIB),NullParameter)
--- 14,29 ----
  #endif
     MBUFSRCS = xmbufinfo.c
     MBUFOBJS = xmbufinfo.o
+   XTESTSRCS = xtesttest.c
+   XTESTOBJS = xtesttest.o
     INCLUDES = -I../include
!        SRCS = $(SHAPESRCS) $(SHMSRCS) $(MBUFSRCS) $(XTESTSRCS)
!        OBJS = $(SHAPEOBJS) $(SHMOBJS) $(MBUFOBJS) $(XTESTOBJS)
  
  #if HasShm
! all:: shapetest shmtest xmbufinfo xtesttest
  #else
! all:: shapetest xmbufinfo xtesttest
  #endif
  
  NormalProgramTarget(xmbufinfo,$(MBUFOBJS),$(DEPXLIB),$(XLIB),NullParameter)
***************
*** 31,36 ****
--- 31,37 ----
  #if HasShm
  NormalProgramTarget(shmtest,$(SHMOBJS),$(DEPXLIB),$(XLIB),NullParameter)
  #endif
+ NormalProgramTarget(xtesttest,$(XTESTOBJS),$(DEPXTESTLIB) $(DEPXLIB),$(XTESTLIB) $(XLIB),NullParameter)
  
  DependTarget()
  
*** /dev/null	Tue Feb 25 09:56:20 1992
--- extensions/test/xtesttest.c	Tue Feb 25 09:58:13 1992
***************
*** 0 ****
--- 1,162 ----
+ /* $XConsortium: xtesttest.c,v 1.4 92/02/25 09:57:39 keith Exp $ */
+ /*
+ 
+ Copyright 1992 by the Massachusetts Institute of Technology
+ 
+ Permission to use, copy, modify, distribute, and sell this software and its
+ documentation for any purpose is hereby granted without fee, provided that
+ the above copyright notice appear in all copies and that both that
+ copyright notice and this permission notice appear in supporting
+ documentation, and that the name of M.I.T. not be used in advertising or
+ publicity pertaining to distribution of the software without specific,
+ written prior permission.  M.I.T. makes no representations about the
+ suitability of this software for any purpose.  It is provided "as is"
+ without express or implied warranty.
+ 
+ */
+ 
+ #include <stdio.h>
+ #include <X11/Xlib.h>
+ #include <X11/Xos.h>
+ #include <X11/extensions/XTest.h>
+ #include <X11/cursorfont.h>
+ #include <X11/keysym.h>
+ 
+ char *ProgramName;
+ 
+ static void usage ()
+ {
+     fprintf (stderr, "usage:  %s [-display dpy]\n", ProgramName);
+     exit (1);
+ }
+ 
+ main (argc, argv)
+     int argc;
+     char **argv;
+ {
+     char *displayname = NULL;
+     Display *dpy;
+     int i;    
+     int event_base, error_base;
+     int major_version, minor_version;
+     unsigned long req;
+     GC gc;
+     XID gid;
+     Window w;
+     XSetWindowAttributes swa;
+     int key, minkey, maxkey;
+     XEvent ev, second_ev, third_ev;
+     long    delta_time;
+ 
+     ProgramName = argv[0];
+     for (i = 1; i < argc; i++) {
+ 	char *arg = argv[i];
+ 
+ 	if (arg[0] == '-') {
+ 	    switch (arg[1]) {
+ 	      case 'd':			/* -display dpy */
+ 		if (++i >= argc) usage ();
+ 		displayname = argv[i];
+ 		continue;
+ 	    }
+ 	}
+ 	usage ();
+     }
+ 
+     dpy = XOpenDisplay (displayname);
+     if (!dpy) {
+ 	fprintf (stderr, "%s:  unable to open display \"%s\"\n",
+ 		 ProgramName, XDisplayName(displayname));
+ 	exit (1);
+     }
+ 
+     if (!XTestQueryExtension (dpy, &event_base, &error_base, &major_version, &minor_version)) {
+ 	fprintf (stderr, 
+ 	 "%s:  XTest extension not supported on server \"%s\"\n",
+ 		 ProgramName, DisplayString(dpy));
+ 	XCloseDisplay(dpy);
+ 	exit (1);
+     }
+     printf ("XTest information for server \"%s\":\n",
+ 	    DisplayString(dpy));
+     printf ("  Major version:       %d\n", major_version);
+     printf ("  Minor version:       %d\n", minor_version);
+     printf ("  First event number:  %d\n", event_base);
+     printf ("  First error number:  %d\n", error_base);
+ 
+     
+     swa.override_redirect = True;
+     swa.cursor = XCreateFontCursor(dpy, XC_boat);
+     swa.event_mask = KeyPressMask|KeyReleaseMask|ButtonPressMask|ButtonReleaseMask|ButtonMotionMask;
+     w = XCreateWindow(dpy, DefaultRootWindow(dpy), 0, 0, 100, 100, 0, 0,
+ 		      InputOnly, CopyFromParent,
+ 		      CWEventMask|CWOverrideRedirect|CWCursor, &swa);
+     XMapWindow(dpy, w);
+     if (!XTestCompareCursorWithWindow(dpy, w, swa.cursor))
+ 	printf("error: window cursor is not the expected one\n");
+     XTestFakeMotionEvent(dpy, DefaultScreen(dpy), 10, 10, 0);
+     if (!XTestCompareCurrentCursorWithWindow(dpy, w))
+ 	printf("error: window cursor is not the displayed one\n");
+     XUndefineCursor(dpy, w);
+     if (!XTestCompareCursorWithWindow(dpy, w, None))
+ 	printf("error: window cursor is not the expected None\n");
+     XSync(dpy, True);
+     XDisplayKeycodes(dpy, &minkey, &maxkey);
+     key = XKeysymToKeycode(dpy, XK_a);
+     if (!key)
+ 	key = minkey;
+     XTestFakeKeyEvent(dpy, key, True, 0);
+     XNextEvent(dpy, &ev);
+     if (ev.type != KeyPress ||
+ 	ev.xkey.keycode != key ||
+ 	ev.xkey.x_root != 10 ||
+ 	ev.xkey.y_root != 10)
+ 	printf("error: bad event received for key press\n");
+     XTestFakeKeyEvent(dpy, key, False, 0);
+     XNextEvent(dpy, &ev);
+     if (ev.type != KeyRelease ||
+ 	ev.xkey.keycode != key ||
+ 	ev.xkey.x_root != 10 ||
+ 	ev.xkey.y_root != 10)
+ 	printf("error: bad event received for key release\n");
+     XTestFakeButtonEvent(dpy, 1, True, 0);
+     XTestFakeMotionEvent(dpy, DefaultScreen(dpy), 9, 8, 1000);
+     XTestFakeButtonEvent(dpy, 1, False, 2000);
+     XNextEvent(dpy, &ev);
+     if (ev.type != ButtonPress ||
+ 	ev.xbutton.button != 1 ||
+ 	ev.xbutton.x_root != 10 ||
+ 	ev.xbutton.y_root != 10)
+ 	printf("error: bad event received for button press\n");
+     XNextEvent(dpy, &second_ev);
+     if (second_ev.type != MotionNotify ||
+ 	second_ev.xmotion.x_root != 9 ||
+ 	second_ev.xmotion.y_root != 8)
+ 	printf("error: bad event received for motion\n");
+     delta_time = second_ev.xmotion.time - ev.xbutton.time;
+     if (delta_time > 1100 || delta_time < 900)
+ 	printf ("Poor event spacing is %d should be %d\n", delta_time, 1000);
+     XNextEvent(dpy, &third_ev);
+     if (third_ev.type != ButtonRelease ||
+ 	third_ev.xbutton.button != 1 ||
+ 	third_ev.xbutton.x_root != 9 ||
+ 	third_ev.xbutton.y_root != 8)
+ 	printf("error: bad event received for button release\n");
+     delta_time = third_ev.xbutton.time - second_ev.xmotion.time;
+     if (delta_time > 2100 || delta_time < 1900)
+ 	printf ("Poor event spacing is %d should be %d\n", delta_time, 2000);
+     gc = DefaultGC(dpy, DefaultScreen(dpy));
+     req = NextRequest(dpy);
+     XDrawPoint(dpy, w, gc, 0, 0);
+     if (!XTestDiscard(dpy) || req != NextRequest(dpy))
+ 	printf("error: XTestDiscard failed to discard an XDrawPoint\n");
+     gid = XGContextFromGC(gc);
+     XTestSetGContextOfGC(gc, 3L);
+     if (XGContextFromGC(gc) != 3L)
+ 	printf("error: XTestSetGContextOfGC failed\n");
+     XTestSetGContextOfGC(gc, gid);
+     if (XGContextFromGC(gc) != gid)
+ 	printf("error: XTestSetGContextOfGC failed\n");
+     XCloseDisplay (dpy);
+     exit (0);
+ }
*** /tmp/,RCSt1025189	Tue Feb 25 10:04:40 1992
--- server/ddx/mi/miinitext.c	Tue Feb 25 10:04:41 1992
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: miinitext.c,v 1.15 90/08/15 08:42:23 rws Exp $ */
  
  #ifdef BEZIER
  extern void BezierExtensionInit();
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: miinitext.c,v 1.17 92/01/25 16:35:50 rws Exp $ */
  
  #ifdef BEZIER
  extern void BezierExtensionInit();
***************
*** 44,49 ****
--- 44,52 ----
  #ifdef XINPUT
  extern void XInputExtensionInit();
  #endif
+ #ifdef XTEST
+ extern void XTestExtensionInit();
+ #endif
  #ifdef MITMISC
  extern void MITMiscExtensionInit();
  #endif
***************
*** 50,55 ****
--- 53,61 ----
  #ifdef XIDLE
  extern void XIdleExtensionInit();
  #endif
+ #ifdef XTRAP
+ extern void DEC_XTRAPInit();
+ #endif
  
  /*ARGSUSED*/
  void
***************
*** 78,87 ****
--- 84,99 ----
  #ifdef XINPUT
      XInputExtensionInit();
  #endif
+ #ifdef XTEST
+     XTestExtensionInit();
+ #endif
  #ifdef MITMISC
      MITMiscExtensionInit();
  #endif
  #ifdef XIDLE
      XIdleExtensionInit();
+ #endif
+ #ifdef XTRAP
+     DEC_XTRAPInit();
  #endif
  }
*** /tmp/d25247	Tue Feb 25 10:09:26 1992
--- server/os/access.c	Sun Dec 29 14:07:36 1991
***************
*** 22,28 ****
  
  ******************************************************************/
  
! /* $XConsortium: access.c,v 1.51 91/07/09 15:13:16 rws Exp $ */
  
  #include "Xos.h"
  #include "X.h"
--- 22,28 ----
  
  ******************************************************************/
  
! /* $XConsortium: access.c,v 1.53 91/12/29 14:06:01 rws Exp $ */
  
  #include "Xos.h"
  #include "X.h"
***************
*** 63,68 ****
--- 63,70 ----
  #include "dixstruct.h"
  #include "osdep.h"
  
+ Bool defeatAccessControl = FALSE;
+ 
  #define acmp(a1, a2, len) bcmp((char *)(a1), (char *)(a2), len)
  #define acopy(a1, a2, len) bcopy((char *)(a1), (char *)(a2), len)
  #define addrEqual(fam, address, length, host) \
***************
*** 266,271 ****
--- 268,282 ----
  	    if (family != FamilyInternet)
  		continue;
  
+ 	    /*
+  	     * ignore 'localhost' entries as they're not useful
+ 	     * on the other end of the wire
+ 	     */
+ 	    if (len == 4 &&
+ 		addr[0] == 127 && addr[1] == 0 &&
+ 		addr[2] == 0 && addr[3] == 1)
+ 		continue;
+ 
  	    XdmcpRegisterConnection (family, (char *)addr, len);
  	    broad_addr = ifr->ifr_addr;
  	    ((struct sockaddr_in *) &broad_addr)->sin_addr.s_addr =
***************
*** 365,371 ****
      pointer		addr;
      register struct hostent *hp;
  
!     AccessEnabled = DEFAULT_ACCESS_CONTROL;
      LocalHostEnabled = FALSE;
      while (host = validhosts)
      {
--- 376,382 ----
      pointer		addr;
      register struct hostent *hp;
  
!     AccessEnabled = defeatAccessControl ? FALSE : DEFAULT_ACCESS_CONTROL;
      LocalHostEnabled = FALSE;
      while (host = validhosts)
      {
***************
*** 450,456 ****
      pointer		addr;
      register HOST	*host;
  
!     if (!client)
  	return TRUE;
      alen = sizeof (from);
      if (!getpeername (((OsCommPtr)client->osPrivate)->fd, &from, &alen))
--- 461,467 ----
      pointer		addr;
      register HOST	*host;
  
!     if (!client || defeatAccessControl)
  	return TRUE;
      alen = sizeof (from);
      if (!getpeername (((OsCommPtr)client->osPrivate)->fd, &from, &alen))
*** /tmp/d25497	Tue Feb 25 10:11:38 1992
--- server/os/utils.c	Mon Feb 24 19:03:25 1992
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: utils.c,v 1.105 91/07/19 23:22:14 keith Exp $ */
  #include "Xos.h"
  #include <stdio.h>
  #include "misc.h"
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: utils.c,v 1.109 92/02/24 19:03:14 keith Exp $ */
  #include "Xos.h"
  #include <stdio.h>
  #include "misc.h"
***************
*** 64,69 ****
--- 64,70 ----
  extern long ScreenSaverTime;		/* for forcing reset */
  extern Bool permitOldBugs;
  extern int monitorResolution;
+ extern Bool defeatAccessControl;
  
  Bool CoreDump;
  
***************
*** 76,82 ****
  #ifdef AIXV3
  #define AIXFILE "/tmp/aixfile"
  FILE *aixfd;
- int FlushOn = 0;
  int SyncOn  = 0;
  extern int SelectWaitTime;
  #endif
--- 77,82 ----
***************
*** 160,170 ****
--- 160,196 ----
  }
  #endif
  
+ AdjustWaitForDelay (waitTime, newdelay)
+     pointer	    waitTime;
+     unsigned long   newdelay;
+ {
+     static struct timeval   delay_val;
+     struct timeval	    **wt = (struct timeval **) waitTime;
+     unsigned long	    olddelay;
+ 
+     if (*wt == NULL)
+     {
+ 	delay_val.tv_sec = newdelay / 1000;
+ 	delay_val.tv_usec = 1000 * (newdelay % 1000);
+ 	*wt = &delay_val;
+     }
+     else
+     {
+ 	olddelay = (*wt)->tv_sec * 1000 + (*wt)->tv_usec / 1000;
+ 	if (newdelay < olddelay)
+ 	{
+ 	    (*wt)->tv_sec = newdelay / 1000;
+ 	    (*wt)->tv_usec = 1000 * (newdelay % 1000);
+ 	}
+     }
+ }
+ 
  void UseMsg()
  {
  #if !defined(AIXrt) && !defined(AIX386)
      ErrorF("use: X [:<display>] [option]\n");
      ErrorF("-a #                   mouse acceleration (pixels)\n");
+     ErrorF("-ac                    disable access control restrictions\n");
  #ifdef MEMBUG
      ErrorF("-alloc int             chance alloc should fail\n");
  #endif
***************
*** 228,236 ****
--- 254,267 ----
      int i, skip;
  
  #ifdef MEMBUG
+ #ifndef AIXV3
      if (!minfree)
  	minfree = (pointer)sbrk(0);
+ #else
+     /* segment 2 is user data space */
+     minfree = (pointer) 0x20000000;
  #endif
+ #endif
      defaultKeyboardControl.autoRepeat = TRUE;
  
  #ifdef AIXV3
***************
*** 256,261 ****
--- 287,296 ----
  	    else
  		UseMsg();
  	}
+ 	else if ( strcmp( argv[i], "-ac") == 0)
+ 	{
+ 	    defeatAccessControl = TRUE;
+ 	}
  #ifdef MEMBUG
  	else if ( strcmp( argv[i], "-alloc") == 0)
  	{
***************
*** 481,490 ****
              else
                  UseMsg();
          }
-         else if ( strcmp( argv[i], "-flush") == 0)
-         {
-             FlushOn++;
-         }
          else if ( strcmp( argv[i], "-sync") == 0)
          {
              SyncOn++;
--- 516,521 ----
***************
*** 842,849 ****
  {
  #ifdef AIXV3
      fprintf(aixfd, f, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9);
!     if (FlushOn || SyncOn)
!         fflush (aixfd);
      if (SyncOn)
          sync();
  #else
--- 873,880 ----
  {
  #ifdef AIXV3
      fprintf(aixfd, f, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9);
!     fflush (aixfd);
! 
      if (SyncOn)
          sync();
  #else
*** /tmp/d25582	Tue Feb 25 10:25:13 1992
--- server/Xserver.man	Tue Feb 25 10:25:23 1992
***************
*** 1,3 ****
--- 1,4 ----
+ .\" $XConsortium: Xserver.man,v 1.44 92/02/25 10:24:47 rws Exp $
  .TH XSERVER 1 "Release 5"  "X Version 11"
  .SH NAME
  Xserver \- X Window System server
***************
*** 49,54 ****
--- 50,61 ----
  .B \-a \fInumber\fP
  sets pointer acceleration (i.e. the ratio of how much is reported to how much
  the user actually moved the pointer).
+ .TP 8
+ .B \-ac
+ disables host-based access control mechanisms.  Enables access by any host,
+ and permits any host to modify the access control list.
+ Use with extreme caution.
+ This option exists primarily for running test suites remotely.
  .TP 8
  .B \-auth \fIauthorization-file\fP
  Specifies a file which contains a collection of authorization records used
