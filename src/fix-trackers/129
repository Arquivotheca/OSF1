Path: news.crl.dec.com!pa.dec.com!nobody
Message-Id: <9202111958.AA15720@xenon.lcs.mit.edu>
To: fix-trackers@expo.lcs.mit.edu
Subject: (seq: 2352) Huge cfb diff, part 1 of 3
Date: Tue, 11 Feb 92 14:58:46 EST
From: Keith Packard <keith@expo.lcs.mit.edu>
Distribution: dec
X-Mailing-List: fix-trackers@expo.lcs.mit.edu
X-Disclaimer: This message originated from a mailing list outside of Digital.
Newsgroups: dec.mail.lists.x.fix-trackers
Approved: news@usenet.pa.dec.com


*** /tmp/,RCSt1a08248	Fri Feb  7 18:43:31 1992
--- server/ddx/cfb/Imakefile	Sat Dec 28 14:22:27 1991
***************
*** 1,24 ****
! XCOMM $XConsortium: Imakefile,v 5.31 91/07/16 22:51:52 gildea Exp $
  #include <Server.tmpl>
  
! SRCS =	 cfbgc.c cfbrrop.c cfbwindow.c \
! 	 cfbpntwin.c cfbmskbits.c cfbpixmap.c cfbbitblt.c \
! 	 cfbfillsp.c cfbsetsp.c cfbscrinit.c \
! 	 cfbgetsp.c cfbfillrct.c \
! 	 cfbsolidC.c cfbsolidX.c cfbsolidG.c \
! 	 cfbtile32C.c cfbtile32G.c \
! 	 cfbtileoddC.c cfbtileoddG.c \
! 	 cfbcmap.c cfbzerarcC.c cfbzerarcX.c cfbzerarcG.c \
! 	 cfbfillarcC.c cfbfillarcG.c \
! 	 cfbtegblt.c cfbbstore.c cfb8cppl.c \
! 	 cfbbltC.c cfbbltX.c cfbbltO.c cfbbltG.c \
! 	 cfb8bit.c cfbteblt8.c cfbglblt8.c cfbglrop8.c cfbigblt8.c \
!  	 cfbpush8.c cfbrctstp8.c cfbpolypnt.c \
! 	 cfb8lineCO.c cfb8lineX.c cfb8lineG.c cfb8lineCP.c \
!  	 cfb8segC.c cfb8segX.c cfb8segG.c cfb8segCS.c \
! 	 cfbbres.c cfbline.c cfbhrzvert.c cfbbresd.c cfbimage.c cfbseg.c \
! 	 cfbply1rctC.c cfbply1rctG.c
  
  #ifdef MipsArchitecture
  STIPPLESRC = stipmips.s stipmipste.s
  STIPPLEOBJ = stipmips.o stipmipste.o
--- 1,13 ----
! XCOMM $XConsortium: Imakefile,v 5.34 91/12/28 14:20:56 rws Exp $
  #include <Server.tmpl>
  
! #ifndef PixelSize
! #define PixelSize 8
! #endif
  
+ #if PixelSize == 8
+ PSZSRCS = cfb8cppl.c cfb8bit.c cfbteblt8.c cfbglrop8.c cfbpush8.c cfbrctstp8.c
+ PSZOBJS = cfb8cppl.o cfb8bit.o cfbteblt8.o cfbglrop8.o cfbpush8.o cfbrctstp8.o
  #ifdef MipsArchitecture
  STIPPLESRC = stipmips.s stipmipste.s
  STIPPLEOBJ = stipmips.o stipmipste.o
***************
*** 29,57 ****
  STIPPLEOBJ = stipsparc.o stipsparcte.o
  STIPPLEDEF = -DHAS_STIPPLE_CODE
  #endif
  
  OBJS =   cfbgc.o cfbrrop.o cfbwindow.o \
  	 cfbgetsp.o cfbfillrct.o \
  	 cfbsolidC.o cfbsolidX.o cfbsolidG.o \
! 	 cfbtile32C.o cfbtile32G.o \
! 	 cfbtileoddC.o cfbtileoddG.o \
! 	 cfbfillsp.o cfbsetsp.o cfbscrinit.o \
  	 cfbpntwin.o cfbmskbits.o cfbpixmap.o \
  	 cfbcmap.o cfbzerarcC.o cfbzerarcX.o cfbzerarcG.o \
  	 cfbfillarcC.o cfbfillarcG.o \
! 	 cfbtegblt.o cfbbstore.o cfb8cppl.o \
! 	 cfb8bit.o cfbteblt8.o cfbglblt8.o cfbglrop8.o cfbigblt8.o \
!  	 cfbrctstp8.o cfbpolypnt.o \
!  	 cfb8segCS.o cfb8segX.o cfb8segG.o cfb8segC.o \
! 	 cfb8lineCO.o cfb8lineX.o cfb8lineG.o cfb8lineCP.o \
  	 cfbbres.o cfbline.o cfbhrzvert.o cfbbresd.o cfbimage.o cfbseg.o \
   	 cfbbitblt.o cfbbltC.o cfbbltX.o cfbbltO.o cfbbltG.o \
! 	 cfbpush8.o cfbply1rctC.o cfbply1rctG.o $(STIPPLEOBJ)
  
     INCLUDES = -I. -I../mfb -I../mi -I../../include -I$(INCLUDESRC) \
     	      -I$(FONTSRC)/include
     LINTLIBS = ../../dix/llib-ldix.ln ../../os/llib-los.ln \
  	     ../mfb/llib-lmfb.ln ../mi/llib-lmi.ln
  
  NormalLibraryObjectRule()
  NormalLibraryTarget(cfb,$(OBJS))
--- 18,71 ----
  STIPPLEOBJ = stipsparc.o stipsparcte.o
  STIPPLEDEF = -DHAS_STIPPLE_CODE
  #endif
+ #endif
  
+ #if PixelSize == 32
+ #ifdef SparcArchitecture
+ STIPPLESRC = stipsparc32.s stipsparcte32.s
+ STIPPLEOBJ = stipsparc32.o stipsparcte32.o
+ STIPPLEDEF = -DHAS_STIPPLE_CODE
+ #endif
+ #endif
+ 
+ 
+ SRCS =	 cfbgc.c cfbrrop.c cfbwindow.c \
+ 	 cfbpntwin.c cfbmskbits.c cfbpixmap.c cfbbitblt.c \
+ 	 cfbfillsp.c cfbsetsp.c cfbscrinit.c cfballpriv.c \
+ 	 cfbgetsp.c cfbfillrct.c \
+ 	 cfbsolidC.c cfbsolidX.c cfbsolidG.c \
+ 	 cfbtileoddC.c cfbtileoddG.c cfbtile32C.c cfbtile32G.c \
+ 	 cfbcmap.c cfbzerarcC.c cfbzerarcX.c cfbzerarcG.c \
+ 	 cfbfillarcC.c cfbfillarcG.c \
+ 	 cfbigblt8.c cfbglblt8.c cfbtegblt.c cfbbstore.c \
+ 	 cfbbltC.c cfbbltX.c cfbbltO.c cfbbltG.c \
+ 	 cfbpolypnt.c \
+ 	 cfbbres.c cfbline.c cfbhrzvert.c cfbbresd.c cfbimage.c cfbseg.c \
+ 	 cfb8lineCO.c cfb8lineX.c cfb8lineG.c cfb8lineCP.c \
+ 	 cfb8segC.c cfb8segX.c cfb8segG.c cfb8segCS.c \
+ 	 cfbply1rctC.c cfbply1rctG.c $(PSZSRCS)
+ 
  OBJS =   cfbgc.o cfbrrop.o cfbwindow.o \
  	 cfbgetsp.o cfbfillrct.o \
  	 cfbsolidC.o cfbsolidX.o cfbsolidG.o \
! 	 cfbtileoddC.o cfbtileoddG.o cfbtile32C.o cfbtile32G.o \
! 	 cfbfillsp.o cfbsetsp.o cfbscrinit.o cfballpriv.o \
  	 cfbpntwin.o cfbmskbits.o cfbpixmap.o \
  	 cfbcmap.o cfbzerarcC.o cfbzerarcX.o cfbzerarcG.o \
  	 cfbfillarcC.o cfbfillarcG.o \
! 	 cfbigblt8.o cfbglblt8.o cfbtegblt.o cfbbstore.o \
! 	 cfbpolypnt.o \
  	 cfbbres.o cfbline.o cfbhrzvert.o cfbbresd.o cfbimage.o cfbseg.o \
+ 	 cfb8lineCO.o cfb8lineX.o cfb8lineG.o cfb8lineCP.o \
+ 	 cfb8segCS.o cfb8segX.o cfb8segG.o cfb8segC.o \
   	 cfbbitblt.o cfbbltC.o cfbbltX.o cfbbltO.o cfbbltG.o \
! 	 cfbply1rctC.o cfbply1rctG.o $(PSZOBJS) $(STIPPLEOBJ)
  
     INCLUDES = -I. -I../mfb -I../mi -I../../include -I$(INCLUDESRC) \
     	      -I$(FONTSRC)/include
     LINTLIBS = ../../dix/llib-ldix.ln ../../os/llib-los.ln \
  	     ../mfb/llib-lmfb.ln ../mi/llib-lmi.ln
+     DEFINES = -DPSZ=PixelSize
  
  NormalLibraryObjectRule()
  NormalLibraryTarget(cfb,$(OBJS))
***************
*** 64,96 ****
  	XCOMM load $(CFLAGS) $(SRCS)
  #endif
  
! #ifdef MipsArchitecture
! stipmipste.s: stipmips.s
! 	$(RM) $@
! 	$(LN) stipmips.s stipmipste.s
! clean::
! 	$(RM) stipmipste.s
  
! stipmipste.o: stipmipste.s
! 	$(AS) -o $@ -DTETEXT stipmipste.s
  #endif
  #ifdef SparcArchitecture
! stipsparcte.s: stipsparc.s
! 	$(RM) $@
! 	$(LN) stipsparc.s stipsparcte.s
! clean::
! 	$(RM) stipsparcte.s
! 
! stipsparc.o: stipsparc.s
! 	$(CPP) stipsparc.s | $(AS) -o $@ -
! 
! stipsparcte.o: stipsparcte.s
! 	$(CPP) -DTETEXT stipsparcte.s | $(AS) -o $@ -
  #endif
  
  ObjectFromSpecialSource(cfbseg,cfbline,-DPOLYSEGMENT)
- ObjectFromSpecialSource(cfbglrop8,cfbglblt8,-DGLYPHROP)
- SpecialObjectRule(cfbglblt8.o,$(NOTDEF),$(STIPPLEDEF))
  
  ObjectFromSpecialSource(cfbfillarcC,cfbfillarc,-DRROP=GXcopy)
  ObjectFromSpecialSource(cfbfillarcG,cfbfillarc,-DRROP=GXset)
--- 78,148 ----
  	XCOMM load $(CFLAGS) $(SRCS)
  #endif
  
! #ifdef LinkDirectory
! #define LinkDepSourceFile(file,dir)		@@\
! LinkSourceFile(file,dir)			@@\
! depend:: file					@@\
! clean::						@@\
! 	$(RM) file
  
! LinkDepSourceFile(cfb.h,LinkDirectory)
! LinkDepSourceFile(cfbmap.h,LinkDirectory)
! LinkDepSourceFile(cfballpriv.c,LinkDirectory)
! LinkDepSourceFile(cfbbitblt.c,LinkDirectory)
! LinkDepSourceFile(cfbblt.c,LinkDirectory)
! LinkDepSourceFile(cfbbres.c,LinkDirectory)
! LinkDepSourceFile(cfbbresd.c,LinkDirectory)
! LinkDepSourceFile(cfbbstore.c,LinkDirectory)
! LinkDepSourceFile(cfbcmap.c,LinkDirectory)
! LinkDepSourceFile(cfbfillarc.c,LinkDirectory)
! LinkDepSourceFile(cfbfillrct.c,LinkDirectory)
! LinkDepSourceFile(cfbfillsp.c,LinkDirectory)
! LinkDepSourceFile(cfbgc.c,LinkDirectory)
! LinkDepSourceFile(cfbgetsp.c,LinkDirectory)
! LinkDepSourceFile(cfbhrzvert.c,LinkDirectory)
! LinkDepSourceFile(cfbimage.c,LinkDirectory)
! LinkDepSourceFile(cfbline.c,LinkDirectory)
! LinkDepSourceFile(cfb8line.c,LinkDirectory)
! LinkDepSourceFile(cfbmskbits.c,LinkDirectory)
! LinkDepSourceFile(cfbmskbits.h,LinkDirectory)
! LinkDepSourceFile(cfbpixmap.c,LinkDirectory)
! LinkDepSourceFile(cfbply1rct.c,LinkDirectory)
! LinkDepSourceFile(cfbpntwin.c,LinkDirectory)
! LinkDepSourceFile(cfbpolypnt.c,LinkDirectory)
! LinkDepSourceFile(cfbrrop.c,LinkDirectory)
! LinkDepSourceFile(cfbrrop.h,LinkDirectory)
! LinkDepSourceFile(cfbscrinit.c,LinkDirectory)
! LinkDepSourceFile(cfbsetsp.c,LinkDirectory)
! LinkDepSourceFile(cfbsolid.c,LinkDirectory)
! LinkDepSourceFile(cfbigblt8.c,LinkDirectory)
! LinkDepSourceFile(cfbglblt8.c,LinkDirectory)
! LinkDepSourceFile(cfbtegblt.c,LinkDirectory)
! LinkDepSourceFile(cfbtileodd.c,LinkDirectory)
! LinkDepSourceFile(cfbtile32.c,LinkDirectory)
! LinkDepSourceFile(cfbwindow.c,LinkDirectory)
! LinkDepSourceFile(cfbzerarc.c,LinkDirectory)
! LinkDepSourceFile(cfb8bit.h,LinkDirectory)
! #if PixelSize == 8
! LinkDepSourceFile(cfb8bit.c,LinkDirectory)
! LinkDepSourceFile(cfb8cppl.c,LinkDirectory)
! LinkDepSourceFile(cfbpush8.c,LinkDirectory)
! LinkDepSourceFile(cfbrctstp8.c,LinkDirectory)
! LinkDepSourceFile(cfbteblt8.c,LinkDirectory)
! #ifdef MipsArchitecture
! LinkDepSourceFile(stipmips.s,LinkDirectory)
  #endif
  #ifdef SparcArchitecture
! LinkDepSourceFile(stipsparc.s,LinkDirectory)
  #endif
+ #endif
+ #if PixelSize == 32
+ #ifdef SparcArchitecture
+ LinkDepSourceFile(stipsparc32.s,LinkDirectory)
+ #endif
+ #endif
+ #endif
  
  ObjectFromSpecialSource(cfbseg,cfbline,-DPOLYSEGMENT)
  
  ObjectFromSpecialSource(cfbfillarcC,cfbfillarc,-DRROP=GXcopy)
  ObjectFromSpecialSource(cfbfillarcG,cfbfillarc,-DRROP=GXset)
***************
*** 108,119 ****
  ObjectFromSpecialSource(cfbsolidX,cfbsolid,-DRROP=GXxor)
  ObjectFromSpecialSource(cfbsolidG,cfbsolid,-DRROP=GXset)
  
- ObjectFromSpecialSource(cfbtile32C,cfbtile32,-DMROP=Mcopy)
- ObjectFromSpecialSource(cfbtile32G,cfbtile32,-DMROP=0)
- 
  ObjectFromSpecialSource(cfbtileoddC,cfbtileodd,-DMROP=Mcopy)
  ObjectFromSpecialSource(cfbtileoddG,cfbtileodd,-DMROP=0)
  
  ObjectFromSpecialSource(cfb8lineCO,cfb8line,-DRROP=GXcopy)
  ObjectFromSpecialSource(cfb8lineCP,cfb8line,-DRROP=GXcopy -DPREVIOUS)
  ObjectFromSpecialSource(cfb8lineX,cfb8line,-DRROP=GXxor)
--- 160,171 ----
  ObjectFromSpecialSource(cfbsolidX,cfbsolid,-DRROP=GXxor)
  ObjectFromSpecialSource(cfbsolidG,cfbsolid,-DRROP=GXset)
  
  ObjectFromSpecialSource(cfbtileoddC,cfbtileodd,-DMROP=Mcopy)
  ObjectFromSpecialSource(cfbtileoddG,cfbtileodd,-DMROP=0)
  
+ ObjectFromSpecialSource(cfbtile32C,cfbtile32,-DMROP=Mcopy)
+ ObjectFromSpecialSource(cfbtile32G,cfbtile32,-DMROP=0)
+ 
  ObjectFromSpecialSource(cfb8lineCO,cfb8line,-DRROP=GXcopy)
  ObjectFromSpecialSource(cfb8lineCP,cfb8line,-DRROP=GXcopy -DPREVIOUS)
  ObjectFromSpecialSource(cfb8lineX,cfb8line,-DRROP=GXxor)
***************
*** 126,130 ****
--- 178,229 ----
  
  ObjectFromSpecialSource(cfbply1rctC,cfbply1rct,-DRROP=GXcopy)
  ObjectFromSpecialSource(cfbply1rctG,cfbply1rct,-DRROP=GXset)
+ 
+ SpecialObjectRule(cfbglblt8.o,$(NOTDEF),$(STIPPLEDEF))
+ 
+ #if PixelSize == 8
+ ObjectFromSpecialSource(cfbglrop8,cfbglblt8,-DGLYPHROP)
+ 
+ #ifdef MipsArchitecture
+ stipmipste.s: stipmips.s
+ 	$(RM) $@
+ 	$(LN) stipmips.s stipmipste.s
+ clean::
+ 	$(RM) stipmipste.s
+ 
+ stipmipste.o: stipmipste.s
+ 	$(AS) -o $@ -DTETEXT stipmipste.s
+ #endif
+ 
+ #ifdef SparcArchitecture
+ stipsparcte.s: stipsparc.s
+ 	$(RM) $@
+ 	$(LN) stipsparc.s stipsparcte.s
+ clean::
+ 	$(RM) stipsparcte.s
+ 
+ stipsparc.o: stipsparc.s
+ 	$(CPP) stipsparc.s | $(AS) -o $@ -
+ 
+ stipsparcte.o: stipsparcte.s
+ 	$(CPP) -DTETEXT stipsparcte.s | $(AS) -o $@ -
+ #endif
+ #endif
+ 
+ #if PixelSize == 32
+ #ifdef SparcArchitecture
+ stipsparcte32.s: stipsparc32.s
+ 	$(RM) $@
+ 	$(LN) stipsparc32.s stipsparcte32.s
+ clean::
+ 	$(RM) stipsparcte32.s
+ 
+ stipsparc32.o: stipsparc32.s
+ 	$(CPP) stipsparc32.s | $(AS) -o $@ -
+ 
+ stipsparcte32.o: stipsparcte32.s
+ 	$(CPP) -DTETEXT stipsparcte32.s | $(AS) -o $@ -
+ #endif
+ #endif
  
  DependTarget()
*** /tmp/,RCSt1a08302	Fri Feb  7 18:43:50 1992
--- server/ddx/cfb/cfb.h	Fri Jan 31 18:28:17 1992
***************
*** 1,3 ****
--- 1,4 ----
+ /* $XConsortium: cfb.h,v 5.25 92/01/31 18:27:59 gildea Exp $ */
  /************************************************************
  Copyright 1987 by Sun Microsystems, Inc. Mountain View, CA.
  
***************
*** 34,39 ****
--- 35,42 ----
  #include "servermd.h"
  #include "mfb.h"
  
+ #include "cfbmap.h"
+ 
  extern Bool cfbScreenInit();
  extern void cfbQueryBestSize();
  extern Bool cfbCreateWindow();
***************
*** 66,72 ****
  extern RegionPtr cfbCopyPlane();
  extern void cfbPolyFillArcSolidCopy(),cfbPolyFillArcSolidXor();
  extern void cfbPolyFillArcSolidGeneral();
! extern RegionPtr cfbCopyArea();
  extern void cfbFillPoly1RectCopy(), cfbFillPoly1RectGeneral();
  
  extern void cfbPushPixels8();
--- 69,75 ----
  extern RegionPtr cfbCopyPlane();
  extern void cfbPolyFillArcSolidCopy(),cfbPolyFillArcSolidXor();
  extern void cfbPolyFillArcSolidGeneral();
! extern RegionPtr cfbCopyArea(), cfbBitBlt();
  extern void cfbFillPoly1RectCopy(), cfbFillPoly1RectGeneral();
  
  extern void cfbPushPixels8();
***************
*** 173,193 ****
      PixmapPtr	pRotatedBorder;
      } cfbPrivWin;
  
  /* Common macros for extracting drawing information */
  
  #define cfbGetTypedWidth(pDrawable,wtype) (\
      (((pDrawable)->type == DRAWABLE_WINDOW) ? \
!      (int) (((PixmapPtr)((pDrawable)->pScreen->devPrivate))->devKind) : \
       (int)(((PixmapPtr)pDrawable)->devKind)) / sizeof (wtype))
  
  #define cfbGetByteWidth(pDrawable) cfbGetTypedWidth(pDrawable, unsigned char)
  
  #define cfbGetLongWidth(pDrawable) cfbGetTypedWidth(pDrawable, unsigned long)
      
  #define cfbGetTypedWidthAndPointer(pDrawable, width, pointer, wtype, ptype) {\
      PixmapPtr   _pPix; \
      if ((pDrawable)->type == DRAWABLE_WINDOW) \
! 	_pPix = (PixmapPtr) (pDrawable)->pScreen->devPrivate; \
      else \
  	_pPix = (PixmapPtr) (pDrawable); \
      (pointer) = (ptype *) _pPix->devPrivate.ptr; \
--- 176,219 ----
      PixmapPtr	pRotatedBorder;
      } cfbPrivWin;
  
+ /*
+  * This is the only completely portable way to
+  * compute this info
+  */
+ 
+ #define BitsPerPixel(d) (\
+     (1 << PixmapWidthPaddingInfo[d].padBytesLog2) * 8 / \
+     (PixmapWidthPaddingInfo[d].padRoundUp+1))
+ 
  /* Common macros for extracting drawing information */
  
+ #if !defined(SINGLEDEPTH) && PSZ != 8 || defined(FORCE_SEPARATE_PRIVATE)
+ 
+ #define CFB_NEED_SCREEN_PRIVATE
+ 
+ extern int cfbScreenPrivateIndex;
+ #define cfbGetScreenPixmap(s)	((PixmapPtr) (s)->devPrivates[cfbScreenPrivateIndex].ptr)
+ #else
+ #define cfbGetScreenPixmap(s)	((PixmapPtr) (s)->devPrivate)
+ #endif
+ 
+ #define cfbGetWindowPixmap(d)	cfbGetScreenPixmap((d)->pScreen)
+ 
  #define cfbGetTypedWidth(pDrawable,wtype) (\
      (((pDrawable)->type == DRAWABLE_WINDOW) ? \
!      (int) (cfbGetWindowPixmap(pDrawable)->devKind) : \
       (int)(((PixmapPtr)pDrawable)->devKind)) / sizeof (wtype))
  
  #define cfbGetByteWidth(pDrawable) cfbGetTypedWidth(pDrawable, unsigned char)
  
+ #define cfbGetPixelWidth(pDrawable) cfbGetTypedWidth(pDrawable, PixelType)
+ 
  #define cfbGetLongWidth(pDrawable) cfbGetTypedWidth(pDrawable, unsigned long)
      
  #define cfbGetTypedWidthAndPointer(pDrawable, width, pointer, wtype, ptype) {\
      PixmapPtr   _pPix; \
      if ((pDrawable)->type == DRAWABLE_WINDOW) \
! 	_pPix = cfbGetWindowPixmap(pDrawable); \
      else \
  	_pPix = (PixmapPtr) (pDrawable); \
      (pointer) = (ptype *) _pPix->devPrivate.ptr; \
***************
*** 200,207 ****
  #define cfbGetLongWidthAndPointer(pDrawable, width, pointer) \
      cfbGetTypedWidthAndPointer(pDrawable, width, pointer, unsigned long, unsigned long)
  
  #define cfbGetWindowTypedWidthAndPointer(pWin, width, pointer, wtype, ptype) {\
!     PixmapPtr	_pPix = (PixmapPtr) (pWin)->drawable.pScreen->devPrivate; \
      (pointer) = (ptype *) _pPix->devPrivate.ptr; \
      (width) = ((int) _pPix->devKind) / sizeof (wtype); \
  }
--- 226,236 ----
  #define cfbGetLongWidthAndPointer(pDrawable, width, pointer) \
      cfbGetTypedWidthAndPointer(pDrawable, width, pointer, unsigned long, unsigned long)
  
+ #define cfbGetPixelWidthAndPointer(pDrawable, width, pointer) \
+     cfbGetTypedWidthAndPointer(pDrawable, width, pointer, PixelType, PixelType)
+ 
  #define cfbGetWindowTypedWidthAndPointer(pWin, width, pointer, wtype, ptype) {\
!     PixmapPtr	_pPix = cfbGetWindowPixmap((DrawablePtr) (pWin)); \
      (pointer) = (ptype *) _pPix->devPrivate.ptr; \
      (width) = ((int) _pPix->devKind) / sizeof (wtype); \
  }
***************
*** 211,216 ****
--- 240,248 ----
  
  #define cfbGetWindowByteWidthAndPointer(pWin, width, pointer) \
      cfbGetWindowTypedWidthAndPointer(pWin, width, pointer, unsigned char, unsigned char)
+ 
+ #define cfbGetWindowPixelWidthAndPointer(pDrawable, width, pointer) \
+     cfbGetWindowTypedWidthAndPointer(pDrawable, width, pointer, PixelType, PixelType)
  
  /* Macros which handle a coordinate in a single register */
  
*** /tmp/,RCSt1a08320	Fri Feb  7 18:43:56 1992
--- server/ddx/cfb/cfb8bit.c	Thu Dec 19 18:36:51 1991
***************
*** 4,11 ****
   * 8 bit color frame buffer utility routines
   */
  
! /* $XConsortium: cfb8bit.c,v 1.5 91/01/27 13:02:56 keith Exp $ */
  
  #include	"X.h"
  #include	"Xmd.h"
  #include	"Xproto.h"
--- 4,13 ----
   * 8 bit color frame buffer utility routines
   */
  
! /* $XConsortium: cfb8bit.c,v 1.7 91/12/19 18:36:48 keith Exp $ */
  
+ #if PSZ == 8
+ 
  #include	"X.h"
  #include	"Xmd.h"
  #include	"Xproto.h"
***************
*** 18,25 ****
  #include	"cfbmskbits.h"
  #include	"cfb8bit.h"
  
- #if (PPW == 4)
- 
  unsigned long cfb8StippleMasks[16] = {
      0x00000000, 0x000000ff, 0x0000ff00, 0x0000ffff,
      0x00ff0000, 0x00ff00ff, 0x00ffff00, 0x00ffffff,
--- 20,25 ----
***************
*** 222,225 ****
      return result;
  }
  
! #endif /* PPW == 4 */
--- 222,225 ----
      return result;
  }
  
! #endif /* PSZ == 8 */
*** /tmp/,RCSt1a08338	Fri Feb  7 18:44:04 1992
--- server/ddx/cfb/cfb8bit.h	Thu Dec 19 18:37:43 1991
***************
*** 18,27 ****
  purpose.  It is provided "as is" without express or implied warranty.
  */
  
! /* $XConsortium: cfb8bit.h,v 1.11 91/07/11 17:58:48 keith Exp $ */
  
- #if (PPW == 4)
- 
  #include "servermd.h"
  
  #if (BITMAP_BIT_ORDER == MSBFirst)
--- 18,25 ----
  purpose.  It is provided "as is" without express or implied warranty.
  */
  
! /* $XConsortium: cfb8bit.h,v 1.13 91/12/19 18:37:40 keith Exp $ */
  
  #include "servermd.h"
  
  #if (BITMAP_BIT_ORDER == MSBFirst)
***************
*** 44,49 ****
--- 42,49 ----
   				: "0" (x), "dI" (k))
  #endif
  
+ #if PSZ == 8
+ 
  #define GetFourPixels(x)	(cfb8StippleXor[GetFourBits(x)])
  #define RRopPixels(dst,x)	(DoRRop(dst,cfb8StippleAnd[x], cfb8StippleXor[x]))
  #define RRopFourPixels(dst,x)	(RRopPixels(dst,GetFourBits(x)))
***************
*** 164,171 ****
      register int    _bitsTmp = (bits);				\
      *(dst) = MaskRRopPixels(*(dst),bits,mask);			\
      }
  
! #ifndef AVOID_MEMORY_READ
  
  #define WriteFourBits(dst,pixel,bits)				\
      {								\
--- 164,172 ----
      register int    _bitsTmp = (bits);				\
      *(dst) = MaskRRopPixels(*(dst),bits,mask);			\
      }
+ #endif /* PSZ == 8 */
  
! #if !defined(AVOID_MEMORY_READ) && PSZ == 8
  
  #define WriteFourBits(dst,pixel,bits)				\
      {								\
***************
*** 184,242 ****
  #else /* AVOID_MEMORY_READ */
  
  #if (BITMAP_BIT_ORDER == MSBFirst)
  #define WriteFourBits(dst,pixel,bits) \
  	switch (bits) {			\
  	case 0:				\
  	    break;			\
  	case 1:				\
! 	    ((char *) (dst))[3] = (pixel);	\
  	    break;			\
  	case 2:				\
! 	    ((char *) (dst))[2] = (pixel);	\
  	    break;			\
  	case 3:				\
! 	    ((short *) (dst))[1] = (pixel);	\
  	    break;			\
  	case 4:				\
! 	    ((char *) (dst))[1] = (pixel);	\
  	    break;			\
  	case 5:				\
! 	    ((char *) (dst))[3] = (pixel);	\
! 	    ((char *) (dst))[1] = (pixel);	\
  	    break;			\
  	case 6:				\
! 	    ((char *) (dst))[2] = (pixel);	\
! 	    ((char *) (dst))[1] = (pixel);	\
  	    break;			\
  	case 7:				\
! 	    ((short *) (dst))[1] = (pixel);	\
! 	    ((char *) (dst))[1] = (pixel);	\
  	    break;			\
  	case 8:				\
! 	    ((char *) (dst))[0] = (pixel);	\
  	    break;			\
  	case 9:				\
! 	    ((char *) (dst))[3] = (pixel);	\
! 	    ((char *) (dst))[0] = (pixel);	\
  	    break;			\
  	case 10:			\
! 	    ((char *) (dst))[2] = (pixel);	\
! 	    ((char *) (dst))[0] = (pixel);	\
  	    break;			\
  	case 11:			\
! 	    ((short *) (dst))[1] = (pixel);	\
! 	    ((char *) (dst))[0] = (pixel);	\
  	    break;			\
  	case 12:			\
! 	    ((short *) (dst))[0] = (pixel);	\
  	    break;			\
  	case 13:			\
! 	    ((char *) (dst))[3] = (pixel);	\
! 	    ((short *) (dst))[0] = (pixel);	\
  	    break;			\
  	case 14:			\
! 	    ((char *) (dst))[2] = (pixel);	\
! 	    ((short *) (dst))[0] = (pixel);	\
  	    break;			\
  	case 15:			\
  	    ((long *) (dst))[0] = (pixel);	\
--- 185,268 ----
  #else /* AVOID_MEMORY_READ */
  
  #if (BITMAP_BIT_ORDER == MSBFirst)
+ #define Byte0	3
+ #define Byte1	2
+ #define Byte2	1
+ #define Byte3	0
+ #define Short0	1
+ #define Short1	0
+ #define Short2	3
+ #define Short3	2
+ #else
+ #define Byte0	0
+ #define Byte1	1
+ #define Byte2	2
+ #define Byte3	3
+ #define Short0	0
+ #define Short1	1
+ #define Short2	2
+ #define Short3	3
+ #endif
+ #define Long0	0
+ #define Long1	1
+ #define Long2	2
+ #define Long3	3
+ 
+ #if PSZ == 8
+ 
  #define WriteFourBits(dst,pixel,bits) \
  	switch (bits) {			\
  	case 0:				\
  	    break;			\
  	case 1:				\
! 	    ((char *) (dst))[Byte0] = (pixel);	\
  	    break;			\
  	case 2:				\
! 	    ((char *) (dst))[Byte1] = (pixel);	\
  	    break;			\
  	case 3:				\
! 	    ((short *) (dst))[Short0] = (pixel);	\
  	    break;			\
  	case 4:				\
! 	    ((char *) (dst))[Byte2] = (pixel);	\
  	    break;			\
  	case 5:				\
! 	    ((char *) (dst))[Byte0] = (pixel);	\
! 	    ((char *) (dst))[Byte2] = (pixel);	\
  	    break;			\
  	case 6:				\
! 	    ((char *) (dst))[Byte1] = (pixel);	\
! 	    ((char *) (dst))[Byte2] = (pixel);	\
  	    break;			\
  	case 7:				\
! 	    ((short *) (dst))[Short0] = (pixel);	\
! 	    ((char *) (dst))[Byte2] = (pixel);	\
  	    break;			\
  	case 8:				\
! 	    ((char *) (dst))[Byte3] = (pixel);	\
  	    break;			\
  	case 9:				\
! 	    ((char *) (dst))[Byte0] = (pixel);	\
! 	    ((char *) (dst))[Byte3] = (pixel);	\
  	    break;			\
  	case 10:			\
! 	    ((char *) (dst))[Byte1] = (pixel);	\
! 	    ((char *) (dst))[Byte3] = (pixel);	\
  	    break;			\
  	case 11:			\
! 	    ((short *) (dst))[Short0] = (pixel);	\
! 	    ((char *) (dst))[Byte3] = (pixel);	\
  	    break;			\
  	case 12:			\
! 	    ((short *) (dst))[Short1] = (pixel);	\
  	    break;			\
  	case 13:			\
! 	    ((char *) (dst))[Byte0] = (pixel);	\
! 	    ((short *) (dst))[Short1] = (pixel);	\
  	    break;			\
  	case 14:			\
! 	    ((char *) (dst))[Byte1] = (pixel);	\
! 	    ((short *) (dst))[Short1] = (pixel);	\
  	    break;			\
  	case 15:			\
  	    ((long *) (dst))[0] = (pixel);	\
***************
*** 243,301 ****
  	    break;			\
  	}
  
  #define SwitchFourBits(dst,pixel,bits) { \
  	switch (bits) { \
  	case 0: \
! 	    break; \
  	case 1: \
! 	    SwitchBitsLoop (((char *) (dst))[3] = (pixel);) \
  	    break; \
  	case 2: \
! 	    SwitchBitsLoop (((char *) (dst))[2] = (pixel);) \
  	    break; \
  	case 3: \
! 	    SwitchBitsLoop (((short *) (dst))[1] = (pixel);) \
  	    break; \
  	case 4: \
! 	    SwitchBitsLoop (((char *) (dst))[1] = (pixel);) \
  	    break; \
  	case 5: \
! 	    SwitchBitsLoop (((char *) (dst))[3] = (pixel); \
! 		     ((char *) (dst))[1] = (pixel);) \
  	    break; \
  	case 6: \
! 	    SwitchBitsLoop (((char *) (dst))[2] = (pixel); \
! 		     ((char *) (dst))[1] = (pixel);) \
  	    break; \
  	case 7: \
! 	    SwitchBitsLoop (((short *) (dst))[1] = (pixel); \
! 		     ((char *) (dst))[1] = (pixel);) \
  	    break; \
  	case 8: \
! 	    SwitchBitsLoop (((char *) (dst))[0] = (pixel);) \
  	    break; \
  	case 9: \
! 	    SwitchBitsLoop (((char *) (dst))[3] = (pixel); \
! 		     ((char *) (dst))[0] = (pixel);) \
  	    break; \
  	case 10: \
! 	    SwitchBitsLoop (((char *) (dst))[2] = (pixel); \
! 		     ((char *) (dst))[0] = (pixel);) \
  	    break; \
  	case 11: \
! 	    SwitchBitsLoop (((short *) (dst))[1] = (pixel); \
! 		     ((char *) (dst))[0] = (pixel);) \
  	    break; \
  	case 12: \
! 	    SwitchBitsLoop (((short *) (dst))[0] = (pixel);) \
  	    break; \
  	case 13: \
! 	    SwitchBitsLoop (((char *) (dst))[3] = (pixel); \
! 		     ((short *) (dst))[0] = (pixel);) \
  	    break; \
  	case 14: \
! 	    SwitchBitsLoop (((char *) (dst))[2] = (pixel); \
! 		     ((short *) (dst))[0] = (pixel);) \
  	    break; \
  	case 15: \
  	    SwitchBitsLoop (((long *) (dst))[0] = (pixel);) \
--- 269,328 ----
  	    break;			\
  	}
  
+ 
  #define SwitchFourBits(dst,pixel,bits) { \
  	switch (bits) { \
  	case 0: \
!        	    break; \
  	case 1: \
! 	    SwitchBitsLoop (((char *) (dst))[Byte0] = (pixel);) \
  	    break; \
  	case 2: \
! 	    SwitchBitsLoop (((char *) (dst))[Byte1] = (pixel);) \
  	    break; \
  	case 3: \
! 	    SwitchBitsLoop (((short *) (dst))[Short0] = (pixel);) \
  	    break; \
  	case 4: \
! 	    SwitchBitsLoop (((char *) (dst))[Byte2] = (pixel);) \
  	    break; \
  	case 5: \
! 	    SwitchBitsLoop (((char *) (dst))[Byte0] = (pixel); \
! 		     ((char *) (dst))[Byte2] = (pixel);) \
  	    break; \
  	case 6: \
! 	    SwitchBitsLoop (((char *) (dst))[Byte1] = (pixel); \
! 		     ((char *) (dst))[Byte2] = (pixel);) \
  	    break; \
  	case 7: \
! 	    SwitchBitsLoop (((short *) (dst))[Short0] = (pixel); \
! 		     ((char *) (dst))[Byte2] = (pixel);) \
  	    break; \
  	case 8: \
! 	    SwitchBitsLoop (((char *) (dst))[Byte3] = (pixel);) \
  	    break; \
  	case 9: \
! 	    SwitchBitsLoop (((char *) (dst))[Byte0] = (pixel); \
! 		     ((char *) (dst))[Byte3] = (pixel);) \
  	    break; \
  	case 10: \
! 	    SwitchBitsLoop (((char *) (dst))[Byte1] = (pixel); \
! 		     ((char *) (dst))[Byte3] = (pixel);) \
  	    break; \
  	case 11: \
! 	    SwitchBitsLoop (((short *) (dst))[Short0] = (pixel); \
! 		     ((char *) (dst))[Byte3] = (pixel);) \
  	    break; \
  	case 12: \
! 	    SwitchBitsLoop (((short *) (dst))[Short1] = (pixel);) \
  	    break; \
  	case 13: \
! 	    SwitchBitsLoop (((char *) (dst))[Byte0] = (pixel); \
! 		     ((short *) (dst))[Short1] = (pixel);) \
  	    break; \
  	case 14: \
! 	    SwitchBitsLoop (((char *) (dst))[Byte1] = (pixel); \
! 		     ((short *) (dst))[Short1] = (pixel);) \
  	    break; \
  	case 15: \
  	    SwitchBitsLoop (((long *) (dst))[0] = (pixel);) \
***************
*** 302,309 ****
  	    break; \
  	} \
  }
  
! #else /* BITMAP_BIT_ORDER */
  
  #define WriteFourBits(dst,pixel,bits) \
  	switch (bits) {			\
--- 329,337 ----
  	    break; \
  	} \
  }
+ #endif /* PSZ == 8 */
  
! #if PSZ == 16
  
  #define WriteFourBits(dst,pixel,bits) \
  	switch (bits) {			\
***************
*** 310,366 ****
  	case 0:				\
  	    break;			\
  	case 1:				\
! 	    ((char *) (dst))[0] = (pixel);	\
  	    break;			\
  	case 2:				\
! 	    ((char *) (dst))[1] = (pixel);	\
  	    break;			\
  	case 3:				\
! 	    ((short *) (dst))[0] = (pixel);	\
  	    break;			\
  	case 4:				\
! 	    ((char *) (dst))[2] = (pixel);	\
  	    break;			\
  	case 5:				\
! 	    ((char *) (dst))[0] = (pixel);	\
! 	    ((char *) (dst))[2] = (pixel);	\
  	    break;			\
  	case 6:				\
! 	    ((char *) (dst))[1] = (pixel);	\
! 	    ((char *) (dst))[2] = (pixel);	\
  	    break;			\
  	case 7:				\
! 	    ((short *) (dst))[0] = (pixel);	\
! 	    ((char *) (dst))[2] = (pixel);	\
  	    break;			\
  	case 8:				\
! 	    ((char *) (dst))[3] = (pixel);	\
  	    break;			\
  	case 9:				\
! 	    ((char *) (dst))[0] = (pixel);	\
! 	    ((char *) (dst))[3] = (pixel);	\
  	    break;			\
  	case 10:			\
! 	    ((char *) (dst))[1] = (pixel);	\
! 	    ((char *) (dst))[3] = (pixel);	\
  	    break;			\
  	case 11:			\
! 	    ((short *) (dst))[0] = (pixel);	\
! 	    ((char *) (dst))[3] = (pixel);	\
  	    break;			\
  	case 12:			\
! 	    ((short *) (dst))[1] = (pixel);	\
  	    break;			\
  	case 13:			\
! 	    ((char *) (dst))[0] = (pixel);	\
! 	    ((short *) (dst))[1] = (pixel);	\
  	    break;			\
  	case 14:			\
! 	    ((char *) (dst))[1] = (pixel);	\
! 	    ((short *) (dst))[1] = (pixel);	\
  	    break;			\
  	case 15:			\
! 	    ((long *) (dst))[0] = (pixel);	\
  	    break;			\
  	}
  
--- 338,395 ----
  	case 0:				\
  	    break;			\
  	case 1:				\
! 	    ((short *) (dst))[Short0] = (pixel);	\
  	    break;			\
  	case 2:				\
! 	    ((short *) (dst))[Short1] = (pixel);	\
  	    break;			\
  	case 3:				\
! 	    ((long *) (dst))[Long0] = (pixel);	\
  	    break;			\
  	case 4:				\
! 	    ((short *) (dst))[Short2] = (pixel);	\
  	    break;			\
  	case 5:				\
! 	    ((short *) (dst))[Short0] = (pixel);	\
! 	    ((short *) (dst))[Short2] = (pixel);	\
  	    break;			\
  	case 6:				\
! 	    ((short *) (dst))[Short1] = (pixel);	\
! 	    ((short *) (dst))[Short2] = (pixel);	\
  	    break;			\
  	case 7:				\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    ((short *) (dst))[Short2] = (pixel);	\
  	    break;			\
  	case 8:				\
! 	    ((short *) (dst))[Short3] = (pixel);	\
  	    break;			\
  	case 9:				\
! 	    ((short *) (dst))[Short0] = (pixel);	\
! 	    ((short *) (dst))[Short3] = (pixel);	\
  	    break;			\
  	case 10:			\
! 	    ((short *) (dst))[Short1] = (pixel);	\
! 	    ((short *) (dst))[Short3] = (pixel);	\
  	    break;			\
  	case 11:			\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    ((short *) (dst))[Short3] = (pixel);	\
  	    break;			\
  	case 12:			\
! 	    ((long *) (dst))[Long1] = (pixel);	\
  	    break;			\
  	case 13:			\
! 	    ((short *) (dst))[Short0] = (pixel);	\
! 	    ((long *) (dst))[Long1] = (pixel);	\
  	    break;			\
  	case 14:			\
! 	    ((short *) (dst))[Short1] = (pixel);	\
! 	    ((long *) (dst))[Long1] = (pixel);	\
  	    break;			\
  	case 15:			\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    ((long *) (dst))[Long1] = (pixel);	\
  	    break;			\
  	}
  
***************
*** 369,433 ****
  	case 0: \
         	    break; \
  	case 1: \
! 	    SwitchBitsLoop (((char *) (dst))[0] = (pixel);) \
  	    break; \
  	case 2: \
! 	    SwitchBitsLoop (((char *) (dst))[1] = (pixel);) \
  	    break; \
  	case 3: \
! 	    SwitchBitsLoop (((short *) (dst))[0] = (pixel);) \
  	    break; \
  	case 4: \
! 	    SwitchBitsLoop (((char *) (dst))[2] = (pixel);) \
  	    break; \
  	case 5: \
! 	    SwitchBitsLoop (((char *) (dst))[0] = (pixel); \
! 		     ((char *) (dst))[2] = (pixel);) \
  	    break; \
  	case 6: \
! 	    SwitchBitsLoop (((char *) (dst))[1] = (pixel); \
! 		     ((char *) (dst))[2] = (pixel);) \
  	    break; \
  	case 7: \
! 	    SwitchBitsLoop (((short *) (dst))[0] = (pixel); \
! 		     ((char *) (dst))[2] = (pixel);) \
  	    break; \
  	case 8: \
! 	    SwitchBitsLoop (((char *) (dst))[3] = (pixel);) \
  	    break; \
  	case 9: \
! 	    SwitchBitsLoop (((char *) (dst))[0] = (pixel); \
! 		     ((char *) (dst))[3] = (pixel);) \
  	    break; \
  	case 10: \
! 	    SwitchBitsLoop (((char *) (dst))[1] = (pixel); \
! 		     ((char *) (dst))[3] = (pixel);) \
  	    break; \
  	case 11: \
! 	    SwitchBitsLoop (((short *) (dst))[0] = (pixel); \
! 		     ((char *) (dst))[3] = (pixel);) \
  	    break; \
  	case 12: \
! 	    SwitchBitsLoop (((short *) (dst))[1] = (pixel);) \
  	    break; \
  	case 13: \
! 	    SwitchBitsLoop (((char *) (dst))[0] = (pixel); \
! 		     ((short *) (dst))[1] = (pixel);) \
  	    break; \
  	case 14: \
! 	    SwitchBitsLoop (((char *) (dst))[1] = (pixel); \
! 		     ((short *) (dst))[1] = (pixel);) \
  	    break; \
  	case 15: \
! 	    SwitchBitsLoop (((long *) (dst))[0] = (pixel);) \
  	    break; \
  	} \
  }
  
! # endif /* BITMAP_BIT_ORDER */
  #endif /* AVOID_MEMORY_READ */
  
  extern unsigned long	cfb8BitLenMasks[32];
  extern int		cfb8ComputeClipMasks32 ();
  
- #endif /* PPW == 4 */
--- 398,602 ----
  	case 0: \
         	    break; \
  	case 1: \
! 	    SwitchBitsLoop (((short *) (dst))[Short0] = (pixel);) \
  	    break; \
  	case 2: \
! 	    SwitchBitsLoop (((short *) (dst))[Short1] = (pixel);) \
  	    break; \
  	case 3: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel);) \
  	    break; \
  	case 4: \
! 	    SwitchBitsLoop (((short *) (dst))[Short2] = (pixel);) \
  	    break; \
  	case 5: \
! 	    SwitchBitsLoop (((short *) (dst))[Short0] = (pixel); \
! 		     ((short *) (dst))[Short2] = (pixel);) \
  	    break; \
  	case 6: \
! 	    SwitchBitsLoop (((short *) (dst))[Short1] = (pixel); \
! 		     ((short *) (dst))[Short2] = (pixel);) \
  	    break; \
  	case 7: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel); \
! 		     ((short *) (dst))[Short2] = (pixel);) \
  	    break; \
  	case 8: \
! 	    SwitchBitsLoop (((short *) (dst))[Short3] = (pixel);) \
  	    break; \
  	case 9: \
! 	    SwitchBitsLoop (((short *) (dst))[Short0] = (pixel); \
! 		     ((short *) (dst))[Short3] = (pixel);) \
  	    break; \
  	case 10: \
! 	    SwitchBitsLoop (((short *) (dst))[Short1] = (pixel); \
! 		     ((short *) (dst))[Short3] = (pixel);) \
  	    break; \
  	case 11: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel); \
! 		     ((short *) (dst))[Short3] = (pixel);) \
  	    break; \
  	case 12: \
! 	    SwitchBitsLoop (((long *) (dst))[Long1] = (pixel);) \
  	    break; \
  	case 13: \
! 	    SwitchBitsLoop (((short *) (dst))[Short0] = (pixel); \
! 		     ((long *) (dst))[Long1] = (pixel);) \
  	    break; \
  	case 14: \
! 	    SwitchBitsLoop (((short *) (dst))[Short1] = (pixel); \
! 		     ((long *) (dst))[Long1] = (pixel);) \
  	    break; \
  	case 15: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel); \
! 			    ((long *) (dst))[Long1] = (pixel);) \
  	    break; \
  	} \
  }
  
! #endif /* PSZ == 16 */
! #if PSZ == 32
! 
! #define WriteFourBits(dst,pixel,bits) \
! 	switch (bits) {			\
! 	case 0:				\
! 	    break;			\
! 	case 1:				\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    break;			\
! 	case 2:				\
! 	    ((long *) (dst))[Long1] = (pixel);	\
! 	    break;			\
! 	case 3:				\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    ((long *) (dst))[Long1] = (pixel);	\
! 	    break;			\
! 	case 4:				\
! 	    ((long *) (dst))[Long2] = (pixel);	\
! 	    break;			\
! 	case 5:				\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    ((long *) (dst))[Long2] = (pixel);	\
! 	    break;			\
! 	case 6:				\
! 	    ((long *) (dst))[Long1] = (pixel);	\
! 	    ((long *) (dst))[Long2] = (pixel);	\
! 	    break;			\
! 	case 7:				\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    ((long *) (dst))[Long1] = (pixel);	\
! 	    ((long *) (dst))[Long2] = (pixel);	\
! 	    break;			\
! 	case 8:				\
! 	    ((long *) (dst))[Long3] = (pixel);	\
! 	    break;			\
! 	case 9:				\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    ((long *) (dst))[Long3] = (pixel);	\
! 	    break;			\
! 	case 10:			\
! 	    ((long *) (dst))[Long1] = (pixel);	\
! 	    ((long *) (dst))[Long3] = (pixel);	\
! 	    break;			\
! 	case 11:			\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    ((long *) (dst))[Long1] = (pixel);	\
! 	    ((long *) (dst))[Long3] = (pixel);	\
! 	    break;			\
! 	case 12:			\
! 	    ((long *) (dst))[Long2] = (pixel);	\
! 	    ((long *) (dst))[Long3] = (pixel);	\
! 	    break;			\
! 	case 13:			\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    ((long *) (dst))[Long2] = (pixel);	\
! 	    ((long *) (dst))[Long3] = (pixel);	\
! 	    break;			\
! 	case 14:			\
! 	    ((long *) (dst))[Long1] = (pixel);	\
! 	    ((long *) (dst))[Long2] = (pixel);	\
! 	    ((long *) (dst))[Long3] = (pixel);	\
! 	    break;			\
! 	case 15:			\
! 	    ((long *) (dst))[Long0] = (pixel);	\
! 	    ((long *) (dst))[Long1] = (pixel);	\
! 	    ((long *) (dst))[Long2] = (pixel);	\
! 	    ((long *) (dst))[Long3] = (pixel);	\
! 	    break;			\
! 	}
! 
! #define SwitchFourBits(dst,pixel,bits) { \
! 	switch (bits) { \
! 	case 0: \
!        	    break; \
! 	case 1: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel);) \
! 	    break; \
! 	case 2: \
! 	    SwitchBitsLoop (((long *) (dst))[Long1] = (pixel);) \
! 	    break; \
! 	case 3: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel); \
! 			    ((long *) (dst))[Long1] = (pixel);) \
! 	    break; \
! 	case 4: \
! 	    SwitchBitsLoop (((long *) (dst))[Long2] = (pixel);) \
! 	    break; \
! 	case 5: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel); \
! 			    ((long *) (dst))[Long2] = (pixel);) \
! 	    break; \
! 	case 6: \
! 	    SwitchBitsLoop (((long *) (dst))[Long1] = (pixel); \
! 			    ((long *) (dst))[Long2] = (pixel);) \
! 	    break; \
! 	case 7: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel); \
! 			    ((long *) (dst))[Long1] = (pixel); \
! 			    ((long *) (dst))[Long2] = (pixel);) \
! 	    break; \
! 	case 8: \
! 	    SwitchBitsLoop (((long *) (dst))[Long3] = (pixel);) \
! 	    break; \
! 	case 9: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel); \
! 			    ((long *) (dst))[Long3] = (pixel);) \
! 	    break; \
! 	case 10: \
! 	    SwitchBitsLoop (((long *) (dst))[Long1] = (pixel); \
! 			    ((long *) (dst))[Long3] = (pixel);) \
! 	    break; \
! 	case 11: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel); \
! 			    ((long *) (dst))[Long1] = (pixel); \
! 			    ((long *) (dst))[Long3] = (pixel);) \
! 	    break; \
! 	case 12: \
! 	    SwitchBitsLoop (((long *) (dst))[Long2] = (pixel); \
! 			    ((long *) (dst))[Long3] = (pixel);) \
! 	    break; \
! 	case 13: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel); \
! 			    ((long *) (dst))[Long2] = (pixel); \
! 			    ((long *) (dst))[Long3] = (pixel);) \
! 	    break; \
! 	case 14: \
! 	    SwitchBitsLoop (((long *) (dst))[Long1] = (pixel); \
! 			    ((long *) (dst))[Long2] = (pixel); \
! 			    ((long *) (dst))[Long3] = (pixel);) \
! 	    break; \
! 	case 15: \
! 	    SwitchBitsLoop (((long *) (dst))[Long0] = (pixel); \
! 			    ((long *) (dst))[Long1] = (pixel); \
! 			    ((long *) (dst))[Long2] = (pixel); \
! 			    ((long *) (dst))[Long3] = (pixel);) \
! 	    break; \
! 	} \
! }
! 
! #endif /* PSZ == 32 */
  #endif /* AVOID_MEMORY_READ */
  
  extern unsigned long	cfb8BitLenMasks[32];
  extern int		cfb8ComputeClipMasks32 ();
  
*** /tmp/,RCSt1a08356	Fri Feb  7 18:44:11 1992
--- server/ddx/cfb/cfb8cppl.c	Thu Dec 19 18:36:58 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: cfb8cppl.c,v 1.5 91/08/22 15:41:05 keith Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: cfb8cppl.c,v 1.7 91/12/19 18:36:56 keith Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
***************
*** 23,34 ****
   * Author:  Keith Packard, MIT X Consortium
   */
  
! /* 
!  * this is actually an mfb-specific function, except that
!  * it knows how to read from 8-bit cfb pixmaps.  Alas, this
!  * means that it doesn't know PPW so it is always compiled
!  */
! 
  #include "X.h"
  #include "Xmd.h"
  #include "gcstruct.h"
--- 23,29 ----
   * Author:  Keith Packard, MIT X Consortium
   */
  
! #if PSZ == 8
  #include "X.h"
  #include "Xmd.h"
  #include "gcstruct.h"
***************
*** 37,44 ****
  #include "scrnintstr.h"
  #include "windowstr.h"
  #include "cfb.h"
  #include "maskbits.h"
- 
  #include "mergerop.h"
  
  #if BITMAP_BIT_ORDER == MSBFirst
--- 32,39 ----
  #include "scrnintstr.h"
  #include "windowstr.h"
  #include "cfb.h"
+ #undef PSZ /* for maskbits.h */
  #include "maskbits.h"
  #include "mergerop.h"
  
  #if BITMAP_BIT_ORDER == MSBFirst
***************
*** 216,218 ****
--- 211,215 ----
  	}
      }
  }
+ 
+ #endif
*** /tmp/,RCSt1a08374	Fri Feb  7 18:44:18 1992
--- server/ddx/cfb/cfb8line.c	Thu Dec 19 14:15:38 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: cfb8line.c,v 1.19 91/07/09 16:07:32 rws Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: cfb8line.c,v 1.20 91/12/19 14:15:34 keith Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
***************
*** 36,41 ****
--- 36,43 ----
  #include "cfbmskbits.h"
  #include "cfbrrop.h"
  
+ #ifdef PIXEL_ADDR
+ 
  #if defined(__GNUC__) && defined(mc68020)
  #define STUPID volatile
  #define REARRANGE
***************
*** 164,170 ****
  {
      register int    e;
      register int    y1_or_e1;
!     register unsigned char   *addrb;
      register int    stepmajor;
      register int    stepminor;
  #ifndef REARRANGE
--- 166,172 ----
  {
      register int    e;
      register int    y1_or_e1;
!     register PixelType   *addrp;
      register int    stepmajor;
      register int    stepminor;
  #ifndef REARRANGE
***************
*** 205,211 ****
  # define Y2  intToY(c2)
  #endif
      unsigned long    ClipMask = 0x80008000;
!     unsigned char   *addr;
      int		    nwidth;
      cfbPrivGCPtr    devPriv;
      BoxPtr	    extents;
--- 207,213 ----
  # define Y2  intToY(c2)
  #endif
      unsigned long    ClipMask = 0x80008000;
!     PixelType   *addr;
      int		    nwidth;
      cfbPrivGCPtr    devPriv;
      BoxPtr	    extents;
***************
*** 212,218 ****
      int		    *ppt;
  
      devPriv = (cfbPrivGC *)(pGC->devPrivates[cfbGCPrivateIndex].ptr); 
!     cfbGetByteWidthAndPointer (pDrawable, nwidth, addr);
  #ifndef REARRANGE
      RROP_FETCH_GCPRIV(devPriv);
  #endif
--- 214,220 ----
      int		    *ppt;
  
      devPriv = (cfbPrivGC *)(pGC->devPrivates[cfbGCPrivateIndex].ptr); 
!     cfbGetPixelWidthAndPointer (pDrawable, nwidth, addr);
  #ifndef REARRANGE
      RROP_FETCH_GCPRIV(devPriv);
  #endif
***************
*** 249,255 ****
  #ifdef SAVE_X2Y2
      intToCoord(c2,x2,y2);
  #endif
!     addrb = addr + WIDTH_MUL(Y2, nwidth) + X2;
      while (--npt)
  #endif
      {
--- 251,257 ----
  #ifdef SAVE_X2Y2
      intToCoord(c2,x2,y2);
  #endif
!     addrp = addr + WIDTH_MUL(Y2, nwidth) + X2;
      while (--npt)
  #endif
      {
***************
*** 261,267 ****
  	    break;
  	intToCoord(y1_or_e1,x1_or_len,y1_or_e1);
  	/* compute now to avoid needing x1, y1 later */
! 	addrb = addr + WIDTH_MUL(y1_or_e1, nwidth) + x1_or_len;
  #else
  #ifndef SAVE_X2Y2
  	y1_or_e1 = c2;
--- 263,269 ----
  	    break;
  	intToCoord(y1_or_e1,x1_or_len,y1_or_e1);
  	/* compute now to avoid needing x1, y1 later */
! 	addrp = addr + WIDTH_MUL(y1_or_e1, nwidth) + x1_or_len;
  #else
  #ifndef SAVE_X2Y2
  	y1_or_e1 = c2;
***************
*** 351,362 ****
  	e3 = e << 1;
  
  #define body {\
! 	    RROP_SOLID(addrb); \
! 	    addrb += stepmajor; \
  	    e += y1_or_e1; \
  	    if (e >= 0) \
  	    { \
! 		addrb += stepminor; \
  		e += e3; \
  	     } \
  	}
--- 353,364 ----
  	e3 = e << 1;
  
  #define body {\
! 	    RROP_SOLID(addrp); \
! 	    addrp += stepmajor; \
  	    e += y1_or_e1; \
  	    if (e >= 0) \
  	    { \
! 		addrp += stepminor; \
  		e += e3; \
  	     } \
  	}
***************
*** 413,419 ****
  #endif
  
  #ifdef POLYSEGMENT
! 	RROP_SOLID(addrb);
  #endif
  	}
  #undef body
--- 415,421 ----
  #endif
  
  #ifdef POLYSEGMENT
! 	RROP_SOLID(addrp);
  #endif
  	}
  #undef body
***************
*** 422,428 ****
  	else
  	{
  # ifndef POLYSEGMENT
! 	    unsigned char    *t;
  #endif
  
  # ifdef REARRANGE
--- 424,430 ----
  	else
  	{
  # ifndef POLYSEGMENT
! 	    PixelType    *t;
  #endif
  
  # ifdef REARRANGE
***************
*** 432,464 ****
  # endif
  	    if (stepmajor < 0)
  	    {
! 		addrb -= x1_or_len;
  # ifndef POLYSEGMENT
! 		t = addrb;
  # else
  		if (capStyle)
  		    x1_or_len++;
  		else
  # endif
! 		    addrb++;
  	    }
  	    else
  	    {
  # ifndef POLYSEGMENT
! 		t = addrb + x1_or_len;
  # else
  		if (capStyle)
  		    x1_or_len++;
  # endif
  	    }
! 	    y1_or_e1 = ((int) addrb) & 3;
! 	    addrb = addrb - y1_or_e1;
  	    if (y1_or_e1 + x1_or_len <= PPW)
  	    {
  		if (x1_or_len)
  		{
  		    maskpartialbits(y1_or_e1, x1_or_len, e)
! 		    RROP_SOLID_MASK((int *) addrb, e);
  		}
  	    }
  	    else
--- 434,469 ----
  # endif
  	    if (stepmajor < 0)
  	    {
! 		addrp -= x1_or_len;
  # ifndef POLYSEGMENT
! 		t = addrp;
  # else
  		if (capStyle)
  		    x1_or_len++;
  		else
  # endif
! 		    addrp++;
  	    }
  	    else
  	    {
  # ifndef POLYSEGMENT
! 		t = addrp + x1_or_len;
  # else
  		if (capStyle)
  		    x1_or_len++;
  # endif
  	    }
! 	    y1_or_e1 = ((int) addrp) & (sizeof (long) - 1);
! 	    addrp = (PixelType *) (((unsigned char *) addrp) - y1_or_e1);
! #if PWSH != 2
! 	    y1_or_e1 >>= (2 - PWSH);
! #endif
  	    if (y1_or_e1 + x1_or_len <= PPW)
  	    {
  		if (x1_or_len)
  		{
  		    maskpartialbits(y1_or_e1, x1_or_len, e)
! 		    RROP_SOLID_MASK((unsigned long *) addrp, e);
  		}
  	    }
  	    else
***************
*** 466,480 ****
  	    	maskbits(y1_or_e1, x1_or_len, e, e3, x1_or_len)
  	    	if (e)
  	    	{
! 		    RROP_SOLID_MASK((int *) addrb, e);
! 		    addrb += 4;
  	    	}
! 		RROP_SPAN(addrb, x1_or_len)
  	    	if (e3)
! 		    RROP_SOLID_MASK((int *) addrb, e3);
  	    }
  # ifndef POLYSEGMENT
! 	    addrb = t;
  # endif
  	}
  #endif
--- 471,485 ----
  	    	maskbits(y1_or_e1, x1_or_len, e, e3, x1_or_len)
  	    	if (e)
  	    	{
! 		    RROP_SOLID_MASK((unsigned long *) addrp, e);
! 		    addrp += PPW;
  	    	}
! 		RROP_SPAN(addrp, x1_or_len)
  	    	if (e3)
! 		    RROP_SOLID_MASK((unsigned long *) addrp, e3);
  	    }
  # ifndef POLYSEGMENT
! 	    addrp = t;
  # endif
  	}
  #endif
***************
*** 500,506 ****
  
  	RROP_FETCH_GCPRIV(devPriv);
  # endif
! 	RROP_SOLID (addrb);
      }
  #endif
      return -1;
--- 505,511 ----
  
  	RROP_FETCH_GCPRIV(devPriv);
  # endif
! 	RROP_SOLID (addrp);
      }
  #endif
      return -1;
***************
*** 539,545 ****
  	func = cfb8SegmentSS1RectCopy;
  	clip = cfb8ClippedLineCopy;
  #ifdef FAST_MUL
! 	if (cfbGetByteWidth (pDrawable) == WIDTH_FAST)
  	    func = cfb8SegmentSS1RectShiftCopy;
  #endif
  	break;
--- 544,550 ----
  	func = cfb8SegmentSS1RectCopy;
  	clip = cfb8ClippedLineCopy;
  #ifdef FAST_MUL
! 	if (cfbGetPixelWidth (pDrawable) == WIDTH_FAST)
  	    func = cfb8SegmentSS1RectShiftCopy;
  #endif
  	break;
***************
*** 716,728 ****
      int		    signdx, signdy, axis, e, e1, e3, len;
      int		    adx, ady;
  
!     unsigned char   *addr;
      int		    nwidth;
      int		    stepx, stepy;
      int		    xorg, yorg;
  
  
!     cfbGetByteWidthAndPointer(pDrawable, nwidth, addr);
  
      xorg = pDrawable->x;
      yorg = pDrawable->y;
--- 721,733 ----
      int		    signdx, signdy, axis, e, e1, e3, len;
      int		    adx, ady;
  
!     PixelType   *addr;
      int		    nwidth;
      int		    stepx, stepy;
      int		    xorg, yorg;
  
  
!     cfbGetPixelWidthAndPointer(pDrawable, nwidth, addr);
  
      xorg = pDrawable->x;
      yorg = pDrawable->y;
***************
*** 819,835 ****
  	return;
  
      {
!     register unsigned char	*addrb;
      RROP_DECLARE
  
      RROP_FETCH_GC(pGC);
  
!     addrb = addr + (y1 * nwidth) + x1;
  
  #ifndef REARRANGE
      if (!ady)
      {
! #define body	{ RROP_SOLID(addrb); addrb += stepx; }
  	while (len >= 4)
  	{
  	    body body body body
--- 824,840 ----
  	return;
  
      {
!     register PixelType	*addrp;
      RROP_DECLARE
  
      RROP_FETCH_GC(pGC);
  
!     addrp = addr + (y1 * nwidth) + x1;
  
  #ifndef REARRANGE
      if (!ady)
      {
! #define body	{ RROP_SOLID(addrp); addrp += stepx; }
  	while (len >= 4)
  	{
  	    body body body body
***************
*** 845,856 ****
  #endif
      {
  #define body {\
! 	    RROP_SOLID(addrb); \
! 	    addrb += stepx; \
  	    e += e1; \
  	    if (e >= 0) \
  	    { \
! 		addrb += stepy; \
  		e += e3; \
  	     } \
  	}
--- 850,861 ----
  #endif
      {
  #define body {\
! 	    RROP_SOLID(addrp); \
! 	    addrp += stepx; \
  	    e += e1; \
  	    if (e >= 0) \
  	    { \
! 		addrp += stepy; \
  		e += e3; \
  	     } \
  	}
***************
*** 878,884 ****
  
  #endif
      }
!     RROP_SOLID(addrb);
  #undef body
  
      }
--- 883,889 ----
  
  #endif
      }
!     RROP_SOLID(addrp);
  #undef body
  
      }
***************
*** 885,887 ****
--- 890,893 ----
  }
  
  #endif /* !POLYSEGMENT && !PREVIOUS */
+ #endif /* PIXEL_ADDR */
*** /dev/null	Fri Feb  7 17:57:27 1992
--- server/ddx/cfb/cfballpriv.c	Thu Dec 19 18:37:03 1991
***************
*** 0 ****
--- 1,83 ----
+ /*
+  * $XConsortium: cfballpriv.c,v 1.2 91/12/19 18:37:00 keith Exp $
+  *
+  * Copyright 1991 Massachusetts Institute of Technology
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and its
+  * documentation for any purpose is hereby granted without fee, provided that
+  * the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of M.I.T. not be used in advertising or
+  * publicity pertaining to distribution of the software without specific,
+  * written prior permission.  M.I.T. makes no representations about the
+  * suitability of this software for any purpose.  It is provided "as is"
+  * without express or implied warranty.
+  *
+  * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.
+  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * Author:  Keith Packard, MIT X Consortium
+  */
+ 
+ #include "X.h"
+ #include "Xmd.h"
+ #include "servermd.h"
+ #include "scrnintstr.h"
+ #include "pixmapstr.h"
+ #include "resource.h"
+ #include "colormap.h"
+ #include "colormapst.h"
+ #include "cfb.h"
+ #include "mi.h"
+ #include "mistruct.h"
+ #include "dix.h"
+ #include "cfbmskbits.h"
+ #include "mibstore.h"
+ 
+ int cfbWindowPrivateIndex;
+ int cfbGCPrivateIndex;
+ #ifdef CFB_NEED_SCREEN_PRIVATE
+ int cfbScreenPrivateIndex;
+ #endif
+ 
+ extern RegionPtr    miCopyPlane (), (*cfbPuntCopyPlane)();
+ 
+ Bool
+ cfbAllocatePrivates(pScreen, window_index, gc_index)
+     ScreenPtr	pScreen;
+     int		*window_index, *gc_index;
+ {
+     if (!window_index || !gc_index ||
+ 	*window_index == -1 && *gc_index == -1)
+     {
+     	if (!mfbAllocatePrivates(pScreen,
+ 			     	 &cfbWindowPrivateIndex, &cfbGCPrivateIndex))
+ 	    return FALSE;
+     	if (window_index)
+ 	    *window_index = cfbWindowPrivateIndex;
+     	if (gc_index)
+ 	    *gc_index = cfbGCPrivateIndex;
+     }
+     else
+     {
+ 	cfbWindowPrivateIndex = *window_index;
+ 	cfbGCPrivateIndex = *gc_index;
+     }
+     if (!AllocateWindowPrivate(pScreen, cfbWindowPrivateIndex,
+ 			       sizeof(cfbPrivWin)) ||
+ 	!AllocateGCPrivate(pScreen, cfbGCPrivateIndex, sizeof(cfbPrivGC)))
+ 	return FALSE;
+ #if PSZ != 8
+     cfbPuntCopyPlane = miCopyPlane;
+ #endif
+ #ifdef CFB_NEED_SCREEN_PRIVATE
+     cfbScreenPrivateIndex = AllocateScreenPrivateIndex ();
+     if (cfbScreenPrivateIndex == -1)
+ 	return FALSE;
+ #endif
+     return TRUE;
+ }
*** /tmp/,RCSt1a08406	Fri Feb  7 18:44:31 1992
--- server/ddx/cfb/cfbbitblt.c	Thu Dec 19 18:36:47 1991
***************
*** 18,24 ****
  Author: Keith Packard
  
  */
! /* $XConsortium: cfbbitblt.c,v 5.43 91/07/19 23:20:45 keith Exp $ */
  
  #include	"X.h"
  #include	"Xmd.h"
--- 18,24 ----
  Author: Keith Packard
  
  */
! /* $XConsortium: cfbbitblt.c,v 5.45 91/12/19 18:36:43 keith Exp $ */
  
  #include	"X.h"
  #include	"Xmd.h"
***************
*** 342,348 ****
              pGC, srcx, srcy, width, height, dstx, dsty, doBitBlt, 0);
  }
  
! #if (PPW == 4)
  
  cfbCopyPlane1to8 (pSrcDrawable, pDstDrawable, rop, prgnDst, pptSrc, planemask, bitPlane)
      DrawablePtr pSrcDrawable;
--- 342,348 ----
              pGC, srcx, srcy, width, height, dstx, dsty, doBitBlt, 0);
  }
  
! #if PSZ == 8
  
  cfbCopyPlane1to8 (pSrcDrawable, pDstDrawable, rop, prgnDst, pptSrc, planemask, bitPlane)
      DrawablePtr pSrcDrawable;
***************
*** 607,612 ****
--- 607,615 ----
  
  #endif
  
+ /* shared among all different cfb depths through linker magic */
+ RegionPtr   (*cfbPuntCopyPlane)();
+ 
  RegionPtr cfbCopyPlane(pSrcDrawable, pDstDrawable,
  	    pGC, srcx, srcy, width, height, dstx, dsty, bitPlane)
      DrawablePtr 	pSrcDrawable;
***************
*** 621,627 ****
      extern RegionPtr    miHandleExposures();
      int		(*doBitBlt)();
  
! #if (PPW == 4)
      extern cfbCopyPlane8to1();
  
      if (pSrcDrawable->bitsPerPixel == 1 && pDstDrawable->bitsPerPixel == 8)
--- 624,630 ----
      extern RegionPtr    miHandleExposures();
      int		(*doBitBlt)();
  
! #if PSZ == 8
      extern cfbCopyPlane8to1();
  
      if (pSrcDrawable->bitsPerPixel == 1 && pDstDrawable->bitsPerPixel == 8)
***************
*** 653,659 ****
  		    pGC, srcx, srcy, width, height, dstx, dsty, cfbCopyPlane8to1, bitPlane);
  	pGC->alu = oldalu;
      }
!     else
      {
  	PixmapPtr	pBitmap;
  	ScreenPtr	pScreen = pSrcDrawable->pScreen;
--- 656,662 ----
  		    pGC, srcx, srcy, width, height, dstx, dsty, cfbCopyPlane8to1, bitPlane);
  	pGC->alu = oldalu;
      }
!     else if (pSrcDrawable->bitsPerPixel == 8 && pDstDrawable->bitsPerPixel == 8)
      {
  	PixmapPtr	pBitmap;
  	ScreenPtr	pScreen = pSrcDrawable->pScreen;
***************
*** 691,699 ****
  				 srcx, srcy, width, height,
  				 dstx, dsty, bitPlane);
      }
!     return ret;
! #else
!     return miCopyPlane (pSrcDrawable, pDstDrawable,
! 	    pGC, srcx, srcy, width, height, dstx, dsty, bitPlane);
  #endif
  }
--- 694,702 ----
  				 srcx, srcy, width, height,
  				 dstx, dsty, bitPlane);
      }
!     else
  #endif
+     ret = (*cfbPuntCopyPlane) (pSrcDrawable, pDstDrawable,
+ 	    pGC, srcx, srcy, width, height, dstx, dsty, bitPlane);
+     return ret;
  }
*** /tmp/,RCSt1a08442	Fri Feb  7 18:44:43 1992
--- server/ddx/cfb/cfbbres.c	Thu Dec 19 14:16:03 1991
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbbres.c,v 1.10 91/07/10 14:53:48 keith Exp $ */
  #include "X.h"
  #include "misc.h"
  #include "cfb.h"
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbbres.c,v 1.11 91/12/19 14:16:00 keith Exp $ */
  #include "X.h"
  #include "misc.h"
  #include "cfb.h"
***************
*** 34,64 ****
  */
  
  cfbBresS(rop, and, xor, addrl, nlwidth, signdx, signdy, axis, x1, y1, e, e1, e2, len)
! int rop;
! unsigned long and, xor;
! int *addrl;		/* pointer to base of bitmap */
! int nlwidth;		/* width in longwords of bitmap */
! register int signdx;
! int signdy;		/* signs of directions */
! int axis;		/* major axis (Y_AXIS or X_AXIS) */
! int x1, y1;		/* initial point */
! register int e;		/* error accumulator */
! register int e1;	/* bresenham increments */
! int e2;
! int len;		/* length of line */
  {
!     register int    e3 = e2-e1;
  
- #if (PPW == 4)
-     register unsigned char *addrb;		/* bitmask long pointer 
- 					     	 * cast to char pointer */
-     register unsigned char pix = xor;
- 
      if (len == 0)
      	return;
      /* point to first point */
!     nlwidth <<= 2;
!     addrb = (unsigned char *)(addrl) + (y1 * nlwidth) + x1;
      if (signdy < 0)
      	nlwidth = -nlwidth;
      e = e-e1;			/* to make looping easier */
--- 34,61 ----
  */
  
  cfbBresS(rop, and, xor, addrl, nlwidth, signdx, signdy, axis, x1, y1, e, e1, e2, len)
!     int		    rop;
!     unsigned long   and, xor;
!     unsigned long   *addrl;		/* pointer to base of bitmap */
!     int		    nlwidth;		/* width in longwords of bitmap */
!     register int    signdx;
!     int		    signdy;		/* signs of directions */
!     int		    axis;		/* major axis (Y_AXIS or X_AXIS) */
!     int		    x1, y1;		/* initial point */
!     register int    e;			/* error accumulator */
!     register int    e1;			/* bresenham increments */
!     int		    e2;
!     int		    len;		/* length of line */
  {
!     register int	e3 = e2-e1;
! #ifdef PIXEL_ADDR
!     register PixelType	*addrp;		/* Pixel pointer */
  
      if (len == 0)
      	return;
      /* point to first point */
!     nlwidth <<= PWSH;
!     addrp = (PixelType *)(addrl) + (y1 * nlwidth) + x1;
      if (signdy < 0)
      	nlwidth = -nlwidth;
      e = e-e1;			/* to make looping easier */
***************
*** 75,106 ****
      {
  	--len;
  #define body {\
! 	    *addrb = pix; \
! 	    addrb += signdx; \
  	    e += e1; \
  	    if (e >= 0) \
  	    { \
! 		addrb += nlwidth; \
  		e += e3; \
  	    } \
  	}
- #ifdef LARGE_INSTRUCTION_CACHE
- 	while (len >= 16)
- 	{
- 	    body body body body
- 	    body body body body
- 	    body body body body
- 	    body body body body
- 	    len -= 16;
- 	}
- 	switch (len)
- 	{
- 	case 15: body case 14: body case 13: body case 12: body
- 	case 11: body case 10: body case  9: body case  8: body
- 	case  7: body case  6: body case  5: body case  4: body
- 	case  3: body case  2: body case  1: body
- 	}
- #else
  	while (len >= 4)
  	{
  	    body body body body
--- 72,86 ----
      {
  	--len;
  #define body {\
! 	    *addrp = xor; \
! 	    addrp += signdx; \
  	    e += e1; \
  	    if (e >= 0) \
  	    { \
! 		addrp += nlwidth; \
  		e += e3; \
  	    } \
  	}
  	while (len >= 4)
  	{
  	    body body body body
***************
*** 110,131 ****
  	{
  	case  3: body case  2: body case  1: body
  	}
- #endif
  #undef body
! 	*addrb = pix;
      }
      else
      {
  	while(len--)
  	{ 
! 	    *addrb = DoRRop (*addrb, and, xor);
  	    e += e1;
  	    if (e >= 0)
  	    {
! 		addrb += nlwidth;
  		e += e3;
  	    }
! 	    addrb += signdx;
  	}
      }
  #else
--- 90,110 ----
  	{
  	case  3: body case  2: body case  1: body
  	}
  #undef body
! 	*addrp = xor;
      }
      else
      {
  	while(len--)
  	{ 
! 	    *addrp = DoRRop (*addrp, and, xor);
  	    e += e1;
  	    if (e >= 0)
  	    {
! 		addrp += nlwidth;
  		e += e3;
  	    }
! 	    addrp += signdx;
  	}
      }
  #else
*** /tmp/,RCSt1a08460	Fri Feb  7 18:44:50 1992
--- server/ddx/cfb/cfbbresd.c	Thu Dec 26 14:37:55 1991
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbbresd.c,v 1.11 91/12/26 14:32:45 rws Exp $ */
  #include "X.h"
  #include "misc.h"
  #include "cfb.h"
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbbresd.c,v 1.12 91/12/26 14:36:31 keith Exp $ */
  #include "X.h"
  #include "misc.h"
  #include "cfb.h"
***************
*** 33,71 ****
  	 pdashIndex, pDash, numInDashList, pdashOffset, isDoubleDash,
  	 addrl, nlwidth,
  	 signdx, signdy, axis, x1, y1, e, e1, e2, len)
! cfbRRopPtr  rrops;
! int *pdashIndex;	/* current dash */
! unsigned char *pDash;	/* dash list */
! int numInDashList;	/* total length of dash list */
! int *pdashOffset;	/* offset into current dash */
! int isDoubleDash;
! int *addrl;		/* pointer to base of bitmap */
! int nlwidth;		/* width in longwords of bitmap */
! int signdx, signdy;	/* signs of directions */
! int axis;		/* major axis (Y_AXIS or X_AXIS) */
! int x1, y1;		/* initial point */
! register int e;		/* error accumulator */
! register int e1;	/* bresenham increments */
! int e2;
! int len;		/* length of line */
  {
!     register unsigned char *addrb;
!     register int e3 = e2-e1;
!     int dashIndex;
!     int dashOffset;
!     int dashRemaining;
!     unsigned long   xorFg, andFg, xorBg, andBg;
!     Bool isCopy;
!     int thisDash;
  
      dashOffset = *pdashOffset;
      dashIndex = *pdashIndex;
-     dashRemaining = pDash[dashIndex] - dashOffset;
      isCopy = (rrops[0].rop == GXcopy && rrops[1].rop == GXcopy);
      xorFg = rrops[0].xor;
      andFg = rrops[0].and;
      xorBg = rrops[1].xor;
      andBg = rrops[1].and;
      if ((thisDash = dashRemaining) >= len)
      {
  	thisDash = len;
--- 33,71 ----
  	 pdashIndex, pDash, numInDashList, pdashOffset, isDoubleDash,
  	 addrl, nlwidth,
  	 signdx, signdy, axis, x1, y1, e, e1, e2, len)
!     cfbRRopPtr	    rrops;
!     int		    *pdashIndex;	/* current dash */
!     unsigned char   *pDash;		/* dash list */
!     int		    numInDashList;	/* total length of dash list */
!     int		    *pdashOffset;	/* offset into current dash */
!     int		    isDoubleDash;
!     unsigned long   *addrl;		/* pointer to base of bitmap */
!     int		    nlwidth;		/* width in longwords of bitmap */
!     int		    signdx, signdy;	/* signs of directions */
!     int		    axis;		/* major axis (Y_AXIS or X_AXIS) */
!     int		    x1, y1;		/* initial point */
!     register int    e;			/* error accumulator */
!     register int    e1;			/* bresenham increments */
!     int		    e2;
!     int		    len;		/* length of line */
  {
!     register PixelType	*addrp;
!     register		int e3 = e2-e1;
!     int			dashIndex;
!     int			dashOffset;
!     int			dashRemaining;
!     unsigned long	xorFg, andFg, xorBg, andBg;
!     Bool		isCopy;
!     int			thisDash;
  
      dashOffset = *pdashOffset;
      dashIndex = *pdashIndex;
      isCopy = (rrops[0].rop == GXcopy && rrops[1].rop == GXcopy);
      xorFg = rrops[0].xor;
      andFg = rrops[0].and;
      xorBg = rrops[1].xor;
      andBg = rrops[1].and;
+     dashRemaining = pDash[dashIndex] - dashOffset;
      if ((thisDash = dashRemaining) >= len)
      {
  	thisDash = len;
***************
*** 87,101 ****
      } \
  }
  
! #if (PPW == 4)
  
  #define Loop(store) while (thisDash--) {\
  			store; \
!  			BresStep(addrb+=signdy,addrb+=signdx) \
  		    }
      /* point to first point */
!     nlwidth <<= 2;
!     addrb = (unsigned char *)(addrl) + (y1 * nlwidth) + x1;
      signdy *= nlwidth;
      if (axis == Y_AXIS)
      {
--- 87,101 ----
      } \
  }
  
! #ifdef PIXEL_ADDR
  
  #define Loop(store) while (thisDash--) {\
  			store; \
!  			BresStep(addrp+=signdy,addrp+=signdx) \
  		    }
      /* point to first point */
!     nlwidth <<= PWSH;
!     addrp = (PixelType *)(addrl) + (y1 * nlwidth) + x1;
      signdy *= nlwidth;
      if (axis == Y_AXIS)
      {
***************
*** 113,124 ****
  	    len -= thisDash;
  	    if (dashIndex & 1) {
  		if (isDoubleDash) {
! 		    Loop(*addrb = xorBg)
  		} else {
  		    Loop(;)
  		}
  	    } else {
! 		Loop(*addrb = xorFg)
  	    }
  	    if (!len)
  		break;
--- 113,124 ----
  	    len -= thisDash;
  	    if (dashIndex & 1) {
  		if (isDoubleDash) {
! 		    Loop(*addrp = xorBg)
  		} else {
  		    Loop(;)
  		}
  	    } else {
! 		Loop(*addrp = xorFg)
  	    }
  	    if (!len)
  		break;
***************
*** 132,143 ****
  	    len -= thisDash;
  	    if (dashIndex & 1) {
  		if (isDoubleDash) {
! 		    Loop(*addrb = DoRRop(*addrb,andBg, xorBg))
  		} else {
  		    Loop(;)
  		}
  	    } else {
! 		Loop(*addrb = DoRRop(*addrb,andFg, xorFg))
  	    }
  	    if (!len)
  		break;
--- 132,143 ----
  	    len -= thisDash;
  	    if (dashIndex & 1) {
  		if (isDoubleDash) {
! 		    Loop(*addrp = DoRRop(*addrp,andBg, xorBg))
  		} else {
  		    Loop(;)
  		}
  	    } else {
! 		Loop(*addrp = DoRRop(*addrp,andFg, xorFg))
  	    }
  	    if (!len)
  		break;
*** /tmp/,RCSt1a08499	Fri Feb  7 18:45:03 1992
--- server/ddx/cfb/cfbcmap.c	Thu Dec 19 14:16:11 1991
***************
*** 309,311 ****
--- 309,532 ----
      (*pScreen->InstallColormap)(cmap);
      return TRUE;
  }
+ 
+ extern int defaultColorVisualClass;
+ 
+ #define _BP 8
+ #define _RZ(d) ((d + 2) / 3)
+ #define _RS(d) 0
+ #define _RM(d) ((1 << _RZ(d)) - 1)
+ #define _GZ(d) ((d - _RZ(d) + 1) / 2)
+ #define _GS(d) _RZ(d)
+ #define _GM(d) (((1 << _GZ(d)) - 1) << _GS(d))
+ #define _BZ(d) (d - _RZ(d) - _GZ(d))
+ #define _BS(d) (_RZ(d) + _GZ(d))
+ #define _BM(d) (((1 << _BZ(d)) - 1) << _BS(d))
+ #define _CE(d) (1 << _RZ(d))
+ 
+ #define MAX_PSEUDO_DEPTH    10	    /* largest DAC size I know */
+ 
+ #define StaticGrayMask	(1 << StaticGray)
+ #define GrayScaleMask	(1 << GrayScale)
+ #define StaticColorMask	(1 << StaticColor)
+ #define PseudoColorMask	(1 << PseudoColor)
+ #define TrueColorMask	(1 << TrueColor)
+ #define DirectColorMask (1 << DirectColor)
+ 
+ #define ALL_VISUALS	(StaticGrayMask|\
+ 			 GrayScaleMask|\
+ 			 StaticColorMask|\
+ 			 PseudoColorMask|\
+ 			 TrueColorMask|\
+ 			 DirectColorMask)
+ 
+ #define LARGE_VISUALS	(TrueColorMask|\
+ 			 DirectColorMask)
+ 
+ typedef struct _cfbVisuals {
+     struct _cfbVisuals	*next;
+     int			depth;
+     int			bitsPerRGB;
+     int			visuals;
+     int			count;
+ } cfbVisualsRec, *cfbVisualsPtr;
+ 
+ static int  cfbVisualPriority[] = {
+     PseudoColor, DirectColor, GrayScale, StaticColor, TrueColor, StaticGray
+ };
+ 
+ #define NUM_PRIORITY	6
+ 
+ static cfbVisualsPtr	cfbVisuals;
+ 
+ Bool
+ cfbSetVisualTypes (depth, visuals, bitsPerRGB)
+     int	    depth;
+     int	    visuals;
+ {
+     cfbVisualsPtr   new, *prev, v;
+     int		    count;
+ 
+     new = (cfbVisualsPtr) xalloc (sizeof *new);
+     if (!new)
+ 	return FALSE;
+     new->next = 0;
+     new->depth = depth;
+     new->visuals = visuals;
+     new->bitsPerRGB = bitsPerRGB;
+     count = (visuals >> 1) & 033333333333;
+     count = visuals - count - ((count >> 1) & 033333333333);
+     count = (((count + (count >> 3)) & 030707070707) % 077);	/* HAKMEM 169 */
+     new->count = count;
+     for (prev = &cfbVisuals; v = *prev; prev = &v->next);
+     *prev = new;
+     return TRUE;
+ }
+ 
+ /*
+  * Given a list of formats for a screen, create a list
+  * of visuals and depths for the screen which coorespond to
+  * the set which can be used with this version of cfb.
+  */
+ 
+ Bool
+ cfbInitVisuals (visualp, depthp, nvisualp, ndepthp, rootDepthp, defaultVisp, sizes)
+     VisualPtr	*visualp;
+     DepthPtr	*depthp;
+     int		*nvisualp, *ndepthp;
+     int		*rootDepthp;
+     VisualID	*defaultVisp;
+     unsigned long   sizes;
+ {
+     int		i, j, k;
+     VisualPtr	visual;
+     DepthPtr	depth;
+     VisualID	*vid;
+     int		d, b;
+     int		f;
+     int		ndepth, nvisual;
+     int		nvtype;
+     int		vtype;
+     VisualID	defaultVisual;
+     cfbVisualsPtr   visuals, nextVisuals;
+ 
+     /* none specified, we'll guess from pixmap formats */
+     if (!cfbVisuals) 
+     {
+     	for (f = 0; f < screenInfo.numPixmapFormats; f++) 
+     	{
+ 	    d = screenInfo.formats[f].depth;
+ 	    b = screenInfo.formats[f].bitsPerPixel;
+ 	    if (sizes & (1 << (b - 1)))
+ 	    {
+ 	    	if (d > MAX_PSEUDO_DEPTH)
+ 		    vtype = LARGE_VISUALS;
+ 	    	else if (d == 1)
+ 		    vtype = StaticGrayMask;
+ 		else
+ 		    vtype = ALL_VISUALS;
+ 	    }
+ 	    else
+ 		vtype = 0;
+ 	    if (!cfbSetVisualTypes (d, vtype, _BP))
+ 		return FALSE;
+     	}
+     }
+     nvisual = 0;
+     ndepth = 0;
+     for (visuals = cfbVisuals; visuals; visuals = nextVisuals) 
+     {
+ 	nextVisuals = visuals->next;
+ 	ndepth++;
+ 	nvisual += visuals->count;
+     }
+     depth = (DepthPtr) xalloc (ndepth * sizeof (DepthRec));
+     visual = (VisualPtr) xalloc (nvisual * sizeof (VisualRec));
+     if (!depth || !visual)
+     {
+ 	xfree (depth);
+ 	xfree (visual);
+ 	return FALSE;
+     }
+     *depthp = depth;
+     *visualp = visual;
+     *ndepthp = ndepth;
+     *nvisualp = nvisual;
+     for (visuals = cfbVisuals; visuals; visuals = nextVisuals) 
+     {
+ 	nextVisuals = visuals->next;
+ 	d = visuals->depth;
+ 	vtype = visuals->visuals;
+ 	nvtype = visuals->count;
+ 	vid = (VisualID *) xalloc (nvtype * sizeof (VisualID));
+ 	if (!vid && nvtype)
+ 	    return FALSE;
+ 	depth->depth = d;
+ 	depth->numVids = nvtype;
+ 	depth->vids = (unsigned long *) vid;
+ 	depth++;
+ 	for (i = 0; i < NUM_PRIORITY; i++) {
+ 	    if (! (vtype & (1 << cfbVisualPriority[i])))
+ 		continue;
+ 	    visual->class = cfbVisualPriority[i];
+ 	    visual->bitsPerRGBValue = visuals->bitsPerRGB;
+ 	    visual->ColormapEntries = 1 << d;
+ 	    visual->nplanes = d;
+ 	    visual->vid = *vid = FakeClientID (0);
+ 	    switch (visual->class) {
+ 	    case PseudoColor:
+ 	    case GrayScale:
+ 	    case StaticGray:
+ 		visual->redMask = 0;
+ 		visual->greenMask =  0;
+ 		visual->blueMask =  0;
+ 		visual->offsetRed  =  0;
+ 		visual->offsetGreen = 0;
+ 		visual->offsetBlue =  0;
+ 		break;
+ 	    case DirectColor:
+ 	    case TrueColor:
+ 		visual->ColormapEntries = _CE(d);
+ 		/* fall through */
+ 	    case StaticColor:
+ 		visual->redMask =  _RM(d);
+ 		visual->greenMask =  _GM(d);
+ 		visual->blueMask =  _BM(d);
+ 		visual->offsetRed  =  _RS(d);
+ 		visual->offsetGreen = _GS(d);
+ 		visual->offsetBlue =  _BS(d);
+ 	    }
+ 	    vid++;
+ 	    visual++;
+ 	}
+ 	xfree (visuals);
+     }
+     cfbVisuals = NULL;
+     visual = *visualp;
+     depth = *depthp;
+     for (i = 0; i < ndepth; i++)
+     {
+ 	if (*rootDepthp && *rootDepthp != depth[i].depth)
+ 	    continue;
+ 	for (j = 0; j < depth[i].numVids; j++)
+ 	{
+ 	    for (k = 0; k < nvisual; k++)
+ 		if (visual[k].vid == depth[i].vids[j])
+ 		    break;
+ 	    if (k == nvisual)
+ 		continue;
+ 	    if (defaultColorVisualClass < 0 ||
+ 		visual[k].class == defaultColorVisualClass)
+ 		break;
+ 	}
+ 	if (j != depth[i].numVids)
+ 	    break;
+     }
+     if (i == ndepth) {
+ 	i = 0;
+ 	j = 0;
+     }
+     *rootDepthp = depth[i].depth;
+     *defaultVisp = depth[i].vids[j];
+     return TRUE;
+ }
