Path: news!news.crl.dec.com!pa.dec.com!nobody
Message-Id: <9210200006.AA19676@explain.lcs.mit.edu>
To: fix-trackers@expo.lcs.mit.edu
Subject: (seq: 2696) close XBUG #5571: Xlib: (Ximp) keyEvent dropping/dis-order problem (2 of 7)
Date: Mon, 19 Oct 92 20:06:53 EDT
From: Bob Scheifler <rws@expo.lcs.mit.edu>
Distribution: dec
X-Mailing-List: fix-trackers@expo.lcs.mit.edu
X-Disclaimer: This message originated from a mailing list outside of Digital.
Newsgroups: dec.mail.lists.x.fix-trackers
Approved: news@usenet.pa.dec.com

### bug number:   5571
### area:         Xlib
### severity:     low
### comments:     part 2 of 7

*** /tmp/d18591	Mon Oct 19 19:30:53 1992
--- lib/X/Ximp/XimpCrFS.c	Mon Oct 19 19:24:14 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpCrFS.c,v 1.6 92/04/14 13:28:48 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpCrFS.c,v 1.7 92/10/19 19:24:08 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
***************
*** 88,95 ****
      char *font_name;
      XFontStruct *font;
      FontSetDataRec *font_data_list[MAX_CODESET];
-     unsigned min_char;
-     unsigned max_char;
  } FontInfoRec;
  
  /* method list */
--- 88,93 ----
***************
*** 107,149 ****
      _Ximp_wc_draw_image_string
  };
  
! static Ximp_XFontSet
  initFontSet(lcd)
!     Ximp_XLCd lcd;
  {
!     Ximp_XFontSet ximp_fontset;
      XFontSetXimpRec *fspart;
      FontSetRec *fontset;
!     int codeset_num = lcd->ximp_lcpart->codeset_num;
  
!     ximp_fontset = (Ximp_XFontSet) Xmalloc(sizeof(Ximp_XFontSetRec));
      if (ximp_fontset == NULL)
  	return NULL;
  
-     fspart = (XFontSetXimpRec *) Xmalloc(sizeof(XFontSetXimpRec));
-     if (fspart == NULL)
- 	goto error;
- 
      fontset = (FontSetRec *) Xmalloc(sizeof(FontSetRec) * codeset_num);
      if (fontset == NULL)
  	goto error;
- 
-     bzero(ximp_fontset, sizeof(Ximp_XFontSetRec));
-     bzero(fspart, sizeof(XFontSetXimpRec));
      bzero(fontset, sizeof(FontSetRec) * codeset_num);
  
      fspart->fontset_num = codeset_num;
      fspart->fontset = fontset;
  
      ximp_fontset->methods = &fontset_methods;
      ximp_fontset->core.lcd = (XLCd) lcd;
-     ximp_fontset->ximp_fspart = fspart;
  
      return ximp_fontset;
  
  error:
-     if (fspart)
- 	Xfree(fspart);
      Xfree(ximp_fontset);
  
      return NULL;
--- 105,139 ----
      _Ximp_wc_draw_image_string
  };
  
! static XimpFontSet
  initFontSet(lcd)
!     XimpLCd lcd;
  {
!     XimpFontSet ximp_fontset;
      XFontSetXimpRec *fspart;
      FontSetRec *fontset;
!     int codeset_num = lcd->locale.codeset_num;
  
!     ximp_fontset = (XimpFontSet) Xmalloc(sizeof(XimpFontSetRec));
      if (ximp_fontset == NULL)
  	return NULL;
+     bzero(ximp_fontset, sizeof(XimpFontSetRec));
  
      fontset = (FontSetRec *) Xmalloc(sizeof(FontSetRec) * codeset_num);
      if (fontset == NULL)
  	goto error;
      bzero(fontset, sizeof(FontSetRec) * codeset_num);
  
+     fspart = &ximp_fontset->ximp_fspart;
      fspart->fontset_num = codeset_num;
      fspart->fontset = fontset;
  
      ximp_fontset->methods = &fontset_methods;
      ximp_fontset->core.lcd = (XLCd) lcd;
  
      return ximp_fontset;
  
  error:
      Xfree(ximp_fontset);
  
      return NULL;
***************
*** 151,179 ****
  
  static int
  getCharsetName(lcd, font_info)
!     Ximp_XLCd lcd;
      FontInfoRec *font_info;
  {
!     FontSetDataRec *data = lcd->ximp_lcpart->fontset_data;
      FontInfoRec *info_ptr;
      char *name;
      int	count, data_num;
!     int	i;
  
      count = 0;
!     data_num = lcd->ximp_lcpart->fontset_data_num;
      while (data_num--) {
  	name = data->font_name;
  	info_ptr = font_info;
  	for (i = 0; i < count; i++, info_ptr++)
  	    if (!strcmp(name, info_ptr->charset_name)) {
! 		info_ptr->font_data_list[data->cset_number] = data;
  		break;
  	    }
  
  	if (i == count) {	/* not found same font name */
  	    info_ptr->charset_name = name;
! 	    info_ptr->font_data_list[data->cset_number] = data;
  	    if (++count >= MAX_FONTSET)
  		return count;
  	}
--- 141,171 ----
  
  static int
  getCharsetName(lcd, font_info)
!     XimpLCd lcd;
      FontInfoRec *font_info;
  {
!     FontSetDataRec *data = lcd->locale.fontset_data;
      FontInfoRec *info_ptr;
      char *name;
      int	count, data_num;
!     int	i, cs_num;
  
      count = 0;
!     data_num = lcd->locale.fontset_data_num;
      while (data_num--) {
  	name = data->font_name;
  	info_ptr = font_info;
  	for (i = 0; i < count; i++, info_ptr++)
  	    if (!strcmp(name, info_ptr->charset_name)) {
! 		cs_num = data->cs_num;
! 		info_ptr->font_data_list[cs_num] = data;
  		break;
  	    }
  
  	if (i == count) {	/* not found same font name */
  	    info_ptr->charset_name = name;
! 	    cs_num = data->cs_num;
! 	    info_ptr->font_data_list[cs_num] = data;
  	    if (++count >= MAX_FONTSET)
  		return count;
  	}
***************
*** 247,259 ****
  		     checkCharSet(prop_fname, info_ptr->charset_name)) {
  		fname = prop_fname;
  found:
! 		info_ptr->font_name = Xmalloc(strlen(fname) + 1);
! 		strcpy(info_ptr->font_name, fname);
! 		info_ptr->min_char = (fs_list->min_byte1 << 8) + 
! 				     fs_list->min_char_or_byte2;
! 		info_ptr->max_char = (fs_list->max_byte1 << 8) + 
! 				     fs_list->max_char_or_byte2;
! 		found_num++;
  		break;
  	    }
  	}
--- 239,248 ----
  		     checkCharSet(prop_fname, info_ptr->charset_name)) {
  		fname = prop_fname;
  found:
! 		if( (info_ptr->font_name = Xmalloc(strlen(fname) + 1)) != NULL ) {
! 		    strcpy(info_ptr->font_name, fname);
! 		    found_num++;
! 		}
  		break;
  	    }
  	}
***************
*** 268,347 ****
  }
  
  static Bool
- check_ext_font(font_info, ext_font, ext_font_num)
-     FontInfoRec *font_info;
-     register ExtFontRec *ext_font;
-     int ext_font_num;
- {
-     register unsigned min_char = font_info->min_char;
-     register unsigned max_char = font_info->max_char;
- 
-     while (ext_font_num--) {
- 	if (min_char > ext_font->min_char && max_char < ext_font->max_char)
- 	    return False;
- 	ext_font++;
-     }
- 
-     return True;
- }
- 
- static Bool
  setInternalPartData(lcd, dpy, xfont_set, font_info, font_info_num)
!     Ximp_XLCd lcd;
      Display *dpy;
!     Ximp_XFontSet xfont_set;
      FontInfoRec *font_info;
      int font_info_num;
  {
!     FontSetRec *fontset = xfont_set->ximp_fspart->fontset;
!     ExtFontRec ext_font[MAX_EXT_FONT], *ext_font_ptr;
      FontInfoRec *info_ptr;
      FontSetDataRec *data;
      char *font_name;
!     int i,j, codeset_num, ext_font_num;
  
!     codeset_num = lcd->ximp_lcpart->codeset_num;
      for (i = 0; i < codeset_num; i++, fontset++) {
  	info_ptr = font_info;
- 	ext_font_ptr = ext_font;
- 	ext_font_num = 0;
  	for (j = 0; j < font_info_num; j++, info_ptr++) {
  	    data = info_ptr->font_data_list[i];
  	    if (data && (font_name = info_ptr->font_name)) {
! 		if (data->ext_flag) {
! 		    if (ext_font_num < MAX_EXT_FONT &&
! 			check_ext_font(info_ptr, ext_font, ext_font_num)) {
! 
! 			if (info_ptr->font == NULL)
! 			    info_ptr->font = XLoadQueryFont(dpy, font_name);
! 			if (ext_font_ptr->font = info_ptr->font) {
! 			    ext_font_ptr->msb_mask = data->msb_mask;
! 			    ext_font_ptr->min_char = info_ptr->min_char;
! 			    ext_font_ptr->max_char = info_ptr->max_char;
! 			    ext_font_ptr++;
! 			    ext_font_num++;
! 			}
! 		    }
! 		} else if (fontset->font == NULL) {
  		    if (info_ptr->font == NULL)
  			info_ptr->font = XLoadQueryFont(dpy, font_name);
  		    fontset->font = info_ptr->font;
! 		    fontset->msb_mask = data->msb_mask;
  		}
  	    }
  	}
- 
- 	if (fontset->font && ext_font_num) {
- 	    ext_font_ptr = (ExtFontRec *) Xmalloc(ext_font_num *
- 						  sizeof(ExtFontRec));
- 	    if (ext_font_ptr == NULL)
- 		return False;
- 	    
- 	    fontset->ext_font_list = ext_font_ptr;
- 	    fontset->ext_font_num = ext_font_num;
- 	    for (j = 0; j < ext_font_num; j++)
- 		*ext_font_ptr = ext_font[j];
- 	}
      }
  
      return True;
--- 257,290 ----
  }
  
  static Bool
  setInternalPartData(lcd, dpy, xfont_set, font_info, font_info_num)
!     XimpLCd lcd;
      Display *dpy;
!     XimpFontSet xfont_set;
      FontInfoRec *font_info;
      int font_info_num;
  {
!     FontSetRec *fontset = xfont_set->ximp_fspart.fontset;
      FontInfoRec *info_ptr;
      FontSetDataRec *data;
      char *font_name;
!     int i,j, codeset_num;
  
!     codeset_num = lcd->locale.codeset_num;
      for (i = 0; i < codeset_num; i++, fontset++) {
  	info_ptr = font_info;
  	for (j = 0; j < font_info_num; j++, info_ptr++) {
  	    data = info_ptr->font_data_list[i];
  	    if (data && (font_name = info_ptr->font_name)) {
! 		if (fontset->font == NULL) {
  		    if (info_ptr->font == NULL)
  			info_ptr->font = XLoadQueryFont(dpy, font_name);
  		    fontset->font = info_ptr->font;
! 		    fontset->codeset = lcd->locale.codeset_list[data->cs_num];
! 		    fontset->side = data->side;
  		}
  	    }
  	}
      }
  
      return True;
***************
*** 349,355 ****
  
  static void
  setFontSetExtents(font_set)
!     Ximp_XFontSet font_set;
  {
      XRectangle *ink = &font_set->core.font_set_extents.max_ink_extent;
      XRectangle *logical = &font_set->core.font_set_extents.max_logical_extent;
--- 292,298 ----
  
  static void
  setFontSetExtents(font_set)
!     XimpFontSet font_set;
  {
      XRectangle *ink = &font_set->core.font_set_extents.max_ink_extent;
      XRectangle *logical = &font_set->core.font_set_extents.max_logical_extent;
***************
*** 389,395 ****
  
  static Bool
  setCorePartData(font_set, font_info, font_info_num)
!     Ximp_XFontSet font_set;
      FontInfoRec *font_info;
      int font_info_num;
  {
--- 332,338 ----
  
  static Bool
  setCorePartData(font_set, font_info, font_info_num)
!     XimpFontSet font_set;
      FontInfoRec *font_info;
      int font_info_num;
  {
***************
*** 453,466 ****
  static Bool
  setMissingList(lcd, xfont_set, font_info, font_info_num, 
  	       missing_charset_list, missing_charset_count)
!     Ximp_XLCd lcd;
!     Ximp_XFontSet xfont_set;
      FontInfoRec *font_info;
      int font_info_num;
      char ***missing_charset_list;
      int *missing_charset_count;
  {
!     FontSetRec *fontset = xfont_set->ximp_fspart->fontset;
      FontSetDataRec *data;
      char *name_list[MAX_CODESET], **charset_list, *charset_buf;
      int missing_cset_num[MAX_CODESET], missing_cset_count;
--- 396,409 ----
  static Bool
  setMissingList(lcd, xfont_set, font_info, font_info_num, 
  	       missing_charset_list, missing_charset_count)
!     XimpLCd lcd;
!     XimpFontSet xfont_set;
      FontInfoRec *font_info;
      int font_info_num;
      char ***missing_charset_list;
      int *missing_charset_count;
  {
!     FontSetRec *fontset = xfont_set->ximp_fspart.fontset;
      FontSetDataRec *data;
      char *name_list[MAX_CODESET], **charset_list, *charset_buf;
      int missing_cset_num[MAX_CODESET], missing_cset_count;
***************
*** 467,473 ****
      int	i, j, count, length, codeset_num;
  
      missing_cset_count = 0;
!     codeset_num = lcd->ximp_lcpart->codeset_num;
      for (i = 0; i < codeset_num; i++)
  	if (fontset[i].font == NULL)
  	    missing_cset_num[missing_cset_count++] = i;
--- 410,416 ----
      int	i, j, count, length, codeset_num;
  
      missing_cset_count = 0;
!     codeset_num = lcd->locale.codeset_num;
      for (i = 0; i < codeset_num; i++)
  	if (fontset[i].font == NULL)
  	    missing_cset_num[missing_cset_count++] = i;
***************
*** 480,486 ****
  	    if ((codeset_num = missing_cset_num[j]) < 0)
  		continue;
  	    data = font_info->font_data_list[codeset_num];
! 	    if (data && data->ext_flag == False) {
  		name_list[count++] = font_info->charset_name;
  		length += strlen(font_info->charset_name) + 1;
  		missing_cset_num[j] = -1;
--- 423,429 ----
  	    if ((codeset_num = missing_cset_num[j]) < 0)
  		continue;
  	    data = font_info->font_data_list[codeset_num];
! 	    if (data) {
  		name_list[count++] = font_info->charset_name;
  		length += strlen(font_info->charset_name) + 1;
  		missing_cset_num[j] = -1;
***************
*** 511,518 ****
  }
  
  XFontSet
! _Ximp_Create_fontset(xlcd, dpy, base_name, name_list, count,
! 		     missing_charset_list, missing_charset_count)
      XLCd xlcd;
      Display *dpy;
      char *base_name;
--- 454,461 ----
  }
  
  XFontSet
! _XDefaultCreateFontSet(xlcd, dpy, base_name, name_list, count,
! 		       missing_charset_list, missing_charset_count)
      XLCd xlcd;
      Display *dpy;
      char *base_name;
***************
*** 521,532 ****
      char ***missing_charset_list;
      int *missing_charset_count;	
  {
!     Ximp_XLCd lcd = (Ximp_XLCd) xlcd;
!     Ximp_XFontSet font_set;
      FontInfoRec font_info[MAX_FONTSET];
      char *name, **name_list_ptr, **fn_list, buf[BUFSIZE];
      XFontStruct *fs_list;
!     int i, fn_num, font_info_num, found_num = 0;
  
      *missing_charset_list = NULL;
      *missing_charset_count = 0;
--- 464,476 ----
      char ***missing_charset_list;
      int *missing_charset_count;	
  {
!     XimpLCd lcd = (XimpLCd) xlcd;
!     XimpFontSet font_set;
      FontInfoRec font_info[MAX_FONTSET];
      char *name, **name_list_ptr, **fn_list, buf[BUFSIZE];
      XFontStruct *fs_list;
!     int i, length, fn_num, font_info_num, found_num = 0;
!     Bool is_found;
  
      *missing_charset_list = NULL;
      *missing_charset_count = 0;
***************
*** 541,546 ****
--- 485,525 ----
      name_list_ptr = name_list;
      while (count--) {
          name = *name_list_ptr++;
+ 	length = strlen(name);
+ 	/* XXX */
+ 	if (length > 1 && name[length - 1] == '*' &&  name[length - 2] == '-') {
+ 	    (void) strcpy(buf, name);
+ 	    is_found = False;
+ 
+ 	    for (i = 0; i < font_info_num; i++) {
+ 		if (font_info[i].font_name)
+ 		    continue;
+ 
+ 		if (length > 2 && name[length - 3] == '*')
+ 		    (void) strcpy(buf + length - 1, font_info[i].charset_name);
+ 		else {
+ 		    buf[length] = '-';
+ 		    (void) strcpy(buf + length + 1, font_info[i].charset_name);
+ 		}
+ 		fn_list = XListFonts(dpy, buf, 1, &fn_num);
+ 		if (fn_num == 0)
+ 		    continue;
+ 
+ 		font_info[i].font_name = Xmalloc(strlen(*fn_list) + 1);
+ 		if (font_info[i].font_name == NULL)
+ 		    goto error;
+ 		(void) strcpy(font_info[i].font_name, *fn_list);
+ 
+ 		XFreeFontNames(fn_list);
+ 		found_num++;
+ 		is_found = True;
+ 	    }
+ 	    if (found_num == font_info_num)
+ 		break;
+ 	    if (is_found == True)
+ 		continue;
+ 	}
+ 
  	fn_list = XListFontsWithInfo(dpy, name, MAXFONTS, &fn_num, &fs_list);
  	if (fn_num == 0) {
  	    char *p;
***************
*** 613,628 ****
      Display *dpy;
      XFontSet xfont_set;
  {
!     XFontSetXimpRec *fspart = ((Ximp_XFontSet) xfont_set)->ximp_fspart;
      FontSetRec *fontset = fspart->fontset;
      int	num = fspart->fontset_num;
  
!     while (num-- > 0) {
! 	if (fontset->ext_font_list)
! 	   Xfree(fontset->ext_font_list);
  	fontset++;
-     }
  
      Xfree(fspart->fontset);
-     Xfree(fspart);
  }
--- 592,603 ----
      Display *dpy;
      XFontSet xfont_set;
  {
!     XFontSetXimpRec *fspart = &((XimpFontSet) xfont_set)->ximp_fspart;
      FontSetRec *fontset = fspart->fontset;
      int	num = fspart->fontset_num;
  
!     while (num-- > 0)
  	fontset++;
  
      Xfree(fspart->fontset);
  }
*** /tmp/d18610	Mon Oct 19 19:31:04 1992
--- lib/X/Ximp/XimpIC.c	Mon Oct 19 19:24:34 1992
***************
*** 1,8 ****
! /* $XConsortium: XimpIC.c,v 1.7 92/07/29 10:15:50 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
                Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,9 ----
! /* $XConsortium: XimpIC.c,v 1.8 92/10/19 19:24:31 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
                Copyright 1991, 1992 by Sony Corporation
+               Copyright 1991, 1992 by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 9,24 ****
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporation not be used in advertising or publicity
! pertaining to distribution of the software without specific,
! written prior permission.
! FUJITSU LIMITED and Sony Corporation make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
  SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
--- 10,25 ----
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporation and Sun Microsystems, Inc. must not be used in
! advertising or publicity pertaining to distribution of the software 
! without specific, written prior permission.
! FUJITSU LIMITED and Sony Corporation and Sun Microsystems, Inc. make no
! representations about the suitability of this software for any purpose.  
! It is provided "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SONY CORPORATION AND SUN MICROSYTEMS, INC. DISCLAIM 
! ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
! OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
  SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
***************
*** 27,32 ****
--- 28,34 ----
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
            Makoto Wakamatsu     Sony Corporation
+ 	  Hideki Hiura         Sun Microsystems, Inc.
  
  ******************************************************************/
  
***************
*** 49,374 ****
  
  extern char 		*_Ximp_SetICValueData();
  extern void		_Ximp_SetValue_Resource();
! extern Bool		_Ximp_SetOpenXIMP();
  
! extern void		_Ximp_SetFocusWindow();
  extern void		_Ximp_SetPreeditAtr();
  extern void		_Ximp_SetPreeditFont();
  extern void		_Ximp_SetStatusAtr();
  extern void		_Ximp_SetStatusFont();
  extern Bool		_Ximp_XimFilter_Keypress();
  extern Bool		_Ximp_XimFilter_Client();
- 
- static void 		_Ximp_AttributesSetL();
  extern void 		_Ximp_IM_SendMessage();
  
  static XICMethodsRec Ximp_ic_methods = {
! 				_Ximp_DestroyIC, 	/* destroy */
! 				_Ximp_SetFocus,  	/* set_focus */
! 				_Ximp_UnSetFocus,	/* unset_focus */
! 				_Ximp_SetICValues,	/* set_values */
! 				_Ximp_GetICValues,	/* get_values */
! 				_Ximp_MbReset,		/* mb_reset */
! 				_Ximp_WcReset,		/* wc_reset */
! 				_Ximp_MbLookupString,	/* mb_lookup_string */
! 				_Ximp_WcLookupString,	/* wc_lookup_string */
! 				};
  
  XIC
  _Ximp_CreateIC(im, values)
! 	XIM		 im;
! 	XIMArg		*values;
  {
! 	Ximp_XIC	 ic;
! 	long		 dummy;
! 	XICXimpRec	*ximp_icpart;
  
! 	if((ic = (Ximp_XIC)Xmalloc(sizeof(Ximp_XICRec))) == (Ximp_XIC)NULL) {
! 		return((XIC)NULL);
! 		} 
! 	if((ximp_icpart = (XICXimpRec *)Xmalloc(sizeof(XICXimpRec))) == (XICXimpRec *)NULL) {
! 		Xfree(ic);
! 		return((XIC)NULL);
! 		} 
! 	bzero((char *)ic, sizeof(Ximp_XICRec));
! 	bzero((char *)ximp_icpart, sizeof(XICXimpRec));
  
! 	ic->methods = &Ximp_ic_methods;
! 	ic->core.im = im;
! 	/* Filter Event : for Ximp Protocol */
! 	ic->core.filter_events = KeyPressMask | KeyReleaseMask | StructureNotifyMask;
  
! 	ic->ximp_icpart = ximp_icpart;
! 	if(_Ximp_SetICValueData(ic, values, XIMP_CREATE_IC, &dummy))
! 		goto Set_Error;
! 
! 	/* The Value must be set */
! 	if(!(ximp_icpart->value_mask & XIMP_INPUT_STYLE)) /* Input Style */
! 		goto Set_Error;
! 	if(ic->core.input_style & XIMPreeditPosition)
! 		if(!(ximp_icpart->proto_mask & XIMP_PRE_SPOTL_MASK)) /* SpotLocation */
! 			goto Set_Error;
! 	if(   (ic->core.input_style & XIMPreeditPosition)
! 	   || (ic->core.input_style & XIMPreeditArea)    )
! 		if(!(ximp_icpart->proto_mask & XIMP_PRE_FONT_MASK)) /* FontSet */
! 			goto Set_Error;
! 	if(ic->core.input_style & XIMStatusArea)
! 		if(!(ximp_icpart->proto_mask & XIMP_STS_FONT_MASK)) /* FontSet */
! 			goto Set_Error;
! 	if(ic->core.input_style & XIMPreeditCallbacks)
! 		if(!(ximp_icpart->value_mask & XIMP_PRE_CALLBAK)) /* Preedit Callback */
! 			goto Set_Error;
! 	if(ic->core.input_style & XIMStatusCallbacks)
! 		if(!(ximp_icpart->value_mask & XIMP_STS_CALLBAK)) /* Status Callback */
! 			goto Set_Error;
! 	
! 	_Ximp_SetValue_Resource(ic, &dummy);
  
! 	if(((Ximp_XIM)im)->ximp_impart->inputserver ||
! 	   ((Ximp_XIM)im)->ximp_impart->connectserver) {
! 		if(_Ximp_SetOpenXIMP(ic, XIMP_CREATE_IC) == False)
! 			goto Set_Error;
! 	} else {
! 		if(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK) {
! 			_XRegisterFilterByType (ic->core.im->core.display,
! 						ic->core.focus_window,
! 						KeyPress, KeyPress,
! 						_Ximp_XimFilter_Keypress,
! 						(XPointer)ic);
! 			ic->ximp_icpart->filter_mode |= 0x1;
! 			_XRegisterFilterByType(ic->core.im->core.display,
! 					       ic->core.focus_window,
! 					       ClientMessage, ClientMessage,
! 					       _Ximp_XimFilter_Client, NULL);
! 			ic->ximp_icpart->filter_mode |= 0x2;
! 		    }
  	}
! 	return((XIC)ic);
  
!    Set_Error :
! 	Xfree(ic);
! 	Xfree(ximp_icpart);
! 	return((XIC)NULL);
  }
  
  static void
  _Ximp_DestroyIC(ic)
! 	Ximp_XIC	 ic;
  {
! 	if(ic->ximp_icpart->filter_mode & 0x1) {
! 		_XUnregisterFilter (ic->core.im->core.display,
! 				ic->core.focus_window,
! 				_Ximp_XimFilter_Keypress,
! 				(XPointer)ic);
! 	}
! 	if(ic->ximp_icpart->filter_mode & 0x2) {
! 		_XUnregisterFilter(ic->core.im->core.display,
! 				   ic->ximp_icpart->back_focus_win,
! 				   _Ximp_XimFilter_Client, (XPointer)NULL);
! 	}
!  	_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
! 	if( ic->ximp_icpart->preedit_font )
! 	    Xfree( ic->ximp_icpart->preedit_font );
! 	if( ic->ximp_icpart->status_font )
! 	    Xfree( ic->ximp_icpart->status_font );
! 	Xfree(ic->ximp_icpart);
! 	return;
  }
  
  static void
  _Ximp_SetFocus(ic)
! 	Ximp_XIC	ic;
  {
!  	_Ximp_IM_SendMessage(ic, XIMP_SETFOCUS, NULL, NULL, NULL);
! 	if(!(ic->ximp_icpart->filter_mode & 0x1)) {
! 		_XRegisterFilterByType (ic->core.im->core.display,
! 					ic->core.focus_window,
! 					KeyPress, KeyPress,
! 					_Ximp_XimFilter_Keypress,
! 					(XPointer)ic);
! 		ic->ximp_icpart->filter_mode |= 0x1;
! 	}
! 	return;
  }
  
  static void
  _Ximp_UnSetFocus(ic)
! 	Ximp_XIC	ic;
  {
! 	_Ximp_IM_SendMessage(ic, XIMP_UNSETFOCUS, NULL, NULL, NULL);
! 	if(ic->ximp_icpart->filter_mode & 0x1) {
! 		_XUnregisterFilter (ic->core.im->core.display,
! 				ic->core.focus_window,
! 				_Ximp_XimFilter_Keypress,
! 				(XPointer)ic);
! 		ic->ximp_icpart->filter_mode &= ~(0x1);
! 	}
! 	return;
  }
  
  void
! _Ximp_SetFocusWindow(ic)
! 	Ximp_XIC	 ic;
  {
! 	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
! 			XA_WINDOW, 32, PropModeReplace,
! 			(unsigned char *)&ic->core.focus_window, 1);
  
! 	if(ic->ximp_icpart->filter_mode & 0x2) {
! 		_XUnregisterFilter(ic->core.im->core.display,
! 				   ic->ximp_icpart->back_focus_win,
! 				   _Ximp_XimFilter_Client, (XPointer)NULL);
! 	}
  	_XRegisterFilterByType(ic->core.im->core.display,
! 			       ic->core.focus_window,
! 			       ClientMessage, ClientMessage,
! 			       _Ximp_XimFilter_Client, NULL);
! 	ic->ximp_icpart->filter_mode |= 0x2;
  
! 	if(ic->ximp_icpart->filter_mode & 0x1) {
! 		_XUnregisterFilter (ic->core.im->core.display,
! 				ic->ximp_icpart->back_focus_win,
! 				_Ximp_XimFilter_Keypress,
! 				(XPointer)ic);
! 	}
! 	_XRegisterFilterByType (ic->core.im->core.display,
! 				ic->core.focus_window,
! 				KeyPress, KeyPress,
! 				_Ximp_XimFilter_Keypress,
! 				(XPointer)ic);
! 	ic->ximp_icpart->filter_mode |= 0x1;
! 	return;
  }
  
  void
  _Ximp_SetPreeditAtr(ic)
! 	Ximp_XIC		 ic;
  {
! 	Ximp_PreeditPropRec	*preedit_atr;
! 	unsigned char		 prop_data[XIMP_PREEDIT_MAX_CHAR];
  
! 	preedit_atr = &(ic->ximp_icpart->preedit_attr);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Area.x,             0);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Area.y,             4);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Area.width,         8);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Area.height,       12);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Foreground,        16);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Background,        20);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Colormap,          24);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Bg_Pixmap,         28);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->LineSpacing,       32);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Cursor,            36);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->AreaNeeded.width,  40);
  	_Ximp_AttributesSetL(prop_data, preedit_atr->AreaNeeded.height, 44);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.x,    48);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.y,    52);
  
! 	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
! 			32, PropModeReplace, prop_data, XIMP_PREEDIT_MAX_LONG);
! 	return;
  }
  
  void
  _Ximp_SetPreeditFont(ic)
! 	Ximp_XIC		 ic;
  {
! 	if (ic->core.preedit_attr.fontset != NULL) {
! 	    XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id,
  			XA_STRING, 8, PropModeReplace,
  			(unsigned char *)(ic->ximp_icpart->preedit_font),
  			strlen(ic->ximp_icpart->preedit_font));
! 	    }
! 	return;
  }
  
  void
  _Ximp_SetStatusAtr(ic)
! 	Ximp_XIC		 ic;
  {
! 	Ximp_StatusPropRec	*status_atr;
! 	unsigned char		 prop_data[XIMP_STATUS_MAX_CHAR];
  
! 	status_atr = &(ic->ximp_icpart->status_attr);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Area.x,             0);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Area.y,             4);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Area.width,         8);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Area.height,       12);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Foreground,        16);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Background,        20);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Colormap,          24);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Bg_Pixmap,         28);
! 	_Ximp_AttributesSetL(prop_data, status_atr->LineSpacing,       32);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Cursor,            36);
! 	_Ximp_AttributesSetL(prop_data, status_atr->AreaNeeded.width,  40);
  	_Ximp_AttributesSetL(prop_data, status_atr->AreaNeeded.height, 44);
! 	_Ximp_AttributesSetL(prop_data, status_atr->window,            48);
  
! 	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
! 			32, PropModeReplace, prop_data, XIMP_STATUS_MAX_LONG);
! 	return;
  }
  
  void
  _Ximp_SetStatusFont(ic)
! 	Ximp_XIC		ic;
  {
! 	if (ic->core.status_attr.fontset != NULL) {
! 	    XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id,
! 			XA_STRING, 8, PropModeReplace,
! 			(unsigned char *)(ic->ximp_icpart->status_font),
! 			strlen(ic->ximp_icpart->status_font));
! 	    }
! 	return;
  }
  
- static void
- _Ximp_AttributesSetL(data, setdata, cnt)
- 	char	*data;
- 	long	 setdata;
- 	int	 cnt;
- {
- 	long	*ptr;
- 
- 	ptr = (long *)&data[cnt];
- 	*ptr = setdata;
- 	return;
- }
- 
  void
  _Ximp_IM_SendMessage(ic, request, data1, data2, data3)
! 	Ximp_XIC	ic;
! 	unsigned long	request;
! 	unsigned long	data1, data2, data3;
  {
! 	XEvent		Message;
! 	
! 	if((request != XIMP_CREATE) && !(ic->ximp_icpart->icid))
! 		return;
  
! 	/* ClientMessage Send */
! 	Message.xclient.type         = ClientMessage;
! 	Message.xclient.display      = ic->core.im->core.display;
! 	Message.xclient.window       = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	Message.xclient.message_type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Message.xclient.format       = 32;
! 	Message.xclient.data.l[0]    = request;
! 	if(request == XIMP_CREATE)
! 		Message.xclient.data.l[1] = (long)ic->core.client_window;
! 	else
! 		Message.xclient.data.l[1] = ic->ximp_icpart->icid;
! 	Message.xclient.data.l[2]    = data1;
! 	Message.xclient.data.l[3]    = data2;
! 	Message.xclient.data.l[4]    = data3;
! 	XSendEvent(ic->core.im->core.display,
! 			   ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
! 			   False, NoEventMask, &Message);
! 	XFlush(ic->core.im->core.display);
! 	return;
  }
--- 51,439 ----
  
  extern char 		*_Ximp_SetICValueData();
  extern void		_Ximp_SetValue_Resource();
! extern Bool		_Ximp_ConnectIC();
  
! extern void		_Ximp_SetFocusWindowProp();
! extern void		_Ximp_SetFocusWindowFilter();
  extern void		_Ximp_SetPreeditAtr();
  extern void		_Ximp_SetPreeditFont();
  extern void		_Ximp_SetStatusAtr();
  extern void		_Ximp_SetStatusFont();
  extern Bool		_Ximp_XimFilter_Keypress();
+ extern Bool		_Ximp_XimFilter_Keyrelease();
  extern Bool		_Ximp_XimFilter_Client();
  extern void 		_Ximp_IM_SendMessage();
  
  static XICMethodsRec Ximp_ic_methods = {
!     _Ximp_DestroyIC, 		/* destroy */
!     _Ximp_SetFocus,  		/* set_focus */
!     _Ximp_UnSetFocus,		/* unset_focus */
!     _Ximp_SetICValues,		/* set_values */
!     _Ximp_GetICValues,		/* get_values */
!     _Ximp_MbReset,		/* mb_reset */
!     _Ximp_WcReset,		/* wc_reset */
!     _Ximp_MbLookupString,	/* mb_lookup_string */
!     _Ximp_WcLookupString,	/* wc_lookup_string */
! };
  
  XIC
  _Ximp_CreateIC(im, values)
! XIM		 im;
! XIMArg		*values;
  {
!     Ximp_XIC		 ic;
!     XimpChangeMaskRec	 dummy;
!     XICXimpRec		*ximp_icpart;
  
!     if((ic = (Ximp_XIC)Xmalloc(sizeof(Ximp_XICRec))) == (Ximp_XIC)NULL)
! 	return((XIC)NULL);
!     if((ximp_icpart = (XICXimpRec *)Xmalloc(sizeof(XICXimpRec)))
! 	    == (XICXimpRec *)NULL) {
! 	Xfree(ic);
! 	return((XIC)NULL);
!     }
!     bzero((char *)ic, sizeof(Ximp_XICRec));
!     bzero((char *)ximp_icpart, sizeof(XICXimpRec));
  
!     ic->methods = &Ximp_ic_methods;
!     ic->core.im = im;
!     /* Filter Event : for Ximp Protocol */
!     ic->core.filter_events
! 		= KeyPressMask | KeyReleaseMask | StructureNotifyMask;
  
!     ximp_icpart->svr_mode = ((Ximp_XIM)im)->ximp_impart->def_svr_mode;
  
!     ic->ximp_icpart = ximp_icpart;
! 
!     if(_Ximp_SetICValueData(ic, values, XIMP_CREATE_IC, &dummy))
! 	goto Set_Error;
! 
!     /* The Value must be set */
!     if(!(ximp_icpart->value_mask & XIMP_INPUT_STYLE)) /* Input Style */
! 	goto Set_Error;
! 
!     if(ic->core.input_style & XIMPreeditCallbacks)
! 	if(!(ximp_icpart->value_mask & XIMP_PRE_CALLBAK)) /* Preedit Callback */
! 	    goto Set_Error;
!     if(ic->core.input_style & XIMStatusCallbacks)
! 	if(!(ximp_icpart->value_mask & XIMP_STS_CALLBAK)) /* Status Callback */
! 	    goto Set_Error;
! 
!     if(IS_UNCONNECTABLE(im)) {
! 	if(_Ximp_ConnectIC(ic, XIMP_CREATE_IC) == False)
! 	    goto Set_Error;
!     } else {
! 	if(IS_SERVER_CONNECTED(im)) {
! 	    if(_Ximp_ConnectIC(ic, XIMP_CREATE_IC))
! 		return((XIC)ic);
  	}
! 	if( XIMP_CHK_FOCUSWINMASK(ic) ) {
! 	    _XRegisterFilterByType (ic->core.im->core.display,
! 				    ic->core.focus_window,
! 				    KeyPress, KeyPress,
! 				    _Ximp_XimFilter_Keypress,
! 				    (XPointer)ic);
! 	    _XRegisterFilterByType (ic->core.im->core.display,
! 				    ic->core.focus_window,
! 				    KeyRelease, KeyRelease,
! 				    _Ximp_XimFilter_Keyrelease,
! 				    (XPointer)ic);
! 	    ic->ximp_icpart->filter_mode |= 0x1;
! 	}
!     }
!     return((XIC)ic);
  
! Set_Error :
!     Xfree(ic);
!     Xfree(ximp_icpart);
!     return((XIC)NULL);
  }
  
  static void
  _Ximp_DestroyIC(ic)
! Ximp_XIC	 ic;
  {
!     if(ic->ximp_icpart->filter_mode & 0x1) {
! 	_XUnregisterFilter (ic->core.im->core.display,
! 			    ic->core.focus_window,
! 			    _Ximp_XimFilter_Keypress,
! 			    (XPointer)ic);
! 	_XUnregisterFilter (ic->core.im->core.display,
! 			    ic->core.focus_window,
! 			    _Ximp_XimFilter_Keyrelease,
! 			    (XPointer)ic);
!     }
!     if(ic->ximp_icpart->filter_mode & 0x2) {
! 	_XUnregisterFilter(ic->core.im->core.display,
! 			   ic->ximp_icpart->back_focus_win,
! 			   _Ximp_XimFilter_Client, (XPointer)ic);
!     }
!     if(ic->ximp_icpart->filter_mode & 0x4) {			/* XXXXX */
! 	_XUnregisterFilter(ic->core.im->core.display,
! 			   ic->core.client_window,
! 			   _Ximp_XimFilter_Client, (XPointer)ic);
!     }
!     if(IS_IC_CONNECTED(ic))
!     	_Ximp_IM_SendMessage(ic, XIMP_DESTROY(ic), NULL, NULL, NULL);
!     Xfree(ic->ximp_icpart);
!     return;
  }
  
  static void
  _Ximp_SetFocus(ic)
! Ximp_XIC	ic;
  {
!     if(IS_IC_CONNECTED(ic))
! 	_Ximp_IM_SendMessage(ic, XIMP_SETFOCUS(ic), NULL, NULL, NULL);
!     if(!(ic->ximp_icpart->filter_mode & 0x1)) {
! 	_XRegisterFilterByType (ic->core.im->core.display,
! 				ic->core.focus_window,
! 				KeyPress, KeyPress,
! 				_Ximp_XimFilter_Keypress,
! 				(XPointer)ic);
! 	_XRegisterFilterByType (ic->core.im->core.display,
! 				ic->core.focus_window,
! 				KeyRelease, KeyRelease,
! 				_Ximp_XimFilter_Keyrelease,
! 				(XPointer)ic);
! 	ic->ximp_icpart->filter_mode |= 0x1;
!     }
!     return;
  }
  
  static void
  _Ximp_UnSetFocus(ic)
! Ximp_XIC	ic;
  {
!     if(IS_IC_CONNECTED(ic))
! 	_Ximp_IM_SendMessage(ic, XIMP_UNSETFOCUS(ic), NULL, NULL, NULL);
!     if(ic->ximp_icpart->filter_mode & 0x1) {
! 	_XUnregisterFilter (ic->core.im->core.display,
! 			    ic->core.focus_window,
! 			    _Ximp_XimFilter_Keypress,
! 			    (XPointer)ic);
! 	_XUnregisterFilter (ic->core.im->core.display,
! 			    ic->core.focus_window,
! 			    _Ximp_XimFilter_Keyrelease,
! 			    (XPointer)ic);
! 	ic->ximp_icpart->filter_mode &= ~(0x1);
!     }
!     return;
  }
  
  void
! _Ximp_SetFocusWindowFilter(ic)
! Ximp_XIC	 ic;
  {
!     if(ic->ximp_icpart->filter_mode & 0x1) {
! 	_XUnregisterFilter (ic->core.im->core.display,
! 		ic->ximp_icpart->back_focus_win,
! 		_Ximp_XimFilter_Keypress,
! 		(XPointer)ic);
! 	_XUnregisterFilter (ic->core.im->core.display,
! 		ic->ximp_icpart->back_focus_win,
! 		_Ximp_XimFilter_Keyrelease,
! 		(XPointer)ic);
!     }
!     _XRegisterFilterByType (ic->core.im->core.display,
! 		ic->core.focus_window,
! 		KeyPress, KeyPress,
! 		_Ximp_XimFilter_Keypress,
! 		(XPointer)ic);
!     _XRegisterFilterByType (ic->core.im->core.display,
! 		ic->core.focus_window,
! 		KeyRelease, KeyRelease,
! 		_Ximp_XimFilter_Keyrelease,
! 		(XPointer)ic);
!     ic->ximp_icpart->filter_mode |= 0x1;
  
!     if(ic->ximp_icpart->filter_mode & 0x2) {
! 	_XUnregisterFilter(ic->core.im->core.display,
! 		ic->ximp_icpart->back_focus_win,
! 		_Ximp_XimFilter_Client, (XPointer)ic);
!     }
!     _XRegisterFilterByType(ic->core.im->core.display,
! 		ic->core.focus_window,
! 		ClientMessage, ClientMessage,
! 		_Ximp_XimFilter_Client, (XPointer)ic);
!     ic->ximp_icpart->filter_mode |= 0x2;
! 
!     if(!(ic->ximp_icpart->filter_mode & 0x4)) {		/* XXXXX */
  	_XRegisterFilterByType(ic->core.im->core.display,
! 				ic->core.client_window,
! 				ClientMessage, ClientMessage,
! 				_Ximp_XimFilter_Client, (XPointer)ic);
! 	ic->ximp_icpart->filter_mode |= 0x4;
!     }
!     return;
! }
  
! static void
! _Ximp_AttributesSetL(data, setdata, cnt)
! char	*data;
! long	 setdata;
! int	 cnt;
! {
!     long	*ptr;
! 
!     ptr = (long *)&data[cnt];
!     *ptr = setdata;
!     return;
  }
  
  void
+ _Ximp_SetFocusWindowProp(ic)
+ Ximp_XIC	 ic;
+ {
+     XChangeProperty(ic->core.im->core.display, ic->core.client_window,
+ 		((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
+ 		XA_WINDOW, 32, PropModeReplace,
+ 		(unsigned char *)&ic->core.focus_window, 1);
+     return;
+ }
+ 
+ void
  _Ximp_SetPreeditAtr(ic)
! Ximp_XIC		 ic;
  {
!     Ximp_PreeditPropRec4	*preedit_atr;
!     unsigned char		 prop_data[XIMP_PREEDIT_MAX_CHAR4];
  
!     preedit_atr = &(ic->ximp_icpart->preedit_attr);
!     _Ximp_AttributesSetL(prop_data, preedit_atr->Area.x, 0);
!     _Ximp_AttributesSetL(prop_data, preedit_atr->Area.y, 4);
!     _Ximp_AttributesSetL(prop_data, preedit_atr->Area.width, 8);
!     _Ximp_AttributesSetL(prop_data, preedit_atr->Area.height, 12);
!     if(ISXimp4(ic)) {
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->AreaNeeded.width, 16);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->AreaNeeded.height, 20);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.x, 24);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.y, 28);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Colormap, 32);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->StdColormap, 36);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Foreground, 40);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Background, 44);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Bg_Pixmap,	48);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->LineSpacing, 52);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Cursor, 56);
!     } else {
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Foreground, 16);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Background, 20);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Colormap, 24);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Bg_Pixmap, 28);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->LineSpacing, 32);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->Cursor, 36);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->AreaNeeded.width, 40);
  	_Ximp_AttributesSetL(prop_data, preedit_atr->AreaNeeded.height, 44);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.x, 48);
! 	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.y, 52);
!     }
  
!     XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 		((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
! 		((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
! 		32, PropModeReplace, prop_data, XIMP_PREEDIT_MAX_LONG(ic));
!     return;
  }
  
  void
  _Ximp_SetPreeditFont(ic)
! Ximp_XIC		 ic;
  {
!     if (ic->core.preedit_attr.fontset != NULL) {
! 	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id,
  			XA_STRING, 8, PropModeReplace,
  			(unsigned char *)(ic->ximp_icpart->preedit_font),
  			strlen(ic->ximp_icpart->preedit_font));
!     }
  }
  
  void
  _Ximp_SetStatusAtr(ic)
! Ximp_XIC		 ic;
  {
!     Ximp_StatusPropRec4		*status_atr;
!     unsigned char		 prop_data[XIMP_STATUS_MAX_CHAR4];
  
!     status_atr = &(ic->ximp_icpart->status_attr);
!     _Ximp_AttributesSetL(prop_data, status_atr->Area.x, 0);
!     _Ximp_AttributesSetL(prop_data, status_atr->Area.y, 4);
!     _Ximp_AttributesSetL(prop_data, status_atr->Area.width, 8);
!     _Ximp_AttributesSetL(prop_data, status_atr->Area.height, 12);
!     if(ISXimp4(ic)) {
! 	_Ximp_AttributesSetL(prop_data, status_atr->AreaNeeded.width,  16);
! 	_Ximp_AttributesSetL(prop_data, status_atr->AreaNeeded.height, 20);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Colormap, 24);
! 	_Ximp_AttributesSetL(prop_data, status_atr->StdColormap, 28);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Foreground, 32);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Background, 36);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Bg_Pixmap, 40);
! 	_Ximp_AttributesSetL(prop_data, status_atr->LineSpacing, 44);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Cursor, 48);
! 	_Ximp_AttributesSetL(prop_data, status_atr->window, 52);
!     } else {
! 	_Ximp_AttributesSetL(prop_data, status_atr->Foreground, 16);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Background, 20);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Colormap, 24);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Bg_Pixmap, 28);
! 	_Ximp_AttributesSetL(prop_data, status_atr->LineSpacing, 32);
! 	_Ximp_AttributesSetL(prop_data, status_atr->Cursor, 36);
! 	_Ximp_AttributesSetL(prop_data, status_atr->AreaNeeded.width, 40);
  	_Ximp_AttributesSetL(prop_data, status_atr->AreaNeeded.height, 44);
! 	_Ximp_AttributesSetL(prop_data, status_atr->window, 48);
!     }
  
!     XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 		((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
! 		((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
! 		32, PropModeReplace, prop_data, XIMP_STATUS_MAX_LONG(ic));
!     return;
  }
  
  void
  _Ximp_SetStatusFont(ic)
! Ximp_XIC		ic;
  {
!     if (ic->core.status_attr.fontset != NULL) {
! 	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 		((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id,
! 		XA_STRING, 8, PropModeReplace,
! 		(unsigned char *)(ic->ximp_icpart->status_font),
! 		strlen(ic->ximp_icpart->status_font));
!     }
  }
  
  void
  _Ximp_IM_SendMessage(ic, request, data1, data2, data3)
! Ximp_XIC	ic;
! unsigned long	request;
! unsigned long	data1, data2, data3;
  {
!     XEvent		Message;
  
!     if(!(IS_IC_CONNECTED(ic)) && (request != XIMP_CREATE(ic)))
! 	    return;
! 
!     /* ClientMessage Send */
!     Message.xclient.type         = ClientMessage;
!     Message.xclient.display      = ic->core.im->core.display;
!     Message.xclient.window       = ((Ximp_XIM)ic->core.im)->
! 					ximp_impart->fe_window;
!     Message.xclient.message_type = ((Ximp_XIM)ic->core.im)->
! 					ximp_impart->improtocol_id;
!     Message.xclient.format       = 32;
!     Message.xclient.data.l[0]    = request;
!     if(request == XIMP_CREATE(ic))
! 	Message.xclient.data.l[1] = (long)ic->core.client_window;
!     else
! 	Message.xclient.data.l[1] = ic->ximp_icpart->icid;
!     Message.xclient.data.l[2]    = data1;
!     Message.xclient.data.l[3]    = data2;
!     Message.xclient.data.l[4]    = data3;
!     XSendEvent(ic->core.im->core.display,
! 	((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
! 	False, NoEventMask, &Message);
!     XFlush(ic->core.im->core.display);
!     return;
  }
*** /tmp/d18629	Mon Oct 19 19:31:15 1992
--- lib/X/Ximp/XimpIM.c	Mon Oct 19 19:24:48 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpIM.c,v 1.8 92/07/29 10:16:10 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
                Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
--- 1,8 ----
! /* $XConsortium: XimpIM.c,v 1.9 92/10/19 19:24:44 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
+ 	      Copyright 1991, 1992 by Sun Microsystems, Inc.
                Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
***************
*** 8,31 ****
  and its documentation for any purpose is hereby granted without fee,
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
! in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporation not be used in advertising or publicity
! pertaining to distribution of the software without specific,
  written prior permission.
! FUJITSU LIMITED and Sony Corporation make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
! SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
! PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
  	  Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
--- 9,34 ----
  and its documentation for any purpose is hereby granted without fee,
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
! in supporting documentation, and that the name of FUJITSU LIMITED,
! Sun Microsystems, Inc. and Sony Corporation not be used in advertising 
! or publicity pertaining to distribution of the software without specific,
  written prior permission.
! FUJITSU LIMITED, Sun Microsystems, Inc. and Sony Corporation make no 
! representations about the suitability of this software for any purpose.
! It is provided "as is" without express or implied warranty.
  
! FUJITSU LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION DISCLAIM 
! ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED 
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU
! LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION BE LIABLE FOR ANY
! SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
! RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
! CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
! CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
+           Hiromu Inukai        Sun Microsystems, Inc.
+           Hideki Hiura         Sun Microsystems, Inc.
  	  Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
***************
*** 36,541 ****
  #include "Xlcint.h"
  
  #include "Ximplc.h"
  
  static Status		 _Ximp_CloseIM();
  static char		*_Ximp_GetIMValues();
  extern XIC		 _Ximp_CreateIC();
  
! extern Bool		 _Ximp_OpenIM_Resource();
  extern Ximp_XIC		 _Ximp_LookupXIC();
  extern int		 _Ximp_SetupFree();
! extern Bool		 _Ximp_Setup();
  
  extern void		 _Ximp_SetupExtension();
  extern Bool		 _Ximp_GetIMExtension();
- static Bool 		 _Ximp_GetStyle();
- 
  extern Bool		 _Ximp_XimFilter_Destroy();
  
  Ximp_XIM 		*Ximp_Xim_List = (Ximp_XIM *)NULL;
  int			 Ximp_Xim_count = 0;
! static	Atom	 	 Protocol_ID;
  static XIMMethodsRec	 Ximp_im_methods = {
! 				_Ximp_CloseIM, 		/* close */
! 				_Ximp_GetIMValues, 	/* get_values */
! 				_Ximp_CreateIC, 	/* create_ic */
! 				};
  
! char	*_Ximp_Strstr( src, dest )
  register char	*src, *dest;
  {
      register	len;
! 
!     if( src == NULL  ||  dest == NULL )
  	return( NULL );
      len = strlen(dest);
!     while( src = index( src, *dest ) ) {
! 	if( strncmp( src, dest, len ) == 0 )
! 	    return( src );
  	src++;
      }
!     return( NULL );
  }
  
! XIM
! _Ximp_OpenIM(lcd, dpy, rdb, res_name, res_class)
! 	XLCd		 lcd;
! 	Display		*dpy;
! 	XrmDatabase	 rdb;
! 	char		*res_name, *res_class;
  {
! 	Ximp_XIM		 im;
! 	XIMXimpRec		*ximp_impart;
! 	Bool			 ret;
  
! 	if((im = (Ximp_XIM)Xmalloc(sizeof(Ximp_XIMRec))) == (Ximp_XIM)NULL) {
! 		return((XIM)NULL);
  	}
  
! 	im->methods = &Ximp_im_methods;
  
- 	im->core.lcd      = lcd;
- 	im->core.ic_chain = (XIC)NULL;
- 	im->core.display   = dpy;
- 	im->core.rdb       = rdb;
- 	im->core.res_name  = res_name;
- 	im->core.res_class = res_class;
  
! 	if((ximp_impart = (XIMXimpRec *)Xmalloc(sizeof(XIMXimpRec))) == (XIMXimpRec *)NULL) {
! 		Xfree(im);
! 		return((XIM)NULL);
  	}
! 	ximp_impart->connectserver  = 0;
! 	ximp_impart->inputserver    = 1;
! 	ximp_impart->use_wchar      = False;
! 	ximp_impart->process_start_keys = NULL;
! 	im->ximp_impart = ximp_impart;
! 
!         if(_Ximp_OpenIM_Resource(im) == True)
! 		im->ximp_impart->inputserver = 0;
! 	if(_Ximp_Setup(im) == False && im->ximp_impart->inputserver) {
! 		Xfree(ximp_impart);
! 		Xfree(im);
! 		return((XIM)NULL);
  	}
! 	return((XIM)im);
  }
  
! static char *
! _Ximp_GetIMValues(im, values)
! 	Ximp_XIM	 im;
! 	XIMArg		*values;
  {
! 	XIMArg		*p;
  
! 	for(p = values; p->name != NULL; p++) {
! 		if(strcmp(p->name, XNQueryInputStyle) == 0) {
! 			if( _Ximp_GetStyle(im, p->value) == False )
! 				break;
! 		}
! 		else {
! 			if( _Ximp_GetIMExtension(im, p->name, p->value) == False )
! 				break;
! 		}
  	}
! 	return(p->name);
  }
  
  static Status
  _Ximp_CloseIM(im)
! 	Ximp_XIM	im;
  {
! 	XIC		ic;
! 	int		i;
! 	XIMXimpRec	*ximp_impart;
! 
! 	for(ic = im->core.ic_chain; ic; ic = ic->core.next)
! 		XDestroyIC(ic);
! 	ximp_impart = (XIMXimpRec *)im->ximp_impart;
! 	if( ximp_impart->process_start_keys ) {
! 		XFree( ximp_impart->process_start_keys->keys_list );
! 		XFree( ximp_impart->process_start_keys );
  	}
! 	for(i=0; i < Ximp_Xim_count; i++) {
! 		if(Ximp_Xim_List[i] == im) {
! 			Ximp_Xim_List[i] = NULL;
! 			break;
! 		}
! 	}
! 	if(ximp_impart->connectserver) {
! 		_Ximp_SetupFreeExtension(im);
! 		_Ximp_SetupFree(ximp_impart->im_proto_vl,
! 				ximp_impart->im_styles,
! 				ximp_impart->im_keyslist,
! 				ximp_impart->im_server_name,
! 				ximp_impart->im_server_vl,
! 				ximp_impart->im_vendor_name,
! 				ximp_impart->im_ext_list);
! 	}
! 	Xfree(ximp_impart);
! 	return(True);
  }
  
- static	char	 IMname[XIMP_NAME];
- static  char     LCname[XIMP_NAME];
- 
  Bool
! _Ximp_Setup(im)
! 	Ximp_XIM	im;
  {
! 	XLCd		 lcd;
! 	Atom		 atom_server;
! 	Window	 	 fe_window_id;
! 	Display		*dpy;
! 	Atom		improtocol_id,
! 			version_id, style_id, keys_id, servername_id,
! 			serverversion_id, vendorname_id, extentions_id,
! 			ctext_id, focus_win_id, preedit_atr_id, status_atr_id,
! 			preeditfont_id, statusfont_id, preeditmaxsize_id;
! 	char		*version;
! 	XIMStyles	*imstyle;
! 	Ximp_KeyList	*keylist;
! 	Atom		*ext_list;
! 	char		*server_name;
! 	char		*server_vl;
! 	char		*vendor_name;
! 	Atom		actual_type;
! 	int		actual_format;
! 	unsigned long	nitems, bytes_after;
! 	char		*prop;
! 	long		*prop_long;
! 	int		*prop_int;
! 	int		 i, n, count;
  
! 	lcd = im->core.lcd;
! 	dpy = im->core.display;
  
! 	strcpy(LCname, lcd->core.name);
! 	prop = index(LCname, '.');
! #ifdef sun	/* XXX */
! 	if (!strcmp(LCname, "japanese"))
! 	    strcpy(LCname, "ja_JP");
! #endif
! 	if (prop)
! 	    *prop = 0;
  
! 	/* IMserver Name  ex. _XIMP_ja_JP  */
! 	if(lcd->core.modifiers == (char *)NULL || *lcd->core.modifiers == '\0')
! 		sprintf(IMname, "%s%s", _XIMP_BASE, LCname); /* Default */
! 	else {
! #define MODIFIER "@im="
!  		char *mod, *s, buf[20];
!  
!  		(void)strcpy(IMname, _XIMP_BASE);
!  		(void)strcat(IMname, LCname);
!  		mod = _Ximp_Strstr(lcd->core.modifiers, MODIFIER);
!  		if (mod) {
!  			(void)strcat(IMname, "@");
!  			mod += strlen(MODIFIER);
!  			s = IMname + strlen(IMname);
!  			while (*mod && *mod != '@') {
!  				*s++ = *mod++;
! 			}
! 			*s = '\0';
! 		}
! 		(void)sprintf(buf, ".%d", dpy->default_screen);
! 		(void)strcat(IMname, buf);
  	}
! #undef MODIFIER
! 	/* Get IMS Window WID */
! 	if((atom_server = XInternAtom(dpy, IMname, False)) == (Atom)NULL){
! 		return(False);
  	}
! 	fe_window_id = XGetSelectionOwner(dpy, atom_server);
! 	if(fe_window_id == NULL) return(False);
! 
! 	/* Get Property : _XIMP_VERSION */
! 	version_id = XInternAtom(dpy, _XIMP_VERSION, False);
! 	if( XGetWindowProperty(dpy, fe_window_id, version_id, 0L, 1000000L, False,
! 			XA_STRING, &actual_type, &actual_format, &nitems,
! 			&bytes_after, (unsigned char **)(&prop)) != Success)
  		return(False);
! 	if((version = Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
! 		XFree(prop);
  		return(False);
! 	}
! 	strncpy(version, prop, nitems);
! 	version[nitems] = '\0';
! 	XFree(prop);
! 
! 	/* Get Property : _XIMP_STYLE */
! 	style_id = XInternAtom(dpy, _XIMP_STYLE, False);
! 	if( XGetWindowProperty(dpy, fe_window_id, style_id, 0L, 1000000L, False,
! 			style_id, &actual_type, &actual_format, &nitems,
! 			&bytes_after, (unsigned char **)(&prop_long)) != Success) {
! 		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
  		return(False);
  	}
! 	if((imstyle = (XIMStyles *)Xmalloc(sizeof(XIMStyles))) == NULL) {
! 		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
! 		XFree((XPointer)prop_long);
! 		return(False);
  	}
! 	if((imstyle->supported_styles =
! 		(XIMStyle *)Xmalloc(sizeof(XIMStyle) * nitems)) == NULL) {
! 		Xfree(imstyle);
! 		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
! 		XFree((XPointer)prop_long);
! 		return(False);
  	}
! 	for(i=0; i < nitems; i++) {
! 		imstyle->supported_styles[i] = prop_long[i];
  	}
! 	imstyle->count_styles = nitems;
! 	XFree((XPointer)prop_long);
! 
! 	/* Get Property : _XIMP_KEYS */
  	keys_id = XInternAtom(dpy, _XIMP_KEYS, False);
  	if( XGetWindowProperty(dpy, fe_window_id, keys_id, 0L, 1000000L, False,
! 			keys_id, &actual_type, &actual_format, &nitems,
! 			&bytes_after, (unsigned char **)(&prop_int)) != Success) {
! 		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
! 		return(False);
  	}
  	if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) == NULL) {
! 		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
! 		XFree((XPointer)prop_int);
! 		return(False);
  	}
  	count = nitems / 3;
  	if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key) * count)) == NULL) {
! 		Xfree(keylist);
! 		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
! 		XFree((XPointer)prop_int);
! 		return(False);
  	}
  	for(i=0,n=0; n < count; n++) {
! 		keylist->keys_list[n].modifier        = prop_int[i++];
! 		keylist->keys_list[n].modifier_mask   = prop_int[i++];
! 		keylist->keys_list[n].keysym          = prop_int[i++];
  	}
  	keylist->count_keys = count;
  	XFree((XPointer)prop_int);
! 
! 	/* Get Property : _XIMP_SERVERNAME */
! 	servername_id = XInternAtom(dpy, _XIMP_SERVERNAME, False);
! 	if( XGetWindowProperty(dpy, fe_window_id, servername_id, 0L, 1000000L, False,
! 			XA_STRING, &actual_type, &actual_format, &nitems,
! 			&bytes_after, (unsigned char **)(&prop)) != Success) {
! 		_Ximp_SetupFree(version, imstyle, keylist, NULL, NULL, NULL, NULL);
! 		return(False);
! 	}
! 	if((server_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
! 		_Ximp_SetupFree(version, imstyle, keylist, NULL, NULL, NULL, NULL);
! 		XFree(prop);
! 		return(False);
! 	}
! 	strncpy(server_name, prop, nitems);
! 	server_name[nitems] = '\0';
  	XFree(prop);
! 
! 	/* Get Property : _XIMP_SERVERVERSION */
! 	serverversion_id  = XInternAtom(dpy, _XIMP_SERVERVERSION, False);
! 	if( XGetWindowProperty(dpy, fe_window_id, serverversion_id, 0L, 1000000L, False,
! 			XA_STRING, &actual_type, &actual_format, &nitems,
! 			&bytes_after, (unsigned char **)(&prop)) != Success) {
! 		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
! 		return(False);
! 	}
! 	if((server_vl = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
! 		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
! 		XFree(prop);
! 		return(False);
! 	}
! 	strncpy(server_vl, prop, nitems);
! 	server_vl[nitems] = '\0';
  	XFree(prop);
! 
! 	/* Get Property : _XIMP_VENDORNAME */
! 	vendorname_id  = XInternAtom(dpy, _XIMP_VENDORNAME, False);
! 	if( XGetWindowProperty(dpy, fe_window_id, vendorname_id, 0L, 1000000L, False,
! 			XA_STRING, &actual_type, &actual_format, &nitems,
! 			&bytes_after, (unsigned char **)(&prop)) != Success) {
! 		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
! 		return(False);
! 	}
! 	if((vendor_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
! 		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
! 		XFree(prop);
! 		return(False);
! 	}
! 	strncpy(vendor_name, prop, nitems);
! 	vendor_name[nitems] = '\0';
  	XFree(prop);
  
! 	/* Get Property : _XIMP_EXTENSIONS */
! 	extentions_id = XInternAtom(dpy, _XIMP_EXTENSIONS, False);
! 	if( XGetWindowProperty(dpy, fe_window_id, extentions_id, 0L, 1000000L, False,
! 			extentions_id, &actual_type, &actual_format, &nitems,
! 			&bytes_after, (unsigned char **)(&prop_int)) != Success) {
! 		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
! 		return(False);
! 	}
! 	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * (nitems + 1)))) == NULL) {
! 		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
! 		if( prop_int )
! 		    XFree((XPointer)prop_int);
! 		return(False);
! 	}
! 	for(i=0; i < nitems; i++)
! 		ext_list[i] = prop_int[i];
! 	ext_list[nitems] = NULL;
! 	if( prop_int )
! 	    XFree((XPointer)prop_int);
  
! 	im->ximp_impart->fe_window	    = fe_window_id;
! 	Protocol_ID                 = XInternAtom(dpy, _XIMP_PROTOCOL, False);
! 	im->ximp_impart->improtocol_id  = Protocol_ID;
! 	im->ximp_impart->version_id     = version_id;
! 	im->ximp_impart->style_id       = style_id;
! 	im->ximp_impart->keys_id        = keys_id;
! 	im->ximp_impart->servername_id  = servername_id;
! 	im->ximp_impart->serverversion_id = serverversion_id;
! 	im->ximp_impart->vendorname_id  = vendorname_id;
! 	im->ximp_impart->extentions_id  = extentions_id;
! 	im->ximp_impart->ctext_id       = XInternAtom(dpy, _XIMP_CTEXT, False);
! 	im->ximp_impart->focus_win_id   = XInternAtom(dpy, _XIMP_FOCUS, False);
! 	im->ximp_impart->preedit_atr_id = XInternAtom(dpy, _XIMP_PREEDIT, False);
! 	im->ximp_impart->status_atr_id  = XInternAtom(dpy, _XIMP_STATUS, False);
! 	im->ximp_impart->preeditfont_id = XInternAtom(dpy, _XIMP_PREEDITFONT, False);
! 	im->ximp_impart->statusfont_id  = XInternAtom(dpy, _XIMP_STATUSFONT, False);
! 	im->ximp_impart->preeditmaxsize_id = XInternAtom(dpy, _XIMP_PREEDITMAXSIZE, False);
! 	im->ximp_impart->im_proto_vl = version;
! 	im->ximp_impart->im_styles   = imstyle;;
! 	im->ximp_impart->im_keyslist = keylist;
! 	im->ximp_impart->im_server_name = server_name;
! 	im->ximp_impart->im_server_vl = server_vl;
! 	im->ximp_impart->im_vendor_name = vendor_name;
! 	im->ximp_impart->im_ext_list  = ext_list;
  
! 	if(Ximp_Xim_List == (Ximp_XIM *)NULL){
! 		Ximp_Xim_List = (Ximp_XIM *)Xmalloc(sizeof(Ximp_XIM));
! 		if( Ximp_Xim_List == NULL ) {
! 		    _Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
! 		    return( False );
! 		}
! 		Ximp_Xim_List[0] = im;
! 		Ximp_Xim_count = 1;
  	}
! 	else {
! 		Ximp_XIM	*ximp_xim;
  
! 		n = 0;
! 		for(i=0; i < Ximp_Xim_count; i++) {
! 			if( Ximp_Xim_List[i] == im ) {
! 				n = 1;
! 				break;
! 			}
! 			if(Ximp_Xim_List[i] == NULL) {
! 				Ximp_Xim_List[i] = im;
! 				n = 1;
! 				break;
! 			}
! 		}
! 		if(n == 0) {
! 			ximp_xim = (Ximp_XIM *)Xrealloc(Ximp_Xim_List, ((i + 1) * sizeof(Ximp_XIM)));
! 			if( ximp_xim == NULL ) {
! 			    _Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
! 			    return( False );
! 			}
! 			Ximp_Xim_List = ximp_xim;
! 			Ximp_Xim_List[Ximp_Xim_count] = im;
! 			Ximp_Xim_count++;
! 		}
! 	}
! 
! 	_Ximp_SetupExtension(im);
! 
! 	_XRegisterFilterByType(im->core.display, fe_window_id,
! 			       DestroyNotify, DestroyNotify,
! 			       _Ximp_XimFilter_Destroy, NULL);
! 	XSelectInput(im->core.display, fe_window_id, StructureNotifyMask);
! 
! 	im->ximp_impart->connectserver  = 1;
! 	return(True);
  }
  
  int
! _Ximp_SetupFree(proto_vl, style_list, keys_list, server_name, server_vl, 
! 		vendor_name, ext_list)
! 	char		*proto_vl;
! 	XIMStyles	*style_list;
! 	Ximp_KeyList	*keys_list;
! 	char		*server_name;
! 	char		*server_vl;
! 	char		*vendor_name;
! 	Atom		*ext_list;
! {
! 	if(proto_vl)
! 		Xfree(proto_vl);
! 	if(style_list) {
! 		Xfree(style_list->supported_styles);
! 		Xfree(style_list);
! 	}
! 	if(keys_list) {
! 		Xfree(keys_list->keys_list);
! 		Xfree(keys_list);
! 	}
! 	if(server_name)
! 		Xfree(server_name);
! 	if(server_vl)
! 		Xfree(server_vl);
! 	if(vendor_name)
! 		Xfree(vendor_name);
! 	if(ext_list)
! 		Xfree(ext_list);
! }
! 
! Ximp_XIC
! _Ximp_LookupXIC(icid)
! 	int	icid;
  {
! 	int		i;
! 	Ximp_XIM	pim;
! 	Ximp_XIC	pic;
! 
! 	for(i = 0; i < Ximp_Xim_count; i++) {
! 		if( (pim = Ximp_Xim_List[i]) == NULL )
! 			continue;
! 		for(pic = (Ximp_XIC)pim->core.ic_chain; pic; pic = (Ximp_XIC)pic->core.next) {
! 			if(pic->ximp_icpart->icid == icid)
! 				return(pic);
! 		}
! 	}
! 	return(NULL);
  }
  
  static Bool
  _Ximp_GetStyle(im, p_style)
! 	Ximp_XIM	im;
! 	XIMStyles	**p_style;
  {
! 	XIMStyles	*p;
! 	int		i;
  
! 	if(!(im->ximp_impart->connectserver)) {
! 		*p_style = (XIMStyles *)NULL;
! 		return(False);
! 	}
  	p = im->ximp_impart->im_styles;
! 	if((*p_style = (XIMStyles *)Xmalloc(sizeof(XIMStyles)
! 			    + p->count_styles * sizeof(XIMStyle))) == NULL)
! 		return(False);
! 	(*p_style)->count_styles = p->count_styles;
! 	(*p_style)->supported_styles = (XIMStyle *)((char *)*p_style + sizeof(XIMStyles));
! 	for(i=0; i < (int)p->count_styles; i++) {
! 		(*p_style)->supported_styles[i] = p->supported_styles[i];
! 	}
! 	return(True);
  }
  
! Atom
! _Ximp_Protocol_id()
  {
! 	return(Protocol_ID);
  }
--- 39,773 ----
  #include "Xlcint.h"
  
  #include "Ximplc.h"
+ #include <stdio.h>
  
+ #ifndef	isdigit
+ #define	isdigit(c)	(0x30<=(c) && (c)<=0x39)
+ #endif	/* !isdigit */
+ 
  static Status		 _Ximp_CloseIM();
  static char		*_Ximp_GetIMValues();
  extern XIC		 _Ximp_CreateIC();
  
! extern void		 _Ximp_OpenIM_Resource();
  extern Ximp_XIC		 _Ximp_LookupXIC();
  extern int		 _Ximp_SetupFree();
! extern void		 _Ximp_Local_OpenIM_hook();
  
  extern void		 _Ximp_SetupExtension();
  extern Bool		 _Ximp_GetIMExtension();
  extern Bool		 _Ximp_XimFilter_Destroy();
+ extern FILE		*_XlcOpenLocaleFile();
  
+ 
  Ximp_XIM 		*Ximp_Xim_List = (Ximp_XIM *)NULL;
  int			 Ximp_Xim_count = 0;
! static	Atom	 	 Protocol_ID = 0;
! 
  static XIMMethodsRec	 Ximp_im_methods = {
!     _Ximp_CloseIM, 		/* close */
!     _Ximp_GetIMValues, 	/* get_values */
!     _Ximp_CreateIC, 	/* create_ic */
! };
  
! extern XIMMethodsRec	  Ximp_local_im_methods;
! 
! char	*
! _Ximp_Strstr(src, dest)
  register char	*src, *dest;
  {
      register	len;
!     
!     if(!src || !dest)
  	return( NULL );
      len = strlen(dest);
!     while(src = index(src, *dest)) {
! 	if(strncmp(src, dest, len) == 0)
! 	    return(src);
  	src++;
      }
!     return(NULL);
  }
  
! Ximp_XIC
! _Ximp_LookupXIC(icid)
! int	icid;
  {
!     int		i;
!     Ximp_XIM	pim;
!     Ximp_XIC	pic;
!     
!     for(i = 0; i < Ximp_Xim_count; i++) {
! 	if((pim = Ximp_Xim_List[i]) == NULL) continue ;
! 	for(pic = (Ximp_XIC)pim->core.ic_chain; pic; pic = (Ximp_XIC)pic->core.next) {
! 	    if(pic->ximp_icpart->icid == icid)
! 		return(pic);
! 	}
!     }
!     return(NULL);
! }
  
! Atom
! _Ximp_Protocol_id()
! {
!     return(Protocol_ID);
! }
! 
! static int
! _Ximp_vl2vnum (version)
! register char *version;
! {
!     char p[1024];
!     register char *q;
!     register int l = strlen(version);
!     register int i;
!     Bool hyphen = False;
!     Bool u_score = False;
!     
!     q = p;
!     for (i = 0;i < l;i++){
! 	if(isdigit(*version)) {
! 	    *q = *version;
! 	    q++;
! 	} else if(*version == '_') {
! 	    u_score = True;
! 	} else if(*version == '-') {
! 	    hyphen = True;
  	}
+ 	version++;
+     }
+     p[l] = '\n';
+     if(u_score) {
+ 	return (atoi(p) + 100);
+     } else if(hyphen) {
+ 	return (atoi(p) + 200);
+     } else {
+ 	return(atoi(p));
+     }
+ }
  
! static Bool
! _Ximp_IMList(im)
! Ximp_XIM	im;
! {
!     int		n, i = 0;
!     Ximp_XIM	*ximp_xim;
  
  
!     if( Ximp_Xim_List == (Ximp_XIM *)NULL ) {
! 	if( (Ximp_Xim_List = (Ximp_XIM *)Xmalloc(sizeof(Ximp_XIM))) == NULL ) {
! 	    return( False );
  	}
! 	Ximp_Xim_List[0] = im;
! 	Ximp_Xim_count = 1;
!     }
!     else {
! 	n = 0;
! 	for( i = 0; i < Ximp_Xim_count; i++ ) {
! 	    if( Ximp_Xim_List[i] == NULL ) {
! 		Ximp_Xim_List[i] = im;
! 		n = 1;
! 		break;
! 	    }
  	}
! 	if( n == 0 ) {
! 	    if( (ximp_xim = (Ximp_XIM *)Xrealloc( Ximp_Xim_List, ((i + 1) * sizeof(Ximp_XIM)))) == NULL ) {
! 		return( False );
! 	    }
! 	    Ximp_Xim_List = ximp_xim;
! 	    Ximp_Xim_List[Ximp_Xim_count] = im;
! 	    Ximp_Xim_count++;
! 	}
!     }
!     return( True );
  }
  
! XIM
! _Ximp_OpenIM(lcd, dpy, rdb, res_name, res_class)
! XLCd		 lcd;
! Display		*dpy;
! XrmDatabase	 rdb;
! char		*res_name, *res_class;
  {
!     Ximp_XIM		 im;
!     XIMXimpRec		*ximp_impart;
!     Bool		 success;
!     char		*mod, buf[128];
!     int			 i;
!     
!     if((im = (Ximp_XIM)Xmalloc(sizeof(Ximp_XIMRec))) == (Ximp_XIM)NULL) {
! 	return((XIM)NULL);
!     }
!     if((ximp_impart = (XIMXimpRec *)Xmalloc(sizeof(XIMXimpRec))) == (XIMXimpRec *)NULL) {
! 	Xfree(im);
! 	return((XIM)NULL);
!     }
!     bzero(im, sizeof(Ximp_XIMRec));
!     bzero(ximp_impart, sizeof(XIMXimpRec));
  
!     im->ximp_impart = ximp_impart;
! 
!     im->methods        = &Ximp_im_methods;
!     im->core.lcd       = lcd;
!     im->core.ic_chain  = (XIC)NULL;
!     im->core.display   = dpy;
!     im->core.rdb       = rdb;
!     im->core.res_name  = res_name;
!     im->core.res_class = res_class;
! 
!     ximp_impart->is_local             = False;
!     ximp_impart->reconnection_mode    = XIMP_NOCONNECT;
!     ximp_impart->is_connected         = False;
!     ximp_impart->im_name              = (char *)NULL;
!     ximp_impart->process_start_keys   = (Ximp_KeyList *)NULL;
!     ximp_impart->use_wchar            = False;
!     ximp_impart->delaybind_styles     = (XIMStyles *)NULL;
!     ximp_impart->current_ic           = (XIC)NULL;
! 
!     buf[0] = '\0';
!     i = 0;
!     if( lcd->core.modifiers != (char *)NULL  &&  *lcd->core.modifiers != '\0' ) {
! #define	MODIFIER	"@im="
! 	mod = _Ximp_Strstr( lcd->core.modifiers, MODIFIER );
! 	if( mod ) {
! 	    mod += strlen( MODIFIER );
! 	    while( *mod  &&  *mod != '@' ) {
! 		buf[i++] = *mod++;
! 	    }
! 	    buf[i] = '\0';
  	}
!     }
! #undef	MODIFIER
!     if((ximp_impart->im_name = Xmalloc(i+1)) == NULL)
! 	goto Set_Error;
!     strcpy(ximp_impart->im_name, buf);
! 
!     if( !_Ximp_IMList(im) ) 
! 	goto Set_Error;
! 
!     _Ximp_OpenIM_Resource( im );
! 
!     if( strcmp( ximp_impart->im_name, "" ) == 0 ) {
! 	FILE	*fp;
! 	fp = _XlcOpenLocaleFile( NULL, ((XimpLCd)im->core.lcd)->locale.language, COMPOSE_FILE );
! 	if( fp != NULL ) {
! 	    fclose( fp );
! 	    IS_LOCAL_PROCESSING(im) = True;
! 	}
!     } else if( strcmp( im->ximp_impart->im_name, "local" ) == 0  ||
! 	strcmp( im->ximp_impart->im_name, "none" ) == 0 ) {
! 	IS_LOCAL_PROCESSING(im) = True;
!     }
! 
!     if( IS_LOCAL_PROCESSING(im) ) {
! 	if( !_Ximp_LocalConnect(im) )
! 	    goto Set_Error;
!     }
!     else {
! 	if( !_Ximp_ConnectServer(im) ) {
! 	    if( !(IS_DELAYBINDABLE(im)) )
! 		goto Set_Error;
! 	}
!     }
! 
!     return((XIM)im);
! 
! Set_Error :
!     if( ximp_impart->delaybind_styles )
! 	Xfree( ximp_impart->delaybind_styles );
!     Xfree( ximp_impart );
!     Xfree( im );
!     return( NULL );
  }
  
  static Status
  _Ximp_CloseIM(im)
! Ximp_XIM	im;
  {
!     XIC		ic;
!     int		i;
!     XIMXimpRec	*ximp_impart;
!     
!     while( ic = im->core.ic_chain )
! 	XDestroyIC(ic);
!     ximp_impart = (XIMXimpRec *)im->ximp_impart;
!     if(ximp_impart->process_start_keys) {
! 	XFree( ximp_impart->process_start_keys->keys_list );
! 	XFree( ximp_impart->process_start_keys );
!     }
!     if( ximp_impart->im_name )
! 	XFree( ximp_impart->im_name );
!     for(i=0; i < Ximp_Xim_count; i++) {
! 	if(Ximp_Xim_List[i] == im) {
! 	    Ximp_Xim_List[i] = NULL;
! 	    break;
  	}
!     }
!     if(IS_SERVER_CONNECTED(im)){
! 	_Ximp_SetupFreeExtension(im);
! 	_Ximp_SetupFree(ximp_impart->im_proto_vl,
! 			ximp_impart->im_styles,
! 			ximp_impart->type_list,
! 			ximp_impart->im_keyslist,
! 			ximp_impart->im_offkeyslist,
! 			ximp_impart->im_server_name,
! 			ximp_impart->im_server_vl,
! 			ximp_impart->im_vendor_name,
! 			ximp_impart->im_ext_list);
!     }
!     if( ximp_impart->delaybind_styles )
! 	Xfree( ximp_impart->delaybind_styles );
!     Xfree(ximp_impart);
!     return(True);
  }
  
  Bool
! _Ximp_ConnectServer( im )
! Ximp_XIM	im;
  {
!     char	 	IMname[XIMP_NAME];
!     char	 	LCname[XIMP_NAME];
!     XLCd		lcd;
!     Atom		atom_server;
!     Window	 	fe_window_id;
!     Display	       *dpy;
!     Atom		improtocol_id, type_id, off_keys_id,
!     version_id, style_id, keys_id, servername_id,
!     serverversion_id, vendorname_id, extentions_id,
!     ctext_id, focus_win_id, preedit_atr_id, status_atr_id,
!     preeditfont_id, statusfont_id, preeditmaxsize_id;
!     char	       *version;
!     XIMStyles	       *imstyle;
!     Ximp_KeyList       *keylist;
!     Ximp_KeyList       *offkeylist = NULL;
!     long               *type_list;
!     Atom	       *ext_list;
!     char	       *server_name;
!     char	       *server_vl;
!     char	       *vendor_name;
!     Atom		actual_type;
!     int			actual_format;
!     unsigned long	nitems, bytes_after;
!     char	       *prop;
!     long	       *prop_long;
!     int		       *prop_int;
!     int		 	i, n, count;
!     Ximp_XIM	       *ximp_xim;
!     char	       *language, *territory;
  
!     lcd = im->core.lcd;
!     dpy = im->core.display;
  
!     language = ((XimpLCd) lcd)->locale.language;
!     territory = ((XimpLCd) lcd)->locale.territory;
!     if (*territory)
! 	sprintf(LCname, "%s_%s", language, territory);
!     else
! 	strcpy(LCname, language);
!     
!     /* IMserver Name  ex. _XIMP_ja_JP  */
!     if(lcd->core.modifiers == (char *)NULL || *lcd->core.modifiers == '\0')
! 	sprintf(IMname, "%s%s", _XIMP_BASE, LCname); /* Default */
!     else {
! 	char	buf[20];
! 	
! 	strcpy(IMname, _XIMP_BASE);
! 	strcat(IMname, LCname);
! 	strcat( IMname, "@" );
! 	strcat( IMname, im->ximp_impart->im_name );
! 	sprintf(buf, ".%d", dpy->default_screen);
! 	strcat(IMname, buf);
!     }
  
!     /* Get IMS Window WID */
!     if((atom_server = XInternAtom(dpy, IMname, False)) == (Atom)NULL){
! 	return(False);
!     }
!     fe_window_id = XGetSelectionOwner(dpy, atom_server);
!     if(fe_window_id == NULL) {
! 	return(False);
!     }
!     /* Get Property : _XIMP_VERSION */
!     version_id = XInternAtom(dpy, _XIMP_VERSION, False);
!     if(XGetWindowProperty(dpy, fe_window_id, version_id, 0L, 1000000L, False,
! 			  XA_STRING, &actual_type, &actual_format, &nitems,
! 			  &bytes_after, (unsigned char **)(&prop)) != Success)
! 	return(False);
!     if((version = Xmalloc((sizeof(char) * nitems + 1))) == NULL){
! 	XFree((XPointer)prop);
! 	return(False);
!     }
!     strncpy(version, prop, nitems);
!     version[nitems] = '\0';
!     XFree(prop);
!     im->ximp_impart->im_proto_vnum = _Ximp_vl2vnum(version);
!     
!     /* Get Property : _XIMP_STYLE */
!     style_id = XInternAtom(dpy, _XIMP_STYLE, False);
!     if( XGetWindowProperty(dpy, fe_window_id, style_id, 0L, 1000000L, False,
! 			   style_id, &actual_type, &actual_format, &nitems,
! 			   &bytes_after, (unsigned char **)(&prop_long)) != Success) {
! 	_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
! 	return(False);
!     }
!     if((imstyle = (XIMStyles *)Xmalloc(sizeof(XIMStyles))) == NULL) {
! 	_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
! 	XFree((XPointer)prop_long);
! 	return(False);
!     }
!     if((imstyle->supported_styles =
! 	(XIMStyle *)Xmalloc(sizeof(XIMStyle) * nitems)) == NULL) {
! 	Xfree(imstyle);
! 	_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
! 	XFree((XPointer)prop_long);
! 	return(False);
!     }
!     for(i=0; i < nitems; i++) {
! 	imstyle->supported_styles[i] = prop_long[i];
!     }
!     imstyle->count_styles = nitems;
!     XFree((XPointer)prop_long);
!     
!     /* Get Property : _XIMP_TYPE for Ximp4.0 */
!     if(ISXimp4IM(im)){
! 	type_id = XInternAtom(dpy, _XIMP_TYPE, False);
! 	if( XGetWindowProperty(dpy, fe_window_id, type_id, 0L, 1000000L, False,
! 			       type_id, &actual_type, &actual_format, &nitems,
! 			       &bytes_after, (unsigned char **)(&prop_long)) != Success) {
! 	    _Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
! 	    XFree((XPointer)prop_long);
! 	    return(False);
  	}
! 	if((type_list = (long *)Xmalloc(sizeof(long) * (nitems + 1))) == NULL) {
! 	    _Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
! 	    XFree((XPointer)prop_long);
! 	    return(False);
  	}
! 	for(i = 0; i < nitems; i++) {
! 	    type_list[i] = prop_long[i];
! 	}
! 	type_list[nitems] = NULL;
! 	XFree((XPointer)prop_long);
!     } else {
! 	type_list = NULL; /* For save _Ximp_SetupFree() */
!     }
!     
!     /*
!      *Get Property :
!      *_XIMP_SPROC_STARTED_KEYS and _XIMP_SPROC_STOPPED_KEYS(Ximp4.0)
!      *_XIMP_KEYS(Ximp3.5)
!      */
!     if(ISXimp4IM(im)){
! 	if(im->ximp_impart->im_keyslist){
! 	    /*
! 	     * if this is reconnected, this field must be remaining.
! 	     * BIG assumption: always same server will be reconnected!
! 	     */
! 	    keylist = im->ximp_impart->im_keyslist ;
! 	} else {
! 	    keys_id = XInternAtom(dpy, _XIMP_SPROC_STARTED_KEYS, False);
! 	    if( XGetWindowProperty(dpy, fe_window_id, keys_id, 0L, 1000000L, False,
! 				   keys_id, &actual_type, &actual_format, &nitems,
! 				   &bytes_after, (unsigned char **)(&prop_int)) != Success) {
! 		_Ximp_SetupFree(version, imstyle, type_list, NULL, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 	    }
! 	    if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) == NULL) {
! 		_Ximp_SetupFree(version, imstyle, type_list, NULL, NULL, NULL, NULL, NULL, NULL);
! 		XFree( (XPointer)prop_int );
  		return(False);
! 	    }
! 	    count = nitems / 3;
! 	    if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key) * count)) == NULL) {
! 		Xfree(keylist);
! 		_Ximp_SetupFree(version, imstyle, type_list, NULL, NULL, NULL, NULL, NULL, NULL);
! 		XFree( (XPointer)prop_int );
  		return(False);
+ 	    }
+ 	    for(i=0,n=0; n < count; n++) {
+ 		keylist->keys_list[n].modifier        = prop_int[i++];
+ 		keylist->keys_list[n].modifier_mask   = prop_int[i++];
+ 		keylist->keys_list[n].keysym          = prop_int[i++];
+ 	    }
+ 	    keylist->count_keys = count;
+ 	    XFree((XPointer)prop_int);
  	}
! 	off_keys_id = XInternAtom(dpy, _XIMP_SPROC_STOPPED_KEYS, False);
! 	if( XGetWindowProperty(dpy, fe_window_id, off_keys_id, 0L, 1000000L, False,
! 			       off_keys_id, &actual_type, &actual_format, &nitems,
! 			       &bytes_after, (unsigned char **)(&prop_int)) != Success) {
! 	    _Ximp_SetupFree(version, imstyle, type_list, keylist, NULL, NULL, NULL, NULL, NULL);
! 	    XFree( (XPointer)prop_int );
! 	    return(False);
  	}
! 	if((offkeylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) == NULL) {
! 	    _Ximp_SetupFree(version, imstyle, type_list, keylist, NULL, NULL, NULL, NULL, NULL);
! 	    XFree( (XPointer)prop_int );
! 	    return(False);
  	}
! 	count = nitems / 3;
! 	if((offkeylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key) * count)) == NULL) {
! 	    Xfree(offkeylist);
! 	    XFree( (XPointer)prop_int );
! 	    _Ximp_SetupFree(version, imstyle, type_list, keylist, NULL, NULL, NULL, NULL, NULL);
! 	    return(False);
  	}
! 	for(i=0,n=0; n < count; n++) {
! 	    offkeylist->keys_list[n].modifier        = prop_int[i++];
! 	    offkeylist->keys_list[n].modifier_mask   = prop_int[i++];
! 	    offkeylist->keys_list[n].keysym          = prop_int[i++];
! 	}
! 	offkeylist->count_keys = count;
! 	XFree((XPointer)prop_int);
!     } else { /* Ximp3.5 */
  	keys_id = XInternAtom(dpy, _XIMP_KEYS, False);
  	if( XGetWindowProperty(dpy, fe_window_id, keys_id, 0L, 1000000L, False,
! 			       keys_id, &actual_type, &actual_format, &nitems,
! 			       &bytes_after, (unsigned char **)(&prop_int)) != Success) {
! 	    _Ximp_SetupFree(version, imstyle, type_list, NULL, NULL, NULL, NULL, NULL, NULL);
! 	    return(False);
  	}
  	if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) == NULL) {
! 	    _Ximp_SetupFree(version, imstyle, type_list, NULL, NULL, NULL, NULL, NULL, NULL);
! 	    XFree( (XPointer)prop_int );
! 	    return(False);
  	}
  	count = nitems / 3;
  	if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key) * count)) == NULL) {
! 	    Xfree(keylist);
! 	    XFree( (XPointer)prop_int );
! 	    _Ximp_SetupFree(version, imstyle, type_list, NULL, NULL, NULL, NULL, NULL, NULL);
! 	    return(False);
  	}
  	for(i=0,n=0; n < count; n++) {
! 	    keylist->keys_list[n].modifier        = prop_int[i++];
! 	    keylist->keys_list[n].modifier_mask   = prop_int[i++];
! 	    keylist->keys_list[n].keysym          = prop_int[i++];
  	}
  	keylist->count_keys = count;
  	XFree((XPointer)prop_int);
!     }
!     /* Get Property : _XIMP_SERVERNAME */
!     servername_id = XInternAtom(dpy, _XIMP_SERVERNAME, False);
!     if( XGetWindowProperty(dpy, fe_window_id, servername_id, 0L, 1000000L, False,
! 			   XA_STRING, &actual_type, &actual_format, &nitems,
! 			   &bytes_after, (unsigned char **)(&prop)) != Success) {
! 	_Ximp_SetupFree(version, imstyle, type_list, keylist, offkeylist, NULL, NULL, NULL, NULL);
! 	return(False);
!     }
!     if((server_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
! 	_Ximp_SetupFree(version, imstyle, type_list, keylist, offkeylist, NULL, NULL, NULL, NULL);
  	XFree(prop);
! 	return(False);
!     }
!     strncpy(server_name, prop, nitems);
!     server_name[nitems] = '\0';
!     XFree(prop);
!     
!     /* Get Property : _XIMP_SERVERVERSION */
!     serverversion_id  = XInternAtom(dpy, _XIMP_SERVERVERSION, False);
!     if( XGetWindowProperty(dpy, fe_window_id, serverversion_id, 0L, 1000000L, False,
! 			   XA_STRING, &actual_type, &actual_format, &nitems,
! 			   &bytes_after, (unsigned char **)(&prop)) != Success) {
! 	_Ximp_SetupFree(version, imstyle, type_list, keylist, offkeylist, server_name, NULL, NULL, NULL);
! 	return(False);
!     }
!     if((server_vl = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
! 	_Ximp_SetupFree(version, imstyle, type_list, keylist, offkeylist, server_name, NULL, NULL, NULL);
  	XFree(prop);
! 	return(False);
!     }
!     strncpy(server_vl, prop, nitems);
!     server_vl[nitems] = '\0';
!     XFree(prop);
!     
!     /* Get Property : _XIMP_VENDORNAME */
!     vendorname_id  = XInternAtom(dpy, _XIMP_VENDORNAME, False);
!     if( XGetWindowProperty(dpy, fe_window_id, vendorname_id, 0L, 1000000L, False,
! 			   XA_STRING, &actual_type, &actual_format, &nitems,
! 			   &bytes_after, (unsigned char **)(&prop)) != Success) {
! 	_Ximp_SetupFree(version, imstyle, type_list, keylist, offkeylist, server_name, server_vl, NULL, NULL);
! 	return(False);
!     }
!     if((vendor_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
! 	_Ximp_SetupFree(version, imstyle, type_list, keylist, offkeylist, server_name, server_vl, NULL, NULL);
  	XFree(prop);
+ 	return(False);
+     }
+     strncpy(vendor_name, prop, nitems);
+     vendor_name[nitems] = '\0';
+     XFree(prop);
+     
+     /* Get Property : _XIMP_EXTENSIONS */
+     extentions_id = XInternAtom(dpy, _XIMP_EXTENSIONS, False);
+     if( XGetWindowProperty(dpy, fe_window_id, extentions_id, 0L, 1000000L, False,
+ 			   extentions_id, &actual_type, &actual_format, &nitems,
+ 			   &bytes_after, (unsigned char **)(&prop_int)) != Success) {
+ 	_Ximp_SetupFree(version, imstyle, type_list, keylist, offkeylist, server_name, server_vl, vendor_name, NULL);
+ 	return(False);
+     }
+     if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * (nitems + 1)))) == NULL) {
+ 	_Ximp_SetupFree(version, imstyle, type_list, keylist, offkeylist, server_name, server_vl, vendor_name, NULL);
+ 	if(prop_int) XFree((XPointer)prop_int);
+ 	return(False);
+     }
+     for(i=0; i < nitems; i++)
+ 	ext_list[i] = prop_int[i];
+     ext_list[nitems] = NULL;
+     if(prop_int) XFree((XPointer)prop_int);
+     
+     im->ximp_impart->fe_window	    = fe_window_id;
+     Protocol_ID                 = XInternAtom(dpy, _XIMP_PROTOCOL, False);
+     im->ximp_impart->improtocol_id  = Protocol_ID;
+     im->ximp_impart->version_id     = version_id;
+     im->ximp_impart->style_id       = style_id;
+     im->ximp_impart->keys_id        = keys_id;
+     im->ximp_impart->servername_id  = servername_id;
+     im->ximp_impart->serverversion_id = serverversion_id;
+     im->ximp_impart->vendorname_id  = vendorname_id;
+     im->ximp_impart->extentions_id  = extentions_id;
+     im->ximp_impart->ctext_id       = XInternAtom(dpy, _XIMP_CTEXT, False);
+     im->ximp_impart->focus_win_id   = XInternAtom(dpy, _XIMP_FOCUS, False);
+     im->ximp_impart->preedit_atr_id = XInternAtom(dpy, _XIMP_PREEDIT, False);
+     im->ximp_impart->status_atr_id  = XInternAtom(dpy, _XIMP_STATUS, False);
+     im->ximp_impart->preeditfont_id = XInternAtom(dpy, _XIMP_PREEDITFONT, False);
+     im->ximp_impart->statusfont_id  = XInternAtom(dpy, _XIMP_STATUSFONT, False);
+     im->ximp_impart->preeditmaxsize_id = XInternAtom(dpy, _XIMP_PREEDITMAXSIZE, False);
+     im->ximp_impart->im_proto_vl = version;
+     im->ximp_impart->im_styles   = imstyle;;
+     im->ximp_impart->im_keyslist = keylist;
+     im->ximp_impart->im_offkeyslist = offkeylist;
+     im->ximp_impart->type_id = type_id;
+     im->ximp_impart->type_list = type_list;
+     im->ximp_impart->im_server_name = server_name;
+     im->ximp_impart->im_server_vl = server_vl;
+     im->ximp_impart->im_vendor_name = vendor_name;
+     im->ximp_impart->im_ext_list  = ext_list;
+     
+     _Ximp_SetupExtension(im);
+     _XRegisterFilterByType(im->core.display, fe_window_id,
+ 			   DestroyNotify, DestroyNotify,
+ 			   _Ximp_XimFilter_Destroy, NULL);
+     XSelectInput(im->core.display, fe_window_id, StructureNotifyMask);
  
!     IS_SERVER_CONNECTED(im) = True ;
!     return(True);
! }
  
! Bool
! _Ximp_LocalConnect( im )
! Ximp_XIM	im;
! {
!     im->ximp_impart->type_list      = NULL; /* dummy */
!     im->ximp_impart->im_server_name = NULL; /* dummy */
!     im->ximp_impart->im_vendor_name = NULL; /* dummy */
!     im->ximp_impart->im_proto_vl    = NULL; /* dummy */
!     im->ximp_impart->im_proto_vnum  = 0; /* dummy */
!     im->ximp_impart->im_ext_list    = 0; /* dummy */
  
!     im->ximp_impart->im_styles = (XIMStyles *)Xmalloc(sizeof(XIMStyles));
!     if( im->ximp_impart->im_styles ) {
! 	im->ximp_impart->im_styles->supported_styles = (XIMStyle *)Xmalloc(sizeof(XIMStyle) * 2);
! 	im->ximp_impart->im_styles->count_styles = 2;
! 	if( im->ximp_impart->im_styles->supported_styles == NULL ) {
! 	    Xfree( im->ximp_impart->im_styles );
! 	    im->ximp_impart->im_styles = NULL;
! 	    return( False );
  	}
! 	im->ximp_impart->im_styles->supported_styles[0] = XIMPreeditNone | XIMStatusNone;
! 	im->ximp_impart->im_styles->supported_styles[1] = XIMPreeditNothing | XIMStatusNothing;
!     }
!     else {
! 	return( False );
!     }
  
!     im->methods = &Ximp_local_im_methods;
!     _Ximp_Local_OpenIM_hook( im );
!     return( True );
  }
  
  int
! _Ximp_SetupFree(proto_vl, style_list, type_list, keys_list, off_keys_list, server_name, server_vl, vendor_name, ext_list)
! char		*proto_vl;
! XIMStyles	*style_list;
! long		*type_list;
! Ximp_KeyList	*keys_list;
! Ximp_KeyList	*off_keys_list;
! char		*server_name;
! char		*server_vl;
! char		*vendor_name;
! Atom		*ext_list;
  {
!     if(proto_vl)
! 	Xfree(proto_vl);
!     if(style_list) {
! 	Xfree(style_list->supported_styles);
! 	Xfree(style_list);
!     }
!     if(type_list)
! 	Xfree(type_list);
!     if(keys_list) {
! 	Xfree(keys_list->keys_list);
! 	Xfree(keys_list);
!     }
!     if(off_keys_list) {
! 	Xfree(off_keys_list->keys_list);
! 	Xfree(off_keys_list);
!     }
!     if(server_name)
! 	Xfree(server_name);
!     if(server_vl)
! 	Xfree(server_vl);
!     if(vendor_name)
! 	Xfree(vendor_name);
!     if(ext_list)
! 	Xfree(ext_list);
  }
  
  static Bool
  _Ximp_GetStyle(im, p_style)
! Ximp_XIM	im;
! XIMStyles	**p_style;
  {
!     XIMStyles	*p;
!     int		i;
!     
!     if(!IS_SERVER_CONNECTED(im) && !(IS_DELAYBINDABLE(im))){
! 	*p_style = (XIMStyles *)NULL;
! 	return(False);
!     }
  
!     if(IS_SERVER_CONNECTED(im))
  	p = im->ximp_impart->im_styles;
!     else
! 	p = im->ximp_impart->delaybind_styles;
! 
!     if((*p_style = (XIMStyles *)Xmalloc(sizeof(XIMStyles)
! 					+ p->count_styles * sizeof(XIMStyle))) == NULL)
! 	return(False);
!     (*p_style)->count_styles = p->count_styles;
!     (*p_style)->supported_styles = (XIMStyle *)((char *)*p_style + sizeof(XIMStyles));
!     for(i=0; i < (int)p->count_styles; i++) {
! 	(*p_style)->supported_styles[i] = p->supported_styles[i];
!     }
!     return(True);
  }
  
! static char *
! _Ximp_GetIMValues(im, values)
! Ximp_XIM	 im;
! XIMArg		*values;
  {
!     XIMArg		*p;
!     
!     for(p = values; p->name != NULL; p++) {
! 	if(strcmp(p->name, XNQueryInputStyle) == 0) {
! 	    if( _Ximp_GetStyle(im, p->value) == False)
! 		break;
! 	} else {
! 	    if( _Ximp_GetIMExtension(im, p->name, p->value) == False)
! 		break;
! 	}
!     }
!     return(p->name);
  }
