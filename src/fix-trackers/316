Path: news!news.crl.dec.com!pa.dec.com!nobody
Message-Id: <9205151639.AA13979@alex.lcs.mit.edu>
To: fix-trackers@expo.lcs.mit.edu
Subject: (seq: 2543) Font Service protocol version 2 sample implementation, part 2 of 2
Date: Fri, 15 May 92 12:39:41 EDT
From: Stephen Gildea <gildea@expo.lcs.mit.edu>
Distribution: dec
X-Mailing-List: fix-trackers@expo.lcs.mit.edu
X-Disclaimer: This message originated from a mailing list outside of Digital.
Newsgroups: dec.mail.lists.x.fix-trackers
Approved: news@usenet.pa.dec.com

*** /tmp/da13358	Fri May 15 12:03:03 1992
--- fonts/lib/font/Type1/t1funcs.c	Tue May 12 18:07:52 1992
***************
*** 1,4 ****
! /* $XConsortium: t1funcs.c,v 1.9 92/03/27 18:13:14 eswu Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: t1funcs.c,v 1.10 92/05/12 18:07:55 gildea Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 69,78 ****
   
  int         Type1OpenScalable ();
  static int  Type1GetGlyphs();
- extern int  GenericGetExtents();
  void        Type1CloseFont();
  extern int  Type1GetInfoScalable ();
- extern int  GenericGetBitmaps();
   
  static int  Type1GetMetrics ();
   
--- 69,76 ----
***************
*** 252,261 ****
         pFont->info.firstRow = 0;
         pFont->info.lastRow  = 0;
   
-        pFont->get_bitmaps = GenericGetBitmaps;
         pFont->get_metrics = Type1GetMetrics;
         pFont->get_glyphs  = Type1GetGlyphs;
-        pFont->get_extents = GenericGetExtents;
         pFont->unload_font = Type1CloseFont;
         pFont->refcnt = 0;
         pFont->maxPrivate = -1;
--- 250,257 ----
*** /tmp/da13377	Fri May 15 12:03:05 1992
--- fonts/lib/font/util/Imakefile	Fri May 15 11:17:01 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.8 91/10/18 11:22:58 keith Exp $
  #include <Server.tmpl>
  
          INCLUDES = -I$(FONTSRC)/include -I../include -I$(FONTSERVERSRC)/include
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.9 92/05/15 11:15:42 gildea Exp $
  #include <Server.tmpl>
  
          INCLUDES = -I$(FONTSRC)/include -I../include -I$(FONTSERVERSRC)/include
***************
*** 7,16 ****
       FORMAT_DEFS = FontFormatDefines
  #endif
              SRCS = bitmaputil.c fontnames.c fontutil.c fontxlfd.c format.c \
! 		   fontaccel.c atom.c miscutil.c private.c patcache.c fsfuncs.c
  
              OBJS = bitmaputil.o fontnames.o fontutil.o fontxlfd.o format.o \
! 		   fontaccel.o atom.o miscutil.o private.o patcache.o fsfuncs.o
  
  SubdirLibraryRule($(OBJS))
  NormalLibraryObjectRule()
--- 7,16 ----
       FORMAT_DEFS = FontFormatDefines
  #endif
              SRCS = bitmaputil.c fontnames.c fontutil.c fontxlfd.c format.c \
! 		   fontaccel.c atom.c miscutil.c private.c patcache.c
  
              OBJS = bitmaputil.o fontnames.o fontutil.o fontxlfd.o format.o \
! 		   fontaccel.o atom.o miscutil.o private.o patcache.o
  
  SubdirLibraryRule($(OBJS))
  NormalLibraryObjectRule()
*** /tmp/da13396	Fri May 15 12:03:07 1992
--- fonts/server/include/clientstr.h	Tue May 12 18:07:55 1992
***************
*** 1,4 ****
! /* $XConsortium: clientstr.h,v 1.3 91/05/13 16:48:15 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: clientstr.h,v 1.4 92/05/12 18:07:58 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 20,28 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)clientstr.h	4.2	91/05/03
-  *
   */
  
  #ifndef _CLIENTSTR_H_
--- 20,25 ----
***************
*** 50,55 ****
--- 47,54 ----
      Mask        eventmask;
      fsResolution *resolutions;
      int         num_resolutions;
+     int		major_version;	/* client-major-protocol-version */
+     int		minor_version;
  }           ClientRec;
  
  typedef struct _WorkQueue {
*** /tmp/da13415	Fri May 15 12:03:09 1992
--- fonts/server/include/servermd.h	Tue May 12 18:07:58 1992
***************
*** 1,4 ****
! /* $XConsortium: servermd.h,v 1.4 91/07/25 12:15:04 keith Exp $ */
  /* 
   * Copyright 1990, 1991 Network Computing Devices; 
   * Portions Copyright 1987 by Digital Equipment Corporation and the 
--- 1,4 ----
! /* $XConsortium: servermd.h,v 1.5 92/05/12 18:08:01 gildea Exp $ */
  /* 
   * Copyright 1990, 1991 Network Computing Devices; 
   * Portions Copyright 1987 by Digital Equipment Corporation and the 
***************
*** 20,34 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)servermd.h	4.1	91/05/02
-  *
   */
  #ifndef _SERVERMD_H_
  #define _SERVERMD_H_
  
  #ifndef VENDOR_RELEASE
! #define VENDOR_RELEASE 5000
  #endif
  
  #ifndef VENDOR_STRING
--- 20,31 ----
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   */
  #ifndef _SERVERMD_H_
  #define _SERVERMD_H_
  
  #ifndef VENDOR_RELEASE
! #define VENDOR_RELEASE 5001
  #endif
  
  #ifndef VENDOR_STRING
*** /tmp/da13434	Fri May 15 12:03:10 1992
--- fonts/server/difs/Imakefile	Tue May 12 18:08:00 1992
***************
*** 1,13 ****
! XCOMM $XConsortium: Imakefile,v 1.8 91/07/17 16:06:01 gildea Exp $
  #undef ServerDefines
  #include <Server.tmpl>
  
  SRCS =	main.c dispatch.c extensions.c globals.c events.c tables.c \
! 	fontinfo.c swapreq.c swaprep.c resource.c \
  	fonts.c difsutils.c cache.c initfonts.c atom.c
  
  OBJS =  main.o dispatch.o extensions.o globals.o events.o tables.o \
! 	fontinfo.o swapreq.o swaprep.o resource.o \
  	fonts.o difsutils.o cache.o initfonts.o atom.o
  
  
--- 1,13 ----
! XCOMM $XConsortium: Imakefile,v 1.9 92/05/12 18:08:03 gildea Exp $
  #undef ServerDefines
  #include <Server.tmpl>
  
  SRCS =	main.c dispatch.c extensions.c globals.c events.c tables.c \
! 	fontinfo.c charinfo.c swapreq.c swaprep.c resource.c \
  	fonts.c difsutils.c cache.c initfonts.c atom.c
  
  OBJS =  main.o dispatch.o extensions.o globals.o events.o tables.o \
! 	fontinfo.o charinfo.o swapreq.o swaprep.o resource.o \
  	fonts.o difsutils.o cache.o initfonts.o atom.o
  
  
*** /tmp/da13453	Fri May 15 12:03:12 1992
--- fonts/server/difs/dispatch.c	Tue May 12 18:08:03 1992
***************
*** 1,4 ****
! /* $XConsortium: dispatch.c,v 1.9 92/02/11 13:06:43 eswu Exp $ */
  /*
   * protocol dispatcher
   */
--- 1,4 ----
! /* $XConsortium: dispatch.c,v 1.11 92/05/12 18:08:05 gildea Exp $ */
  /*
   * protocol dispatcher
   */
***************
*** 23,31 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * $NCDId: @(#)dispatch.c,v 4.11 1991/07/09 14:09:07 lemke Exp $
-  *
   */
  
  #include	"FS.h"
--- 23,28 ----
***************
*** 182,187 ****
--- 179,186 ----
  	client->swapped = TRUE;
  	SwapConnClientPrefix(prefix);
      }
+     client->major_version = prefix->major_version;
+     client->minor_version = prefix->minor_version;
      stuff->reqType = 2;
      stuff->length += (prefix->auth_len >> 2);
      if (client->swapped) {
***************
*** 249,255 ****
  	return FSBadAlloc;
      }
      csp.status = auth_accept;
!     csp.major_version = FS_PROTOCOL;
      csp.minor_version = FS_PROTOCOL_MINOR;
      csp.num_alternates = num_alts;
      csp.alternate_len = altlen;
--- 248,258 ----
  	return FSBadAlloc;
      }
      csp.status = auth_accept;
!     if (client->major_version == 1)
! 	/* we implement backwards compatibility for version 1.0 */
! 	csp.major_version = client->major_version;
!     else
! 	csp.major_version = FS_PROTOCOL;
      csp.minor_version = FS_PROTOCOL_MINOR;
      csp.num_alternates = num_alts;
      csp.alternate_len = altlen;
***************
*** 312,317 ****
--- 315,321 ----
      case FSBadFont:
      case FSBadAccessContext:
      case FSBadIDChoice:
+     case FSBadEventMask:
  	if (client->swapped)
  	    SwapLongs((long *) data, 1);
  	extralen = sizeof(Font);
***************
*** 711,723 ****
      }
      if (stuff->format_hint != 0 &&
  	    stuff->format_hint & ~ALL_FORMAT_BITS) {
! 	SendErrToClient(client, FSBadFormat,
! 			(pointer) &stuff->format_hint);
  	return FSBadFormat;
      }
      if (stuff->format_mask & ~ALL_FORMAT_MASK_BITS) {
! 	SendErrToClient(client, FSBadFormat,
! 			(pointer) &stuff->format_mask);
  	return FSBadFormat;
      }
      err = OpenFont(client, stuff->fid, stuff->format_hint, stuff->format_mask,
--- 715,725 ----
      }
      if (stuff->format_hint != 0 &&
  	    stuff->format_hint & ~ALL_FORMAT_BITS) {
! 	SendErrToClient(client, FSBadFormat, (pointer) &stuff->format_hint);
  	return FSBadFormat;
      }
      if (stuff->format_mask & ~ALL_FORMAT_MASK_BITS) {
! 	SendErrToClient(client, FSBadFormat, (pointer) &stuff->format_mask);
  	return FSBadFormat;
      }
      err = OpenFont(client, stuff->fid, stuff->format_hint, stuff->format_mask,
***************
*** 752,762 ****
      reply.sequenceNumber = client->sequence;
  
      /* get the header */
!     err = LoadFontHeader(&cfp->font->info, &reply.header, &prop_info);
  
!     if (err != Successful) {
! 	SendErrToClient(client, FontToFSError(err), (pointer) NULL);
  	return err;
      }
      lendata = sizeof(fsPropInfo) +
  	prop_info->num_offsets * sizeof(fsPropOffset) +
--- 754,775 ----
      reply.sequenceNumber = client->sequence;
  
      /* get the header */
!     err = LoadXFontInfo(client, &cfp->font->info, &reply.header, &prop_info);
  
!     switch (err)
!     {
!     case Successful:
! 	break;
!     case AllocError:
! 	SendErrToClient(client, FSBadAlloc, (pointer) 0);
  	return err;
+ 	break;
+     default:
+ 	ErrorF("ProcQueryXInfo: unexpected return val %d from LoadXFontInfo",
+ 	       err);
+ 	SendErrToClient(client, FSBadImplementation, (pointer) 0);
+ 	return err;
+ 	break;
      }
      lendata = sizeof(fsPropInfo) +
  	prop_info->num_offsets * sizeof(fsPropOffset) +
*** /tmp/da13472	Fri May 15 12:03:13 1992
--- fonts/server/difs/fontinfo.c	Tue May 12 18:08:05 1992
***************
*** 1,4 ****
! /* $XConsortium: fontinfo.c,v 1.7 91/07/25 12:24:51 keith Exp $ */
  /*
   * font data query
   */
--- 1,4 ----
! /* $XConsortium: fontinfo.c,v 1.8 92/05/12 18:08:08 gildea Exp $ */
  /*
   * font data query
   */
***************
*** 23,31 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)fontinfo.c	4.1	5/2/91
-  *
   */
  
  #include        "FS.h"
--- 23,28 ----
***************
*** 132,138 ****
  
  
  int
! LoadFontHeader(pinfo, hdr, pi)
      FontInfoPtr pinfo;
      fsFontHeader *hdr;
      fsPropInfo **pi;
--- 129,136 ----
  
  
  int
! LoadXFontInfo(client, pinfo, hdr, pi)
!     ClientPtr client;		/* for client version info */
      FontInfoPtr pinfo;
      fsFontHeader *hdr;
      fsPropInfo **pi;
***************
*** 147,158 ****
  
      if (pinfo->inkInside)
  	hdr->flags |= FontInfoInkInside;
!     hdr->char_range.min_char.low = pinfo->firstCol;
!     hdr->char_range.min_char.high = pinfo->firstRow;
!     hdr->char_range.max_char.low = pinfo->lastCol;
!     hdr->char_range.max_char.high = pinfo->lastRow;
!     hdr->default_char.low = pinfo->defaultCh & 0xff;
!     hdr->default_char.high = pinfo->defaultCh >> 8;
  
      CopyCharInfo(&pinfo->ink_minbounds, &hdr->min_bounds);
      CopyCharInfo(&pinfo->ink_maxbounds, &hdr->max_bounds);
--- 145,165 ----
  
      if (pinfo->inkInside)
  	hdr->flags |= FontInfoInkInside;
!     if (client->major_version > 1) {
! 	hdr->char_range.min_char.low = pinfo->firstCol;
! 	hdr->char_range.min_char.high = pinfo->firstRow;
! 	hdr->char_range.max_char.low = pinfo->lastCol;
! 	hdr->char_range.max_char.high = pinfo->lastRow;
! 	hdr->default_char.low = pinfo->defaultCh & 0xff;
! 	hdr->default_char.high = pinfo->defaultCh >> 8;
!     } else {
! 	hdr->char_range.min_char.high = pinfo->firstCol;
! 	hdr->char_range.min_char.low = pinfo->firstRow;
! 	hdr->char_range.max_char.high = pinfo->lastCol;
! 	hdr->char_range.max_char.low = pinfo->lastRow;
! 	hdr->default_char.high = pinfo->defaultCh & 0xff;
! 	hdr->default_char.low = pinfo->defaultCh >> 8;
!     }
  
      CopyCharInfo(&pinfo->ink_minbounds, &hdr->min_bounds);
      CopyCharInfo(&pinfo->ink_maxbounds, &hdr->max_bounds);
***************
*** 233,238 ****
--- 240,265 ----
      }
  }
  
+ /*
+  * provide backward compatibility with version 1, which had
+  * the bytes of char2b backwards
+  */
+ static void
+ swap_char2b (values, number)
+     fsChar2b *values;
+     int number;
+ {
+     fsChar2b temp;
+     int i;
+ 
+     for (i = 0; i < number; i++) {
+ 	temp.low = ((fsChar2b_version1 *)values)->low;
+ 	temp.high = ((fsChar2b_version1 *)values)->high;
+ 	*values++ = temp;
+     }
+ }
+ 
+ 
  static Bool
  do_query_extents(client, c)
      ClientPtr   client;
***************
*** 244,250 ****
      fsCharInfo *extents;
      fsQueryXExtents8Reply reply;
  
!     err = (*c->pfont->get_extents) ((pointer) c->client, c->pfont,
  		     c->flags, c->nranges, c->range, &num_extents, &extents);
      if (err == Suspended) {
  	if (!c->slept) {
--- 271,277 ----
      fsCharInfo *extents;
      fsQueryXExtents8Reply reply;
  
!     err = GetExtents (c->client, c->pfont,
  		     c->flags, c->nranges, c->range, &num_extents, &extents);
      if (err == Suspended) {
  	if (!c->slept) {
***************
*** 288,293 ****
--- 315,323 ----
      fsRange    *fixed_range;
      Bool        all_glyphs = FALSE;
  
+     if (item_size == 2  &&  client->major_version == 1)
+ 	swap_char2b (range_data, nranges);
+ 
      fixed_range = build_range(range_flag, range_data, item_size,
  			      &nranges, &all_glyphs);
  
***************
*** 322,328 ****
      fsQueryXBitmaps8Reply reply;
      int		freedata;
  
!     err = (*c->pfont->get_bitmaps) ((pointer) c->client, c->pfont, c->format,
  				    c->flags, c->nranges, c->range,
  			     &data_size, &num_glyphs, &offsets, &glyph_data, &freedata);
  
--- 352,358 ----
      fsQueryXBitmaps8Reply reply;
      int		freedata;
  
!     err = GetBitmaps (c->client, c->pfont, c->format,
  				    c->flags, c->nranges, c->range,
  			     &data_size, &num_glyphs, &offsets, &glyph_data, &freedata);
  
***************
*** 375,380 ****
--- 405,413 ----
      QBclosurePtr c;
      fsRange    *fixed_range;
      Bool        all_glyphs = FALSE;
+ 
+     if (item_size == 2  &&  client->major_version == 1)
+ 	swap_char2b (range_data, nranges);
  
      fixed_range = build_range(range_flag, range_data, item_size,
  			      &nranges, &all_glyphs);
*** /tmp/da13491	Fri May 15 12:03:15 1992
--- fonts/server/difs/fonts.c	Wed May 13 15:49:51 1992
***************
*** 1,4 ****
! /* $XConsortium: fonts.c,v 1.10 92/03/17 18:55:15 eswu Exp $ */
  /*
   * font control
   */
--- 1,4 ----
! /* $XConsortium: fonts.c,v 1.12 92/05/13 15:49:41 gildea Exp $ */
  /*
   * font control
   */
***************
*** 23,31 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * $NCDId: @(#)fonts.c,v 4.14 1991/06/27 19:01:42 lemke Exp $
-  *
   */
  
  #include        "FS.h"
--- 23,28 ----
***************
*** 848,853 ****
--- 845,853 ----
      return FSSuccess;
  }
  
+ static int padlength[4] = {0, 3, 2, 1};
+ static char padding[3];
+ 
  do_list_fonts_with_info(client, c)
      ClientPtr   client;
      LFWXIclosurePtr c;
***************
*** 963,969 ****
  		name = c->savedName;
  		namelen = strlen(name);
  	    }
! 	    err = LoadFontHeader(pFontInfo, &hdr, &prop_info);
  	    if (err != Successful)
  		break;
  	    lenpropdata = sizeof(fsPropInfo) +
--- 963,969 ----
  		name = c->savedName;
  		namelen = strlen(name);
  	    }
! 	    err = LoadXFontInfo(client, pFontInfo, &hdr, &prop_info);
  	    if (err != Successful)
  		break;
  	    lenpropdata = sizeof(fsPropInfo) +
***************
*** 972,978 ****
  
  	    reply->type = FS_Reply;
  	    reply->length =
! 		(sizeof(fsListFontsWithXInfoReply) + sizeof(fsFontHeader) +
  		 lenpropdata + namelen + 3) >> 2;
  	    reply->sequenceNumber = client->sequence;
  	    reply->nameLength = namelen;
--- 972,978 ----
  
  	    reply->type = FS_Reply;
  	    reply->length =
! 		(sizeof(fsListFontsWithXInfoReply) +
  		 lenpropdata + namelen + 3) >> 2;
  	    reply->sequenceNumber = client->sequence;
  	    reply->nameLength = namelen;
***************
*** 979,993 ****
  	    reply->nReplies = numFonts;
  	    reply->header = hdr;
  	    WriteReplyToClient(client, sizeof(fsListFontsWithXInfoReply), reply);
- 	    (void) WriteToClient(client, namelen, name);
  	    if (client->swapped)
  		SwapPropInfo(prop_info);
! 	    (void) WriteToClient(client, lenpropdata, (char *) prop_info);
  	    if (pFontInfo == &fontInfo) {
  		fsfree(fontInfo.props);
  		fsfree(fontInfo.isStringProp);
  	    }
  	    fsfree(prop_info);
  	    --c->current.max_names;
  	    if (c->current.max_names < 0)
  		abort();
--- 979,1003 ----
  	    reply->nReplies = numFonts;
  	    reply->header = hdr;
  	    WriteReplyToClient(client, sizeof(fsListFontsWithXInfoReply), reply);
  	    if (client->swapped)
  		SwapPropInfo(prop_info);
! 	    if (client->major_version > 1)
! 	    {
! 		(void)WriteToClientUnpadded(client, lenpropdata, (char *) prop_info);
! 		(void)WriteToClientUnpadded(client, namelen, name);
! 		(void)WriteToClientUnpadded(client,
! 					    padlength[(lenpropdata+namelen)&3],
! 					    padding);
! 	    } else {
! 		(void) WriteToClient(client, namelen, name);
! 		(void) WriteToClient(client, lenpropdata, (char *) prop_info);
! 	    }
  	    if (pFontInfo == &fontInfo) {
  		fsfree(fontInfo.props);
  		fsfree(fontInfo.isStringProp);
  	    }
  	    fsfree(prop_info);
+ 
  	    --c->current.max_names;
  	    if (c->current.max_names < 0)
  		abort();
***************
*** 994,1016 ****
  	}
      }
  
      if (err == Successful) {
! 	reply = c->reply;
! 	length = sizeof(fsListFontsWithXInfoReply);
  	if (c->length < length) {
! 	    reply = (fsListFontsWithXInfoReply *) fsrealloc(c->reply, length);
! 	    if (reply) {
! 		c->reply = reply;
  		c->length = length;
  	    } else
  		err = AllocError;
  	}
  	if (err == Successful) {
! 	    bzero((char *) reply, sizeof(fsListFontsWithXInfoReply));
! 	    reply->type = FS_Reply;
! 	    reply->sequenceNumber = client->sequence;
! 	    reply->length = sizeof(fsListFontsWithXInfoReply) >> 2;
! 	    WriteReplyToClient(client, length, reply);
  	}
      }
      if (err != Successful)
--- 1004,1034 ----
  	}
      }
  
+     /*
+      * send the final reply
+      */
      if (err == Successful) {
! 	fsGenericReply *final_reply;
! 
! 	final_reply = (fsGenericReply *)c->reply;
! 	if (client->major_version > 1)
! 	    length = sizeof(fsGenericReply);
! 	else
! 	    length = sizeof(fsListFontsWithXInfoReply);
  	if (c->length < length) {
! 	    final_reply = (fsGenericReply *) fsrealloc(c->reply, length);
! 	    if (final_reply) {
! 		c->reply = (fsListFontsWithXInfoReply *)final_reply;
  		c->length = length;
  	    } else
  		err = AllocError;
  	}
  	if (err == Successful) {
! 	    final_reply->type = FS_Reply;
! 	    final_reply->data1 = 0; /* notes that this is final */
! 	    final_reply->sequenceNumber = client->sequence;
! 	    final_reply->length = length >> 2;
! 	    WriteReplyToClient(client, length, final_reply);
  	}
      }
      if (err != Successful)
*** /dev/null	Fri May 15 12:02:40 1992
--- fonts/server/difs/charinfo.c	Fri May 15 12:01:13 1992
***************
*** 0 ****
--- 1,595 ----
+ /* $XConsortium: charinfo.c,v 1.5 92/05/15 12:01:05 gildea Exp $ */
+ /*
+  * Copyright 1990, 1991 Network Computing Devices;
+  * Portions Copyright 1987 by Digital Equipment Corporation and the
+  * Massachusetts Institute of Technology
+  *
+  * Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the names of Network Computing Devices, Digital
+  * or MIT not be used in advertising or publicity pertaining to distribution
+  * of the software without specific, written prior permission.
+  *
+  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
+  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
+  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
+  * DIGITAL OR MIT BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
+  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+  * THIS SOFTWARE.
+  */
+ /*
+  * Defines GetExtents() and GetBitmaps(), which are
+  * called from routines in fontinfo.c.
+  * This file was once on the other side of
+  * the font library interface as util/fsfuncs.c.
+  */
+ 
+ #include <X11/Xos.h>
+ #include "misc.h"
+ #include "fontstruct.h"
+ #include "clientstr.h"
+ #define FSMD_H
+ #include "FSproto.h"
+ 
+ #define GLWIDTHBYTESPADDED(bits,nbytes) \
+ 	((nbytes) == 1 ? (((bits)+7)>>3)        /* pad to 1 byte */ \
+ 	:(nbytes) == 2 ? ((((bits)+15)>>3)&~1)  /* pad to 2 bytes */ \
+ 	:(nbytes) == 4 ? ((((bits)+31)>>3)&~3)  /* pad to 4 bytes */ \
+ 	:(nbytes) == 8 ? ((((bits)+63)>>3)&~7)  /* pad to 8 bytes */ \
+ 	: 0)
+ 
+ #define GLYPH_SIZE(ch, nbytes)          \
+ 	GLWIDTHBYTESPADDED((ch)->metrics.rightSideBearing - \
+ 			(ch)->metrics.leftSideBearing, (nbytes))
+ 
+ #define n2dChars(pfi)   (((pfi)->lastRow - (pfi)->firstRow + 1) * \
+                          ((pfi)->lastCol - (pfi)->firstCol + 1))
+ 
+ static CharInfoRec  junkDefault;
+ 
+ static int
+ getCharInfos (pfont, num_ranges, range, ink_metrics, nump, retp)
+     FontPtr	pfont;
+     int		num_ranges;
+     fsRange	*range;
+     Bool	ink_metrics;
+     int		*nump;		/* return */
+     CharInfoPtr	**retp;		/* return */
+ {
+     CharInfoPtr	*xchars, *xci;
+     int		nchars;
+     FontInfoPtr pinfo = &pfont->info;
+     int		r, c;
+     unsigned char   ch[2];
+     int         firstCol = pinfo->firstCol;
+     int         firstRow = pinfo->firstRow;
+     int         lastRow = pinfo->lastRow;
+     int         lastCol = pinfo->lastCol;
+     int		minCol, maxCol;
+     int         num_cols = lastCol - firstCol + 1;
+     fsRange	local_range, *rp;
+     int		i;
+     FontEncoding    encoding;
+     int		err;
+     unsigned long   glyphCount;
+     unsigned short  defaultCh;
+     CharInfoPtr	    defaultPtr;
+     int (*metrics_func) ();
+     
+     /*
+      * compute nchars
+      */
+     if (num_ranges == 0) {
+ 	if (lastRow)
+ 	    nchars = n2dChars(pinfo);
+ 	else
+ 	    nchars = lastCol - firstCol + 1;
+ 	local_range.min_char.low = firstCol;
+ 	local_range.min_char.high = firstRow;
+ 	local_range.max_char.low = lastCol;
+ 	local_range.max_char.high = lastRow;
+ 	range = &local_range;
+ 	num_ranges = 1;
+     } else {
+ 	nchars = 0;
+ 	for (i = 0, rp = range; i < num_ranges; i++, rp++) {
+ 	    if (rp->min_char.high > rp->max_char.high)
+ 		return BadCharRange;
+ 	    if (rp->min_char.high == rp->max_char.high)
+ 	    {
+ 		if (rp->min_char.low > rp->max_char.low)
+ 		    return BadCharRange;
+ 		nchars += rp->max_char.low - rp->min_char.low + 1;
+ 	    }
+ 	    else
+ 	    {
+ 		nchars += lastRow - rp->min_char.low + 1;
+ 		nchars += (rp->max_char.high - rp->min_char.high - 1) * num_cols;
+ 		nchars += rp->max_char.low - firstRow + 1;
+ 	    }
+ 	}
+     }
+ 
+     xchars = (CharInfoPtr *) fsalloc (sizeof (CharInfoPtr) * nchars);
+     if (!xchars)
+ 	return AllocError;
+ 
+     if (ink_metrics)
+ 	metrics_func = pfont->get_metrics;
+     else
+ 	metrics_func = pfont->get_glyphs;
+ 
+     xci = xchars;
+     encoding = Linear16Bit;
+     if (lastRow)
+ 	encoding = TwoD16Bit;
+     defaultCh = pinfo->defaultCh;
+     ch[0] = defaultCh >> 8;
+     ch[1] = defaultCh & 0xff;
+     /* get the default character */
+     (*metrics_func) (pfont, 1, ch, encoding,
+ 			  &glyphCount, &defaultPtr);
+     if (glyphCount != 1)
+ 	defaultPtr = 0;
+     
+     /* for each range, get each character individually, undoing the
+      default character substitution so we get zero metrics for
+      non-existent characters. */
+     for (i = 0, rp = range; i < num_ranges; i++, rp++) {
+ 	for (r = rp->min_char.high; r <= rp->max_char.high; r++)
+ 	{
+ 	    minCol = firstCol;
+ 	    if (r == rp->min_char.high)
+ 		minCol = rp->min_char.low;
+ 	    maxCol = lastCol;
+ 	    if (r == rp->max_char.high)
+ 		maxCol = rp->max_char.low;
+ 	    for (c = minCol; c <= maxCol; c++) {
+ 		ch[0] = r;
+ 		ch[1] = c;
+ 		err = (*metrics_func) (pfont, 1, ch, encoding,
+ 					    &glyphCount, xci);
+ 		if (err != Successful)
+ 		{
+ 		    fsfree (xchars);
+ 		    return err;
+ 		}
+ 		if (glyphCount != 1 || 
+ 		    *xci == defaultPtr && defaultCh != ((r<<8)+c))
+ 		    *xci = &junkDefault;
+ 		xci++;
+ 	    }
+ 	}
+     }
+     *retp = xchars;
+     *nump = nchars;
+     return Successful;
+ }
+ 
+ int
+ GetExtents(client, pfont, flags, num_ranges, range, num_extents, data)
+     ClientPtr     client;
+     FontPtr     pfont;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     unsigned long *num_extents;	/* return */
+     fsCharInfo **data;		/* return */
+ {
+     unsigned long size;
+     fsCharInfo *ci,
+     *pci;
+     fsRange    *rp;
+     CharInfoPtr	*xchars, *xcharsFree, xci;
+     int		nchars;
+     int		err;
+     
+     if (flags & LoadAll)
+ 	num_ranges = 0;
+     err = getCharInfos (pfont, num_ranges, range,
+ 			client->major_version > 1 ? TRUE : FALSE,
+ 			&nchars, &xchars);
+     if (err != Successful)
+ 	return err;
+     
+     size = sizeof(fsCharInfo) * nchars;
+     pci = ci = (fsCharInfo *) fsalloc(size);
+     if (!ci) {
+ 	fsfree (xchars);
+ 	return AllocError;
+     }
+     
+     *num_extents = nchars;
+     xcharsFree = xchars;
+     
+     while (nchars--) {
+ 	xci = *xchars++;
+ 	pci->ascent = xci->metrics.ascent;
+ 	pci->descent = xci->metrics.descent;
+ 	pci->left = xci->metrics.leftSideBearing;
+ 	pci->right = xci->metrics.rightSideBearing;
+ 	pci->width = xci->metrics.characterWidth;
+ 	pci->attributes = 0;
+ 	pci++;
+     }
+     
+     fsfree (xcharsFree);
+     
+     *data = ci;
+     
+     return Successful;
+ }
+ 
+ static int
+ packGlyphs (client, pfont, format, flags, num_ranges, range, tsize, num_glyphs,
+ 		offsets, data, freeData)
+     ClientPtr   client;
+     FontPtr     pfont;
+     int         format;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     int        *tsize;
+     unsigned long *num_glyphs;
+     fsOffset  **offsets;
+     pointer    *data;
+     int		*freeData;
+ {
+     unsigned long start,
+     end;
+     int         i;
+     fsOffset	*lengths, *l;
+     unsigned long size = 0;
+     pointer     gdata,
+     gd;
+     long        ch;
+     int         bitorder, byteorder, scanlinepad, scanlineunit, mappad;
+     int		height, dstbpr, charsize;
+     int		dst_off, src_off;
+     Bool	contiguous, reformat;
+     fsRange    *rp = range;
+     int		nchars;
+     int         src_glyph_pad = pfont->glyph;
+     int         src_bit_order = pfont->bit;
+     int         src_byte_order = pfont->byte;
+     int         err;
+     int		max_ascent, max_descent;
+     int		min_left, max_right;
+     int		srcbpr;
+     int		lshift = 0, rshift = 0, dst_left_bytes = 0, src_left_bytes = 0;
+     unsigned char   *src;
+     unsigned char   *dst;
+     unsigned char   bits1, bits2;
+     int		    width;
+     int		    src_extra;
+     int		    dst_extra;
+     int		    r, w;
+     fsRange	allRange;
+     CharInfoPtr	*bitChars, *bitCharsFree, bitc;
+     CharInfoPtr	*inkChars, *inkCharsFree = 0, inkc;
+     FontInfoPtr	pinfo = &pfont->info;
+     xCharInfo	*bitm, *inkm;
+     
+     err = CheckFSFormat(format, (fsBitmapFormatMask) ~ 0,
+ 			&bitorder, &byteorder, &scanlineunit, &scanlinepad, &mappad);
+     
+     if (err != Successful)
+ 	return err;
+     
+     if (flags & LoadAll)
+ 	num_ranges = 0;
+     
+     err = getCharInfos (pfont, num_ranges, range, FALSE, &nchars, &bitCharsFree);
+     
+     if (err != Successful)
+ 	return err;
+     
+     /* compute dstbpr for padded out fonts */
+     reformat = bitorder != src_bit_order || byteorder != src_byte_order;
+ 
+     /* we need the ink metrics when shrink-wrapping a TE font (sigh),
+      * but only for protocol version > 1 */
+     if (mappad != BitmapFormatImageRectMax &&
+ 	pinfo->inkMetrics &&
+ 	client->major_version > 1)
+     {
+ 	err = getCharInfos (pfont, num_ranges, range, TRUE, &nchars, &inkCharsFree);
+ 	if (err != Successful)
+ 	{
+ 	    fsfree (bitCharsFree);
+ 	    return err;
+ 	}
+ 	reformat = TRUE;
+     }
+ 
+     /* get space for glyph offsets */
+     lengths = (fsOffset *) fsalloc(sizeof(fsOffset) * nchars);
+     if (!lengths) {
+ 	fsfree (bitCharsFree);
+ 	fsfree (inkCharsFree);
+ 	return AllocError;
+     }
+     
+     switch (mappad)
+     {
+     case BitmapFormatImageRectMax:
+ 	max_ascent = FONT_MAX_ASCENT(pinfo);
+ 	max_descent = FONT_MAX_DESCENT(pinfo);
+ 	height = max_ascent + max_descent;
+ 	/* do font ascent and font descent match bitmap bounds ? */
+ 	if (height != pinfo->minbounds.ascent + pinfo->minbounds.descent)
+ 	    reformat = TRUE;
+ 	/* fall through */
+     case BitmapFormatImageRectMaxWidth:
+ 	min_left = FONT_MIN_LEFT(pinfo);
+ 	max_right = FONT_MAX_RIGHT(pinfo);
+ 	if (min_left != pinfo->maxbounds.leftSideBearing)
+ 	    reformat = TRUE;
+ 	if (max_right != pinfo->maxbounds.rightSideBearing)
+ 	    reformat = TRUE;
+ 	dstbpr = GLWIDTHBYTESPADDED(max_right - min_left, scanlinepad);
+ 	break;
+     case BitmapFormatImageRectMin:
+ 	break;
+     }
+     if (mappad == BitmapFormatImageRectMax)
+ 	charsize = dstbpr * height;
+     size = 0;
+     gdata = 0;
+     contiguous = TRUE;
+     l = lengths;
+     inkChars = inkCharsFree;
+     bitChars = bitCharsFree;
+     for (i = 0; i < nchars; i++)
+     {
+     	inkc = bitc = *bitChars++;
+ 	/* when ink metrics != bitmap metrics, use ink metrics */
+ 	if (inkChars)
+ 	    inkc = *inkChars++;
+     	l->position = size;
+     	if (bitc && bitc->bits) {
+ 	    if (!gdata)
+ 		gdata = (pointer) bitc->bits;
+ 	    if ((char *) gdata + size != bitc->bits)
+ 		contiguous = FALSE;
+ 	    if (mappad == BitmapFormatImageRectMin)
+ 		dstbpr = GLYPH_SIZE(inkc, scanlinepad);
+ 	    if (mappad != BitmapFormatImageRectMax)
+ 	    {
+ 		height = inkc->metrics.ascent + inkc->metrics.descent;
+ 		charsize = height * dstbpr;
+ 	    }
+ 	    l->length = charsize;
+ 	    size += charsize;
+ 	}
+ 	else
+ 	    l->length = 0;
+ 	l++;
+     }
+     if (contiguous && !reformat)
+     {
+ 	*num_glyphs = nchars;
+ 	*freeData = FALSE;
+ 	*data = gdata;
+ 	*tsize = size;
+ 	*offsets = lengths;
+ 	fsfree (bitCharsFree);
+ 	fsfree (inkCharsFree);
+ 	return Successful;
+     }
+     if (size)
+     {
+ 	gdata = (pointer) fsalloc(size);
+ 	if (!gdata) {
+ 	    fsfree (bitCharsFree);
+ 	    fsfree (inkCharsFree);
+ 	    fsfree (lengths);
+ 	    return AllocError;
+ 	}
+ 	bzero ((char *) gdata, size);
+     }
+     else
+ 	gdata = NULL;
+     
+     *freeData = TRUE;
+     l = lengths;
+     gd = gdata;
+     
+     /* finally do the work */
+     bitChars = bitCharsFree;
+     inkChars = inkCharsFree;
+     for (i = 0; i < nchars; i++, l++) 
+     {
+ 	inkc = bitc = *bitChars++;
+ 	if (inkChars)
+ 	    inkc = *inkChars++;
+ 
+ 	/* ignore missing chars */
+ 	if (l->length == 0)
+ 	    continue;
+ 	
+ 	bitm = &bitc->metrics;
+ 	inkm = &inkc->metrics;
+ 
+ 	/* start address for the destination of bits for this char */
+ 
+ 	dst = gd;
+ 
+ 	/* adjust destination and calculate shift offsets */
+ 	switch (mappad) {
+ 	case BitmapFormatImageRectMax:
+ 	    /* leave the first padded rows blank */
+ 	    dst += dstbpr * (max_ascent - inkm->ascent);
+ 	    /* fall thru */
+ 	case BitmapFormatImageRectMaxWidth:
+ 	    dst_off = inkm->leftSideBearing - min_left;
+ 	    break;
+ 	case BitmapFormatImageRectMin:
+ 	    dst_off = 0;
+ 	    dstbpr = GLYPH_SIZE(inkc, scanlinepad);
+ 	    break;
+ 	}
+ 
+ 	srcbpr = GLYPH_SIZE (bitc, src_glyph_pad);
+ 	src = (unsigned char *) bitc->bits;
+ 
+ 	/* adjust source */
+ 	src_off = 0;
+ 	if (inkm != bitm)
+ 	{
+ 	    src += (bitm->ascent - inkm->ascent) * srcbpr;
+ 	    src_off = inkm->leftSideBearing - bitm->leftSideBearing;
+ 	}
+ 
+ 	dst_left_bytes = dst_off >> 3;
+ 	dst_off &= 7;
+ 	src_left_bytes = src_off >> 3;
+ 	src_off &= 7;
+ 
+ 	/* minimum of source/dest bytes per row */
+ 	width = srcbpr;
+ 	if (srcbpr > dstbpr)
+ 	    width = dstbpr;
+ 	/* extra bytes in source and dest for padding */
+ 	src_extra = srcbpr - width - src_left_bytes;
+ 	dst_extra = dstbpr - width - dst_left_bytes;
+ 	
+ #define MSBBitLeft(b,c)	((b) << (c))
+ #define MSBBitRight(b,c)	((b) >> (c))
+ #define LSBBitLeft(b,c)	((b) >> (c))
+ #define LSBBitRight(b,c)	((b) << (c))
+ 
+ 	if (dst_off == src_off)
+ 	{
+ 	    if (srcbpr == dstbpr && src_left_bytes == dst_left_bytes)
+ 	    {
+ 		r = (bitm->ascent + bitm->descent) * width;
+ 		bcopy (src, dst, r);
+ 		dst += r;
+ 	    }
+ 	    else
+ 	    {
+ 		for (r = bitm->ascent + bitm->descent; r; r--)
+ 		{
+ 		    dst += dst_left_bytes;
+ 		    src += src_left_bytes;
+ 		    for (w = width; w; w--)
+ 			*dst++ = *src++;
+ 		    dst += dst_extra;
+ 		    src += src_extra;
+ 		}
+ 	    }
+ 	}
+ 	else
+ 	{
+ 	    if (dst_off > src_off)
+ 	    {
+ 	    	rshift = dst_off - src_off;
+ 	    	lshift = 8 - rshift;
+ 	    }
+ 	    else
+ 	    {
+ 	    	lshift = src_off - dst_off;
+ 	    	rshift = 8 - lshift;
+ 		/* run the loop one fewer time if necessary */
+ 		if (src_extra <= dst_extra)
+ 		{
+ 		    dst_extra++;
+ 		    width--;
+ 		}
+ 		else
+ 		    src_extra--;
+ 	    }
+ 	    
+ 	    for (r = bitm->ascent + bitm->descent; r; r--)
+ 	    {
+ 		dst += dst_left_bytes;
+ 		src += src_left_bytes;
+ 		bits2 = 0;
+ 		/* fetch first part of source when necessary */
+ 		if (dst_off < src_off)
+ 		    bits2 = *src++;
+ 		/*
+  		 * XXX I bet this does not work when
+ 		 * src_bit_order != src_byte_order && scanlineunit > 1
+ 		 */
+ 		for (w = width; w; w--)
+ 		{
+ 		    bits1 = *src++;
+ 		    if (src_bit_order == MSBFirst)
+ 		    {
+ 			*dst++ = MSBBitRight(bits1, rshift) |
+ 				 MSBBitLeft (bits2, lshift);
+ 		    }
+ 		    else
+ 		    {
+ 			*dst++ = LSBBitRight(bits1, rshift) |
+ 				 LSBBitLeft (bits2, lshift);
+ 		    }
+ 		    bits2 = bits1;
+ 		}
+ 		/* get the last few bits if we have a place to store them */
+ 		if (dst_extra > 0)
+ 		{
+ 		    if (src_bit_order == MSBFirst)
+ 			*dst = MSBBitLeft (bits2, lshift);
+ 		    else
+ 			*dst = LSBBitLeft (bits2, lshift);
+ 		}
+ 		dst += dst_extra;
+ 		src += src_extra;
+ 	    }
+ 	}
+ 	/* skip the amount we just filled in */
+ 	gd += l->length;
+     }
+     
+     
+     /* now do the bit, byte, word swapping */
+     if (bitorder != src_bit_order)
+ 	BitOrderInvert(gdata, size);
+     if (byteorder != src_byte_order) 
+     {
+ 	if (scanlineunit == 2)
+ 	    TwoByteSwap(gdata, size);
+ 	else if (scanlineunit == 4)
+ 	    FourByteSwap(gdata, size);
+     }
+     fsfree (bitCharsFree);
+     fsfree (inkCharsFree);
+     *num_glyphs = nchars;
+     *data = gdata;
+     *tsize = size;
+     *offsets = lengths;
+     
+     return Successful;
+ }
+ 
+ /* ARGSUSED */
+ int
+ GetBitmaps(client, pfont, format, flags, num_ranges, range,
+ 		 size, num_glyphs, offsets, data, freeData)
+     ClientPtr     client;
+     FontPtr     pfont;
+     fsBitmapFormat format;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     int        *size;
+     unsigned long *num_glyphs;
+     fsOffset  **offsets;
+     pointer    *data;
+     int		*freeData;
+ {
+     assert(pfont);
+ 
+     *size = 0;
+     *data = (pointer) 0;
+     return packGlyphs (client, pfont, format, flags,
+ 			      num_ranges, range, size, num_glyphs,
+ 			      offsets, data, freeData);
+ }
*** /tmp/da13531	Fri May 15 12:03:19 1992
--- fonts/server/os/io.c	Fri May 15 10:41:39 1992
***************
*** 1,7 ****
! /* $XConsortium: io.c,v 1.6 92/01/31 17:46:55 eswu Exp $ */
  /*
   * i/o functions
-  *
   */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
--- 1,6 ----
! /* $XConsortium: io.c,v 1.8 92/05/15 10:38:59 gildea Exp $ */
  /*
   * i/o functions
   */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
***************
*** 24,32 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)io.c	4.2	5/3/91
-  *
   */
  
  #include	<stdio.h>
--- 23,28 ----
***************
*** 323,333 ****
  static int  padlength[4] = {0, 3, 2, 1};
  
  int
! FlushClient(client, oc, extraBuf, extraCount)
      ClientPtr   client;
      OsCommPtr   oc;
-     char       *extraBuf;
-     int         extraCount;
  {
      ConnectionOutputPtr oco = oc->output;
      int         fd = oc->fd;
--- 319,327 ----
  static int  padlength[4] = {0, 3, 2, 1};
  
  int
! FlushClient(client, oc)
      ClientPtr   client;
      OsCommPtr   oc;
  {
      ConnectionOutputPtr oco = oc->output;
      int         fd = oc->fd;
***************
*** 334,340 ****
      struct iovec iov[3];
      char        padBuffer[3];
      long        written;
-     long        padsize;
      long        notWritten;
      long        todo;
  
--- 328,333 ----
***************
*** 341,348 ****
      if (!oco)
  	return 0;
      written = 0;
!     padsize = padlength[extraCount & 3];
!     notWritten = oco->count + extraCount + padsize;
      todo = notWritten;
      while (notWritten) {
  	long        before = written;
--- 334,340 ----
      if (!oco)
  	return 0;
      written = 0;
!     notWritten = oco->count;
      todo = notWritten;
      while (notWritten) {
  	long        before = written;
***************
*** 350,355 ****
--- 342,351 ----
  	int         i = 0;
  	long        len;
  
+ 	/* XXX - now that FlushClient doesn't take an extraBuffer
+ 	   argument, we don't really need the fancy writev code.
+ 	   */
+ 
  	/*-
  	 * You could be very general here and have "in" and "out" iovecs and
  	 * write a loop without using a macro, but what the heck.  This
***************
*** 380,387 ****
  	}
  
  	InsertIOV((char *) oco->buf, oco->count);
- 	InsertIOV(extraBuf, extraCount);
- 	InsertIOV(padBuffer, padsize);
  
  	errno = 0;
  	if ((len = writev(fd, iov, i)) >= 0) {
--- 376,381 ----
***************
*** 419,430 ****
  		oco->size = notWritten + OutputBufferSize;
  		oco->buf = obuf;
  	    }
- 	    if ((len = extraCount - written) > 0) {
- 		bcopy(extraBuf + written,
- 		      (char *) oco->buf + oco->count, len);
- 	    }
  	    oco->count = notWritten;
! 	    return extraCount;
  	} else {
  	    close(fd);
  	    MarkClientException(client);
--- 413,420 ----
  		oco->size = notWritten + OutputBufferSize;
  		oco->buf = obuf;
  	    }
  	    oco->count = notWritten;
! 	    return 0;
  	} else {
  	    close(fd);
  	    MarkClientException(client);
***************
*** 451,457 ****
      }
      oc->output = (ConnectionOutputPtr) NULL;
  
!     return extraCount;
  }
  
  void
--- 441,447 ----
      }
      oc->output = (ConnectionOutputPtr) NULL;
  
!     return 0;
  }
  
  void
***************
*** 484,503 ****
  		BITSET(OutputPending, oc->fd);
  		NewOutputPending = TRUE;
  	    } else {
! 		(void) FlushClient(client, oc, (char *) NULL, 0);
  	    }
  	}
      }
  }
  
! WriteToClient(client, count, buf)
      ClientPtr   client;
      int         count;
      char       *buf;
  {
      OsCommPtr   oc = (OsCommPtr) client->osPrivate;
      ConnectionOutputPtr oco = oc->output;
-     int         padBytes;
  
      if (!count)
  	return 0;
--- 474,497 ----
  		BITSET(OutputPending, oc->fd);
  		NewOutputPending = TRUE;
  	    } else {
! 		(void) FlushClient(client, oc);
  	    }
  	}
      }
  }
  
! /*
!  * returns number of bytes written
!  */
! static int
! write_to_client_internal(client, count, buf, padBytes)
      ClientPtr   client;
      int         count;
      char       *buf;
+     int         padBytes;
  {
      OsCommPtr   oc = (OsCommPtr) client->osPrivate;
      ConnectionOutputPtr oco = oc->output;
  
      if (!count)
  	return 0;
***************
*** 512,523 ****
  	}
  	oc->output = oco;
      }
-     padBytes = padlength[count & 3];
- 
      if (oco->count + count + padBytes > oco->size) {
  	BITCLEAR(OutputPending, oc->fd);
  	NewOutputPending = FALSE;
! 	return FlushClient(client, oc, buf, count);
      }
      NewOutputPending = TRUE;
      BITSET(OutputPending, oc->fd);
--- 506,519 ----
  	}
  	oc->output = oco;
      }
      if (oco->count + count + padBytes > oco->size) {
+ 	register int i;
+ 
  	BITCLEAR(OutputPending, oc->fd);
  	NewOutputPending = FALSE;
! 	i = FlushClient(client, oc);
! 	if (i < 0)
! 	    return i;
      }
      NewOutputPending = TRUE;
      BITSET(OutputPending, oc->fd);
***************
*** 525,530 ****
--- 521,542 ----
      oco->count += count + padBytes;
  
      return count;
+ }
+ 
+ WriteToClientUnpadded(client, count, buf)
+     ClientPtr   client;
+     int         count;
+     char       *buf;
+ {
+     write_to_client_internal(client, count, buf, 0);
+ }
+ 
+ WriteToClient(client, count, buf)
+     ClientPtr   client;
+     int         count;
+     char       *buf;
+ {
+      write_to_client_internal(client, count, buf, padlength[count & 3]);
  }
  
  static      ConnectionInputPtr
*** /tmp/da13550	Fri May 15 12:03:20 1992
--- fonts/server/os/connection.c	Fri May 15 10:41:45 1992
***************
*** 1,4 ****
! /* $XConsortium: connection.c,v 1.17 91/09/09 18:56:03 rws Exp $ */
  /*
   * handles connections
   */
--- 1,4 ----
! /* $XConsortium: connection.c,v 1.18 92/05/15 10:41:39 gildea Exp $ */
  /*
   * handles connections
   */
***************
*** 23,31 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * $NCDId: @(#)connection.c,v 4.10 1991/07/03 17:19:22 lemke Exp $
-  *
   */
  
  /* sorry, streams support not here yet */
--- 23,28 ----
***************
*** 471,477 ****
      OsCommPtr   oc = (OsCommPtr) client->osPrivate;
  
      if (oc->output && oc->output->count)
! 	FlushClient(client, oc, (char *) NULL, 0);
      ConnectionTranslation[oc->fd] = 0;
      close_fd(oc);
      client->osPrivate = (pointer) NULL;
--- 468,474 ----
      OsCommPtr   oc = (OsCommPtr) client->osPrivate;
  
      if (oc->output && oc->output->count)
! 	FlushClient(client, oc);
      ConnectionTranslation[oc->fd] = 0;
      close_fd(oc);
      client->osPrivate = (pointer) NULL;
