Path: news.crl.dec.com!pa.dec.com!nobody
Message-Id: <9202112055.AA17257@xenon.lcs.mit.edu>
To: fix-trackers@expo.lcs.mit.edu
Subject: (seq: 2354) Huge cfb diff, part 2 of 3
Date: Tue, 11 Feb 92 15:55:45 EST
From: Keith Packard <keith@expo.lcs.mit.edu>
Distribution: dec
X-Mailing-List: fix-trackers@expo.lcs.mit.edu
X-Disclaimer: This message originated from a mailing list outside of Digital.
Newsgroups: dec.mail.lists.x.fix-trackers
Approved: news@usenet.pa.dec.com


*** /tmp/,RCSt1a16196	Tue Feb 11 15:11:46 1992
--- server/ddx/cfb/cfbfillrct.c	Thu Dec 19 18:36:22 1991
***************
*** 16,22 ****
  purpose.  It is provided "as is" without express or implied warranty.
  */
  
! /* $XConsortium: cfbfillrct.c,v 5.13 90/05/15 18:40:19 keith Exp $ */
  
  #include "X.h"
  #include "Xmd.h"
--- 16,22 ----
  purpose.  It is provided "as is" without express or implied warranty.
  */
  
! /* $XConsortium: cfbfillrct.c,v 5.14 91/12/19 18:36:18 keith Exp $ */
  
  #include "X.h"
  #include "Xmd.h"
***************
*** 31,37 ****
  #include "cfbmskbits.h"
  #include "mergerop.h"
  
! #if PPW == 4
  extern void cfb8FillRectOpaqueStippled32();
  extern void cfb8FillRectTransparentStippled32();
  extern void cfb8FillRectStippledUnnatural();
--- 31,37 ----
  #include "cfbmskbits.h"
  #include "mergerop.h"
  
! #if PSZ == 8
  extern void cfb8FillRectOpaqueStippled32();
  extern void cfb8FillRectTransparentStippled32();
  extern void cfb8FillRectStippledUnnatural();
***************
*** 146,152 ****
  		BoxFill = cfbFillRectTile32General;
  	}
  	break;
! #if (PPW == 4)
      case FillStippled:
  	if (!((cfbPrivGCPtr) pGC->devPrivates[cfbGCPrivateIndex].ptr)->
  							pRotatedPixmap)
--- 146,152 ----
  		BoxFill = cfbFillRectTile32General;
  	}
  	break;
! #if PSZ == 8
      case FillStippled:
  	if (!((cfbPrivGCPtr) pGC->devPrivates[cfbGCPrivateIndex].ptr)->
  							pRotatedPixmap)
*** /tmp/,RCSt1a16215	Tue Feb 11 15:11:52 1992
--- server/ddx/cfb/cfbfillsp.c	Thu Dec 19 18:36:37 1991
***************
*** 50,56 ****
  
  ******************************************************************/
  
! /* $XConsortium: cfbfillsp.c,v 5.17 91/07/18 23:31:04 keith Exp $ */
  
  #include "X.h"
  #include "Xmd.h"
--- 50,56 ----
  
  ******************************************************************/
  
! /* $XConsortium: cfbfillsp.c,v 5.19 91/12/19 18:36:32 keith Exp $ */
  
  #include "X.h"
  #include "Xmd.h"
***************
*** 66,72 ****
  
  #include "mergerop.h"
  
! #if PPW == 4
  #include "cfb8bit.h"
  #endif
  
--- 66,72 ----
  
  #include "mergerop.h"
  
! #if PSZ == 8
  #include "cfb8bit.h"
  #endif
  
***************
*** 174,180 ****
      DEALLOCATE_LOCAL(pwidth);
  }
  
! #if PPW == 4
  
  void
  cfbUnnaturalStippleFS(pDrawable, pGC, nInit, pptInit, pwidthInit, fSorted)
--- 174,180 ----
      DEALLOCATE_LOCAL(pwidth);
  }
  
! #if PSZ == 8
  
  void
  cfbUnnaturalStippleFS(pDrawable, pGC, nInit, pptInit, pwidthInit, fSorted)
***************
*** 376,382 ****
  				/* next three parameters are post-clip */
      int			    n;		/* number of spans to fill */
      register DDXPointPtr    ppt;	/* pointer to list of start points */
!     register unsigned long  *pwidth;	/* pointer to list of n widths */
      int			    iline;	/* first line of tile to use */
      unsigned long	    *addrlBase;	/* pointer to start of bitmap */
      int			    nlwidth;	/* width in longwords of bitmap */
--- 376,382 ----
  				/* next three parameters are post-clip */
      int			    n;		/* number of spans to fill */
      register DDXPointPtr    ppt;	/* pointer to list of start points */
!     register int	    *pwidth;	/* pointer to list of n widths */
      int			    iline;	/* first line of tile to use */
      unsigned long	    *addrlBase;	/* pointer to start of bitmap */
      int			    nlwidth;	/* width in longwords of bitmap */
***************
*** 467,473 ****
  	iline = (ppt->y - ySrc) % stippleHeight;
  	x = ppt->x;
  	pdst = addrlBase + (ppt->y * nlwidth);
!         psrcS = (int *) pStipple->devPrivate.ptr + (iline * stwidth);
  
  	if (*pwidth)
  	{
--- 467,473 ----
  	iline = (ppt->y - ySrc) % stippleHeight;
  	x = ppt->x;
  	pdst = addrlBase + (ppt->y * nlwidth);
!         psrcS = (unsigned long *) pStipple->devPrivate.ptr + (iline * stwidth);
  
  	if (*pwidth)
  	{
***************
*** 475,482 ****
  	    while(width > 0)
  	    {
  	        int xtemp, tmpx;
! 		register unsigned int *ptemp;
! 		register int *pdsttmp;
  		/*
  		 *  Do a stripe through the stipple & destination w pixels
  		 *  wide.  w is not more than:
--- 475,482 ----
  	    while(width > 0)
  	    {
  	        int xtemp, tmpx;
! 		register unsigned long *ptemp;
! 		register unsigned long *pdsttmp;
  		/*
  		 *  Do a stripe through the stipple & destination w pixels
  		 *  wide.  w is not more than:
***************
*** 497,503 ****
  		w = min(w, 32 - (x & 0x1f));
  
  	        xtemp = (xrem & 0x1f);
! 	        ptemp = (unsigned int *)(psrcS + (xrem >> 5));
  		tmpx = x & PIM;
  		pdsttmp = pdst + (x>>PWSH);
  		switch ( pGC->fillStyle ) {
--- 497,503 ----
  		w = min(w, 32 - (x & 0x1f));
  
  	        xtemp = (xrem & 0x1f);
! 	        ptemp = (unsigned long *)(psrcS + (xrem >> 5));
  		tmpx = x & PIM;
  		pdsttmp = pdst + (x>>PWSH);
  		switch ( pGC->fillStyle ) {
***************
*** 530,538 ****
      DEALLOCATE_LOCAL(pwidthFree);
  }
  
! #endif /* PPW == 4 */
  
! #if PPW == 4
  
  void
  cfb8Stipple32FS (pDrawable, pGC, nInit, pptInit, pwidthInit, fSorted)
--- 530,538 ----
      DEALLOCATE_LOCAL(pwidthFree);
  }
  
! #endif /* PSZ == 8 */
  
! #if PSZ == 8
  
  void
  cfb8Stipple32FS (pDrawable, pGC, nInit, pptInit, pwidthInit, fSorted)
*** /tmp/,RCSt1a16234	Tue Feb 11 15:11:59 1992
--- server/ddx/cfb/cfbgc.c	Wed Feb  5 16:08:09 1992
***************
*** 22,28 ****
  
  ******************************************************************/
  
! /* $XConsortium: cfbgc.c,v 5.51 91/07/18 23:36:42 keith Exp $ */
  
  #include "X.h"
  #include "Xmd.h"
--- 22,28 ----
  
  ******************************************************************/
  
! /* $XConsortium: cfbgc.c,v 5.55 92/02/05 16:07:46 keith Exp $ */
  
  #include "X.h"
  #include "Xmd.h"
***************
*** 45,50 ****
--- 45,80 ----
  void cfbValidateGC(), cfbChangeGC(), cfbCopyGC(), cfbDestroyGC();
  void cfbChangeClip(), cfbDestroyClip(), cfbCopyClip();
  
+ #if PSZ == 8
+ # define useTEGlyphBlt  cfbTEGlyphBlt8
+ #else
+ # ifdef WriteFourBits
+ #  define useTEGlyphBlt	cfbImageGlyphBlt8
+ # else
+ #  define useTEGlyphBlt	cfbTEGlyphBlt
+ # endif
+ #endif
+ 
+ #ifdef WriteFourBits
+ # define useImageGlyphBlt	cfbImageGlyphBlt8
+ # define usePolyGlyphBlt	cfbPolyGlyphBlt8
+ #else
+ # define useImageGlyphBlt	miImageGlyphBlt
+ # define usePolyGlyphBlt	miPolyGlyphBlt
+ #endif
+ 
+ #ifdef FOUR_BIT_CODE
+ # define usePushPixels	cfbPushPixels8
+ #else
+ # define usePushPixels	mfbPushPixels
+ #endif
+ 
+ #ifdef PIXEL_ADDR
+ # define ZeroPolyArc	cfbZeroPolyArcSS8Copy
+ #else
+ # define ZeroPolyArc	miZeroPolyArc
+ #endif
+ 
  GCFuncs cfbGCFuncs = {
      cfbValidateGC,
      cfbChangeGC,
***************
*** 62,68 ****
      cfbCopyArea,
      cfbCopyPlane,
      cfbPolyPoint,
! #if PPW == 4
      cfb8LineSS1Rect,
      cfb8SegmentSS1Rect,
  #else
--- 92,98 ----
      cfbCopyArea,
      cfbCopyPlane,
      cfbPolyPoint,
! #ifdef PIXEL_ADDR
      cfb8LineSS1Rect,
      cfb8SegmentSS1Rect,
  #else
***************
*** 70,80 ****
      cfbSegmentSS,
  #endif
      miPolyRectangle,
! #if PPW == 4
!     cfbZeroPolyArcSS8Copy,
! #else
!     miZeroPolyArc,
! #endif
      cfbFillPoly1RectCopy,
      cfbPolyFillRect,
      cfbPolyFillArcSolidCopy,
--- 100,106 ----
      cfbSegmentSS,
  #endif
      miPolyRectangle,
!     ZeroPolyArc,
      cfbFillPoly1RectCopy,
      cfbPolyFillRect,
      cfbPolyFillArcSolidCopy,
***************
*** 82,100 ****
      miPolyText16,
      miImageText8,
      miImageText16,
! #if PPW == 4
!     cfbTEGlyphBlt8,
!     cfbPolyGlyphBlt8,
!     cfbPushPixels8,
! #else
!     cfbTEGlyphBlt,
!     miPolyGlyphBlt,
!     mfbPushPixels,
! #endif
      NULL,
  };
  
! GCOps	cfbTEOps = {
      cfbSolidSpansCopy,
      cfbSetSpans,
      cfbPutImage,
--- 108,120 ----
      miPolyText16,
      miImageText8,
      miImageText16,
!     useTEGlyphBlt,
!     usePolyGlyphBlt,
!     usePushPixels,
      NULL,
  };
  
! GCOps	cfbNonTEOps1Rect = {
      cfbSolidSpansCopy,
      cfbSetSpans,
      cfbPutImage,
***************
*** 101,115 ****
      cfbCopyArea,
      cfbCopyPlane,
      cfbPolyPoint,
      cfbLineSS,
      cfbSegmentSS,
-     miPolyRectangle,
- #if PPW == 4
-     cfbZeroPolyArcSS8Copy,
- #else
-     miZeroPolyArc,
  #endif
!     miFillPolygon,
      cfbPolyFillRect,
      cfbPolyFillArcSolidCopy,
      miPolyText8,
--- 121,136 ----
      cfbCopyArea,
      cfbCopyPlane,
      cfbPolyPoint,
+ #ifdef PIXEL_ADDR
+     cfb8LineSS1Rect,
+     cfb8SegmentSS1Rect,
+ #else
      cfbLineSS,
      cfbSegmentSS,
  #endif
!     miPolyRectangle,
!     ZeroPolyArc,
!     cfbFillPoly1RectCopy,
      cfbPolyFillRect,
      cfbPolyFillArcSolidCopy,
      miPolyText8,
***************
*** 116,134 ****
      miPolyText16,
      miImageText8,
      miImageText16,
! #if PPW == 4
!     cfbTEGlyphBlt8,
!     cfbPolyGlyphBlt8,
!     cfbPushPixels8,
! #else
!     cfbTEGlyphBlt,
!     miPolyGlyphBlt,
!     mfbPushPixels,
! #endif
      NULL,
  };
  
! GCOps	cfbNonTEOps1Rect = {
      cfbSolidSpansCopy,
      cfbSetSpans,
      cfbPutImage,
--- 137,149 ----
      miPolyText16,
      miImageText8,
      miImageText16,
!     useImageGlyphBlt,
!     usePolyGlyphBlt,
!     usePushPixels,
      NULL,
  };
  
! GCOps	cfbTEOps = {
      cfbSolidSpansCopy,
      cfbSetSpans,
      cfbPutImage,
***************
*** 135,154 ****
      cfbCopyArea,
      cfbCopyPlane,
      cfbPolyPoint,
- #if PPW == 4
-     cfb8LineSS1Rect,
-     cfb8SegmentSS1Rect,
- #else
      cfbLineSS,
      cfbSegmentSS,
- #endif
      miPolyRectangle,
! #if PPW == 4
!     cfbZeroPolyArcSS8Copy,
! #else
!     miZeroPolyArc,
! #endif
!     cfbFillPoly1RectCopy,
      cfbPolyFillRect,
      cfbPolyFillArcSolidCopy,
      miPolyText8,
--- 150,160 ----
      cfbCopyArea,
      cfbCopyPlane,
      cfbPolyPoint,
      cfbLineSS,
      cfbSegmentSS,
      miPolyRectangle,
!     ZeroPolyArc,
!     miFillPolygon,
      cfbPolyFillRect,
      cfbPolyFillArcSolidCopy,
      miPolyText8,
***************
*** 155,163 ****
      miPolyText16,
      miImageText8,
      miImageText16,
!     cfbImageGlyphBlt8,
!     cfbPolyGlyphBlt8,
!     cfbPushPixels8,
      NULL,
  };
  
--- 161,169 ----
      miPolyText16,
      miImageText8,
      miImageText16,
!     useTEGlyphBlt,
!     usePolyGlyphBlt,
!     usePushPixels,
      NULL,
  };
  
***************
*** 171,177 ****
      cfbLineSS,
      cfbSegmentSS,
      miPolyRectangle,
! #if PPW == 4
      cfbZeroPolyArcSS8Copy,
  #else
      miZeroPolyArc,
--- 177,183 ----
      cfbLineSS,
      cfbSegmentSS,
      miPolyRectangle,
! #ifdef PIXEL_ADDR
      cfbZeroPolyArcSS8Copy,
  #else
      miZeroPolyArc,
***************
*** 183,197 ****
      miPolyText16,
      miImageText8,
      miImageText16,
! #if PPW == 4
!     cfbImageGlyphBlt8,
!     cfbPolyGlyphBlt8,
!     cfbPushPixels8,
! #else
!     miImageGlyphBlt,
!     miPolyGlyphBlt,
!     mfbPushPixels,
! #endif
      NULL,
  };
  
--- 189,197 ----
      miPolyText16,
      miImageText8,
      miImageText16,
!     useImageGlyphBlt,
!     usePolyGlyphBlt,
!     usePushPixels,
      NULL,
  };
  
***************
*** 214,220 ****
  	FONTMINBOUNDS(pGC->font,characterWidth) >= 0)
      {
  	if (TERMINALFONT(pGC->font)
! #if PPW == 4
  	    && FONTMAXBOUNDS(pGC->font,characterWidth) >= 4
  #endif
  	)
--- 214,220 ----
  	FONTMINBOUNDS(pGC->font,characterWidth) >= 0)
      {
  	if (TERMINALFONT(pGC->font)
! #ifdef FOUR_BIT_CODE
  	    && FONTMAXBOUNDS(pGC->font,characterWidth) >= 4
  #endif
  	)
***************
*** 237,243 ****
  {
      cfbPrivGC  *pPriv;
  
!     if (pGC->depth == 1)
  	return (mfbCreateGC(pGC));
      pGC->clientClip = NULL;
      pGC->clientClipType = CT_NONE;
--- 237,243 ----
  {
      cfbPrivGC  *pPriv;
  
!     if (PixmapWidthPaddingInfo[pGC->depth].padPixelsLog2 == LOG2_BITMAP_PAD)
  	return (mfbCreateGC(pGC));
      pGC->clientClip = NULL;
      pGC->clientClipType = CT_NONE;
***************
*** 603,609 ****
  		}
  	    }
  	    break;
! #if (PPW == 4)
  	case FillStippled:
  	case FillOpaqueStippled:
  	    {
--- 603,609 ----
  		}
  	    }
  	    break;
! #ifdef FOUR_BIT_CODE
  	case FillStippled:
  	case FillOpaqueStippled:
  	    {
***************
*** 638,645 ****
  	    new_rrop = FALSE;
  	else
  	{
! #if PPW ==  4
  	    new_line = TRUE;
  	    new_text = TRUE;
  #endif
  	    new_fillspans = TRUE;
--- 638,647 ----
  	    new_rrop = FALSE;
  	else
  	{
! #ifdef PIXEL_ADDR
  	    new_line = TRUE;
+ #endif
+ #ifdef WriteFourBits
  	    new_text = TRUE;
  #endif
  	    new_fillspans = TRUE;
***************
*** 685,691 ****
  	}
  	if (pGC->lineWidth == 0)
  	{
! #if PPW == 4
  	    if ((pGC->lineStyle == LineSolid) && (pGC->fillStyle == FillSolid))
  	    {
  		switch (devPriv->rop)
--- 687,693 ----
  	}
  	if (pGC->lineWidth == 0)
  	{
! #ifdef PIXEL_ADDR
  	    if ((pGC->lineStyle == LineSolid) && (pGC->fillStyle == FillSolid))
  	    {
  		switch (devPriv->rop)
***************
*** 715,721 ****
  	    {
  		if (pGC->fillStyle == FillSolid)
  		{
! #if PPW == 4
  		    if (devPriv->oneRect)
  		    {
  			pGC->ops->Polylines = cfb8LineSS1Rect;
--- 717,723 ----
  	    {
  		if (pGC->fillStyle == FillSolid)
  		{
! #ifdef PIXEL_ADDR
  		    if (devPriv->oneRect)
  		    {
  			pGC->ops->Polylines = cfb8LineSS1Rect;
***************
*** 756,793 ****
          }
          else
          {
! #if PPW == 4
  	    if (pGC->fillStyle == FillSolid)
  	    {
  		if (devPriv->rop == GXcopy)
  		    pGC->ops->PolyGlyphBlt = cfbPolyGlyphBlt8;
  		else
  		    pGC->ops->PolyGlyphBlt = cfbPolyGlyphRop8;
  	    }
  	    else
  #endif
  		pGC->ops->PolyGlyphBlt = miPolyGlyphBlt;
              /* special case ImageGlyphBlt for terminal emulator fonts */
!             if (TERMINALFONT(pGC->font) &&
  		(pGC->planemask & PMSK) == PMSK
! #if PPW == 4
  		&& FONTMAXBOUNDS(pGC->font,characterWidth) >= 4
  #endif
  		)
  	    {
! #if PPW == 4
!                 pGC->ops->ImageGlyphBlt = cfbTEGlyphBlt8;
! #else
!                 pGC->ops->ImageGlyphBlt = cfbTEGlyphBlt;
! #endif
  	    }
              else
  	    {
! #if PPW == 4
! 		pGC->ops->ImageGlyphBlt = cfbImageGlyphBlt8;
! #else
!                 pGC->ops->ImageGlyphBlt = miImageGlyphBlt;
  #endif
  	    }
          }
      }    
--- 758,800 ----
          }
          else
          {
! #ifdef WriteFourBits
  	    if (pGC->fillStyle == FillSolid)
  	    {
  		if (devPriv->rop == GXcopy)
  		    pGC->ops->PolyGlyphBlt = cfbPolyGlyphBlt8;
  		else
+ #ifdef FOUR_BIT_CODE
  		    pGC->ops->PolyGlyphBlt = cfbPolyGlyphRop8;
+ #else
+ 		    pGC->ops->PolyGlyphBlt = miPolyGlyphBlt;
+ #endif
  	    }
  	    else
  #endif
  		pGC->ops->PolyGlyphBlt = miPolyGlyphBlt;
              /* special case ImageGlyphBlt for terminal emulator fonts */
! #if !defined(WriteFourBits) || PSZ == 8
! 	    if (TERMINALFONT(pGC->font) &&
  		(pGC->planemask & PMSK) == PMSK
! #ifdef FOUR_BIT_CODE
  		&& FONTMAXBOUNDS(pGC->font,characterWidth) >= 4
  #endif
  		)
  	    {
! 		pGC->ops->ImageGlyphBlt = useTEGlyphBlt;
  	    }
              else
+ #endif
  	    {
! #ifdef WriteFourBits
! 		if (devPriv->rop == GXcopy &&
! 		    pGC->fillStyle == FillSolid &&
! 		    (pGC->planemask & PMSK) == PMSK)
! 		    pGC->ops->ImageGlyphBlt = cfbImageGlyphBlt8;
! 		else
  #endif
+ 		    pGC->ops->ImageGlyphBlt = miImageGlyphBlt;
  	    }
          }
      }    
***************
*** 820,826 ****
  		pGC->ops->FillSpans = cfbUnnaturalTileFS;
  	    break;
  	case FillStippled:
! #if PPW == 4
  	    if (devPriv->pRotatedPixmap)
  		pGC->ops->FillSpans = cfb8Stipple32FS;
  	    else
--- 827,833 ----
  		pGC->ops->FillSpans = cfbUnnaturalTileFS;
  	    break;
  	case FillStippled:
! #ifdef FOUR_BIT_CODE
  	    if (devPriv->pRotatedPixmap)
  		pGC->ops->FillSpans = cfb8Stipple32FS;
  	    else
***************
*** 828,834 ****
  		pGC->ops->FillSpans = cfbUnnaturalStippleFS;
  	    break;
  	case FillOpaqueStippled:
! #if PPW == 4
  	    if (devPriv->pRotatedPixmap)
  		pGC->ops->FillSpans = cfb8OpaqueStipple32FS;
  	    else
--- 835,841 ----
  		pGC->ops->FillSpans = cfbUnnaturalStippleFS;
  	    break;
  	case FillOpaqueStippled:
! #ifdef FOUR_BIT_CODE
  	    if (devPriv->pRotatedPixmap)
  		pGC->ops->FillSpans = cfb8OpaqueStipple32FS;
  	    else
***************
*** 841,847 ****
      } /* end of new_fillspans */
  
      if (new_fillarea) {
! #if PPW != 4
  	pGC->ops->PolyFillRect = miPolyFillRect;
  	if (pGC->fillStyle == FillSolid || pGC->fillStyle == FillTiled)
  	{
--- 848,854 ----
      } /* end of new_fillspans */
  
      if (new_fillarea) {
! #ifndef FOUR_BIT_CODE
  	pGC->ops->PolyFillRect = miPolyFillRect;
  	if (pGC->fillStyle == FillSolid || pGC->fillStyle == FillTiled)
  	{
***************
*** 848,854 ****
  	    pGC->ops->PolyFillRect = cfbPolyFillRect;
  	}
  #endif
! #if PPW == 4
  	pGC->ops->PushPixels = mfbPushPixels;
  	if (pGC->fillStyle == FillSolid && devPriv->rop == GXcopy)
  	    pGC->ops->PushPixels = cfbPushPixels8;
--- 855,861 ----
  	    pGC->ops->PolyFillRect = cfbPolyFillRect;
  	}
  #endif
! #ifdef FOUR_BIT_CODE
  	pGC->ops->PushPixels = mfbPushPixels;
  	if (pGC->fillStyle == FillSolid && devPriv->rop == GXcopy)
  	    pGC->ops->PushPixels = cfbPushPixels8;
*** /tmp/,RCSt1a16253	Tue Feb 11 15:12:08 1992
--- server/ddx/cfb/cfbgetsp.c	Tue Feb 11 15:04:24 1992
***************
*** 1,3 ****
--- 1,4 ----
+ /* $XConsortium: cfbgetsp.c,v 5.10 92/02/11 15:04:21 keith Exp $ */
  /***********************************************************
  Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
  and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
***************
*** 59,65 ****
      int         	xEnd;		/* last pixel to copy from */
      register int	nstart; 
      int	 		nend; 
-     int	 		srcStartOver; 
      unsigned long	startmask, endmask;
      int			nlMiddle, nl, srcBit;
      int			w;
--- 60,65 ----
***************
*** 78,90 ****
      
      cfbGetLongWidthAndPointer (pDrawable, widthSrc, psrcBase)
  
! #if PPW == 4
      if ((nspans == 1) && (*pwidth == 1))
      {
! 	tmpSrc = *((unsigned char *)(psrcBase + (ppt->y * (widthSrc >> 2)))
  		   + ppt->x);
  #if BITMAP_BIT_ORDER == MSBFirst
! 	tmpSrc <<= 24;
  #endif
  	*pdstStart = tmpSrc;
  	return;
--- 78,90 ----
      
      cfbGetLongWidthAndPointer (pDrawable, widthSrc, psrcBase)
  
! #ifdef PIXEL_ADDR
      if ((nspans == 1) && (*pwidth == 1))
      {
! 	tmpSrc = *((PixelType *)(psrcBase + (ppt->y * widthSrc))
  		   + ppt->x);
  #if BITMAP_BIT_ORDER == MSBFirst
! 	tmpSrc <<= (sizeof (unsigned long) - sizeof (PixelType)) * 8;
  #endif
  	*pdstStart = tmpSrc;
  	return;
***************
*** 94,128 ****
      pptLast = ppt + nspans;
      while(ppt < pptLast)
      {
! 	xEnd = min(ppt->x + *pwidth, widthSrc << (PWSH-2) );
! 	psrc = psrcBase + (ppt->y * (widthSrc >> 2)) + (ppt->x >> PWSH); 
  	w = xEnd - ppt->x;
  	srcBit = ppt->x & PIM;
! 	/* This shouldn't be needed */
! 	pdstNext = pdst + PixmapWidthInPadUnits(w, PSZ);
  
  	if (srcBit + w <= PPW) 
  	{ 
  	    getbits(psrc, srcBit, w, tmpSrc);
! /*XXX*/	    putbits(tmpSrc, 0, w, pdst, ~((unsigned long)0)); 
  	    pdst++;
  	} 
  	else 
  	{ 
- 
  	    maskbits(ppt->x, w, startmask, endmask, nlMiddle);
  	    if (startmask) 
- 		nstart = PPW - srcBit; 
- 	    else 
- 		nstart = 0; 
- 	    if (endmask) 
- 		nend = xEnd & PIM; 
- 	    srcStartOver = srcBit + nstart > PLST;
- 	    if (startmask) 
  	    { 
  		getbits(psrc, srcBit, nstart, tmpSrc);
! /*XXX*/		putbits(tmpSrc, 0, nstart, pdst, ~((unsigned long)0));
! 		if(srcStartOver)
  		    psrc++;
  	    } 
  	    nl = nlMiddle; 
--- 94,121 ----
      pptLast = ppt + nspans;
      while(ppt < pptLast)
      {
! 	xEnd = min(ppt->x + *pwidth, widthSrc << PWSH);
! 	psrc = psrcBase + ppt->y * widthSrc + (ppt->x >> PWSH); 
  	w = xEnd - ppt->x;
  	srcBit = ppt->x & PIM;
!     	pdstNext = pdst + ((w + PPW - 1) >> PWSH);
  
  	if (srcBit + w <= PPW) 
  	{ 
  	    getbits(psrc, srcBit, w, tmpSrc);
! 	    putbits(tmpSrc, 0, w, pdst, ~((unsigned long)0)); 
  	    pdst++;
  	} 
  	else 
  	{ 
  	    maskbits(ppt->x, w, startmask, endmask, nlMiddle);
+ 	    nstart = 0; 
  	    if (startmask) 
  	    { 
+ 		nstart = PPW - srcBit; 
  		getbits(psrc, srcBit, nstart, tmpSrc);
! 		putbits(tmpSrc, 0, nstart, pdst, ~((unsigned long)0));
! 		if(srcBit + nstart >= PPW)
  		    psrc++;
  	    } 
  	    nl = nlMiddle; 
***************
*** 129,154 ****
  	    while (nl--) 
  	    { 
  		tmpSrc = *psrc;
! /*XXX*/		putbits(tmpSrc, nstart, PPW, pdst, ~((unsigned long)0));
  		psrc++;
  		pdst++;
  	    } 
  	    if (endmask) 
  	    { 
  		getbits(psrc, 0, nend, tmpSrc);
! /*XXX*/		putbits(tmpSrc, nstart, nend, pdst, ~((unsigned long)0));
! 		if(nstart + nend >= PPW)
! 		    pdst++;
  	    } 
- #ifdef	notdef
- 	    pdst++; 
- 	    while(pdst < pdstNext)
- 	    {
- 		*pdst++ = 0;
- 	    }
- #else
  	    pdst = pdstNext;
- #endif
  	} 
          ppt++;
  	pwidth++;
--- 122,138 ----
  	    while (nl--) 
  	    { 
  		tmpSrc = *psrc;
! 		putbits(tmpSrc, nstart, PPW, pdst, ~((unsigned long)0));
  		psrc++;
  		pdst++;
  	    } 
  	    if (endmask) 
  	    { 
+ 		nend = xEnd & PIM; 
  		getbits(psrc, 0, nend, tmpSrc);
! 		putbits(tmpSrc, nstart, nend, pdst, ~((unsigned long)0));
  	    } 
  	    pdst = pdstNext;
  	} 
          ppt++;
  	pwidth++;
*** /tmp/,RCSt1a16272	Tue Feb 11 15:12:14 1992
--- server/ddx/cfb/cfbglblt8.c	Thu Dec 19 14:16:31 1991
***************
*** 1,9 ****
  /*
-  * Poly glyph blt for 8 bit displays.  Accepts
-  * an arbitrary font <= 32 bits wide, in Copy mode only.
-  */
- 
- /*
  Copyright 1989 by the Massachusetts Institute of Technology
  
  Permission to use, copy, modify, and distribute this software and its
--- 1,5 ----
+ /* $XConsortium: cfbglblt8.c,v 5.24 91/12/19 14:16:27 keith Exp $ */
  /*
  Copyright 1989 by the Massachusetts Institute of Technology
  
  Permission to use, copy, modify, and distribute this software and its
***************
*** 16,23 ****
  representations about the suitability of this software for any
  purpose.  It is provided "as is" without express or implied warranty.
  */
- /* $XConsortium: cfbglblt8.c,v 5.23 91/07/18 23:44:50 keith Exp $ */
  
  #include	"X.h"
  #include	"Xmd.h"
  #include	"Xproto.h"
--- 12,23 ----
  representations about the suitability of this software for any
  purpose.  It is provided "as is" without express or implied warranty.
  */
  
+ /*
+  * Poly glyph blt.  Accepts an arbitrary font <= 32 bits wide, in Copy mode
+  * only.
+  */
+ 
  #include	"X.h"
  #include	"Xmd.h"
  #include	"Xproto.h"
***************
*** 44,50 ****
  	 (box1)->y1 <= ((int) (box2)->y1 + (yoffset)) && \
   	 ((int) (box2)->y2 + (yoffset)) <= (box1)->y2)
  
! #if PPW == 4
  
  #if GLYPHPADBYTES != 4
  #define USE_LEFTBITS
--- 44,50 ----
  	 (box1)->y1 <= ((int) (box2)->y1 + (yoffset)) && \
   	 ((int) (box2)->y2 + (yoffset)) <= (box1)->y2)
  
! #if defined(FOUR_BIT_CODE) || defined(WriteFourBits) && !defined(GLYPHROP)
  
  #if GLYPHPADBYTES != 4
  #define USE_LEFTBITS
***************
*** 82,90 ****
  #endif
  
  #if defined(__GNUC__) && !defined(GLYPHROP) && (defined(mc68020) || defined(mc68000) || defined(__mc68000__)) && !defined(USE_LEFTBITS)
! #include    <stip68kgnu.h>
  #endif
  
  void
  cfbPolyGlyphBlt8 (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase)
      DrawablePtr pDrawable;
--- 82,94 ----
  #endif
  
  #if defined(__GNUC__) && !defined(GLYPHROP) && (defined(mc68020) || defined(mc68000) || defined(__mc68000__)) && !defined(USE_LEFTBITS)
! #ifdef USE_STIPPLE_CODE
! #undef USE_STIPPLE_CODE
  #endif
+ #endif
  
+ #define DST_INC	    (4 >> PWSH)
+ 
  void
  cfbPolyGlyphBlt8 (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase)
      DrawablePtr pDrawable;
***************
*** 124,134 ****
  #ifndef STIPPLE
  #ifdef USE_STIPPLE_CODE
      void		(*stipple)();
!     extern void		stipplestack (), stipplestackte ();
  
!     stipple = stipplestack;
      if (FONTCONSTMETRICS(pfont))
! 	stipple = stipplestackte;
  #endif
  #endif
      
--- 128,138 ----
  #ifndef STIPPLE
  #ifdef USE_STIPPLE_CODE
      void		(*stipple)();
!     extern void		cfbStippleStack (), cfbStippleStackTE ();
  
!     stipple = cfbStippleStack;
      if (FONTCONSTMETRICS(pfont))
! 	stipple = cfbStippleStackTE;
  #endif
  #endif
      
***************
*** 194,204 ****
  	glyphBits = (glyphPointer) FONTGLYPHBITS(pglyphBase,pci);
  	xoff = x + pci->metrics.leftSideBearing;
  	dstLine = pdstBase +
! 	          (y - pci->metrics.ascent) * widthDst + (xoff >> 2);
  	x += pci->metrics.characterWidth;
  	if (hTmp = pci->metrics.descent + pci->metrics.ascent)
  	{
! 	    xoff &= 0x3;
  #ifdef STIPPLE
  	    STIPPLE(dstLine,glyphBits,pixel,bwidthDst,hTmp,xoff);
  #else
--- 198,208 ----
  	glyphBits = (glyphPointer) FONTGLYPHBITS(pglyphBase,pci);
  	xoff = x + pci->metrics.leftSideBearing;
  	dstLine = pdstBase +
! 	          (y - pci->metrics.ascent) * widthDst + (xoff >> PWSH);
  	x += pci->metrics.characterWidth;
  	if (hTmp = pci->metrics.descent + pci->metrics.ascent)
  	{
! 	    xoff &= PIM;
  #ifdef STIPPLE
  	    STIPPLE(dstLine,glyphBits,pixel,bwidthDst,hTmp,xoff);
  #else
***************
*** 215,227 ****
  	    	dstLine = (unsigned long *) (((char *) dstLine) + bwidthDst);
  	    	GlyphBits(glyphBits, w, c)
  	    	WriteFourBits(dst, pixel, GetFourBits(BitRight(c,xoff)));
! 	    	dst++;
  	    	c = BitLeft(c,4-xoff);
  	    	while (c)
  	    	{
  		    WriteFourBits(dst, pixel, GetFourBits(c));
  		    NextFourBits(c);
! 		    dst++;
  	    	}
  	    } while (--hTmp);
  #endif /* USE_STIPPLE_CODE else */
--- 219,231 ----
  	    	dstLine = (unsigned long *) (((char *) dstLine) + bwidthDst);
  	    	GlyphBits(glyphBits, w, c)
  	    	WriteFourBits(dst, pixel, GetFourBits(BitRight(c,xoff)));
! 	    	dst += DST_INC;
  	    	c = BitLeft(c,4-xoff);
  	    	while (c)
  	    	{
  		    WriteFourBits(dst, pixel, GetFourBits(c));
  		    NextFourBits(c);
! 		    dst += DST_INC;
  	    	}
  	    } while (--hTmp);
  #endif /* USE_STIPPLE_CODE else */
***************
*** 316,323 ****
  	x += pci->metrics.characterWidth;
  	if (hTmp = pci->metrics.descent + pci->metrics.ascent)
  	{
! 	    dstLine = pdstBase + yG * widthDst + (xG >> 2);
! 	    xoff = xG & 0x3;
  #ifdef USE_LEFTBITS
  	    w = pci->metrics.rightSideBearing - pci->metrics.leftSideBearing;
  	    widthGlyph = PADGLYPHWIDTHBYTES(w);
--- 320,327 ----
  	x += pci->metrics.characterWidth;
  	if (hTmp = pci->metrics.descent + pci->metrics.ascent)
  	{
! 	    dstLine = pdstBase + yG * widthDst + (xG >> PWSH);
! 	    xoff = xG & PIM;
  #ifdef USE_LEFTBITS
  	    w = pci->metrics.rightSideBearing - pci->metrics.leftSideBearing;
  	    widthGlyph = PADGLYPHWIDTHBYTES(w);
***************
*** 337,348 ****
  		    {
  	    	    	WriteFourBits(dst, pixel, GetFourBits(BitRight(c,xoff)));
  	    	    	c = BitLeft(c,4 - xoff);
! 	    	    	dst++;
  	    	    	while (c)
  	    	    	{
  		    	    WriteFourBits(dst, pixel, GetFourBits(c));
  		    	    NextFourBits(c);
! 		    	    dst++;
  	    	    	}
  		    }
  	    	} while (--hTmp);
--- 341,352 ----
  		    {
  	    	    	WriteFourBits(dst, pixel, GetFourBits(BitRight(c,xoff)));
  	    	    	c = BitLeft(c,4 - xoff);
! 	    	    	dst += DST_INC;
  	    	    	while (c)
  	    	    	{
  		    	    WriteFourBits(dst, pixel, GetFourBits(c));
  		    	    NextFourBits(c);
! 		    	    dst += DST_INC;
  	    	    	}
  		    }
  	    	} while (--hTmp);
***************
*** 366,372 ****
  	    	STIPPLE(dstLine,glyphBits,pixel,bwidthDst,hTmp,xoff);
  #else
  #ifdef USE_STIPPLE_CODE
! 	    	stipplestackte(dstLine,glyphBits,pixel,bwidthDst,hTmp,xoff);
  #else
  	    	do {
  	    	    dst = dstLine;
--- 370,376 ----
  	    	STIPPLE(dstLine,glyphBits,pixel,bwidthDst,hTmp,xoff);
  #else
  #ifdef USE_STIPPLE_CODE
! 	    	cfbStippleStackTE(dstLine,glyphBits,pixel,bwidthDst,hTmp,xoff);
  #else
  	    	do {
  	    	    dst = dstLine;
***************
*** 376,387 ****
  		    {
  	    	    	WriteFourBits(dst, pixel, GetFourBits(BitRight(c,xoff)));
  	    	    	c = BitLeft(c,4-xoff);
! 	    	    	dst++;
  	    	    	while (c)
  	    	    	{
  		    	    WriteFourBits(dst, pixel, GetFourBits(c));
  		    	    NextFourBits(c);
! 		    	    dst++;
  	    	    	}
  		    }
  	    	} while (--hTmp);
--- 380,391 ----
  		    {
  	    	    	WriteFourBits(dst, pixel, GetFourBits(BitRight(c,xoff)));
  	    	    	c = BitLeft(c,4-xoff);
! 	    	    	dst += DST_INC;
  	    	    	while (c)
  	    	    	{
  		    	    WriteFourBits(dst, pixel, GetFourBits(c));
  		    	    NextFourBits(c);
! 		    	    dst += DST_INC;
  	    	    	}
  		    }
  	    	} while (--hTmp);
***************
*** 394,397 ****
      DEALLOCATE_LOCAL (clips);
  }
  
! #endif /* PPW == 4 */
--- 398,401 ----
      DEALLOCATE_LOCAL (clips);
  }
  
! #endif /* FOUR_BIT_CODE */
*** /tmp/,RCSt1a16312	Tue Feb 11 15:12:30 1992
--- server/ddx/cfb/cfbhrzvert.c	Thu Dec 19 18:36:44 1991
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbhrzvert.c,v 1.5 90/01/31 12:31:37 keith Exp $ */
  #include "X.h"
  
  #include "gc.h"
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbhrzvert.c,v 1.6 91/12/19 18:36:41 keith Exp $ */
  #include "X.h"
  
  #include "gc.h"
***************
*** 108,117 ****
  int x1, y1;		/* initial point */
  register int len;	/* length of line */
  {
! #if (PPW == 4)
!     register unsigned char    *bits = (unsigned char *) addrl;
  
!     nlwidth <<= 2;
      bits = bits + (y1 * nlwidth) + x1;
  
      /*
--- 108,117 ----
  int x1, y1;		/* initial point */
  register int len;	/* length of line */
  {
! #ifdef PIXEL_ADDR
!     register PixelType    *bits = (PixelType *) addrl;
  
!     nlwidth <<= PWSH;
      bits = bits + (y1 * nlwidth) + x1;
  
      /*
*** /tmp/,RCSt1a16331	Tue Feb 11 15:12:37 1992
--- server/ddx/cfb/cfbigblt8.c	Mon Dec 30 14:06:09 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: cfbigblt8.c,v 1.3 91/07/14 13:50:41 keith Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: cfbigblt8.c,v 1.5 91/12/19 14:16:31 keith Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
***************
*** 37,44 ****
  #include	"cfbmskbits.h"
  #include	"cfb8bit.h"
  
- #if (PPW == 4)
- 
  void
  cfbImageGlyphBlt8 (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase)
      DrawablePtr	    pDrawable;
--- 37,42 ----
***************
*** 75,124 ****
      backrect.height = FONTASCENT(pGC->font) + FONTDESCENT(pGC->font);
  
      priv = (cfbPrivGC *) pGC->devPrivates[cfbGCPrivateIndex].ptr;
      /* this code cheats by knowing that ValidateGC isn't
       * necessary for PolyFillRect
       */
!     rop = priv->rop;
!     xor = priv->xor;
!     and = priv->and;
!     alu = pGC->alu;
      fgPixel = pGC->fgPixel;
-     fillStyle = pGC->fillStyle;
  
-     pGC->fillStyle = FillSolid;
      pGC->fgPixel = pGC->bgPixel;
!     pGC->alu = GXcopy;
!     pm = pGC->planemask & PMSK;
!     if (pm == PMSK)
!     {
! 	priv->rop = GXcopy;
! 	priv->xor = PFILL(pGC->bgPixel);
! 	priv->and = 0;
!     }
!     else
!     {
! 	priv->rop = cfbReduceRasterOp (GXcopy, pGC->bgPixel, pm,
! 				       &priv->and, &priv->xor);
!     }
  
      (*pGC->ops->PolyFillRect) (pDrawable, pGC, 1, &backrect);
  
      pGC->fgPixel = fgPixel;
  
!     if (pm == PMSK)
! 	priv->xor = PFILL(pGC->fgPixel);
!     else
!     {
! 	priv->rop = cfbReduceRasterOp (GXcopy, pGC->fgPixel, pm,
! 				       &priv->and, &priv->xor);
!     }
  
!     cfbPolyGlyphBlt8 (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
      
-     priv->rop = rop;
-     priv->and = and;
-     priv->xor = xor;
-     pGC->alu = alu;
-     pGC->fillStyle = fillStyle;
  }
- #endif
--- 73,94 ----
      backrect.height = FONTASCENT(pGC->font) + FONTDESCENT(pGC->font);
  
      priv = (cfbPrivGC *) pGC->devPrivates[cfbGCPrivateIndex].ptr;
+ 
      /* this code cheats by knowing that ValidateGC isn't
       * necessary for PolyFillRect
       */
! 
      fgPixel = pGC->fgPixel;
  
      pGC->fgPixel = pGC->bgPixel;
!     priv->xor = PFILL(pGC->bgPixel);
  
      (*pGC->ops->PolyFillRect) (pDrawable, pGC, 1, &backrect);
  
      pGC->fgPixel = fgPixel;
  
!     priv->xor = PFILL(pGC->fgPixel);
  
!     (*pGC->ops->PolyGlyphBlt) (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
      
  }
*** /tmp/,RCSt1a16350	Tue Feb 11 15:12:46 1992
--- server/ddx/cfb/cfbimage.c	Thu Dec 19 18:36:39 1991
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbimage.c,v 1.7 91/07/18 23:36:48 keith Exp $ */
  
  #include "X.h"
  #include "windowstr.h"
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbimage.c,v 1.9 91/12/19 18:36:36 keith Exp $ */
  
  #include "X.h"
  #include "windowstr.h"
***************
*** 44,49 ****
--- 44,50 ----
      char 	*pImage;
  {
      PixmapRec	FakePixmap;
+     int		bitsPerPixel;
  
      if ((w == 0) || (h == 0))
  	return;
***************
*** 54,60 ****
      	FakePixmap.drawable.class = 0;
      	FakePixmap.drawable.pScreen = pDraw->pScreen;
      	FakePixmap.drawable.depth = depth;
-     	FakePixmap.drawable.bitsPerPixel = depth;
      	FakePixmap.drawable.id = 0;
      	FakePixmap.drawable.serialNumber = NEXT_SERIAL_NUMBER;
      	FakePixmap.drawable.x = 0;
--- 55,60 ----
***************
*** 61,67 ****
      	FakePixmap.drawable.y = 0;
      	FakePixmap.drawable.width = w+leftPad;
      	FakePixmap.drawable.height = h;
!     	FakePixmap.devKind = PixmapBytePad(FakePixmap.drawable.width, depth);
      	FakePixmap.refcnt = 1;
      	FakePixmap.devPrivate.ptr = (pointer)pImage;
      	((cfbPrivGC *)(pGC->devPrivates[cfbGCPrivateIndex].ptr))->fExpose = FALSE;
--- 61,76 ----
      	FakePixmap.drawable.y = 0;
      	FakePixmap.drawable.width = w+leftPad;
      	FakePixmap.drawable.height = h;
! 	if (format == XYBitmap)
! 	{
! 	    FakePixmap.drawable.bitsPerPixel = 1;
! 	    FakePixmap.devKind = BitmapBytePad(FakePixmap.drawable.width);
! 	}
! 	else
! 	{
! 	    FakePixmap.drawable.bitsPerPixel = BitsPerPixel(depth);
! 	    FakePixmap.devKind = PixmapBytePad(FakePixmap.drawable.width, depth);
! 	}
      	FakePixmap.refcnt = 1;
      	FakePixmap.devPrivate.ptr = (pointer)pImage;
      	((cfbPrivGC *)(pGC->devPrivates[cfbGCPrivateIndex].ptr))->fExpose = FALSE;
***************
*** 87,93 ****
  	gcv[0] = ~0L;
  	gcv[1] = 0;
  	DoChangeGC(pGC, GCForeground | GCBackground, gcv, 0);
! 	bytesPer = (long)h * PixmapBytePad(w + leftPad, 1);
  
  	for (i = 1 << (depth-1); i != 0; i >>= 1, pImage += bytesPer)
  	{
--- 96,102 ----
  	gcv[0] = ~0L;
  	gcv[1] = 0;
  	DoChangeGC(pGC, GCForeground | GCBackground, gcv, 0);
! 	bytesPer = (long)h * BitmapBytePad(w + leftPad);
  
  	for (i = 1 << (depth-1); i != 0; i >>= 1, pImage += bytesPer)
  	{
***************
*** 158,163 ****
--- 167,173 ----
      }
      else
      {
+ #if PSZ == 8
      	FakePixmap.drawable.type = DRAWABLE_PIXMAP;
      	FakePixmap.drawable.class = 0;
      	FakePixmap.drawable.pScreen = pDrawable->pScreen;
***************
*** 169,175 ****
      	FakePixmap.drawable.y = 0;
      	FakePixmap.drawable.width = w;
      	FakePixmap.drawable.height = h;
!     	FakePixmap.devKind = PixmapBytePad(w, 1);
      	FakePixmap.refcnt = 1;
      	FakePixmap.devPrivate.ptr = (pointer)pdstLine;
          ptSrc.x = sx + pDrawable->x;
--- 179,185 ----
      	FakePixmap.drawable.y = 0;
      	FakePixmap.drawable.width = w;
      	FakePixmap.drawable.height = h;
!     	FakePixmap.devKind = BitmapBytePad(w);
      	FakePixmap.refcnt = 1;
      	FakePixmap.devPrivate.ptr = (pointer)pdstLine;
          ptSrc.x = sx + pDrawable->x;
***************
*** 182,186 ****
--- 192,199 ----
  	cfbCopyImagePlane (pDrawable, (DrawablePtr)&FakePixmap, GXcopy, &rgnDst,
  		    &ptSrc, planeMask);
          (*pDrawable->pScreen->RegionUninit)(&rgnDst);
+ #else
+ 	miGetImage (pDrawable, sx, sy, w, h, format, planeMask, pdstLine);
+ #endif
      }
  }
*** /dev/null	Tue Feb 11 14:58:45 1992
--- server/ddx/cfb/cfbmap.h	Thu Dec 19 18:37:05 1991
***************
*** 0 ****
--- 1,181 ----
+ /*
+  * $XConsortium: cfbmap.h,v 1.3 91/12/19 18:37:02 keith Exp $
+  *
+  * Copyright 1991 Massachusetts Institute of Technology
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and its
+  * documentation for any purpose is hereby granted without fee, provided that
+  * the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of M.I.T. not be used in advertising or
+  * publicity pertaining to distribution of the software without specific,
+  * written prior permission.  M.I.T. makes no representations about the
+  * suitability of this software for any purpose.  It is provided "as is"
+  * without express or implied warranty.
+  *
+  * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.
+  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * Author:  Keith Packard, MIT X Consortium
+  */
+ 
+ /*
+  * Map names around so that multiple depths can be supported simultaneously
+  */
+ 
+ #if PSZ != 8
+ #if PSZ == 32
+ #define NAME(subname) CATNAME(cfb32,subname)
+ #endif
+ 
+ #if PSZ == 16
+ #define NAME(subname) CATNAME(cfb16,subname)
+ #endif
+ 
+ #if PSZ == 4
+ #define NAME(subname) CATNAME(cfb4,subname)
+ #endif
+ 
+ #ifndef NAME
+ cfb can not hack PSZ yet
+ #endif
+ 
+ #if __STDC__ && !defined(UNIXCPP)
+ #define CATNAME(prefix,subname) prefix##subname
+ #else
+ #define CATNAME(prefix,subname) prefix/**/subname
+ #endif
+ 
+ 
+ #define cfbScreenPrivateIndex NAME(ScreenPrivateIndex)
+ #define cfbWindowPrivateIndex NAME(WindowPrivateIndex)
+ #define cfbGCPrivateIndex NAME(GCPrivateIndex)
+ #define QuartetBitsTable NAME(QuartetBitsTable)
+ #define QuartetPixelMaskTable NAME(QuartetPixelMaskTable)
+ #define cfbAllocatePrivates NAME(AllocatePrivates)
+ #define cfbBSFuncRec NAME(BSFuncRec)
+ #define cfbBitBlt NAME(BitBlt)
+ #define cfbBresD NAME(BresD)
+ #define cfbBresS NAME(BresS)
+ #define cfbChangeClip NAME(ChangeClip)
+ #define cfbChangeGC NAME(ChangeGC)
+ #define cfbChangeWindowAttributes NAME(ChangeWindowAttributes)
+ #define cfbClipPoint NAME(ClipPoint)
+ #define cfbCloseScreen NAME(CloseScreen)
+ #define cfbCopyArea NAME(CopyArea)
+ #define cfbCopyClip NAME(CopyClip)
+ #define cfbCopyGC NAME(CopyGC)
+ #define cfbCopyImagePlane NAME(CopyImagePlane)
+ #define cfbCopyPixmap NAME(CopyPixmap)
+ #define cfbCopyPlane NAME(CopyPlane)
+ #define cfbCopyRotatePixmap NAME(CopyRotatePixmap)
+ #define cfbCopyWindow NAME(CopyWindow)
+ #define cfbCreateGC NAME(CreateGC)
+ #define cfbCreateOps NAME(CreateOps)
+ #define cfbCreatePixmap NAME(CreatePixmap)
+ #define cfbCreateWindow NAME(CreateWindow)
+ #define cfbDestroyClip NAME(DestroyClip)
+ #define cfbDestroyGC NAME(DestroyGC)
+ #define cfbDestroyOps NAME(DestroyOps)
+ #define cfbDestroyPixmap NAME(DestroyPixmap)
+ #define cfbDestroyWindow NAME(DestroyWindow)
+ #define cfbDoBitblt NAME(DoBitblt)
+ #define cfbDoBitbltCopy NAME(DoBitbltCopy)
+ #define cfbDoBitbltGeneral NAME(DoBitbltGeneral)
+ #define cfbDoBitbltOr NAME(DoBitbltOr)
+ #define cfbDoBitbltXor NAME(DoBitbltXor)
+ #define cfbFillBoxSolid NAME(FillBoxSolid)
+ #define cfbFillBoxTile32 NAME(FillBoxTile32)
+ #define cfbFillBoxTile32sCopy NAME(FillBoxTile32sCopy)
+ #define cfbFillBoxTile32sGeneral NAME(FillBoxTile32sGeneral)
+ #define cfbFillBoxTileOdd NAME(FillBoxTileOdd)
+ #define cfbFillBoxTileOddCopy NAME(FillBoxTileOddCopy)
+ #define cfbFillBoxTileOddGeneral NAME(FillBoxTileOddGeneral)
+ #define cfbFillPoly1RectCopy NAME(FillPoly1RectCopy)
+ #define cfbFillPoly1RectGeneral NAME(FillPoly1RectGeneral)
+ #define cfbFillRectSolidCopy NAME(FillRectSolidCopy)
+ #define cfbFillRectSolidGeneral NAME(FillRectSolidGeneral)
+ #define cfbFillRectSolidXor NAME(FillRectSolidXor)
+ #define cfbFillRectTile32Copy NAME(FillRectTile32Copy)
+ #define cfbFillRectTile32General NAME(FillRectTile32General)
+ #define cfbFillRectTileOdd NAME(FillRectTileOdd)
+ #define cfbFillSpanTile32sCopy NAME(FillSpanTile32sCopy)
+ #define cfbFillSpanTile32sGeneral NAME(FillSpanTile32sGeneral)
+ #define cfbFillSpanTileOddCopy NAME(FillSpanTileOddCopy)
+ #define cfbFillSpanTileOddGeneral NAME(FillSpanTileOddGeneral)
+ #define cfbFinishScreenInit NAME(FinishScreenInit)
+ #define cfbGCFuncs NAME(GCFuncs)
+ #define cfbGetImage NAME(GetImage)
+ #define cfbGetSpans NAME(GetSpans)
+ #define cfbHorzS NAME(HorzS)
+ #define cfbImageGlyphBlt8 NAME(ImageGlyphBlt8)
+ #define cfbLineSD NAME(LineSD)
+ #define cfbLineSS NAME(LineSS)
+ #define cfbMapWindow NAME(MapWindow)
+ #define cfbMatchCommon NAME(MatchCommon)
+ #define cfbNonTEOps NAME(NonTEOps)
+ #define cfbNonTEOps1Rect NAME(NonTEOps1Rect)
+ #define cfbPadPixmap NAME(PadPixmap)
+ #define cfbPaintWindow NAME(PaintWindow)
+ #define cfbPolyGlyphBlt8 NAME(PolyGlyphBlt8)
+ #define cfbPolyGlyphRop8 NAME(PolyGlyphRop8)
+ #define cfbPolyFillArcSolidCopy NAME(PolyFillArcSolidCopy)
+ #define cfbPolyFillArcSolidGeneral NAME(PolyFillArcSolidGeneral)
+ #define cfbPolyFillRect NAME(PolyFillRect)
+ #define cfbPolyPoint NAME(PolyPoint)
+ #define cfbPositionWindow NAME(PositionWindow)
+ #define cfbPutImage NAME(PutImage)
+ #define cfbReduceRasterOp NAME(ReduceRasterOp)
+ #define cfbRestoreAreas NAME(RestoreAreas)
+ #define cfbSaveAreas NAME(SaveAreas)
+ #define cfbScreenInit NAME(ScreenInit)
+ #define cfbSegmentSD NAME(SegmentSD)
+ #define cfbSegmentSS NAME(SegmentSS)
+ #define cfbSetScanline NAME(SetScanline)
+ #define cfbSetSpans NAME(SetSpans)
+ #define cfbSetupScreen NAME(SetupScreen)
+ #define cfbSolidSpansCopy NAME(SolidSpansCopy)
+ #define cfbSolidSpansGeneral NAME(SolidSpansGeneral)
+ #define cfbSolidSpansXor NAME(SolidSpansXor)
+ #define cfbStippleStack NAME(StippleStack)
+ #define cfbStippleStackTE NAME(StippleStackTE)
+ #define cfbTEGlyphBlt NAME(TEGlyphBlt)
+ #define cfbTEOps NAME(TEOps)
+ #define cfbTEOps1Rect NAME(TEOps1Rect)
+ #define cfbTile32FSCopy NAME(Tile32FSCopy)
+ #define cfbTile32FSGeneral NAME(Tile32FSGeneral)
+ #define cfbUnmapWindow NAME(UnmapWindow)
+ #define cfbUnnaturalStippleFS NAME(UnnaturalStippleFS)
+ #define cfbUnnaturalTileFS NAME(UnnaturalTileFS)
+ #define cfbValidateGC NAME(ValidateGC)
+ #define cfbVertS NAME(VertS)
+ #define cfbXRotatePixmap NAME(XRotatePixmap)
+ #define cfbYRotatePixmap NAME(YRotatePixmap)
+ #define cfbendpartial NAME(endpartial)
+ #define cfbendtab NAME(endtab)
+ #define cfbmask NAME(mask)
+ #define cfbrmask NAME(rmask)
+ #define cfbstartpartial NAME(startpartial)
+ #define cfbstarttab NAME(starttab)
+ #define cfb8LineSS1Rect NAME(LineSS1Rect)
+ #define cfb8SegmentSS1Rect NAME(SegmentSS1Rect)
+ #define cfb8ClippedLineCopy NAME(ClippedLineCopy)
+ #define cfb8ClippedLineXor NAME(ClippedLineXor)
+ #define cfb8ClippedLineGeneral  NAME(ClippedLineGeneral )
+ #define cfb8SegmentSS1RectCopy NAME(SegmentSS1RectCopy)
+ #define cfb8SegmentSS1RectXor NAME(SegmentSS1RectXor)
+ #define cfb8SegmentSS1RectGeneral  NAME(SegmentSS1RectGeneral )
+ #define cfb8SegmentSS1RectShiftCopy NAME(SegmentSS1RectShiftCopy)
+ #define cfb8LineSS1RectCopy NAME(LineSS1RectCopy)
+ #define cfb8LineSS1RectXor NAME(LineSS1RectXor)
+ #define cfb8LineSS1RectGeneral  NAME(LineSS1RectGeneral )
+ #define cfb8LineSS1RectPreviousCopy NAME(LineSS1RectPreviousCopy)
+ #define cfbZeroPolyArcSS8Copy NAME(ZeroPolyArcSSCopy)
+ #define cfbZeroPolyArcSS8Xor NAME(ZeroPolyArcSSXor)
+ #define cfbZeroPolyArcSS8General NAME(ZeroPolyArcSSGeneral)
+ 
+ #endif /* PSZ != 8 */
*** /tmp/,RCSt1a16425	Tue Feb 11 15:13:18 1992
--- server/ddx/cfb/cfbmskbits.c	Thu Dec 19 18:36:30 1991
***************
*** 26,32 ****
  
  ********************************************************/
  
! /* $XConsortium: cfbmskbits.c,v 4.6 91/07/05 10:52:59 rws Exp $ */
  
  /*
   * ==========================================================================
--- 26,32 ----
  
  ********************************************************/
  
! /* $XConsortium: cfbmskbits.c,v 4.8 91/12/19 18:36:27 keith Exp $ */
  
  /*
   * ==========================================================================
***************
*** 49,56 ****
--- 49,67 ----
  #include	<X.h>
  #include	<Xmd.h>
  #include	<servermd.h>
+ #include	"cfb.h"
  
  #if	(BITMAP_BIT_ORDER == MSBFirst)
+ #define cfbBits(v)	(v)
+ #else
+ #define cfbFlip2(a)	((((a) & 0x1) << 1) | (((a) & 0x2) >> 1))
+ #define cfbFlip4(a)	((cfbFlip2(a) << 2) | cfbFlip2(a >> 2))
+ #define cfbFlip8(a)	((cfbFlip4(a) << 4) | cfbFlip4(a >> 4))
+ #define cfbFlip16(a)	((cfbFlip8(a) << 8) | cfbFlip8(a >> 8))
+ #define cfbFlip32(a)	((cfbFlip16(a) << 16) | cfbFlip16(a >> 16))
+ #define cfbBits(a)	cfbFlip32(a)
+ #endif
+ 
  /* NOTE:
  the first element in starttab could be 0xffffffff.  making it 0
  lets us deal with a full first word in the middle loop, rather
***************
*** 57,77 ****
  than having to do the multiple reads and masks that we'd
  have to do if we thought it was partial.
  */
  unsigned int cfbstarttab[] =
      {
! 	0x00000000,
! 	0x00FFFFFF,
! 	0x0000FFFF,
! 	0x000000FF
      };
  
  unsigned int cfbendtab[] =
      {
! 	0x00000000,
! 	0xFF000000,
! 	0xFFFF0000,
! 	0xFFFFFF00
      };
  
  /* a hack, for now, since the entries for 0 need to be all
     1 bits, not all zeros.
--- 68,136 ----
  than having to do the multiple reads and masks that we'd
  have to do if we thought it was partial.
  */
+ #if PSZ == 4
  unsigned int cfbstarttab[] =
      {
! 	cfbBits(0x00000000),
! 	cfbBits(0x0FFFFFFF),
! 	cfbBits(0x00FFFFFF),
! 	cfbBits(0x000FFFFF),
! 	cfbBits(0x0000FFFF),
! 	cfbBits(0x00000FFF)
! 	cfbBits(0x000000FF)
! 	cfbBits(0x0000000F)
      };
+ unsigned int cfbendtab[] =
+     {
+ 	cfbBits(0x00000000),
+ 	cfbBits(0xF0000000),
+ 	cfbBits(0xFF000000),
+ 	cfbBits(0xFFF00000),
+ 	cfbBits(0xFFFF0000),
+ 	cfbBits(0xFFFFF000),
+ 	cfbBits(0xFFFFFF00)
+ 	cfbBits(0xFFFFFFF0)
+     };
+ #endif
  
+ #if PSZ == 8
+ unsigned int cfbstarttab[] =
+     {
+ 	cfbBits(0x00000000),
+ 	cfbBits(0x00FFFFFF),
+ 	cfbBits(0x0000FFFF),
+ 	cfbBits(0x000000FF)
+     };
  unsigned int cfbendtab[] =
      {
! 	cfbBits(0x00000000),
! 	cfbBits(0xFF000000),
! 	cfbBits(0xFFFF0000),
! 	cfbBits(0xFFFFFF00)
      };
+ #endif
+ #if PSZ == 16
+ unsigned int cfbstarttab[] =
+     {
+ 	cfbBits(0x00000000),
+ 	cfbBits(0x0000FFFF),
+     };
+ unsigned int cfbendtab[] =
+     {
+ 	cfbBits(0x00000000),
+ 	cfbBits(0xFFFF0000),
+     };
+ #endif
+ #if PSZ == 32
+ unsigned int cfbstarttab[] =
+     {
+ 	cfbBits(0x00000000),
+     };
+ unsigned int cfbendtab[] = 
+     {
+ 	cfbBits(0x00000000),
+     };
+ #endif
  
  /* a hack, for now, since the entries for 0 need to be all
     1 bits, not all zeros.
***************
*** 78,144 ****
     this means the code DOES NOT WORK for segments of length
     0 (which is only a problem in the horizontal line code.)
  */
  unsigned int cfbstartpartial[] =
      {
! 	0xFFFFFFFF,
! 	0x00FFFFFF,
! 	0x0000FFFF,
! 	0x000000FF
      };
  
  unsigned int cfbendpartial[] =
      {
! 	0xFFFFFFFF,
! 	0xFF000000,
! 	0xFFFF0000,
! 	0xFFFFFF00
      };
! #else		/* (BITMAP_BIT_ORDER == LSBFirst) */
! /* NOTE:
! the first element in starttab could be 0xffffffff.  making it 0
! lets us deal with a full first word in the middle loop, rather
! than having to do the multiple reads and masks that we'd
! have to do if we thought it was partial.
! */
! unsigned int cfbstarttab[] = 
! 	{
! 	0x00000000,
! 	0xFFFFFF00,
! 	0xFFFF0000,
! 	0xFF000000
! 	};
  
! unsigned int cfbendtab[] = 
! 	{
! 	0x00000000,
! 	0x000000FF,
! 	0x0000FFFF,
! 	0x00FFFFFF
! 	};
  
! /* a hack, for now, since the entries for 0 need to be all
!    1 bits, not all zeros.
!    this means the code DOES NOT WORK for segments of length
!    0 (which is only a problem in the horizontal line code.)
! */
! unsigned int cfbstartpartial[] = 
! 	{
! 	0xFFFFFFFF,
! 	0xFFFFFF00,
! 	0xFFFF0000,
! 	0xFF000000
! 	};
  
! unsigned int cfbendpartial[] = 
! 	{
! 	0xFFFFFFFF,
! 	0x000000FF,
! 	0x0000FFFF,
! 	0x00FFFFFF
! 	};
! #endif	/* (BITMAP_BIT_ORDER == MSBFirst) */
  
- 
  /* used for masking bits in bresenham lines
     mask[n] is used to mask out all but bit n in a longword (n is a
  screen position).
--- 137,209 ----
     this means the code DOES NOT WORK for segments of length
     0 (which is only a problem in the horizontal line code.)
  */
+ #if PSZ == 4
  unsigned int cfbstartpartial[] =
      {
! 	cfbBits(0xFFFFFFFF),
! 	cfbBits(0x0FFFFFFF),
! 	cfbBits(0x00FFFFFF),
! 	cfbBits(0x000FFFFF),
! 	cfbBits(0x0000FFFF),
! 	cfbBits(0x00000FFF),
! 	cfbBits(0x000000FF)
! 	cfbBits(0x0000000F)
      };
  
  unsigned int cfbendpartial[] =
      {
! 	cfbBits(0xFFFFFFFF),
! 	cfbBits(0xF0000000),
! 	cfbBits(0xFF000000),
! 	cfbBits(0xFFF00000),
! 	cfbBits(0xFFFF0000),
! 	cfbBits(0xFFFFF000),
! 	cfbBits(0xFFFFFF00)
! 	cfbBits(0xFFFFFFF0)
      };
! #endif
! #if PSZ == 8
! unsigned int cfbstartpartial[] =
!     {
! 	cfbBits(0xFFFFFFFF),
! 	cfbBits(0x00FFFFFF),
! 	cfbBits(0x0000FFFF),
! 	cfbBits(0x000000FF)
!     };
  
! unsigned int cfbendpartial[] =
!     {
! 	cfbBits(0xFFFFFFFF),
! 	cfbBits(0xFF000000),
! 	cfbBits(0xFFFF0000),
! 	cfbBits(0xFFFFFF00)
!     };
! #endif
! #if PSZ == 16
! unsigned int cfbstartpartial[] =
!     {
! 	cfbBits(0xFFFFFFFF),
! 	cfbBits(0x0000FFFF),
!     };
  
! unsigned int cfbendpartial[] =
!     {
! 	cfbBits(0xFFFFFFFF),
! 	cfbBits(0xFFFF0000),
!     };
! #endif
! #if PSZ == 32
! unsigned int cfbstartpartial[] =
!     {
! 	cfbBits(0xFFFFFFFF),
!     };
  
! unsigned int cfbendpartial[] =
!     {
! 	cfbBits(0xFFFFFFFF),
!     };
! #endif
  
  /* used for masking bits in bresenham lines
     mask[n] is used to mask out all but bit n in a longword (n is a
  screen position).
***************
*** 146,178 ****
  is a screen posiotion.)
  */
  
! #if	(BITMAP_BIT_ORDER == MSBFirst)
  unsigned int cfbmask[] =
      {
! 	0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF
      }; 
  unsigned int cfbrmask[] = 
      {
! 	0x00FFFFFF, 0xFF00FFFF, 0xFFFF00FF, 0xFFFFFF00
      };
! #else	/* (BITMAP_BIT_ORDER == LSBFirst) */
  unsigned int cfbmask[] =
      {
! 	0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000
      }; 
  unsigned int cfbrmask[] = 
      {
! 	0xFFFFFF00, 0xFFFF00FF, 0xFF00FFFF, 0x00FFFFFF
      };
! #endif	/* (BITMAP_BIT_ORDER == MSBFirst) */
  
  /*
!  * QuartetBitsTable contains four masks whose binary values are masks in the
   * low order quartet that contain the number of bits specified in the
   * index.  This table is used by getstipplepixels.
   */
! unsigned int QuartetBitsTable[5] = {
  #if (BITMAP_BIT_ORDER == MSBFirst)
      0x00000000,                         /* 0 - 0000 */
      0x00000008,                         /* 1 - 1000 */
      0x0000000C,                         /* 2 - 1100 */
--- 211,312 ----
  is a screen posiotion.)
  */
  
! #if PSZ == 4
  unsigned int cfbmask[] =
      {
! 	cfbBits(0xF0000000),
! 	cfbBits(0x0F000000),
!  	cfbBits(0x00F00000),
!  	cfbBits(0x000F0000),
!  	cfbBits(0x0000F000),
!  	cfbBits(0x00000F00),
!  	cfbBits(0x000000F0),
!  	cfbBits(0x0000000F)
      }; 
  unsigned int cfbrmask[] = 
      {
! 	cfbBits(0x0FFFFFFF),
! 	cfbBits(0xF0FFFFFF),
!  	cfbBits(0xFF0FFFFF),
!  	cfbBits(0xFFF0FFFF),
!  	cfbBits(0xFFFF0FFF),
!  	cfbBits(0xFFFFF0FF),
!  	cfbBits(0xFFFFFF0F),
!  	cfbBits(0xFFFFFFF0)
      };
! #endif
! #if PSZ == 8
  unsigned int cfbmask[] =
      {
! 	cfbBits(0xFF000000),
!  	cfbBits(0x00FF0000),
!  	cfbBits(0x0000FF00),
!  	cfbBits(0x000000FF)
      }; 
  unsigned int cfbrmask[] = 
      {
! 	cfbBits(0x00FFFFFF),
!  	cfbBits(0xFF00FFFF),
!  	cfbBits(0xFFFF00FF),
!  	cfbBits(0xFFFFFF00)
      };
! #endif
! #if PSZ == 16
! unsigned int cfbmask[] =
!     {
! 	cfbBits(0xFFFF0000),
!  	cfbBits(0x0000FFFF),
!     }; 
! unsigned int cfbrmask[] = 
!     {
! 	cfbBits(0x0000FFFF),
!  	cfbBits(0xFFFF0000),
!     };
! #endif
! #if PSZ == 32
! unsigned int cfbmask[] =
!     {
! 	cfbBits(0xFFFFFFFF),
!     }; 
! unsigned int cfbrmask[] = 
!     {
! 	cfbBits(0xFFFFFFFF),
!     };
! #endif
  
  /*
!  * QuartetBitsTable contains PPW+1 masks whose binary values are masks in the
   * low order quartet that contain the number of bits specified in the
   * index.  This table is used by getstipplepixels.
   */
! #if PSZ == 4
! unsigned int QuartetBitsTable[] = {
  #if (BITMAP_BIT_ORDER == MSBFirst)
+     0x00000000,                         /* 0 - 00000000 */
+     0x00000080,				/* 1 - 10000000 */
+     0x000000C0,                         /* 2 - 11000000 */
+     0x000000E0,                         /* 3 - 11100000 */
+     0x000000F0,                         /* 4 - 11110000 */
+     0x000000F8,                         /* 5 - 11111000 */
+     0x000000FC,                         /* 6 - 11111100 */
+     0x000000FE,                         /* 7 - 11111110 */
+     0x000000FF,                         /* 8 - 11111111 */
+ #else /* (BITMAP_BIT_ORDER == LSBFirst */
+     0x00000000,                         /* 0 - 00000000 */
+     0x00000001,                         /* 1 - 00000001 */
+     0x00000003,                         /* 2 - 00000011 */
+     0x00000007,                         /* 3 - 00000111 */
+     0x0000000F                          /* 4 - 00001111 */
+     0x0000001F                          /* 5 - 00011111 */
+     0x0000003F                          /* 6 - 00111111 */
+     0x0000007F                          /* 7 - 01111111 */
+     0x000000FF                          /* 8 - 11111111 */
+ #endif /* (BITMAP_BIT_ORDER == MSBFirst) */
+ };
+ #endif
+ #if PSZ == 8
+ unsigned int QuartetBitsTable[] = {
+ #if (BITMAP_BIT_ORDER == MSBFirst)
      0x00000000,                         /* 0 - 0000 */
      0x00000008,                         /* 1 - 1000 */
      0x0000000C,                         /* 2 - 1100 */
***************
*** 186,215 ****
      0x0000000F                          /* 4 - 1111 */
  #endif /* (BITMAP_BIT_ORDER == MSBFirst) */
  };
  
  /*
   * QuartetPixelMaskTable is used by getstipplepixels to get a pixel mask
!  * corresponding to a quartet of bits.
   */
! unsigned int QuartetPixelMaskTable[16] = {
      0x00000000,
      0x000000FF,
      0x0000FF00,
      0x0000FFFF,
      0x00FF0000,
      0x00FF00FF,
      0x00FFFF00,
      0x00FFFFFF,
      0xFF000000,
      0xFF0000FF,
      0xFF00FF00,
      0xFF00FFFF,
      0xFFFF0000,
      0xFFFF00FF,
      0xFFFFFF00,
      0xFFFFFFFF
  };
! 
! #ifdef	vax
! #undef	VAXBYTEORDER
  #endif
--- 320,647 ----
      0x0000000F                          /* 4 - 1111 */
  #endif /* (BITMAP_BIT_ORDER == MSBFirst) */
  };
+ #endif
+ #if PSZ == 16
+ unsigned int QuartetBitsTable[] = {
+ #if (BITMAP_BIT_ORDER == MSBFirst)
+     0x00000000,                         /* 0 - 00 */
+     0x00000002,                         /* 1 - 10 */
+     0x00000003,                         /* 2 - 11 */
+ #else /* (BITMAP_BIT_ORDER == LSBFirst */
+     0x00000000,                         /* 0 - 00 */
+     0x00000001,                         /* 1 - 01 */
+     0x00000003,                         /* 2 - 11 */
+ #endif /* (BITMAP_BIT_ORDER == MSBFirst) */
+ };
+ #endif
+ #if PSZ == 32
+ unsigned int QuartetBitsTable[] = {
+ #if (BITMAP_BIT_ORDER == MSBFirst)
+     0x00000000,                         /* 0 - 0 */
+     0x00000001,                         /* 1 - 1 */
+ #else /* (BITMAP_BIT_ORDER == LSBFirst */
+     0x00000000,                         /* 0 - 0 */
+     0x00000001,                         /* 1 - 1 */
+ #endif /* (BITMAP_BIT_ORDER == MSBFirst) */
+ };
+ #endif
  
  /*
   * QuartetPixelMaskTable is used by getstipplepixels to get a pixel mask
!  * corresponding to a quartet of bits.  Note: the bit/byte order dependency
!  * is handled by QuartetBitsTable above.
   */
! #if PSZ == 4
! unsigned int QuartetPixelMaskTable[] = {
      0x00000000,
+     0x0000000F,
+     0x000000F0,
      0x000000FF,
+     0x00000F00,
+     0x00000F0F,
+     0x00000FF0,
+     0x00000FFF,
+     0x0000F000,
+     0x0000F00F,
+     0x0000F0F0,
+     0x0000F0FF,
      0x0000FF00,
+     0x0000FF0F,
+     0x0000FFF0,
      0x0000FFFF,
+     0x000F0000,
+     0x000F000F,
+     0x000F00F0,
+     0x000F00FF,
+     0x000F0F00,
+     0x000F0F0F,
+     0x000F0FF0,
+     0x000F0FFF,
+     0x000FF000,
+     0x000FF00F,
+     0x000FF0F0,
+     0x000FF0FF,
+     0x000FFF00,
+     0x000FFF0F,
+     0x000FFFF0,
+     0x000FFFFF,
+     0x00F00000,
+     0x00F0000F,
+     0x00F000F0,
+     0x00F000FF,
+     0x00F00F00,
+     0x00F00F0F,
+     0x00F00FF0,
+     0x00F00FFF,
+     0x00F0F000,
+     0x00F0F00F,
+     0x00F0F0F0,
+     0x00F0F0FF,
+     0x00F0FF00,
+     0x00F0FF0F,
+     0x00F0FFF0,
+     0x00F0FFFF,
      0x00FF0000,
+     0x00FF000F,
+     0x00FF00F0,
      0x00FF00FF,
+     0x00FF0F00,
+     0x00FF0F0F,
+     0x00FF0FF0,
+     0x00FF0FFF,
+     0x00FFF000,
+     0x00FFF00F,
+     0x00FFF0F0,
+     0x00FFF0FF,
      0x00FFFF00,
+     0x00FFFF0F,
+     0x00FFFFF0,
      0x00FFFFFF,
+     0x0F000000,
+     0x0F00000F,
+     0x0F0000F0,
+     0x0F0000FF,
+     0x0F000F00,
+     0x0F000F0F,
+     0x0F000FF0,
+     0x0F000FFF,
+     0x0F00F000,
+     0x0F00F00F,
+     0x0F00F0F0,
+     0x0F00F0FF,
+     0x0F00FF00,
+     0x0F00FF0F,
+     0x0F00FFF0,
+     0x0F00FFFF,
+     0x0F0F0000,
+     0x0F0F000F,
+     0x0F0F00F0,
+     0x0F0F00FF,
+     0x0F0F0F00,
+     0x0F0F0F0F,
+     0x0F0F0FF0,
+     0x0F0F0FFF,
+     0x0F0FF000,
+     0x0F0FF00F,
+     0x0F0FF0F0,
+     0x0F0FF0FF,
+     0x0F0FFF00,
+     0x0F0FFF0F,
+     0x0F0FFFF0,
+     0x0F0FFFFF,
+     0x0FF00000,
+     0x0FF0000F,
+     0x0FF000F0,
+     0x0FF000FF,
+     0x0FF00F00,
+     0x0FF00F0F,
+     0x0FF00FF0,
+     0x0FF00FFF,
+     0x0FF0F000,
+     0x0FF0F00F,
+     0x0FF0F0F0,
+     0x0FF0F0FF,
+     0x0FF0FF00,
+     0x0FF0FF0F,
+     0x0FF0FFF0,
+     0x0FF0FFFF,
+     0x0FFF0000,
+     0x0FFF000F,
+     0x0FFF00F0,
+     0x0FFF00FF,
+     0x0FFF0F00,
+     0x0FFF0F0F,
+     0x0FFF0FF0,
+     0x0FFF0FFF,
+     0x0FFFF000,
+     0x0FFFF00F,
+     0x0FFFF0F0,
+     0x0FFFF0FF,
+     0x0FFFFF00,
+     0x0FFFFF0F,
+     0x0FFFFFF0,
+     0x0FFFFFFF,
+     0xF0000000,
+     0xF000000F,
+     0xF00000F0,
+     0xF00000FF,
+     0xF0000F00,
+     0xF0000F0F,
+     0xF0000FF0,
+     0xF0000FFF,
+     0xF000F000,
+     0xF000F00F,
+     0xF000F0F0,
+     0xF000F0FF,
+     0xF000FF00,
+     0xF000FF0F,
+     0xF000FFF0,
+     0xF000FFFF,
+     0xF00F0000,
+     0xF00F000F,
+     0xF00F00F0,
+     0xF00F00FF,
+     0xF00F0F00,
+     0xF00F0F0F,
+     0xF00F0FF0,
+     0xF00F0FFF,
+     0xF00FF000,
+     0xF00FF00F,
+     0xF00FF0F0,
+     0xF00FF0FF,
+     0xF00FFF00,
+     0xF00FFF0F,
+     0xF00FFFF0,
+     0xF00FFFFF,
+     0xF0F00000,
+     0xF0F0000F,
+     0xF0F000F0,
+     0xF0F000FF,
+     0xF0F00F00,
+     0xF0F00F0F,
+     0xF0F00FF0,
+     0xF0F00FFF,
+     0xF0F0F000,
+     0xF0F0F00F,
+     0xF0F0F0F0,
+     0xF0F0F0FF,
+     0xF0F0FF00,
+     0xF0F0FF0F,
+     0xF0F0FFF0,
+     0xF0F0FFFF,
+     0xF0FF0000,
+     0xF0FF000F,
+     0xF0FF00F0,
+     0xF0FF00FF,
+     0xF0FF0F00,
+     0xF0FF0F0F,
+     0xF0FF0FF0,
+     0xF0FF0FFF,
+     0xF0FFF000,
+     0xF0FFF00F,
+     0xF0FFF0F0,
+     0xF0FFF0FF,
+     0xF0FFFF00,
+     0xF0FFFF0F,
+     0xF0FFFFF0,
+     0xF0FFFFFF,
      0xFF000000,
+     0xFF00000F,
+     0xFF0000F0,
      0xFF0000FF,
+     0xFF000F00,
+     0xFF000F0F,
+     0xFF000FF0,
+     0xFF000FFF,
+     0xFF00F000,
+     0xFF00F00F,
+     0xFF00F0F0,
+     0xFF00F0FF,
      0xFF00FF00,
+     0xFF00FF0F,
+     0xFF00FFF0,
      0xFF00FFFF,
+     0xFF0F0000,
+     0xFF0F000F,
+     0xFF0F00F0,
+     0xFF0F00FF,
+     0xFF0F0F00,
+     0xFF0F0F0F,
+     0xFF0F0FF0,
+     0xFF0F0FFF,
+     0xFF0FF000,
+     0xFF0FF00F,
+     0xFF0FF0F0,
+     0xFF0FF0FF,
+     0xFF0FFF00,
+     0xFF0FFF0F,
+     0xFF0FFFF0,
+     0xFF0FFFFF,
+     0xFFF00000,
+     0xFFF0000F,
+     0xFFF000F0,
+     0xFFF000FF,
+     0xFFF00F00,
+     0xFFF00F0F,
+     0xFFF00FF0,
+     0xFFF00FFF,
+     0xFFF0F000,
+     0xFFF0F00F,
+     0xFFF0F0F0,
+     0xFFF0F0FF,
+     0xFFF0FF00,
+     0xFFF0FF0F,
+     0xFFF0FFF0,
+     0xFFF0FFFF,
      0xFFFF0000,
+     0xFFFF000F,
+     0xFFFF00F0,
      0xFFFF00FF,
+     0xFFFF0F00,
+     0xFFFF0F0F,
+     0xFFFF0FF0,
+     0xFFFF0FFF,
+     0xFFFFF000,
+     0xFFFFF00F,
+     0xFFFFF0F0,
+     0xFFFFF0FF,
      0xFFFFFF00,
+     0xFFFFFF0F,
+     0xFFFFFFF0,
+     0xFFFFFFFF,
+ };
+ #endif
+ #if PSZ == 8
+ unsigned int QuartetPixelMaskTable[] = {
+     0x00000000,
+     0x000000FF,
+     0x0000FF00,
+     0x0000FFFF,
+     0x00FF0000,
+     0x00FF00FF,
+     0x00FFFF00,
+     0x00FFFFFF,
+     0xFF000000,
+     0xFF0000FF,
+     0xFF00FF00,
+     0xFF00FFFF,
+     0xFFFF0000,
+     0xFFFF00FF,
+     0xFFFFFF00,
      0xFFFFFFFF
  };
! #endif
! #if PSZ == 16
! unsigned int QuartetPixelMaskTable[] = {
!     0x00000000,
!     0x0000FFFF,
!     0xFFFF0000,
!     0xFFFFFFFF,
! };
! #endif
! #if PSZ == 32
! unsigned int QuartetPixelMaskTable[] = {
!     0x00000000,
!     0xFFFFFFFF,
! };
  #endif
