Path: news!news.crl.dec.com!pa.dec.com!nobody
Message-Id: <9207291423.AA03400@explain.lcs.mit.edu>
To: fix-trackers@expo.lcs.mit.edu
Subject: (seq: 2623) close XBUG #5319, #5320:  Xlib: Ximp error processing is incorrect
Date: Wed, 29 Jul 92 10:23:36 EDT
From: Bob Scheifler <rws@expo.lcs.mit.edu>
Distribution: dec
X-Mailing-List: fix-trackers@expo.lcs.mit.edu
X-Disclaimer: This message originated from a mailing list outside of Digital.
Newsgroups: dec.mail.lists.x.fix-trackers
Approved: news@usenet.pa.dec.com


Subject: Xlib: (Ximp) Memory will be destroyed when XGetIMValues() is called
### bug number:   5319
### area:         Xlib
### severity:     low
### comments:     

Subject: Xlib: Ximp error processing is incorrect
### bug number:   5320
### area:         Xlib
### severity:     low
### comments:     

*** /tmp/d03170	Wed Jul 29 10:17:23 1992
--- lib/X/Ximp/XIMProto.h	Wed Jul 29 10:15:36 1992
***************
*** 1,4 ****
! /* $XConsortium: XIMProto.h,v 1.5 92/04/14 13:28:34 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XIMProto.h,v 1.6 92/07/29 10:15:02 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
***************
*** 28,34 ****
  ******************************************************************/
  
  /* Ximp implementation revision */
! #define XIMP_REVISION "Ximp Revision 3.2"
  
  /* Ximp Protocol Version */
  #define XIMP_PROTOCOL_VERSION "XIMP.3.5"
--- 28,34 ----
  ******************************************************************/
  
  /* Ximp implementation revision */
! #define XIMP_REVISION "Ximp Revision 3.3"
  
  /* Ximp Protocol Version */
  #define XIMP_PROTOCOL_VERSION "XIMP.3.5"
*** /tmp/d03190	Wed Jul 29 10:17:35 1992
--- lib/X/Ximp/XimpCallbk.c	Wed Jul 29 10:15:43 1992
***************
*** 1,9 ****
! /* $XConsortium: XimpCallbk.c,v 1.5 92/04/14 13:28:40 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
                Copyright 1991, 1992 by FUJITSU LIMITED
                Copyright 1991, 1992 by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,10 ----
! /* $XConsortium: XimpCallbk.c,v 1.6 92/07/29 10:15:36 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
                Copyright 1991, 1992 by FUJITSU LIMITED
                Copyright 1991, 1992 by Sun Microsystems, Inc.
+               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 10,36 ****
  provided that the above copyright notice appear in all copies and that
  both that copyright notice and this permission notice appear in
  supporting documentation, and that the name of Fuji Xerox Co.,Ltd.,
! FUJITSU LIMITED, Sun Microsystems, Inc. not be used in advertising or
! publicity pertaining to distribution of the software without specific,
! written prior permission.  Fuji Xerox Co.,Ltd., FUJITSU LIMITED makes
  no representations about the suitability of this software for any
  purpose.  It is provided "as is" without express or implied warranty.
  
! FUJI XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS DISCLAIMS ALL
! WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJI
! XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS BE LIABLE FOR ANY
! SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
  RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
  CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
    Auther: Kazunori Nishihara,  Fuji Xerox Co.,Ltd.
-                                kaz@ssdev.ksp.fujixerox.co.jp
            Takashi Fujiwara     FUJITSU LIMITED
-                                fujiwara@a80.tech.yk.fujitsu.co.jp
            Hideki Hiura         Sun Microsystems, Inc.
!                                hhiura@Sun.COM
  ******************************************************************/
  
  #define NEED_EVENTS
--- 11,37 ----
  provided that the above copyright notice appear in all copies and that
  both that copyright notice and this permission notice appear in
  supporting documentation, and that the name of Fuji Xerox Co.,Ltd.,
! FUJITSU LIMITED, Sun Microsystems, Inc. and Sony Corporation not be
! used in advertising or publicity pertaining to distribution of the
! software without specific, written prior permission.
! Fuji Xerox Co.,Ltd., FUJITSU LIMITED and Sony Corporation make
  no representations about the suitability of this software for any
  purpose.  It is provided "as is" without express or implied warranty.
  
! FUJI XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS AND
! SONY CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJI XEROX CO.,LTD., FUJITSU LIMITED,
! SUN MICROSYSTEMS AND SONY CORPORATION BE LIABLE FOR ANY SPECIAL,
! INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
  RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
  CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
    Auther: Kazunori Nishihara,  Fuji Xerox Co.,Ltd.
            Takashi Fujiwara     FUJITSU LIMITED
            Hideki Hiura         Sun Microsystems, Inc.
!           Makoto Wakamatsu     Sony Corporation
  ******************************************************************/
  
  #define NEED_EVENTS
***************
*** 266,280 ****
      }
  }
  
! static int      _time_flag = 0;
! #ifdef XIMP_SIGNAL
! static int
! _time_out()
  {
!     _time_flag = 1;
  }
- #endif				/* XIMP_SIGNAL */
  
  void
  _Ximp_CallPreeditDrawCallback2(xic, event)
      Ximp_XIC        xic;
--- 267,307 ----
      }
  }
  
! static Bool
! _Ximp_DCMPredicate( d, ev, arg0 )
! Display		*d;
! XEvent		*ev;
! XPointer	arg0;
  {
!     XimpCMPredicateArg	arg = (XimpCMPredicateArg)arg0;
!     ICID		icid;
!     int			n;
! 
!     if( ev->type == ClientMessage ) {
! 	if( ev->xclient.message_type == arg->type ) {
! 	    if( ev->xclient.format == 8 ) {
! 		for( icid = 0, n = 0; n < 4; n++ ) {
! 		    icid <<= 8;
! 		    icid += ev->xclient.data.b[n];
! 		}
! 		if( icid == arg->icid )
! 		    return( True );
! 	    }
! 	    else if( ev->xclient.format == 32  &&
! 		     ev->xclient.data.l[0] == XIMP_ERROR  &&
! 		     ev->xclient.data.l[1] == arg->icid ) {
! 		return( True );
! 	    }
! 	}
!     }
!     else if( ev->type == DestroyNotify ) {
! 	if( ev->xdestroywindow.window == arg->owner ) {
! 	    return( True );
! 	}
!     }
  }
  
+ 
  void
  _Ximp_CallPreeditDrawCallback2(xic, event)
      Ximp_XIC        xic;
***************
*** 291,296 ****
--- 318,324 ----
      Atom            type;
      int             format;
      unsigned long   nitems, after;
+     XimpCMPredicateArgRec	Arg;
  
      bzero(&CallData, sizeof(XIMPreeditDrawCallbackStruct));
      bzero(&cbtext, sizeof(XIMText));
***************
*** 347,377 ****
  	    /*
  	     * Following Client message must be the preedit string.
  	     */
! #ifdef XIMP_SIGNAL
! 	    signal(SIGALRM, _time_out);
! 	    alarm(XIMP_TIME_OUT);
! #endif				/* XIMP_SIGNAL */
! 	    while (_time_flag != 1) {
! 		if ((XCheckTypedEvent(xic->core.im->core.display, ClientMessage, &ev)) == False) {
! #ifdef XIMP_SIGNAL
! 		    sleep(1);
! #endif				/* XIMP_SIGNAL */
! 		    continue;
! 		}
! 		if (ev.xclient.message_type != ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id) {
! 		    XPutBackEvent(xic->core.im->core.display, &ev);
! 		    continue;
! 		} else {
! #ifdef XIMP_SIGNAL
! 		    alarm(0);
! #endif				/* XIMP_SIGNAL */
! 		    break;
! 		}
! 	    }
  
  	    ctlen = ev.xclient.data.b[4];
  	    length = ctlen * XIMP_MB_CUR_MAX(xic->core.im->core.lcd);
- 	    _time_flag = 0;
  	    
  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
  		cbtext.string.wide_char = (wchar_t *) Xmalloc((length + 1) * sizeof(wchar_t));
--- 375,388 ----
  	    /*
  	     * Following Client message must be the preedit string.
  	     */
! 	    Arg.type = ((Ximp_XIM)xic->core.im)->ximp_impart->improtocol_id;
! 	    Arg.owner = ((Ximp_XIM)xic->core.im)->ximp_impart->fe_window;
! 	    Arg.icid = xic->ximp_icpart->icid;
! 	    if( !_XimpIfEvent( xic, &ev, _Ximp_DCMPredicate, (XPointer)&Arg ) )
! 		return;
  
  	    ctlen = ev.xclient.data.b[4];
  	    length = ctlen * XIMP_MB_CUR_MAX(xic->core.im->core.lcd);
  	    
  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
  		cbtext.string.wide_char = (wchar_t *) Xmalloc((length + 1) * sizeof(wchar_t));
***************
*** 648,659 ****
      Ximp_XIC        xic;
      XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
!     char           *text;
!     int             length;
      XIMStatusDrawCallbackStruct CallData;
!     XIMText         cbtext;
!     XEvent          ev;
  
      cb = &xic->core.status_attr.callbacks.draw;
      CallData.type = ToXIMStatusDataType(event->data.l[2]);
--- 659,671 ----
      Ximp_XIC        xic;
      XClientMessageEvent *event;
  {
!     register XIMCallback	*cb;
!     char			*text;
!     int             		length;
      XIMStatusDrawCallbackStruct CallData;
!     XIMText         		cbtext;
!     XEvent          		ev;
!     XimpCMPredicateArgRec	Arg;
  
      cb = &xic->core.status_attr.callbacks.draw;
      CallData.type = ToXIMStatusDataType(event->data.l[2]);
***************
*** 660,687 ****
      if (CallData.type == XIMTextType) {
  	CallData.data.text = &cbtext;
  
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif				/* XIMP_SIGNAL */
! 	while (_time_flag != 1) {
! 	    if ((XCheckTypedEvent(xic->core.im->core.display, ClientMessage, &ev)) == False) {
! #ifdef XIMP_SIGNAL
! 		sleep(1);
! #endif				/* XIMP_SIGNAL */
! 		continue;
! 	    }
! 	    if (ev.xclient.message_type != ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id) {
! 		XPutBackEvent(xic->core.im->core.display, &ev);
! 		continue;
! 	    } else {
! #ifdef XIMP_SIGNAL
! 		alarm(0);
! #endif				/* XIMP_SIGNAL */
! 		break;
! 	    }
! 	}
! 	_time_flag = 0;
  	if (cb->callback) {
  	    length = ev.xclient.data.b[4];
  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
--- 672,683 ----
      if (CallData.type == XIMTextType) {
  	CallData.data.text = &cbtext;
  
! 	Arg.type = ((Ximp_XIM)xic->core.im)->ximp_impart->improtocol_id;
! 	Arg.owner = ((Ximp_XIM)xic->core.im)->ximp_impart->fe_window;
! 	Arg.icid = xic->ximp_icpart->icid;
! 	if( !_XimpIfEvent( xic, &ev, _Ximp_DCMPredicate, (XPointer)&Arg ) )
! 	    return;
! 
  	if (cb->callback) {
  	    length = ev.xclient.data.b[4];
  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
*** /tmp/d03209	Wed Jul 29 10:17:47 1992
--- lib/X/Ximp/XimpExten.c	Wed Jul 29 10:15:50 1992
***************
*** 1,33 ****
! /* $XConsortium: XimpExten.c,v 1.5 92/04/14 13:29:00 rws Exp $ */
  /******************************************************************
  
      Copyright 1991, 1992 by FUJITSU LIMITED.
      Copyright 1991, 1992 by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
  provided that the above copyright notice appear in all copies and that
  both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of FUJITSU LIMITED or Sun
! Microsystems, Inc.  not be used in advertising or publicity pertaining
! to distribution of the software without specific, written prior
! permission.  FUJITSU LIMITED and Sun Microsystems, Inc. make no
! representations about the suitability of this software for any
! purpose.  It is provided "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SUN MICROSYSTEMS, INC. DISCLAIMS ALL WARRANTIES
! WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND SUN
! MICROSYSTEMS, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
! CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
! USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
! OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
! PERFORMANCE OF THIS SOFTWARE.
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
- 		       fujiwara@a80.tech.yk.fujitsu.co.jp
          Hideki Hiura         Sun Microsystems, Inc.
! 	               hhiura@Sun.COM
  ******************************************************************/
  
  #define NEED_EVENTS
--- 1,34 ----
! /* $XConsortium: XimpExten.c,v 1.6 92/07/29 10:15:43 rws Exp $ */
  /******************************************************************
  
      Copyright 1991, 1992 by FUJITSU LIMITED.
      Copyright 1991, 1992 by Sun Microsystems, Inc.
+     Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
  provided that the above copyright notice appear in all copies and that
  both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of FUJITSU LIMITED, Sun
! Microsystems, Inc. and Sony Corporation not be used in advertising
! or publicity pertaining to distribution of the software without
! specific, written prior permission. FUJITSU LIMITED, Sun Microsystems,
! Inc. and Sony Corporation make no representations about the suitability
! of this software for any purpose.  It is provided "as is" without
! express or implied warranty.
  
! FUJITSU LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION DISCLAIMS
! ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU
! LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION BE LIABLE FOR
! ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
! OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
          Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporation
  ******************************************************************/
  
  #define NEED_EVENTS
***************
*** 37,54 ****
  #include "Xlcint.h"
  #include "Ximplc.h"
  
- #ifdef XIMP_SIGNAL
- #include <sys/signal.h>
- #endif /* XIMP_SIGNAL */
- static int	_time_flag = 0;
- #ifdef XIMP_SIGNAL
- static int
- _time_out()
- 	{
- 	_time_flag = 1;
- 	}
- #endif /* XIMP_SIGNAL */
- 
  #define		XIM_UNKNOWN_KEYSYM	0x77777777
  #define		XIM_UNDETERMINED	0x77777776
  
--- 38,43 ----
***************
*** 144,149 ****
--- 133,140 ----
  #define XNExtXimp_AuxProcessCallback    "XNExtXimp_AuxProcessCallback"
  #define XNExtXimp_AuxDoneCallback       "XNExtXimp_AuxDoneCallback"
  #define XNExtXimp_LookupBegin	        "XNExtXimp_LookupBegin"
+ #define XNExtXimp_RestartCallback	"XNExtXimp_RestartCallback"
+ #define XNExtXimp_DestroyCallback	"XNExtXimp_DestroyCallback"
  
  /*
   * Ximp properties for extented XIC attribute
***************
*** 202,207 ****
--- 193,200 ----
  Private int     ximp_ext_aux_draw_callback();
  Private int     ximp_ext_aux_process_callback();
  Private int     ximp_ext_aux_done_callback();
+ Private int     ximp_ext_restart_callback();
+ Private int     ximp_ext_destroy_callback();
  Private int	nested_list();
  
  /* If you need to extend IC attributes, please add function here */
***************
*** 228,233 ****
--- 221,228 ----
  	XNExtXimp_AuxProcessCallback, ximp_ext_aux_process_callback,
  	XNExtXimp_AuxDoneCallback, ximp_ext_aux_done_callback,
  	XNExtXimp_LookupBegin, ximp_ext_lookup_begin,
+ 	XNExtXimp_RestartCallback, ximp_ext_restart_callback,
+ 	XNExtXimp_DestroyCallback, ximp_ext_destroy_callback,
      /*
       * If you need to extend IC attributes, please add attribute/function
       * here
***************
*** 302,310 ****
  
  
  typedef struct {
! 	Atom message_type;
! 	Atom ext_type;
! 	Window owner;
  } XimpConversionPredArgRec, *XimpConversionPredArg;
  
  Private Bool
--- 297,306 ----
  
  
  typedef struct {
! 	Atom	message_type;
! 	Atom	ext_type;
! 	Window	owner;
! 	ICID	icid;
  } XimpConversionPredArgRec, *XimpConversionPredArg;
  
  Private Bool
***************
*** 323,344 ****
  {
      XimpConversionPredArg arg = (XimpConversionPredArg) arg0;
  
! 	if (ev->type == ClientMessage) {
! 		if (ev->xclient.message_type == arg->message_type) {
! 			if (ev->xclient.format == 32) {
! 				if(ev->xclient.data.l[0] == XIMP_ERROR)
! 					return(True);
! 				else if(ev->xclient.data.l[0] == XIMP_EXTENSION
! 				     && ev->xclient.data.l[3] == arg->ext_type)
! 					return(True);
! 			}
! 		}
! 	} else if (ev->type == DestroyNotify) {
! 		if (ev->xdestroywindow.window == arg->owner) {
! 			return(True);
! 		}
  	}
! 	return(False);
  }
  
  Private int
--- 319,340 ----
  {
      XimpConversionPredArg arg = (XimpConversionPredArg) arg0;
  
!     if( ev->type == ClientMessage ) {
! 	if( ev->xclient.message_type == arg->message_type  &&
! 	    ev->xclient.format == 32  &&
! 	    ev->xclient.data.l[1] == arg->icid ) {
! 	    if( ev->xclient.data.l[0] == XIMP_ERROR )
! 		return( True );
! 	    else if( ev->xclient.data.l[0] == XIMP_EXTENSION  &&
! 		     ev->xclient.data.l[2] == arg->ext_type )
! 		return( True );
  	}
!     } else if( ev->type == DestroyNotify ) {
! 	if( ev->xdestroywindow.window == arg->owner ) {
! 	    return( True );
! 	}
!     }
!     return( False );
  }
  
  Private int
***************
*** 376,428 ****
  	return True;
  	break;
      case XICOpGet:
! 	if(ic->ximp_icpart->icid == NULL) {
! 		if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
! 			return (False);
! 		*((long *) value) = (long)(ext_im->extension_conversion);
! 		return (True);
! 		}
! 	_Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
  		     ext_im->extension_conversion_id,
  		     False,	/* GetICVelues */
! 		     value);
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
  	Arg.message_type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.ext_type     = ext_im->extension_conversion_id;
  	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	while(_time_flag != 1) {
! 		if( (XCheckIfEvent(ic->core.im->core.display, &event, ximp_ext_conversionPredicate, (XPointer)&Arg)) == False) {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
! 			}
! 		if(event.type == ClientMessage &&
! 		   event.xclient.data.l[0] == XIMP_EXTENSION) {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			ext_im->extension_conversion = (Bool)event.xclient.data.l[4];
! 			*((long *) value) = (long)(ext_im->extension_conversion);
! 			_time_flag = 0;
! 			return(True);
! 			}
! 		else {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
! 			_time_flag = 0;
! 			/* return(False); */
! 			continue;
! 			}
! 		}
! 	_time_flag = 0;
! 	return(False);
! 	break;
      }
      return (False);
  }
--- 372,396 ----
  	return True;
  	break;
      case XICOpGet:
! 	if( ic->ximp_icpart->icid == NULL ) {
! 	    if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
! 		return( False );
! 	    *((long *) value) = (long)(ext_im->extension_conversion);
! 	    return (True);
! 	}
! 	_Ximp_IM_SendMessage( ic, XIMP_EXTENSION,
  		     ext_im->extension_conversion_id,
  		     False,	/* GetICVelues */
! 		     value );
  	Arg.message_type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.ext_type = ext_im->extension_conversion_id;
  	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	Arg.icid = ic->ximp_icpart->icid;
! 	if( !_XimpIfEvent( ic, &event, ximp_ext_conversionPredicate, (XPointer)&Arg ) )
! 	    return( False );
! 	ext_im->extension_conversion = (Bool)event.xclient.data.l[4];
! 	*((long *) value) = (long)(ext_im->extension_conversion);
! 	return( True );
      }
      return (False);
  }
***************
*** 714,719 ****
--- 682,733 ----
      return (False);
  }
  
+ Private int
+ ximp_ext_restart_callback( ic, op, value )
+ Ximp_XIC        ic;
+ XICOp_t         op;
+ long            value;
+ {
+     switch( op ) {
+       case XICOpCreate:
+       case XICOpSet:
+ 	ic->ximp_icpart->restart.client_data = ((XIMCallback *)value)->client_data;
+ 	ic->ximp_icpart->restart.callback = ((XIMCallback *)value)->callback;
+ 	return( True );
+ 	break;
+ 
+       case XICOpGet:
+ 	/*
+ 	 * NOT surely implemented Yet. Need attention.
+ 	 */
+ 	break;
+     }
+     return( False );
+ }
+ 
+ Private int
+ ximp_ext_destroy_callback( ic, op, value )
+ Ximp_XIC        ic;
+ XICOp_t         op;
+ long            value;
+ {
+     switch( op ) {
+       case XICOpCreate:
+       case XICOpSet:
+ 	ic->ximp_icpart->destroy.client_data = ((XIMCallback *)value)->client_data;
+ 	ic->ximp_icpart->destroy.callback = ((XIMCallback *)value)->callback;
+ 	return( True );
+ 	break;
+ 
+       case XICOpGet:
+ 	/*
+ 	 * NOT surely implemented Yet. Need attention.
+ 	 */
+ 	break;
+     }
+     return( False );
+ }
+ 
  static void _Ximp_Extlookupstart();
  static void _Ximp_Extlookupdraw();
  static void _Ximp_Extlookupprocess();
***************
*** 1277,1283 ****
  
      icid = ev->data.l[1];
      ext_id = ev->data.l[2];
!     ic = _Ximp_LookupXIC(icid);
  
      im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
--- 1291,1298 ----
  
      icid = ev->data.l[1];
      ext_id = ev->data.l[2];
!     if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	return;
  
      im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
***************
*** 1290,1293 ****
--- 1305,1333 ----
      } else;
      /* Add extension here */
      return;
+ }
+ 
+ 
+ void
+ _Ximp_CallRestartCallbackExtension( xic )
+ Ximp_XIC		xic;
+ {
+     register	XIMCallback	*cb;
+ 
+     cb = &xic->ximp_icpart->restart;
+     if( cb->callback ) {
+ 	(*cb->callback)( xic, cb->client_data, NULL );
+     }
+ }
+ 
+ void
+ _Ximp_CallDestroyCallbackExtension( xic )
+ Ximp_XIC		xic;
+ {
+     register	XIMCallback	*cb;
+ 
+     cb = &xic->ximp_icpart->destroy;
+     if( cb->callback ) {
+ 	(*cb->callback)( xic, cb->client_data, NULL );
+     }
  }
*** /tmp/d03228	Wed Jul 29 10:17:59 1992
--- lib/X/Ximp/XimpIC.c	Wed Jul 29 10:15:55 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpIC.c,v 1.6 92/04/14 13:29:06 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpIC.c,v 1.7 92/07/29 10:15:50 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
***************
*** 136,142 ****
  						_Ximp_XimFilter_Keypress,
  						(XPointer)ic);
  			ic->ximp_icpart->filter_mode |= 0x1;
! 		}
  	}
  	return((XIC)ic);
  
--- 136,147 ----
  						_Ximp_XimFilter_Keypress,
  						(XPointer)ic);
  			ic->ximp_icpart->filter_mode |= 0x1;
! 			_XRegisterFilterByType(ic->core.im->core.display,
! 					       ic->core.focus_window,
! 					       ClientMessage, ClientMessage,
! 					       _Ximp_XimFilter_Client, NULL);
! 			ic->ximp_icpart->filter_mode |= 0x2;
! 		    }
  	}
  	return((XIC)ic);
  
***************
*** 162,167 ****
--- 167,176 ----
  				   _Ximp_XimFilter_Client, (XPointer)NULL);
  	}
   	_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
+ 	if( ic->ximp_icpart->preedit_font )
+ 	    Xfree( ic->ximp_icpart->preedit_font );
+ 	if( ic->ximp_icpart->status_font )
+ 	    Xfree( ic->ximp_icpart->status_font );
  	Xfree(ic->ximp_icpart);
  	return;
  }
***************
*** 201,222 ****
  _Ximp_SetFocusWindow(ic)
  	Ximp_XIC	 ic;
  {
- 	Atom		 actual_type;
- 	int		 actual_format;
- 	unsigned long	 nitems, bytes_after;
- 	int		*prop_int;
- 
- 	while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
- 			0L, 1000000L, False, XA_WINDOW,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop_int);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop_int);
- 		}
  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
  			XA_WINDOW, 32, PropModeReplace,
--- 210,215 ----
***************
*** 253,262 ****
  	Ximp_XIC		 ic;
  {
  	Ximp_PreeditPropRec	*preedit_atr;
- 	Atom			 actual_type;
- 	int			 actual_format;
- 	unsigned long		 nitems, bytes_after;
- 	int			*prop_int;
  	unsigned char		 prop_data[XIMP_PREEDIT_MAX_CHAR];
  
  	preedit_atr = &(ic->ximp_icpart->preedit_attr);
--- 246,251 ----
***************
*** 275,292 ****
  	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.x,    48);
  	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.y,    52);
  
- 	while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
- 			0L, 1000000L, False,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)(&prop_int));
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop_int);
- 		}
  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
  			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
--- 264,269 ----
***************
*** 298,320 ****
  _Ximp_SetPreeditFont(ic)
  	Ximp_XIC		 ic;
  {
- 	Atom			actual_type;
- 	int			actual_format;
- 	unsigned long		nitems, bytes_after;
- 	char			*prop;
- 
  	if (ic->core.preedit_attr.fontset != NULL) {
- 	    while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id,
- 			0L, 1000000L, False, XA_STRING,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop);
- 	        }
  	    XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id,
  			XA_STRING, 8, PropModeReplace,
--- 275,281 ----
***************
*** 329,338 ****
  	Ximp_XIC		 ic;
  {
  	Ximp_StatusPropRec	*status_atr;
- 	Atom			 actual_type;
- 	int			 actual_format;
- 	unsigned long		 nitems, bytes_after;
- 	int			*prop_int;
  	unsigned char		 prop_data[XIMP_STATUS_MAX_CHAR];
  
  	status_atr = &(ic->ximp_icpart->status_attr);
--- 290,295 ----
***************
*** 350,367 ****
  	_Ximp_AttributesSetL(prop_data, status_atr->AreaNeeded.height, 44);
  	_Ximp_AttributesSetL(prop_data, status_atr->window,            48);
  
- 	while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
- 			0L, 1000000L, False,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop_int);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop_int);
- 		}
  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
  			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
--- 307,312 ----
***************
*** 373,395 ****
  _Ximp_SetStatusFont(ic)
  	Ximp_XIC		ic;
  {
- 	Atom			actual_type;
- 	int			actual_format;
- 	unsigned long		nitems, bytes_after;
- 	char			*prop;
- 
  	if (ic->core.status_attr.fontset != NULL) {
- 	    while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id,
- 			0L, 1000000L, False, XA_STRING,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop);
- 		}
  	    XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id,
  			XA_STRING, 8, PropModeReplace,
--- 318,324 ----
*** /tmp/d03247	Wed Jul 29 10:18:10 1992
--- lib/X/Ximp/XimpICG.c	Wed Jul 29 10:16:03 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpICG.c,v 1.8 92/04/22 15:46:03 rws Exp $ */
  /******************************************************************
  
      Copyright 1991, 1992 by FUJITSU LIMITED.
--- 1,4 ----
! /* $XConsortium: XimpICG.c,v 1.9 92/07/29 10:15:56 rws Exp $ */
  /******************************************************************
  
      Copyright 1991, 1992 by FUJITSU LIMITED.
***************
*** 28,34 ****
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
          Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
--- 28,34 ----
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
          Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
***************
*** 40,51 ****
  
  #include "Ximplc.h"
  
- #ifdef XIMP_SIGNAL
- #include <sys/signal.h>
- #endif /* XIMP_SIGNAL */
- 
  extern char 		*_Ximp_GetICValues();
  extern Bool		 _Ximp_GetICExtension();
  
  static Bool 		 _Ximp_PreGetAttributes();
  static Bool 		 _Ximp_StatusGetAttributes();
--- 40,48 ----
  
  #include "Ximplc.h"
  
  extern char 		*_Ximp_GetICValues();
  extern Bool		 _Ximp_GetICExtension();
+ extern Bool		_Ximp_CMPredicate();
  
  static Bool 		 _Ximp_PreGetAttributes();
  static Bool 		 _Ximp_StatusGetAttributes();
***************
*** 629,658 ****
  	return(True);
  }
  
- static int	 _time_flag = 0;
- 
- #ifdef XIMP_SIGNAL
- static int
- _time_out()
- {
- 	_time_flag = 1;
- }
- #endif /* XIMP_SIGNAL */
- 
- static Bool Check_Message(display, event, arg)
-     Display *display;
-     XEvent  *event;
-     XPointer arg;
- {
-     if ( event->type == ClientMessage && 
- 	 event->xclient.message_type == 
- 	 ((Ximp_XIM)arg)->ximp_impart->improtocol_id )
- 	return True;
-     else
- 	return False;
- }
- 
- 
  static XPointer
  _Ximp_GetRequestIM(ic, mask, get_atom_id, atom_id)
  	Ximp_XIC	 ic;
--- 626,631 ----
***************
*** 659,708 ****
  	unsigned long	 mask;
  	Atom		 get_atom_id, atom_id;
  {
! 	XEvent		 event;
! 	Atom            actual_type_ret;
! 	int		actual_format_ret;
! 	unsigned long   nitems_ret;
! 	unsigned long   bytes_after_ret;
! 	unsigned char   *data;
  
! 	if(ic->ximp_icpart->icid == (ICID)NULL)
! 		return(NULL);
! 	if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN))
! 		return(NULL);
  
! 	_Ximp_IM_SendMessage(ic, XIMP_GETVALUE, mask, NULL, NULL);
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
  
! 	while(_time_flag != 1) {
! 		if (XCheckIfEvent(ic->core.im->core.display, &event, 
! 			Check_Message, (XPointer)ic->core.im) ) {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			break;
! 		} else {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
! 		}
! 	}
! 	_time_flag = 0;
  
! 	if(event.xclient.data.l[0] != XIMP_GETVALUE_RETURN)
! 		return(NULL);
! 
! 	XGetWindowProperty(ic->core.im->core.display,
! 			   ic->core.client_window,
! 			   get_atom_id, 0L, 1000000L, True, atom_id,
! 			   &actual_type_ret, &actual_format_ret, &nitems_ret,
! 			   &bytes_after_ret, &data);
! 
!         if(actual_format_ret == 0 || nitems_ret == 0)
! 		return(NULL);
! 	return((XPointer)data);
  }
--- 632,665 ----
  	unsigned long	 mask;
  	Atom		 get_atom_id, atom_id;
  {
!     XEvent		event;
!     Atom        	actual_type_ret;
!     int			actual_format_ret;
!     unsigned long	nitems_ret;
!     unsigned long	bytes_after_ret;
!     unsigned char	*data;
!     XimpCMPredicateArgRec	Arg;
  
!     if(ic->ximp_icpart->icid == (ICID)NULL)
! 	return(NULL);
!     if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN))
! 	return(NULL);
  
!     _Ximp_IM_SendMessage(ic, XIMP_GETVALUE, mask, NULL, NULL);
!     Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
!     Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
!     Arg.protocol = XIMP_GETVALUE_RETURN;
!     Arg.icid = ic->ximp_icpart->icid;
!     if( !_XimpIfEvent( ic, &event, _Ximp_CMPredicate, (XPointer)&Arg ) )
! 	return( NULL );
  
!     XGetWindowProperty(ic->core.im->core.display,
! 		       ic->core.client_window,
! 		       get_atom_id, 0L, 1000000L, True, atom_id,
! 		       &actual_type_ret, &actual_format_ret, &nitems_ret,
! 		       &bytes_after_ret, &data);
  
!     if(actual_format_ret == 0 || nitems_ret == 0)
! 	return(NULL);
!     return((XPointer)data);
  }
*** /tmp/d03267	Wed Jul 29 10:18:22 1992
--- lib/X/Ximp/XimpICS.c	Wed Jul 29 10:16:09 1992
***************
*** 1,8 ****
! /* $XConsortium: XimpICS.c,v 1.3 92/04/14 13:29:14 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpICS.c,v 1.4 92/07/29 10:16:04 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 26,35 ****
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
  #include "Xlibint.h"
  #include "Xlcint.h"
  
--- 26,36 ----
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
+ #define	NEED_EVENTS
  #include "Xlibint.h"
  #include "Xlcint.h"
  
***************
*** 51,56 ****
--- 52,128 ----
  static Bool		_Ximp_PreSetAttributes();
  static Bool		_Ximp_StatusSetAttributes();
  
+ 
+ static Bool
+ _Ximp_PNPredicate( d, ev, arg0 )
+ Display		*d;
+ XEvent		*ev;
+ XPointer	arg0;
+ {
+     XimpPNPredicateArg arg = (XimpPNPredicateArg)arg0;
+ 
+     if( ev->type == PropertyNotify ) {
+ 	if( ev->xproperty.window == arg->window  &&
+ 	    ev->xproperty.atom == arg->atom  &&
+ 	    ev->xproperty.state == PropertyDelete ) {
+ 	    return(True);
+ 	}
+     }
+     else if( ev->type == ClientMessage ) {
+ 	if( ev->xclient.message_type == arg->type  &&
+ 	    ev->xclient.format == 32  &&
+ 	    ev->xclient.data.l[1] == arg->icid  &&
+ 	    ev->xclient.data.l[0] == XIMP_ERROR )
+ 	    return( True );
+     }
+     else if( ev->type == DestroyNotify ) {
+ 	if( ev->xdestroywindow.window == arg->owner ) {
+ 	    return( True );
+ 	}
+     }
+     return( False );
+ }
+ 
+ Bool
+ _XimpPNIfEvent( ic, atom )
+ Ximp_XIC	ic;
+ Atom		atom;
+ {
+     XEvent			event;
+     XimpPNPredicateArgRec	Arg;	
+ 
+     Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
+     Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
+     Arg.icid = ic->ximp_icpart->icid;
+     Arg.window = ic->core.client_window;
+     Arg.atom = atom;
+     XIfEvent( ic->core.im->core.display, &event, _Ximp_PNPredicate, (XPointer)&Arg );
+     if( event.type != PropertyNotify ) {
+ 	XPutBackEvent( ic->core.im->core.display, &event );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
+ 	if( event.type == DestroyNotify )
+ 	    XPutBackEvent( ic->core.im->core.display, &event );
+ 	else
+ 	    _Ximp_ProcError( ic, ic->core.im->core.display, NULL, &event );
+ 	return( False );
+     }
+     return( True );
+ }
+ 
  char *
  _Ximp_SetICValues(ic, values)
  	Ximp_XIC	 ic;
***************
*** 117,126 ****
  	else {
  		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
  		}
! 	if(change_mask)
!  		_Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
! 	return(ret);
  	}
  
  char *
  _Ximp_SetICValueData(ic, values, mode, change_mask)
--- 189,222 ----
  	else {
  		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
  		}
! 	if(change_mask) {
! 	    XWindowAttributes		war;
! 	    long			mask;
! 
! 	    XGetWindowAttributes( ic->core.im->core.display,
! 				  ic->core.client_window, &war );
! 	    XSelectInput( ic->core.im->core.display, ic->core.client_window,
! 			  war.your_event_mask | PropertyChangeMask );
! 	    _Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
! 	    if( change_mask & XIMP_PROP_FOCUS )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_PREEDIT )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_PREFONT )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_STATUS )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_STSFONT )
! 		!_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
! 	    XSelectInput( ic->core.im->core.display, ic->core.client_window,
! 			  war.your_event_mask );
  	}
+ 	return(ret);
+ }
  
  char *
  _Ximp_SetICValueData(ic, values, mode, change_mask)
***************
*** 144,158 ****
  		else if(strcmp(p->name, XNClientWindow)==0) {
  			if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
  				if(mode == XIMP_SET_IC && (ic->ximp_icpart->icid)) {
! 					_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
! 					XDestroyWindow(ic->core.im->core.display,
! 						       ic->core.client_window);
! 					ic->core.client_window = (Window)p->value;
  					ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
  					if(_Ximp_SetOpenXIMP(ic, mode) == False) {
  						return_name = p->name;
  						break;
  						}
  					*change_mask = NULL;
  					}
  				else { /* XIMP_CREATE_IC | (XIMP_SET_IC && XIMP_START_IC) */
--- 240,264 ----
  		else if(strcmp(p->name, XNClientWindow)==0) {
  			if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
  				if(mode == XIMP_SET_IC && (ic->ximp_icpart->icid)) {
! 					long	icid_old, icid_new;
! 					Window	client_window;
! 
! 					icid_old = ic->ximp_icpart->icid;
! 					client_window = ic->core.client_window;
  					ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
+ 					ic->core.client_window = (Window)p->value;
  					if(_Ximp_SetOpenXIMP(ic, mode) == False) {
  						return_name = p->name;
+ 						ic->ximp_icpart->value_mask &= ~XIMP_CLIENT_WIN;
+ 						ic->core.client_window = client_window;
  						break;
  						}
+ 					icid_new = ic->ximp_icpart->icid;
+ 					ic->ximp_icpart->icid = icid_old;
+ 					_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
+ 					ic->ximp_icpart->icid = icid_new;
+ 					XDestroyWindow(ic->core.im->core.display,
+ 						       client_window);
  					*change_mask = NULL;
  					}
  				else { /* XIMP_CREATE_IC | (XIMP_SET_IC && XIMP_START_IC) */
***************
*** 333,339 ****
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				tmp = Xmalloc(len + i + 1);
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
--- 439,448 ----
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				if( (tmp = Xmalloc(len + i + 1)) == NULL ) {
! 				    return_name = p->name;
! 				    return( False );
! 				}
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
***************
*** 480,486 ****
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				tmp = Xmalloc(len + i + 1);
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
--- 589,598 ----
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				if( (tmp = Xmalloc(len + i + 1)) == NULL ) {
! 				    return_name = p->name;
! 				    return( False );
! 				}
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
*** /tmp/d03286	Wed Jul 29 10:18:33 1992
--- lib/X/Ximp/XimpIM.c	Wed Jul 29 10:16:16 1992
***************
*** 1,8 ****
! /* $XConsortium: XimpIM.c,v 1.6 92/04/14 13:29:18 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpIM.c,v 1.8 92/07/29 10:16:10 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 26,32 ****
  PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
! 	  Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
--- 26,32 ----
  PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
! 	  Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
***************
*** 156,168 ****
  		XFree( ximp_impart->process_start_keys->keys_list );
  		XFree( ximp_impart->process_start_keys );
  	}
! 	if(ximp_impart->connectserver) {
! 		for(i=0; i < Ximp_Xim_count; i++) {
! 			if(Ximp_Xim_List[i] == im) {
! 				Ximp_Xim_List[i] = NULL;
! 				break;
! 			}
  		}
  		_Ximp_SetupFreeExtension(im);
  		_Ximp_SetupFree(ximp_impart->im_proto_vl,
  				ximp_impart->im_styles,
--- 156,168 ----
  		XFree( ximp_impart->process_start_keys->keys_list );
  		XFree( ximp_impart->process_start_keys );
  	}
! 	for(i=0; i < Ximp_Xim_count; i++) {
! 		if(Ximp_Xim_List[i] == im) {
! 			Ximp_Xim_List[i] = NULL;
! 			break;
  		}
+ 	}
+ 	if(ximp_impart->connectserver) {
  		_Ximp_SetupFreeExtension(im);
  		_Ximp_SetupFree(ximp_impart->im_proto_vl,
  				ximp_impart->im_styles,
***************
*** 255,262 ****
  			XA_STRING, &actual_type, &actual_format, &nitems,
  			&bytes_after, (unsigned char **)(&prop)) != Success)
  		return(False);
! 	if((version = Xmalloc((sizeof(char) * nitems + 1))) == NULL)
  		return(False);
  	strncpy(version, prop, nitems);
  	version[nitems] = '\0';
  	XFree(prop);
--- 255,264 ----
  			XA_STRING, &actual_type, &actual_format, &nitems,
  			&bytes_after, (unsigned char **)(&prop)) != Success)
  		return(False);
! 	if((version = Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
! 		XFree(prop);
  		return(False);
+ 	}
  	strncpy(version, prop, nitems);
  	version[nitems] = '\0';
  	XFree(prop);
***************
*** 271,276 ****
--- 273,279 ----
  	}
  	if((imstyle = (XIMStyles *)Xmalloc(sizeof(XIMStyles))) == NULL) {
  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_long);
  		return(False);
  	}
  	if((imstyle->supported_styles =
***************
*** 277,282 ****
--- 280,286 ----
  		(XIMStyle *)Xmalloc(sizeof(XIMStyle) * nitems)) == NULL) {
  		Xfree(imstyle);
  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_long);
  		return(False);
  	}
  	for(i=0; i < nitems; i++) {
***************
*** 295,300 ****
--- 299,305 ----
  	}
  	if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_int);
  		return(False);
  	}
  	count = nitems / 3;
***************
*** 301,306 ****
--- 306,312 ----
  	if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key) * count)) == NULL) {
  		Xfree(keylist);
  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_int);
  		return(False);
  	}
  	for(i=0,n=0; n < count; n++) {
***************
*** 321,326 ****
--- 327,333 ----
  	}
  	if((server_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, NULL, NULL, NULL, NULL);
+ 		XFree(prop);
  		return(False);
  	}
  	strncpy(server_name, prop, nitems);
***************
*** 337,342 ****
--- 344,350 ----
  	}
  	if((server_vl = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
+ 		XFree(prop);
  		return(False);
  	}
  	strncpy(server_vl, prop, nitems);
***************
*** 353,358 ****
--- 361,367 ----
  	}
  	if((vendor_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
+ 		XFree(prop);
  		return(False);
  	}
  	strncpy(vendor_name, prop, nitems);
***************
*** 369,380 ****
  	}
  	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * (nitems + 1)))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
  		return(False);
  	}
  	for(i=0; i < nitems; i++)
  		ext_list[i] = prop_int[i];
  	ext_list[nitems] = NULL;
! 	if(prop_int) XFree((XPointer)prop_int);
  
  	im->ximp_impart->fe_window	    = fe_window_id;
  	Protocol_ID                 = XInternAtom(dpy, _XIMP_PROTOCOL, False);
--- 378,392 ----
  	}
  	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * (nitems + 1)))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
+ 		if( prop_int )
+ 		    XFree((XPointer)prop_int);
  		return(False);
  	}
  	for(i=0; i < nitems; i++)
  		ext_list[i] = prop_int[i];
  	ext_list[nitems] = NULL;
! 	if( prop_int )
! 	    XFree((XPointer)prop_int);
  
  	im->ximp_impart->fe_window	    = fe_window_id;
  	Protocol_ID                 = XInternAtom(dpy, _XIMP_PROTOCOL, False);
***************
*** 403,414 ****
--- 415,436 ----
  
  	if(Ximp_Xim_List == (Ximp_XIM *)NULL){
  		Ximp_Xim_List = (Ximp_XIM *)Xmalloc(sizeof(Ximp_XIM));
+ 		if( Ximp_Xim_List == NULL ) {
+ 		    _Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
+ 		    return( False );
+ 		}
  		Ximp_Xim_List[0] = im;
  		Ximp_Xim_count = 1;
  	}
  	else {
+ 		Ximp_XIM	*ximp_xim;
+ 
  		n = 0;
  		for(i=0; i < Ximp_Xim_count; i++) {
+ 			if( Ximp_Xim_List[i] == im ) {
+ 				n = 1;
+ 				break;
+ 			}
  			if(Ximp_Xim_List[i] == NULL) {
  				Ximp_Xim_List[i] = im;
  				n = 1;
***************
*** 416,424 ****
  			}
  		}
  		if(n == 0) {
! 			Ximp_Xim_List = (Ximp_XIM *)Xrealloc(Ximp_Xim_List, ((i + 1) * sizeof(Ximp_XIM)));
! 			Ximp_Xim_List[i-1] = im;
! 			Ximp_Xim_count = i;
  		}
  	}
  
--- 438,451 ----
  			}
  		}
  		if(n == 0) {
! 			ximp_xim = (Ximp_XIM *)Xrealloc(Ximp_Xim_List, ((i + 1) * sizeof(Ximp_XIM)));
! 			if( ximp_xim == NULL ) {
! 			    _Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
! 			    return( False );
! 			}
! 			Ximp_Xim_List = ximp_xim;
! 			Ximp_Xim_List[Ximp_Xim_count] = im;
! 			Ximp_Xim_count++;
  		}
  	}
  
***************
*** 473,479 ****
  	Ximp_XIC	pic;
  
  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		pim = Ximp_Xim_List[i];
  		for(pic = (Ximp_XIC)pim->core.ic_chain; pic; pic = (Ximp_XIC)pic->core.next) {
  			if(pic->ximp_icpart->icid == icid)
  				return(pic);
--- 500,507 ----
  	Ximp_XIC	pic;
  
  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		if( (pim = Ximp_Xim_List[i]) == NULL )
! 			continue;
  		for(pic = (Ximp_XIC)pim->core.ic_chain; pic; pic = (Ximp_XIC)pic->core.next) {
  			if(pic->ximp_icpart->icid == icid)
  				return(pic);
***************
*** 499,505 ****
  			    + p->count_styles * sizeof(XIMStyle))) == NULL)
  		return(False);
  	(*p_style)->count_styles = p->count_styles;
! 	(*p_style)->supported_styles = (XIMStyle *)(*p_style + sizeof(XIMStyles));
  	for(i=0; i < (int)p->count_styles; i++) {
  		(*p_style)->supported_styles[i] = p->supported_styles[i];
  	}
--- 527,533 ----
  			    + p->count_styles * sizeof(XIMStyle))) == NULL)
  		return(False);
  	(*p_style)->count_styles = p->count_styles;
! 	(*p_style)->supported_styles = (XIMStyle *)((char *)*p_style + sizeof(XIMStyles));
  	for(i=0; i < (int)p->count_styles; i++) {
  		(*p_style)->supported_styles[i] = p->supported_styles[i];
  	}
*** /tmp/d03305	Wed Jul 29 10:18:43 1992
--- lib/X/Ximp/XimpLkup.c	Wed Jul 29 10:16:22 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpLkup.c,v 1.7 92/04/14 13:29:28 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by Sony Corporation
--- 1,4 ----
! /* $XConsortium: XimpLkup.c,v 1.8 92/07/29 10:16:17 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by Sony Corporation
***************
*** 43,61 ****
  
  #include "Ximplc.h"
  
- #ifdef XIMP_SIGNAL
- #include <sys/signal.h>
- #endif /* XIMP_SIGNAL */
- 
- static int	 _time_flag = 0;
- #ifdef XIMP_SIGNAL
- static int
- _time_out()
- 	{
- 	_time_flag = 1;
- 	}
- #endif /* XIMP_SIGNAL */
- 
  extern Ximp_XIC		_Ximp_LookupXIC();
  extern Atom		_Ximp_Protocol_id();
  extern Bool 		_Ximp_XimFilter_Client();
--- 43,48 ----
***************
*** 72,121 ****
  static void		_Ximp_CallCallback();
  extern void		_Ximp_ProcError();
  
! typedef struct {
! 	Atom type;
! 	ICID icid;
! 	Window owner;
! } XimpResetPredArgRec, *XimpResetPredArg;
  
! static Bool
! #if NeedFunctionPrototypes
! _Ximp_ResetPredicate(
!     Display *d,
!     XEvent *ev,
!     XPointer arg0)
! #else
! _Ximp_ResetPredicate(d, ev, arg0)
  Display *d;
  XEvent *ev;
  XPointer arg0;
- #endif
  {
!     XimpResetPredArg arg = (XimpResetPredArg) arg0 ;
  
! 	if (ev->type == ClientMessage) {
! 		if (ev->xclient.message_type == arg->type) {
! 			if ((ev->xclient.format == 32) &&
! 				(ev->xclient.data.l[1] == arg->icid)) {
! 				switch (ev->xclient.data.l[0]) {
! 				case XIMP_RESET_RETURN:
! 				case XIMP_ERROR:
! 				case XIMP_PREEDITDONE:
! 				case XIMP_PREEDITDRAW:
! 				case XIMP_PREEDITDRAW_CM:
! 				case XIMP_STATUSDONE:
! 				case XIMP_STATUSDRAW:
! 				case XIMP_STATUSDRAW_CM:
! 					return(True);
! 				}
! 			}
! 		}
! 	} else if (ev->type == DestroyNotify) {
! 		if (ev->xdestroywindow.window == arg->owner) {
! 			return(True);
! 		}
  	}
! 	return(False);
  }
  
  static unsigned char *
--- 59,113 ----
  static void		_Ximp_CallCallback();
  extern void		_Ximp_ProcError();
  
! Bool
! _XimpIfEvent( ic, event, predicate, arg )
! Ximp_XIC	ic;
! XEvent		*event;
! Bool		(*predicate)(
! #if NeedNestedPrototypes
! 	Display*,
! 	XEvent*,
! 	char*
! #endif
! );
! char		*arg;
! {
!     XIfEvent( ic->core.im->core.display, event, predicate, arg );
!     if( event->type == DestroyNotify ) {
! 	XPutBackEvent( ic->core.im->core.display, event );
! 	return( False );
!     }
!     else if( event->type == ClientMessage  &&  event->xclient.format == 32  &&
! 	     event->xclient.data.l[0] == XIMP_ERROR ) {
! 	_Ximp_ProcError( ic, ic->core.im->core.display, NULL, event );
! 	return( False );
!     }
!     return( True );
! }
  
! 
! Bool
! _Ximp_CMPredicate(d, ev, arg0)
  Display *d;
  XEvent *ev;
  XPointer arg0;
  {
!     XimpCMPredicateArg arg = (XimpCMPredicateArg)arg0;
  
!     if( ev->type == ClientMessage ) {
! 	if( ev->xclient.message_type == arg->type  &&
! 	    ev->xclient.format == 32 ) {
! 	    if( arg->icid == 0  ||  (ev->xclient.data.l[1] == arg->icid) )
! 		if( ev->xclient.data.l[0] == arg->protocol  ||
! 		    ev->xclient.data.l[0] == XIMP_ERROR )
! 		    return(True);
  	}
!     } else if( ev->type == DestroyNotify) {
! 	if( ev->xdestroywindow.window == arg->owner ) {
! 	    return( True );
! 	}
!     }
!     return( False );
  }
  
  static unsigned char *
***************
*** 122,199 ****
  _Ximp_Reset(ic)
  	Ximp_XIC	 ic;
  {
! 	XEvent		 Message;
! 	XEvent		 event;
! 	XimpResetPredArgRec Arg;
  
! 	if(ic->ximp_icpart->icid) {
! 		/* ClientMessage Send */
! 		_Ximp_IM_SendMessage(ic, XIMP_RESET, NULL, NULL, NULL);
  
! #ifdef XIMP_SIGNAL
! 		signal(SIGALRM, _time_out);
! 		alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
! 		Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 		Arg.icid = ic->ximp_icpart->icid;
! 		Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 		while(_time_flag != 1) {
! 			if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_ResetPredicate, (XPointer)&Arg)) == False) {
! #ifdef XIMP_SIGNAL
! 				sleep(1);
! #endif /* XIMP_SIGNAL */
! 				continue;
! 				}
! 			if (event.type == ClientMessage) {
! 				switch (event.xclient.data.l[0]) {
! 				case XIMP_RESET_RETURN:
! 					{
! 						int rval;
! 						Atom actual_type_return;
! 						int actual_format_return;
! 						unsigned long nitems_return, bytes_after_return;
! 						unsigned char *p = NULL;
! #ifdef XIMP_SIGNAL
! 						alarm(0);
! #endif /* XIMP_SIGNAL */
! 						ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 						rval = XGetWindowProperty(ic->core.im->core.display,
! 									((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
! 									(Atom)event.xclient.data.l[2], 0, 1024, True,
! 									AnyPropertyType, &actual_type_return,
! 									&actual_format_return, &nitems_return,
! 									&bytes_after_return, &p);
! 						return(p);
! 						}
! 				case XIMP_ERROR:
! 					_Ximp_ProcError (ic->core.im->core.display,
! 							 NULL, &event);
! 					_time_flag = 0;
! 					return(NULL);
! 				case XIMP_PREEDITDONE:
! 				case XIMP_PREEDITDRAW:
! 				case XIMP_PREEDITDRAW_CM:
! 				case XIMP_PREEDITDRAW_TINY:
! 				case XIMP_STATUSDONE:
! 				case XIMP_STATUSDRAW:
! 				case XIMP_STATUSDRAW_CM:
! 					_Ximp_CallCallback (ic->core.im->core.display, event.xclient.window, &event);
! 					break;
! 					}
! 				}
! 			else {
! #ifdef XIMP_SIGNAL
! 				alarm(0);
! #endif /* XIMP_SIGNAL */
! 				_Ximp_ProcError (ic->core.im->core.display,
! 							 NULL, &event);
! 				_time_flag = 0;
! 				return(NULL);
! 				}
! 			}
! 		_time_flag = 0;
! 		}
! 	return((unsigned char *)NULL);
  }
  
  #define XIMP_MAXBUF 1024
--- 114,149 ----
  _Ximp_Reset(ic)
  	Ximp_XIC	 ic;
  {
!     XEvent			Message;
!     XEvent			event;
!     XimpCMPredicateArgRec	Arg;
!     int				rval;
!     Atom			actual_type_return;
!     int				actual_format_return;
!     unsigned long		nitems_return, bytes_after_return;
!     unsigned char		*p = NULL;
  
!     if(ic->ximp_icpart->icid) {
! 	/* ClientMessage Send */
! 	_Ximp_IM_SendMessage(ic, XIMP_RESET, NULL, NULL, NULL);
  
! 	Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	Arg.protocol = XIMP_RESET_RETURN;
! 	Arg.icid = ic->ximp_icpart->icid;
! 	if( !_XimpIfEvent( ic, &event, _Ximp_CMPredicate, (XPointer)&Arg ) )
! 	    return( NULL );
! 
! 	ic->ximp_icpart->icid =(ICID)event.xclient.data.l[1];
! 	rval = XGetWindowProperty( ic->core.im->core.display,
! 		    ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
! 		    (Atom)event.xclient.data.l[2], 0, 1024, True,
! 		    AnyPropertyType, &actual_type_return,
! 		    &actual_format_return, &nitems_return,
! 		    &bytes_after_return, &p );
! 	return( p );
!     }
!     return( (unsigned char *)NULL );
  }
  
  #define XIMP_MAXBUF 1024
***************
*** 207,213 ****
  	unsigned char *ct = _Ximp_Reset(ic);
  
  	if (!ct) return(NULL);
! 	mb = Xmalloc(length);
  	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen((char *)ct), mb, &length, NULL);
  	mb[length] = '\0';
  	return(mb);
--- 157,163 ----
  	unsigned char *ct = _Ximp_Reset(ic);
  
  	if (!ct) return(NULL);
! 	mb = Xmalloc(length+1);
  	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen((char *)ct), mb, &length, NULL);
  	mb[length] = '\0';
  	return(mb);
***************
*** 222,228 ****
  	unsigned char *ct = _Ximp_Reset(ic);
  
  	if (!ct) return(NULL);
! 	wc = (wchar_t *)Xmalloc(length * sizeof(wchar_t));
  	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen((char *)ct), wc, &length, NULL);
  	wc[length] = (wchar_t)0;
  	return(wc);
--- 172,178 ----
  	unsigned char *ct = _Ximp_Reset(ic);
  
  	if (!ct) return(NULL);
! 	wc = (wchar_t *)Xmalloc((length + 1) * sizeof(wchar_t));
  	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen((char *)ct), wc, &length, NULL);
  	wc[length] = (wchar_t)0;
  	return(wc);
***************
*** 399,405 ****
  	extern Ximp_XIM	*Ximp_Xim_List;
  
  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		pim = Ximp_Xim_List[i];
  		for (pic = (Ximp_XIC)pim->core.ic_chain;
  			pic; pic = (Ximp_XIC)pic->core.next) {
  			if(pic->core.focus_window == window &&
--- 349,356 ----
  	extern Ximp_XIM	*Ximp_Xim_List;
  
  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		if( (pim = Ximp_Xim_List[i]) == NULL )
! 			continue;
  		for (pic = (Ximp_XIC)pim->core.ic_chain;
  			pic; pic = (Ximp_XIC)pic->core.next) {
  			if(pic->core.focus_window == window &&
***************
*** 484,615 ****
  		NULL);
  	_Ximp_IM_SendMessage(ic, XIMP_BEGIN, NULL, NULL, NULL);
  	XFlush(ic->core.im->core.display);
  	return(True);
  }
  
- 
- typedef struct {
- 	Atom type;
- 	Window owner;
- } XimpCreatePredArgRec, *XimpCreatePredArg;
- 
- static Bool
- _Ximp_CreatePredicate(d, ev, arg0)
- Display *d;
- XEvent *ev;
- XPointer arg0;
- {
-     XimpCreatePredArg arg = (XimpCreatePredArg) arg0;
- 
- 	if (ev->type == ClientMessage) {
- 		if (ev->xclient.message_type == arg->type) {
- 			if (ev->xclient.format == 32) {
- 				switch (ev->xclient.data.l[0]) {
- 				case XIMP_CREATE_RETURN:
- 				case XIMP_ERROR:
- 					return(True);
- 				}
- 			}
- 		}
- 	} else if (ev->type == DestroyNotify) {
- 		if (ev->xdestroywindow.window == arg->owner) {
- 			return(True);
- 		}
- 	}
- 	return(False);
- }
- 
  Bool
  _Ximp_SetOpenXIMP(ic, mode)
  	Ximp_XIC	ic;
  	int		mode;
  {
! 	unsigned long	 mask;
! 	XEvent		 event;
! 	XimpCreatePredArgRec Arg;
  
! 	if(mode == XIMP_CREATE_IC) {  /* XCretaeIC() */
! 		if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 			ic->core.client_window = XCreateSimpleWindow(
! 				ic->core.im->core.display,
! 				DefaultRootWindow(ic->core.im->core.display),
! 				0, 0, 1, 1, 1, 0, 0);
! 		}
  	}
  
! 	if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
! 		ic->core.focus_window = ic->core.client_window;
! 	}
  	
! 	/* Property Data Set */
! 	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->version_id,
! 			XA_STRING, 8, PropModeReplace,
! 			(unsigned char *)XIMP_PROTOCOL_VERSION, strlen(XIMP_PROTOCOL_VERSION));
! 	XFlush(ic->core.im->core.display);
  
! 	mask = ic->ximp_icpart->proto_mask;
! 	_Ximp_SetFocusWindow(ic);
! 	mask |= XIMP_FOCUS_WIN_MASK;
! 	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	     || (ic->core.input_style & XIMPreeditNone) ) ) { 
! 		if(mask & XIMP_PROP_PREEDIT)
! 			_Ximp_SetPreeditAtr(ic);
! 		if(mask & XIMP_PROP_PREFONT)
! 			_Ximp_SetPreeditFont(ic);
! 		}
! 	else {
! 		mask &= ~(XIMP_PROP_PREEDIT | XIMP_PROP_PREFONT);
! 		}
! 	if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	     || (ic->core.input_style & XIMStatusNone) ) ) { 
! 		if(mask & XIMP_PROP_STATUS)
! 			_Ximp_SetStatusAtr(ic);
! 		if(mask & XIMP_PROP_STSFONT)
! 			_Ximp_SetStatusFont(ic);
! 		}
! 	else {
! 		mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
! 		}
  
! 	/* ClientMessage Send */
! 	_Ximp_IM_SendMessage(ic, XIMP_CREATE, ic->core.input_style, mask, NULL);
  
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
! 	Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	while(_time_flag != 1) {
! 		if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_CreatePredicate, (XPointer)&Arg)) == False) {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
! 			}
! 		if(event.type == ClientMessage &&
! 		   event.xclient.data.l[0] == XIMP_CREATE_RETURN) {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 			_Ximp_A_CreateExtension(ic);
! 			_time_flag = 0;
! 			return(True);
! 			}
! 		else {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
! 			_time_flag = 0;
! 			/* return(False); */
! 			continue;
! 			}
! 		}
! 	_time_flag = 0;
! 	return(False);
  }
  
  void
--- 435,537 ----
  		NULL);
  	_Ximp_IM_SendMessage(ic, XIMP_BEGIN, NULL, NULL, NULL);
  	XFlush(ic->core.im->core.display);
+ 	_Ximp_CallRestartCallbackExtension( ic );
  	return(True);
  }
  
  Bool
  _Ximp_SetOpenXIMP(ic, mode)
  	Ximp_XIC	ic;
  	int		mode;
  {
!     unsigned long	mask;
!     XEvent		event;
!     XimpCMPredicateArgRec	Arg;
  
!     if(mode == XIMP_CREATE_IC) {  /* XCretaeIC() */
! 	if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 	    ic->core.client_window = XCreateSimpleWindow(
! 	    ic->core.im->core.display,
! 	    DefaultRootWindow(ic->core.im->core.display),
! 	    0, 0, 1, 1, 1, 0, 0);
  	}
+     }
  
!     if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
! 	ic->core.focus_window = ic->core.client_window;
!     }
  	
!     /* Property Data Set */
!     XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 		    ((Ximp_XIM)ic->core.im)->ximp_impart->version_id,
! 		    XA_STRING, 8, PropModeReplace,
! 		    (unsigned char *)XIMP_PROTOCOL_VERSION, strlen(XIMP_PROTOCOL_VERSION));
!     XFlush(ic->core.im->core.display);
  
!     mask = ic->ximp_icpart->proto_mask;
!     _Ximp_SetFocusWindow(ic);
!     mask |= XIMP_FOCUS_WIN_MASK;
!     if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	 || (ic->core.input_style & XIMPreeditNone) ) ) { 
! 	    if(mask & XIMP_PROP_PREEDIT)
! 		    _Ximp_SetPreeditAtr(ic);
! 	    if(mask & XIMP_PROP_PREFONT)
! 		    _Ximp_SetPreeditFont(ic);
!     }
!     else {
! 	mask &= ~(XIMP_PROP_PREEDIT | XIMP_PROP_PREFONT);
!     }
!     if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	 || (ic->core.input_style & XIMStatusNone) ) ) { 
! 	if(mask & XIMP_PROP_STATUS)
! 	    _Ximp_SetStatusAtr(ic);
! 	if(mask & XIMP_PROP_STSFONT)
! 	    _Ximp_SetStatusFont(ic);
!     }
!     else {
! 	mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
!     }
  
!     /* ClientMessage Send */
!     _Ximp_IM_SendMessage(ic, XIMP_CREATE, ic->core.input_style, mask, NULL);
  
!     Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
!     Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
!     Arg.protocol = XIMP_CREATE_RETURN;
!     Arg.icid = 0;
!     if( _XimpIfEvent( ic, &event, _Ximp_CMPredicate, (XPointer)&Arg ) ) {
! 	ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 	_Ximp_A_CreateExtension(ic);
! 	return(True);
!     }
!     else {
! 	XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id );
! 	if( !((ic->core.input_style & XIMPreeditCallbacks)  ||
! 	    (ic->core.input_style & XIMPreeditNone)) ) { 
! 	    if( mask & XIMP_PROP_PREEDIT )
! 		XDeleteProperty( ic->core.im->core.display,
! 			 ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id );
! 	    if( mask & XIMP_PROP_PREFONT )
! 		XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id );
! 	}
! 	if( !((ic->core.input_style & XIMStatusCallbacks)  ||
! 	    (ic->core.input_style & XIMStatusNone)) ) { 
! 	    if( mask & XIMP_PROP_STATUS )
! 		XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id );
! 	    if( mask & XIMP_PROP_STSFONT )
! 		XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
! 	}
! 	return( False );
!     }
  }
  
  void
***************
*** 622,628 ****
  	ev->keycode = 0;
  }
  
! void
  _Ximp_ProcKeypress (d, w, ev, kev)
  	Display			*d;
  	Window			w;
--- 544,550 ----
  	ev->keycode = 0;
  }
  
! Bool
  _Ximp_ProcKeypress (d, w, ev, kev)
  	Display			*d;
  	Window			w;
***************
*** 633,638 ****
--- 555,562 ----
  	Ximp_XIC 		ic;
  
  	icid = ev->data.l[1];
+ 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
+ 	    return( False );
  	kev->type = KeyPress;
  	kev->serial = ev->serial;
  	kev->send_event = False;
***************
*** 648,657 ****
  	kev->keycode = ev->data.l[2];
  	kev->state = ev->data.l[3];
  	kev->same_screen = True;
- 	ic = _Ximp_LookupXIC(icid);
  	if(ic->ximp_icpart->input_mode) { /* ON : input_mode */
  		ic->ximp_icpart->putback_key_event = True;
  	}
  }
  
  static void
--- 572,581 ----
  	kev->keycode = ev->data.l[2];
  	kev->state = ev->data.l[3];
  	kev->same_screen = True;
  	if(ic->ximp_icpart->input_mode) { /* ON : input_mode */
  		ic->ximp_icpart->putback_key_event = True;
  	}
+ 	return( True );
  }
  
  static void
***************
*** 677,683 ****
  	unsigned long		dummy_mask;
  
  	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
  
  	if(ic->ximp_icpart->input_mode) /* ON : input_mode */
  		return;
--- 601,608 ----
  	unsigned long		dummy_mask;
  
  	icid = ev->data.l[1];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
  
  	if(ic->ximp_icpart->input_mode) /* ON : input_mode */
  		return;
***************
*** 709,715 ****
  	Ximp_XIC		ic;
  
  	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
  	XSelectInput(d, ic->core.focus_window, ic->ximp_icpart->back_mask );
  	XFlush(d);
  	ic->ximp_icpart->input_mode = 0;
--- 634,641 ----
  	Ximp_XIC		ic;
  
  	icid = ev->data.l[1];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
  	XSelectInput(d, ic->core.focus_window, ic->ximp_icpart->back_mask );
  	XFlush(d);
  	ic->ximp_icpart->input_mode = 0;
***************
*** 735,741 ****
  	}
  	icid      = ev->data.l[1];
  	read_prop = ev->data.l[2];
! 	ic   = _Ximp_LookupXIC(icid);
  	rval = XGetWindowProperty( d,
  				((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
  				read_prop, 0, 1024, True,
--- 661,668 ----
  	}
  	icid      = ev->data.l[1];
  	read_prop = ev->data.l[2];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
  	rval = XGetWindowProperty( d,
  				((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
  				read_prop, 0, 1024, True,
***************
*** 751,757 ****
  }
  
  void
! _Ximp_ProcError (d, w, ev)
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
--- 678,685 ----
  }
  
  void
! _Ximp_ProcError (ic0, d, w, ev)
! 	Ximp_XIC		ic0;
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
***************
*** 766,773 ****
  	 *	you should modify this routine.
  	 */
  
! 	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
  	if (ic->ximp_icpart->error.callback) {
  		data[0] = ev->data.l[2];
  		data[2] = ev->data.l[4];
--- 694,706 ----
  	 *	you should modify this routine.
  	 */
  
! 	if( (icid = ev->data.l[1]) != 0 ) {
! 		if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 			return;
! 	}
! 	else if( (ic = ic0) == NULL )
! 		return;
! 
  	if (ic->ximp_icpart->error.callback) {
  		data[0] = ev->data.l[2];
  		data[2] = ev->data.l[4];
***************
*** 812,818 ****
  	Ximp_XIC	ic;
  
  	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
  	switch (ev->data.l[0]) {
  		case XIMP_GEOMETRY:
  			_Ximp_CallGeometryCallback (ic, ev);
--- 745,752 ----
  	Ximp_XIC	ic;
  
  	icid = ev->data.l[1];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
  	switch (ev->data.l[0]) {
  		case XIMP_GEOMETRY:
  			_Ximp_CallGeometryCallback (ic, ev);
***************
*** 866,873 ****
  	if (ev->format == 32) {
  		switch (ev->data.l[0]) {
  		case XIMP_KEYPRESS:
! 			_Ximp_ProcKeypress (d, w, ev, &kev);
! 			XPutBackEvent(d, (XEvent *)&kev);
  			break ;
  		case XIMP_CREATE_RETURN:
  			_Ximp_ProcCreateReturn (d, w, ev);
--- 800,809 ----
  	if (ev->format == 32) {
  		switch (ev->data.l[0]) {
  		case XIMP_KEYPRESS:
! 			if( _Ximp_ProcKeypress (d, w, ev, &kev) )
! 			    XPutBackEvent(d, (XEvent *)&kev);
! 			else
! 			    return( False );
  			break ;
  		case XIMP_CREATE_RETURN:
  			_Ximp_ProcCreateReturn (d, w, ev);
***************
*** 885,891 ****
  			XPutBackEvent(d, (XEvent *)ev);
  			break ;
  		case XIMP_ERROR:
! 			_Ximp_ProcError (d, w, ev);
  			break;
  		case XIMP_GEOMETRY:
  		case XIMP_PREEDITSTART:
--- 821,827 ----
  			XPutBackEvent(d, (XEvent *)ev);
  			break ;
  		case XIMP_ERROR:
! 			_Ximp_ProcError (NULL, d, w, ev);
  			break;
  		case XIMP_GEOMETRY:
  		case XIMP_PREEDITSTART:
***************
*** 947,952 ****
--- 883,889 ----
  		ximp_impart->fe_window = (Window)NULL;
  		for(ic = Ximp_Xim_List[i]->core.ic_chain; ic; ic = ic->core.next) {
  			((Ximp_XIC)ic)->ximp_icpart->icid = NULL;
+ 			_Ximp_CallDestroyCallbackExtension( ic );
  			_XUnregisterFilter(d,
  					   ic->core.focus_window,
  					   _Ximp_XimFilter_Client,
*** /tmp/d03324	Wed Jul 29 10:18:55 1992
--- lib/X/Ximp/XimpRm.c	Wed Jul 29 10:16:27 1992
***************
*** 1,8 ****
! /* $XConsortium: XimpRm.c,v 1.4 92/04/14 13:29:56 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpRm.c,v 1.5 92/07/29 10:16:22 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 26,32 ****
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
--- 26,32 ----
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
***************
*** 175,181 ****
  	{
  	char		 res_name[256];
  	char		 res_class[256];
! 	char		*str_type[50];
  	XrmValue	 value;
  	Bool		 ret = False;
  	KeySym		 keysym = NoSymbol;
--- 175,181 ----
  	{
  	char		 res_name[256];
  	char		 res_class[256];
! 	char		*str_type;
  	XrmValue	 value;
  	Bool		 ret = False;
  	KeySym		 keysym = NoSymbol;
***************
*** 189,195 ****
  	strcat(res_name, "inputserver");
  	strcat(res_class, "Inputserver");
  	if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				str_type, &value) == True) { 
  		if(strcmp(value.addr, "off") == 0) {
  			/* Keysym */
  			_Ximp_Get_resource_name(im, res_name, res_class);
--- 189,195 ----
  	strcat(res_name, "inputserver");
  	strcat(res_class, "Inputserver");
  	if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				&str_type, &value) == True) { 
  		if(strcmp(value.addr, "off") == 0) {
  			/* Keysym */
  			_Ximp_Get_resource_name(im, res_name, res_class);
***************
*** 196,202 ****
  			strcat(res_name, "startkeysym");
  			strcat(res_class, "Startkeysym");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				str_type, &value) == True) { 
  				keysym = XStringToKeysym(value.addr);
  				}
  			ret = False;
--- 196,202 ----
  			strcat(res_name, "startkeysym");
  			strcat(res_class, "Startkeysym");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				&str_type, &value) == True) { 
  				keysym = XStringToKeysym(value.addr);
  				}
  			ret = False;
***************
*** 220,226 ****
  			strcat(res_name, "processStartKeys");
  			strcat(res_class, "ProcessStartKeys");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 						str_type, &value)  == True) {
  				char	*string, *ss, c;
  				char	*line;
  
--- 220,226 ----
  			strcat(res_name, "processStartKeys");
  			strcat(res_class, "ProcessStartKeys");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 						&str_type, &value)  == True) {
  				char	*string, *ss, c;
  				char	*line;
  
***************
*** 249,255 ****
  	strcat(res_name, "callbackEncoding");
  	strcat(res_class, "CallbackEncoding");
  	if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				str_type, &value) == True) { 
  		if(strcmp(value.addr, "wchar") == 0) {
  			im->ximp_impart->use_wchar = True;
  			}
--- 249,255 ----
  	strcat(res_name, "callbackEncoding");
  	strcat(res_class, "CallbackEncoding");
  	if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				&str_type, &value) == True) { 
  		if(strcmp(value.addr, "wchar") == 0) {
  			im->ximp_impart->use_wchar = True;
  			}
***************
*** 267,273 ****
  	Ximp_XIM	 im;
  	char		 res_name[256];
  	char		 res_class[256];
! 	char		*str_type[50];
  	XrmValue	 value;
  	Colormap	 default_colormap;
  	XColor		 screen_def, exact_def;
--- 267,273 ----
  	Ximp_XIM	 im;
  	char		 res_name[256];
  	char		 res_class[256];
! 	char		*str_type;
  	XrmValue	 value;
  	Colormap	 default_colormap;
  	XColor		 screen_def, exact_def;
***************
*** 284,290 ****
  			strcat(res_name, "preedit.background");
  			strcat(res_class, "Preedit.Background");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
--- 284,290 ----
  			strcat(res_name, "preedit.background");
  			strcat(res_class, "Preedit.Background");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
***************
*** 304,310 ****
  			strcat(res_name, "preedit.foreground");
  			strcat(res_class, "Preedit.Foreground");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
--- 304,310 ----
  			strcat(res_name, "preedit.foreground");
  			strcat(res_class, "Preedit.Foreground");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
***************
*** 324,330 ****
  			strcat(res_name, "preedit.linespacing");
  			strcat(res_class, "Preedit.Linespacing");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				num = atoi(value.addr);
  				ic->core.preedit_attr.line_space = num;
  				ic->ximp_icpart->preedit_attr.LineSpacing = 
--- 324,330 ----
  			strcat(res_name, "preedit.linespacing");
  			strcat(res_class, "Preedit.Linespacing");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				num = atoi(value.addr);
  				ic->core.preedit_attr.line_space = num;
  				ic->ximp_icpart->preedit_attr.LineSpacing = 
***************
*** 341,347 ****
  			strcat(res_name, "status.background");
  			strcat(res_class, "Status.Background");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
--- 341,347 ----
  			strcat(res_name, "status.background");
  			strcat(res_class, "Status.Background");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
***************
*** 362,368 ****
  			strcat(res_name, "status.foreground");
  			strcat(res_class, "Status.Foreground");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
--- 362,368 ----
  			strcat(res_name, "status.foreground");
  			strcat(res_class, "Status.Foreground");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
***************
*** 382,388 ****
  			strcat(res_name, "status.linespacing");
  			strcat(res_class, "Status.Linespacing");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				num = atoi(value.addr);
  				ic->core.status_attr.line_space = num;
  				ic->ximp_icpart->status_attr.LineSpacing = 
--- 382,388 ----
  			strcat(res_name, "status.linespacing");
  			strcat(res_class, "Status.Linespacing");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				num = atoi(value.addr);
  				ic->core.status_attr.line_space = num;
  				ic->ximp_icpart->status_attr.LineSpacing = 
*** /tmp/d03343	Wed Jul 29 10:19:05 1992
--- lib/X/Ximp/Ximplc.h	Wed Jul 29 10:16:31 1992
***************
*** 1,4 ****
! /* $XConsortium: Ximplc.h,v 1.5 92/04/14 13:30:42 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: Ximplc.h,v 1.6 92/07/29 10:16:27 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
***************
*** 72,77 ****
--- 72,80 ----
  #include "XIMProto.h"
  
  #define USE_SJIS	True
+ #ifdef SVR4
+ #define FIX_EUC32	True
+ #endif
  
  #define GL		0x00
  #define GR		0x80
***************
*** 354,359 ****
--- 357,364 ----
   	/* Extended Callback attribute */
  	Bool			 use_lookup_choices;
  	ICExtLookupAttributes	 lookup_attr;
+ 	XIMCallback		 restart;
+ 	XIMCallback		 destroy;
  
  	void			*ictype;
  	} XICXimpRec;
***************
*** 366,368 ****
--- 371,391 ----
  	XICCoreRec	 core;
  	XICXimpRec	*ximp_icpart;
  	} Ximp_XICRec;
+ 
+ /*
+  * predicate argument
+  */
+ typedef struct {
+ 	Atom	type;
+ 	Window	owner;
+ 	int	protocol;
+ 	ICID	icid;
+ } XimpCMPredicateArgRec, *XimpCMPredicateArg;
+ 
+ typedef struct {
+ 	Atom	type;
+ 	Window	owner;
+ 	ICID	icid;
+ 	Window	window;
+ 	Atom	atom;
+ } XimpPNPredicateArgRec, *XimpPNPredicateArg;
