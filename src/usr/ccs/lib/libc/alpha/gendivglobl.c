/*
 * *****************************************************************
 * *                                                               *
 * *    Copyright (c) Digital Equipment Corporation, 1991, 1994    *
 * *                                                               *
 * *   All Rights Reserved.  Unpublished rights  reserved  under   *
 * *   the copyright laws of the United States.                    *
 * *                                                               *
 * *   The software contained on this media  is  proprietary  to   *
 * *   and  embodies  the  confidential  technology  of  Digital   *
 * *   Equipment Corporation.  Possession, use,  duplication  or   *
 * *   dissemination of the software and media is authorized only  *
 * *   pursuant to a valid written license from Digital Equipment  *
 * *   Corporation.                                                *
 * *                                                               *
 * *   RESTRICTED RIGHTS LEGEND   Use, duplication, or disclosure  *
 * *   by the U.S. Government is subject to restrictions  as  set  *
 * *   forth in Subparagraph (c)(1)(ii)  of  DFARS  252.227-7013,  *
 * *   or  in  FAR 52.227-19, as applicable.                       *
 * *                                                               *
 * *****************************************************************
 */
/*
 * HISTORY
 */
#ifndef lint
static char *rcsid = "@(#)$RCSfile: gendivglobl.c,v $ $Revision: 1.1.2.2 $ (DEC) $Date: 1993/03/30 21:41:44 $";
#endif

/*
 * This program generates the files divglobl.h and divglobl.s for use
 * by the divide RTL routines.
 */

#include <stdio.h>

typedef unsigned long uint64;
#define size_uint64 (sizeof(uint64)*8)
#define bit_length 8
#define bit_value (1 << bit_length)
#define bit_mask (bit_value -1)
#define k_bit_length bit_length
#define TABLE_BIAS (16384&-16)	/* leave some slop for negative biasing */

uint64  inv[bit_value],inv_m[bit_value];
int	inv_flag[2*bit_value];

static int quick_log2(uint64 i)
{
int shift = size_uint64/4,ln2= size_uint64/2;
uint64 two= 1l;
    two <<= ln2;
    do
    {
       if (two==i) return ln2;
	if ( two > i)
	{
	  two >>= shift;
	  ln2-= shift;
	}
	else
	{
	  two<<= shift;
	  ln2+= shift;
	}
	shift >>= 1;
    } while (shift);
	if ( two > i)
	{
	  ln2--;
	}
    return ln2;
}

static int log2(int n)
    {
	int mask;
	int ln2;

	ln2 = 7;
	mask = 0x80;
	do {
	    if (n & mask) break;
	    mask >>= 1;
	} while (--ln2);
	return ln2;
    }

static void init_inv()
{
  int i,j;
  uint64 e,d,r,t;
  d= 0;
  d= ~d;

  inv[0]= d;
  inv_flag[0]=2;
  inv_flag[1]=0;
  d= d << (size_uint64-1);

  for (i=1;i<bit_value;i++)
  {
     inv_flag[i+i]=0;
     inv_flag[i+i+1]=0;
     e= bit_value +i;
     while ((e & 1)==0)
     {
       e= e >> 1;
     }
     t= d/e;
     r= d % e;
     while ((t >> (size_uint64-1))==0)
     {
       j= size_uint64-1-quick_log2(t);
       r= (r << j);
       t= (t << j) + r/e;
       r= r % e;
     }
     if (r+r>e)
     {
       inv_flag[i+i]= 1;
       t++;
     };
     inv[i]= t;
  }

  for (i=0;i<bit_value;i++)
  {
     e= ((bit_value + i) << 1) + 1;
     t= d/e;
     r= d % e;
     while ((t >> (size_uint64-1))==0)
     {
       j= size_uint64-1-quick_log2(t);
       r= (r << j);
       t= (t << j) + r/e;
       r= r % e;
     }
     if (r+r>e)
     {
       inv_flag[i+i+1]= 1;
       t++;
     };
    inv_m[i]= inv[i]-t;
  }

}

#define HFILE "divglobl.h"
#define SFILE "divglobl.s"

main(argc, argv)
	int	argc;
	char	**argv;
    {
	int i, j;
	FILE *f;
	int offset;

	init_inv();

	f = fopen(HFILE, "w");
	if (f == (FILE *)NULL) {
	    printf("error opening %s\n", HFILE);
	    exit(0);
	}
	fprintf(f, "/*\n");
	fprintf(f, " * DO NOT EDIT -- DO NOT EDIT -- DO NOT EDIT -- DO NOT EDIT\n");
	fprintf(f, " *\n");
	fprintf(f, " * This file contains declarations and data for the divide and remainder\n");
	fprintf(f, " * RTL routines. It was machine generated by %s\n", argv[0]);
	fprintf(f, " *\n");
	fprintf(f, " * DO NOT EDIT -- DO NOT EDIT -- DO NOT EDIT -- DO NOT EDIT\n");
	fprintf(f, " */\n\n");
	fprintf(f, "#define BIT_LENGTH %d\n", bit_length);
	fprintf(f, "#define BIT_VALUE (1<<BIT_LENGTH)\n");
	fprintf(f, "#define BIT_MASK (BIT_VALUE-1)\n");
	fprintf(f, "#define K_BIT_LENGTH %d\n", k_bit_length);
	fprintf(f, "#define K_BIT_VALUE (1<<K_BIT_LENGTH)\n");
	fprintf(f, "#define K_BIT_MASK (K_BIT_VALUE-1)\n");
	fprintf(f, "\n#define TABLE_BIAS %d\n", TABLE_BIAS);
	fprintf(f, "\n");
	offset = -TABLE_BIAS;

	offset = (offset + 3) & ~3;
	fprintf(f, "#define LOG2TAB %d\n", offset);
	offset += 4*256;

	offset = (offset + 7) & ~7;
	fprintf(f, "#define INV_FLAG %d\n", offset);
	offset += (bit_value) * 2;

	offset = (offset + 15) & ~15;
	fprintf(f, "#define INV %d\n", offset);
	fprintf(f, "#define INV_M %d\n", offset+8);
	offset += (bit_value * 8) * 2;

	fprintf(f, "\n");
	fprintf(f, "#define A $24\n");
	fprintf(f, "#define B $25\n");
	fprintf(f, "#define Q $27\n");
	fprintf(f, "#define RA $23\n");
	fprintf(f, "\n");
	fprintf(f, "\t.globl\t__divdat\n");
	fclose(f);

	f = fopen(SFILE, "w");
	if (f == (FILE *)NULL) {
	    printf("error opening %s\n", SFILE);
	    exit(0);
	}

	fprintf(f, "/*\n");
	fprintf(f, " * DO NOT EDIT -- DO NOT EDIT -- DO NOT EDIT -- DO NOT EDIT\n");
	fprintf(f, " *\n");
	fprintf(f, " * This file contains declarations for the divide and remainder\n");
	fprintf(f, " * RTL routines. It was machine generated by %s\n", argv[0]);
	fprintf(f, " *\n");
	fprintf(f, " * DO NOT EDIT -- DO NOT EDIT -- DO NOT EDIT -- DO NOT EDIT\n");
	fprintf(f, " */\n\n");

	fprintf(f, "#include \"%s\"\n", HFILE);
	fprintf(f, "\n\t.rdata\n");
	fprintf(f, "\n\t.align\t4\n");
	fprintf(f, "__divdat:\n");

	fprintf(f, "\n\t#\n\t# LOG2TAB\n\t#\n");
	fprintf(f, "\t.align\t2\n");
	for (i = 0; i < 256; i += 16) {
	    fprintf(f, "\t.long\t");
	    for (j = 0; j < 15; j++) {
		fprintf(f, "%d, ", log2(i+j));
	    }
	    fprintf(f, "%d\n", log2(i+15));
	}

	fprintf(f, "\n\t#\n\t# INV_FLAG\n\t#\n");
	fprintf(f, "\t.align\t3\n");
	j = 0;
	for (i = 0; i < 2*bit_value; i++) {
	    if (j == 0) {
		fprintf(f, "\t.byte\t");
	    }
	    fprintf(f, "%d", !inv_flag[i]);
	    if (++j == 16) {
		fprintf(f, "\n");
		j = 0;
	    } else {
		fprintf(f, ", ");
	    }
	}
	if (j != 0) {
	    fprintf(f, "\n");
	}

	fprintf(f, "\n\t.align\t4\n");
	fprintf(f, "\t#\t\tINV\t\tINV_M\n");
	for (i = 0; i < bit_value; i++) {
	    fprintf(f, "\t.quad\t0x%016lx, 0x%016lx,\t# %4d\n",
		inv[i], inv_m[i], i);
	}

	fclose(f);
    }
