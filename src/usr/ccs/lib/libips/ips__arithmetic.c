/*  DEC/CMS REPLACEMENT HISTORY, Element IPS__ARITHMETIC.C */
/*  *1    11-APR-1991 15:36:08 PICCOLO "fix float strides" */
/*  DEC/CMS REPLACEMENT HISTORY, Element IPS__ARITHMETIC.C */
/*  DEC/CMS REPLACEMENT HISTORY, Element IPS__ARITHMETIC.C */
/*  *8    11-APR-1991 13:26:33 PICCOLO "fix src2 and dst strides" */
/*  *7    13-MAR-1991 11:28:41 POLTRACK "ALPHA port changes for relaxed ANSI 89 compliant code" */
/*  *6     6-NOV-1990 16:08:39 PICCOLO "fix cpp offset for when roi is present" */
/*  *5    16-AUG-1990 09:14:22 PICCOLO "fix error handling" */
/*  *4     9-AUG-1990 14:59:05 DINTINO "fix pos " */
/*  *3    20-JUL-1990 14:14:35 PICCOLO "fix memory alloc on modulo and fixed dst udp creation for ROIs" */
/*  *2    29-JUN-1990 15:25:30 RODWELL "Take out (+ _X1) from data offset" */
/*  *1     1-JUN-1990 16:14:46 PICCOLO "IPS Base Level" */
/*  DEC/CMS REPLACEMENT HISTORY, Element IPS__ARITHMETIC.C */
/************************************************************************
**
**  Copyright (c) Digital Equipment Corporation, 1990-1991 All Rights Reserved.
**  Unpublished rights reserved under the copyright laws of the United States.
**  The software contained on this media is proprietary to and embodies the
**  confidential technology of Digital Equipment Corporation.  Possession, use,
**  duplication or dissemination of the software and media is authorized only
**  pursuant to a valid written license from Digital Equipment Corporation.
**  RESTRICTED RIGHTS LEGEND   Use, duplication, or disclosure by the U.S.
**  Government is subject to restrictions as set forth in Subparagraph
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.
**/

/************************************************************************
**
**  FACILITY:
**
**      Image Processing Services
**
**  ABSTRACT:
**
**      This module contains the user level service and support routines
**	for arithmetic operations two input images of matching data types
**      and generates a destination image of the same data type as the 
**      sources.
**
**  ENVIRONMENT:
**
**      VAX/VMS, VAX/ULTRIX, RISC/ULTRIX
**
**  AUTHOR(S):
**
**      Karen Rodwell
**
**  CREATION DATE:
**
**      14-MAR-1990
**
************************************************************************/

/*
**  Table of contents
*/
#ifdef NODAS_PROTO
long _IpsArithmetic();		    /* main entry routine, tests dtype     */
long _IpsArithmeticByt();	    /* arithmetic operations on byte dtype */
long _IpsArithmeticW();		    /* arithmetic operations on word dtype */
long _IpsArithmeticFlt();	    /* arithmetic operations on float dtype*/

long _IpsArithmeticBytCpp();	    /*arith operations on byte dtype with cpp */
long _IpsArithmeticWCpp();          /*arith operations on word dtype with cpp */
long _IpsArithmeticFltCpp();        /*arith operations on float dtype with cpp*/
#endif

/*
**  Include files
*/
#include <IpsDef.h>			    /* Ips Image Definitions	     */
#include <IpsMacros.h>			    /* Ips Macro Definitions	     */
#include <IpsMemoryTable.h>                 /* Ips Memory Mgt Functions      */
#include <IpsStatusCodes.h>		    /* Ips Status Codes		     */
#ifndef NODAS_PROTO
#include <ipsprot.h>			    /* Ips prototypes */
#endif
/*
**  External References:
*/
#ifdef NODAS_PROTO
long _IpsBuildDstUdp();			    /* from udp_utils */
#endif


/*****************************************************************************
**  _IpsArithmetic - 
**
**  FUNCTIONAL DESCRIPTION:
**	Performs arithmetic operations on corresponding values from the 
**      two source images to produce results for the destination image on 
**      a point by point basis.  
**
**  FORMAL PARAMETERS:
**
**      src1_udp    -- Pointer to first source udp
**	src2_udp    -- Pointer to second source udp
**	dst_udp     -- Pointer to destination udp (uninitialized)
**      cpp	    -- Optional Pointer to Control Processing Plane
**	operator    -- Arithmetic operation to be performed on two planes
**      control     -- Options on overflow/underflow handling
**	result_flag -- The nature of the success.
**
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsArithmetic(src1_udp, src2_udp, dst_udp, cpp, operator, 
		    control, result_flag)
struct UDP *src1_udp;      /* First Source UDP for arithmetic operation  */
struct UDP *src2_udp;      /* Second Source UDP for arithmetic operation */
struct UDP *dst_udp;       /* Destination UDP generated by arithmetic op */
struct UDP *cpp;           /* Optional Control Processing Plane          */
unsigned long operator;	   /* Function operator flag                     */
unsigned long control;     /* Overflow/Underflow control                 */
unsigned long *result_flag;/* Result flag, nature of the success         */
{

long	mem_alloc = 0;	   /* memory alloc flag				 */
long	status;		   /* status					 */

if  (src1_udp->UdpB_Class != UdpK_ClassA)
    return (IpsX_UNSOPTION);

/* return mismatch error if the dimensions are mismatched */

if ((src1_udp->UdpL_ScnCnt != src2_udp->UdpL_ScnCnt) ||
    (src1_udp->UdpL_PxlPerScn != src2_udp->UdpL_PxlPerScn) ||
    (src1_udp->UdpB_DType != src2_udp->UdpB_DType))
    return (IpsX_NOMATCH); 

if ((src1_udp->UdpB_DType == UdpK_DTypeVU) || 
    (src1_udp->UdpB_DType == UdpK_DTypeV) ||
    (src2_udp->UdpB_DType == UdpK_DTypeVU) || 
    (src2_udp->UdpB_DType == UdpK_DTypeV))
    return (IpsX_INVDTYPE);

if (cpp != 0)
    VALIDATE_CPP_(cpp, src1_udp);

if (dst_udp->UdpA_Base == 0) mem_alloc = 1;
status = _IpsBuildDstUdp (src1_udp, dst_udp, 0, IpsM_RetainSrcDim, 
    IpsK_InPlaceAllowed);
if (status != IpsX_SUCCESS) return (status);

*result_flag = 0;
switch (src1_udp->UdpB_DType)
    {
    case UdpK_DTypeBU:
	/* byte op byte = byte */
	if (cpp == 0)
	    status = _IpsArithmeticByt(src1_udp, src2_udp, dst_udp, 
					operator, control, result_flag);
	else
	    status = _IpsArithmeticBytCpp(src1_udp, src2_udp, dst_udp, 
					cpp, operator, control, result_flag);
    break;

    case UdpK_DTypeWU:
	/* word op word = word */
	if (cpp == 0)
	    status = _IpsArithmeticW(src1_udp, src2_udp, dst_udp,
					operator, control, result_flag);
	else
	    status = _IpsArithmeticWCpp(src1_udp, src2_udp, dst_udp, cpp,
					operator, control, result_flag);
    break;

    case UdpK_DTypeF:
	/* float op float = float */
	/* control is ignored with float operations */
	if (cpp == 0)
	    status = _IpsArithmeticFlt(src1_udp, src2_udp, dst_udp, operator);
	else
	    status = _IpsArithmeticFltCpp(src1_udp, src2_udp, dst_udp, 
				    cpp, operator);
    break;

    case UdpK_DTypeLU: 
    default:
	status = IpsX_UNSOPTION;
    break;
    };  /* end switch on DType */

if ((status != IpsX_SUCCESS) && (mem_alloc == 1))
    (*IpsA_MemoryTable[IpsK_FreeDataPlane]) (dst_udp->UdpA_Base);

return (status);
}

/*****************************************************************************
**  _IpsArithmeticByt - 
**
**  FUNCTIONAL DESCRIPTION:
**	Performs arithmetic operations on corresponding values from the 
**      two unsigned byte source images to produce results for the unsigned
**      byte destination image on a point by point basis.  
**
**  FORMAL PARAMETERS:
**
**      src1_udp    -- Pointer to first source udp.
**	src2_udp    -- Pointer to second source udp.
**	dst_udp     -- Pointer to destination udp.
**	operator    -- Arithmetic operation to be performed.
**	control     -- Overflow/underflow control option.
**      result_flag -- Indicates the nature of the results.
**
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsArithmeticByt(src1_udp,src2_udp,dst_udp,operator,control,result_flag)
struct UDP *src1_udp;      /* first source udp  */
struct UDP *src2_udp;      /* second source udp */
struct UDP *dst_udp;       /* destination udp   */
unsigned long operator;    /* type of operation to be performed   */
unsigned long control;     /* overflow/underflow control option   */
unsigned long *result_flag; /* indicates the nature of the results */
{
unsigned long   src1_pad;               /* src1 pad		       */
unsigned long   src2_pad;               /* src2 pad                    */
unsigned long   dst_pad;                /* dst pad		       */
unsigned char   *src1_plane_data_base;  /* pointer to source data base */
unsigned char   *src2_plane_data_base;  /* pointer to dest  data base  */
unsigned char   *dst_byte_ptr;          /* used for dst image          */
unsigned long   ix,iy;                  /* loop counters               */
unsigned long   src1_stride;            /* src1 stride in bytes        */
unsigned long   src2_stride;            /* src2 stride in bytes        */
unsigned long   dst_stride;             /* dst stride in bytes         */
unsigned long   size;                   /* buffer size                 */
long            result;                 /* true signed result          */

src1_plane_data_base = (unsigned char *)src1_udp->UdpA_Base + 
                    ((src1_udp->UdpL_Pos + 
		    (src1_udp->UdpL_ScnStride * src1_udp->UdpL_Y1) +
		    (src1_udp->UdpL_X1 * src1_udp->UdpL_PxlStride) )>>3);
src2_plane_data_base = (unsigned char *)src2_udp->UdpA_Base + 
                    ((src2_udp->UdpL_Pos + 
		    (src2_udp->UdpL_ScnStride * src2_udp->UdpL_Y1) +
		    (src2_udp->UdpL_X1 * src2_udp->UdpL_PxlStride) )>>3);
dst_byte_ptr = (unsigned char *) dst_udp->UdpA_Base + 
                    ((dst_udp->UdpL_Pos + 
		    (dst_udp->UdpL_ScnStride * dst_udp->UdpL_Y1) +
		    (dst_udp->UdpL_X1 * dst_udp->UdpL_PxlStride) )>>3);

src1_stride = (src1_udp->UdpL_ScnStride >> 3);
src2_stride = (src2_udp->UdpL_ScnStride >> 3);
dst_stride = (dst_udp->UdpL_ScnStride >> 3);
src1_pad = src1_stride  - src1_udp->UdpL_PxlPerScn;
src2_pad = src2_stride - src2_udp->UdpL_PxlPerScn;
dst_pad = dst_stride - dst_udp->UdpL_PxlPerScn;
/* 
** 1) Test for the overflow control option.
** 2) Perform the specified arithmetic operation. 
** 3) If overflow or underflow, the result (based on the control option)
**	can either be clipped to fit within the range of levels OR, 
**	by default, wrapped.
*/

switch (operator)
    {
    case IpsK_Addition:
        {
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        result = ((*src1_plane_data_base++) 
					+ (*src2_plane_data_base++));
		        if ((result < 0) || (result > 255))
			    {
			    if (result < 0)
			        *dst_byte_ptr++ = 0;			    
                            else 
		                *dst_byte_ptr++ = 255;
			    *result_flag = IpsK_SUCCESS_CLIP;
			    }
			else
		            *dst_byte_ptr++ = result;
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        *dst_byte_ptr++ = ((*src1_plane_data_base++) 
					+ (*src2_plane_data_base++));
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}/*end addition */
    case IpsK_SubtractSrc2FromSrc1:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        result = ((*src1_plane_data_base++) 
					- (*src2_plane_data_base++));

		        if ((result < 0) || (result > 255))
			    {
			    if (result < 0)
			        *dst_byte_ptr++ = 0;			    
                            else 
		                *dst_byte_ptr++ = 255;
			    *result_flag = IpsK_SUCCESS_CLIP;
			    }
		        else
		            *dst_byte_ptr++ = result;
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        *dst_byte_ptr++ = ((*src1_plane_data_base++) 
					- (*src2_plane_data_base++));
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_SubtractSrc1FromSrc2:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        result = ((*src2_plane_data_base++) 
					- (*src1_plane_data_base++));
		        if ((result < 0) || (result > 255))
			    {
			    if (result < 0)
			        *dst_byte_ptr++ = 0;			    
                            else 
		                *dst_byte_ptr++ = 255;
			    *result_flag = IpsK_SUCCESS_CLIP;
			    }
		        else
		            *dst_byte_ptr++ = result;
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        *dst_byte_ptr++ = ((*src2_plane_data_base++) 
					- (*src1_plane_data_base++));
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_Multiplication:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        result = ((*src2_plane_data_base++) 
					* (*src1_plane_data_base++));
		        if ((result < 0) || (result > 255))
			    {
			    if (result < 0)
			        *dst_byte_ptr++ = 0;			    
                            else 
		                *dst_byte_ptr++ = 255;
			    *result_flag = IpsK_SUCCESS_CLIP;
			    }
		        else
		            *dst_byte_ptr++ = result;
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
		    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        *dst_byte_ptr++ = ((*src2_plane_data_base++) 
					* (*src1_plane_data_base++));
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_DivideSrc1BySrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if (*src2_plane_data_base != 0)
	            result = ((*src1_plane_data_base++) 
					/ (*src2_plane_data_base++));
		else
		    {
		    src2_plane_data_base++;
		    result = *src1_plane_data_base++;
		    }
	       }/* end ix loop */
	    dst_byte_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
	    } /*end iy loop */
	break;
        }
    case IpsK_DivideSrc2BySrc1:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if (*src1_plane_data_base != 0)
                    *dst_byte_ptr++ = ((*src2_plane_data_base++) 
					     / (*src1_plane_data_base++));
	        else
		    {
		    src1_plane_data_base++;
		    *dst_byte_ptr++ = *src2_plane_data_base++;
		    }
		}/* end ix loop */
		dst_byte_ptr +=  dst_pad;
		src1_plane_data_base  += src1_pad;
		src2_plane_data_base += src2_pad;
	    } /*end iy loop */
	break;
	}
    case IpsK_Maximum:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                *dst_byte_ptr++ = MAX_(*src1_plane_data_base, 
					*src2_plane_data_base);
		src2_plane_data_base++;
		src1_plane_data_base++;
                } /* end of ix loop */
            dst_byte_ptr +=  dst_pad;
            src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop */
	break;
	}

    case IpsK_Minimum:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                *dst_byte_ptr++ = MIN_(*src1_plane_data_base, 
					*src2_plane_data_base);
		src2_plane_data_base++;
		src1_plane_data_base++;
                } /* end of ix loop */
            dst_byte_ptr +=  dst_pad;
            src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop */
	break;
	}
    case IpsK_Src1ModuloSrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if (*src2_plane_data_base != 0)
                    *dst_byte_ptr++ = ((*src1_plane_data_base++) 
					% (*src2_plane_data_base++));
		else 
		    {
		    *dst_byte_ptr++ = 0;
		    src1_plane_data_base++;
		    src2_plane_data_base++;
		    }
		}/* end ix loop */
            dst_byte_ptr +=  dst_pad;
            src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /*end iy loop */
	break;
	}

    case IpsK_SetToSrc2:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                *dst_byte_ptr++ = *src2_plane_data_base++;

            dst_byte_ptr +=  dst_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop */
	break;
	}

    default:
        return (IpsX_UNSOPTION);
        break;
    }
return (IpsX_SUCCESS);
}/* end of _IpsArithmeticByt */

/*****************************************************************************
**  _IpsArithmeticBytCpp - 
**
**  FUNCTIONAL DESCRIPTION:
**
**	Performs arithmetic operations on corresponding values from the 
**      two unsigned byte source images to produce results for the unsigned
**      byte destination image on a point by point basis depending on the
**	bits set in the CPP.
**
**      The bits in the CPP plane corresponding to the pixels being 
**	operated on are tested.
** 
**	    If the CPP bit is set, the operation is performed and
**	    the result is placed in the corresponding destination 
**	    plane pixel location.
**
**	    If the CPP bit is not set, the pixel value of the source1
**	    plane is placed in the corresponding destination plane pixel
**	    location.
**
**  FORMAL PARAMETERS:
**
**      src1_udp
**	src2_udp
**	dst_udp
**	cpp
**	operator
**	control
**	result_flag
**
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsArithmeticBytCpp(src1_udp,src2_udp,dst_udp,cpp,operator,control,result_flag)
struct UDP *src1_udp;       /* first source UDP  */
struct UDP *src2_udp;       /* second source UDP */
struct UDP *dst_udp;        /* destination UDP   */
struct UDP *cpp;            /* control processing plane             */
unsigned long operator;     /* arithmetic operation to be performed */
unsigned long control;      /* overflow/underflow control           */
unsigned long *result_flag;  /* indicates the nature of the results  */
{
unsigned char   *src1_plane_data_base;  /* pointer to source data base */
unsigned char   *src2_plane_data_base;  /* pointer to dest  data base  */
unsigned long   ix,iy;                  /* loop counters               */
unsigned long   src1_pad;               /* src1 pad		       */
unsigned long   src2_pad;               /* src2 pad                    */
unsigned long   dst_pad;                /* dst pad		       */
unsigned char   *dst_byte_ptr;          /* used for dst image          */
unsigned char   *cpp_ptr;               /* control proc plane base     */
unsigned long   cpp_stride;		/* control proc plane stride   */
unsigned long	src1_stride;		/* source 1 scanline stride    */
unsigned long	src2_stride;	        /* source 2 scanline stride    */
unsigned long	dst_stride;	        /* dst scanline stride	       */
unsigned long   size;                   /* buffer size                 */
long		result;			/* true signed result	       */
unsigned long   bit;

src1_plane_data_base = (unsigned char *)src1_udp->UdpA_Base + 
                    ((src1_udp->UdpL_Pos + 
		    (src1_udp->UdpL_ScnStride * src1_udp->UdpL_Y1) +
		    (src1_udp->UdpL_X1 * src1_udp->UdpL_PxlStride) )>>3);

src2_plane_data_base = (unsigned char *)src2_udp->UdpA_Base + 
                    ((src2_udp->UdpL_Pos + 
		    (src2_udp->UdpL_ScnStride * src2_udp->UdpL_Y1) +
		    (src2_udp->UdpL_X1 * src2_udp->UdpL_PxlStride) )>>3);

dst_byte_ptr = (unsigned char *) dst_udp->UdpA_Base + 
                    ((dst_udp->UdpL_Pos + 
		    (dst_udp->UdpL_ScnStride * dst_udp->UdpL_Y1) +
		    (dst_udp->UdpL_X1 * dst_udp->UdpL_PxlStride) )>>3);

cpp_ptr = (unsigned char *) cpp->UdpA_Base
                + (((cpp->UdpL_Pos +
		  (cpp->UdpL_ScnStride * cpp->UdpL_Y1) +
		   cpp->UdpL_X1)+7)/8);

cpp_stride = (cpp->UdpL_ScnStride >> 3);

src1_stride = (src1_udp->UdpL_ScnStride >> 3);
src2_stride = (src2_udp->UdpL_ScnStride >> 3);
dst_stride = (dst_udp->UdpL_ScnStride >> 3);
src1_pad = src1_stride  - src1_udp->UdpL_PxlPerScn;
src2_pad = src2_stride - src2_udp->UdpL_PxlPerScn;
dst_pad = dst_stride - dst_udp->UdpL_PxlPerScn;

switch (operator)
    {
    case IpsK_Addition:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
			if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
			    {
                            result = ((*src1_plane_data_base++) 
					+ (*src2_plane_data_base++));

		            if ((result < 0) || (result > 255))
				{
			        if (result < 0)
			            *dst_byte_ptr++ = 0;
                                else 
		                    *dst_byte_ptr++ = 255;
			        *result_flag = IpsK_SUCCESS_CLIP;
				}
		            else
		                *dst_byte_ptr++ = result;
			    }
			else
			    {
			    *dst_byte_ptr++ = *src1_plane_data_base++;
			    src2_plane_data_base++;
			    }
		        } /* end ix loop */
		    cpp_ptr += cpp_stride;
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
	            src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
			if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            *dst_byte_ptr++ = ((*src1_plane_data_base++) 
					+ (*src2_plane_data_base++));
			else
			    {
			    *dst_byte_ptr++ = *src1_plane_data_base++;
			    src2_plane_data_base++;
			    }
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
	            src2_plane_data_base += src2_pad;
		    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}/*end addition */
    case IpsK_SubtractSrc2FromSrc1:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
			if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
			    {
                            result = ((*src1_plane_data_base++) 
					- (*src2_plane_data_base++));

		            if ((result < 0) || (result > 255))
			        {
			        if (result < 0)
			            *dst_byte_ptr++ = 0;
                                else 
		                    *dst_byte_ptr++ = 255;
			        *result_flag = IpsK_SUCCESS_CLIP;
				}
		            else
		                *dst_byte_ptr++ = result;
			    }
			else
			    {
			    *dst_byte_ptr++ = *src1_plane_data_base++;
			    src2_plane_data_base++;
			    }
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
	            src2_plane_data_base += src2_pad;
		    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
			if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            *dst_byte_ptr++ = ((*src1_plane_data_base++) 
					- (*src2_plane_data_base++));
			else
			    {
			    *dst_byte_ptr++ = *src1_plane_data_base++;
			    src2_plane_data_base++;
			    }
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
	            src2_plane_data_base += src2_pad;
		    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_SubtractSrc1FromSrc2:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
			if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
			    {
                            result = ((*src2_plane_data_base++) 
					- (*src1_plane_data_base++));
		            if ((result < 0) || (result > 255))
			        {
			        if (result < 0)
			            *dst_byte_ptr++ = 0;
                                else 
		                    *dst_byte_ptr++ = 255;
			        *result_flag = IpsK_SUCCESS_CLIP;
				}
		            else
		                *dst_byte_ptr++ = result;
			    }
			else
			    {
			    *dst_byte_ptr++ = *src1_plane_data_base++;
			    src2_plane_data_base++;
			    }
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
	            src2_plane_data_base += src2_pad;
		    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
			if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            *dst_byte_ptr++ = ((*src2_plane_data_base++) 
					- (*src1_plane_data_base++));
			else
			    {
			    *dst_byte_ptr++ = *src1_plane_data_base++;
			    src2_plane_data_base++;
			    }
		        }/* end ix loop */
		    cpp_ptr += cpp_stride;
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
	            src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_Multiplication:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
			if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
			    {
                            result = ((*src2_plane_data_base++) 
					* (*src1_plane_data_base++));
		            if ((result < 0) || (result > 255))
				{
			        if (result < 0)
			            *dst_byte_ptr++ = 0;
                                else 
		                    *dst_byte_ptr++ = 255;
			        *result_flag = IpsK_SUCCESS_CLIP;
				}
		            else
		                *dst_byte_ptr++ = result;
			    }
			else
			    {
			    *dst_byte_ptr++ = *src1_plane_data_base++;
			    src2_plane_data_base++;
			    }
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
	            src2_plane_data_base += src2_pad;
		    cpp_ptr += cpp_stride;
		    } /* end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
			if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            *dst_byte_ptr++ = ((*src2_plane_data_base++) 
					* (*src1_plane_data_base++));
			else
			    {
			    *dst_byte_ptr++  = *src1_plane_data_base++;
			    src2_plane_data_base++;
			    }
		        }/* end ix loop */
		    dst_byte_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
	            src2_plane_data_base += src2_pad;
		    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_DivideSrc1BySrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if ((*src2_plane_data_base != 0) && 
		    ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE))
                    *dst_byte_ptr++ = ((*src1_plane_data_base++) 
					/ (*src2_plane_data_base++));
		else
		    {
		    src2_plane_data_base++;
		    *dst_byte_ptr++ = *src1_plane_data_base++;
		    }
		}/* end ix loop */
		dst_byte_ptr +=  dst_pad;
		src1_plane_data_base  += src1_pad;
	        src2_plane_data_base += src2_pad;
		cpp_ptr += cpp_stride;
		} /*end iy loop */
	    break;
	}
    case IpsK_DivideSrc2BySrc1:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
	        if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
	            {
                    if (*src1_plane_data_base != 0)
                        *dst_byte_ptr++ = ((*src2_plane_data_base++) 
					     / (*src1_plane_data_base++));
		    else
			{
			src1_plane_data_base++;
			*dst_byte_ptr++ = *src2_plane_data_base++;
			}
		    }
		else
		    {  
		    *dst_byte_ptr++ = *src1_plane_data_base++;
		    src2_plane_data_base++;
		    }
	        }/* end ix loop */
		dst_byte_ptr +=  dst_pad;
		src1_plane_data_base  += src1_pad;
	        src2_plane_data_base += src2_pad;
		cpp_ptr += cpp_stride;
	    } /*end iy loop */
	break;
	}
    case IpsK_Maximum:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
		    {
                    *dst_byte_ptr++ = MAX_(*src1_plane_data_base, 
					*src2_plane_data_base);
		    src2_plane_data_base++;
 		    src1_plane_data_base++;
		    }
		else
		    {
		    *dst_byte_ptr++ = *src1_plane_data_base++;
		    src2_plane_data_base++;
		    }
                } /* end of ix loop */
	    dst_byte_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop */
	break;
	}
    case IpsK_Minimum:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
		    {
                    *dst_byte_ptr++ = MIN_(*src1_plane_data_base, 
					*src2_plane_data_base);
		    src2_plane_data_base++;
		    src1_plane_data_base++;
		    }
		else
		    {
		    *dst_byte_ptr++ = *src1_plane_data_base++;
		    src2_plane_data_base++;
		    }
                } /* end of ix loop */
	    dst_byte_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
	    cpp_ptr += cpp_stride;
            } /* end of iy loop */
	break;
	}
    case IpsK_Src1ModuloSrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if (((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
		    && (*src2_plane_data_base != 0))
                    *dst_byte_ptr++ = ((*src1_plane_data_base++) 
					% (*src2_plane_data_base++));
		else
		    {
                    *dst_byte_ptr++ = *src1_plane_data_base++;
		    src2_plane_data_base++;
		    }
		}/* end ix loop */
	    dst_byte_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /*end iy loop */
	break;
	}

    case IpsK_SetToSrc2:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
		    {
                    *dst_byte_ptr++ = *src2_plane_data_base++;
		    src1_plane_data_base++;
		    }
		else
		    {
                    *dst_byte_ptr++ = *src1_plane_data_base++;
		    src2_plane_data_base++;
		    }
                } /* end of ix loop */

	    dst_byte_ptr +=  dst_pad;
	    src1_plane_data_base += src1_pad;
	    src2_plane_data_base += src2_pad;
	    cpp_ptr += cpp_stride;
            } /* end of iy loop */
	break;
	}

    default:
        return (IpsX_UNSOPTION);
        break;
    }
return (IpsX_SUCCESS);
}/* end of _IpsArithmeticBytCpp */

/*****************************************************************************
**  _IpsArithmeticW - 
**
**  FUNCTIONAL DESCRIPTION:
**	Performs arithmetic operations on corresponding values from the 
**      two unigned word type source images to produce results for the 
** 	destination image (of datatype unsigned word) on a point by point 
**	basis.  
**
**  FORMAL PARAMETERS:
**
**      src1_udp
**	src2_udp
**	dst_udp
**	operator
**      control
**	result_flag
**
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsArithmeticW(src1_udp,src2_udp,dst_udp, operator, control, result_flag)
struct UDP *src1_udp;		/* source 1 word data type UDP */
struct UDP *src2_udp;		/* source 2 word data type UDP */
struct UDP *dst_udp;		/* destination UDP	       */
unsigned long operator;		/* arithmetic operation to be performed */
unsigned long control;		/* overflow/underflow control handling option */
unsigned long *result_flag;      /* indicates the nature of the results  */
{
unsigned short int *src1_plane_data_base;  /* pointer to source data base  */
unsigned short int *src2_plane_data_base;  /* pointer to dest  data base   */
unsigned short int *dst_word_ptr;          /* used for dst image           */
unsigned long   ix,iy;                     /* loop counters                */
unsigned long   src1_stride;		   /* source 1 udp stride          */
unsigned long   src2_stride;		   /* source 2 udp stride          */
unsigned long   dst_stride;		   /* dst udp stride               */
unsigned long   src1_pad;                  /* src1 pad		           */
unsigned long   src2_pad;                  /* src2 pad                     */
unsigned long   dst_pad;                   /* dst pad		           */
unsigned long   size;                      /* buffer size                  */
long            result;			   /* temp variable for true result*/

src1_plane_data_base = (unsigned short int *)src1_udp->UdpA_Base + 
                    ((src1_udp->UdpL_Pos + 
		    (src1_udp->UdpL_ScnStride * src1_udp->UdpL_Y1) +
		    (src1_udp->UdpL_X1 * src1_udp->UdpL_PxlStride) )>>4);

src2_plane_data_base = (unsigned short int *)src2_udp->UdpA_Base + 
                    ((src2_udp->UdpL_Pos + 
		    (src2_udp->UdpL_ScnStride * src2_udp->UdpL_Y1) +
		    (src2_udp->UdpL_X1 * src2_udp->UdpL_PxlStride) )>>4);

dst_word_ptr = (unsigned short int *) dst_udp->UdpA_Base + 
                    ((dst_udp->UdpL_Pos + 
		    (dst_udp->UdpL_ScnStride * dst_udp->UdpL_Y1) +
		    (dst_udp->UdpL_X1 * dst_udp->UdpL_PxlStride) )>>4);

src1_stride = (src1_udp->UdpL_ScnStride >> 4);
src2_stride = (src2_udp->UdpL_ScnStride >> 4);
dst_stride = (dst_udp->UdpL_ScnStride >> 4);
src1_pad = src1_stride  - src1_udp->UdpL_PxlPerScn;
src2_pad = src2_stride - src2_udp->UdpL_PxlPerScn;
dst_pad = dst_stride - dst_udp->UdpL_PxlPerScn;

switch (operator)
    {
    case IpsK_Addition:
        {
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        result = ((*src1_plane_data_base++) 
					+ (*src2_plane_data_base++));

		        if ((result < 0) || (result > 65535))
			    {
			    if (result < 0)
			        *dst_word_ptr++ = 0;
                            else 
		                *dst_word_ptr++ = 65535;
			    *result_flag = IpsK_SUCCESS_CLIP;
			    }
		        else
		            *dst_word_ptr++ = result;
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        *dst_word_ptr++ = ((*src1_plane_data_base++) 
					+ (*src2_plane_data_base++));
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_SubtractSrc2FromSrc1:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        result = ((*src1_plane_data_base++) 
					- (*src2_plane_data_base++));
		        if ((result < 0) || (result > 65535))
			    {
			    if (result < 0)
			        *dst_word_ptr++ = 0;
                            else 
		                *dst_word_ptr++ = 65535;
			    *result_flag = IpsK_SUCCESS_CLIP;
			    }
		        else
		            *dst_word_ptr++ = result;
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        *dst_word_ptr++ = ((*src1_plane_data_base++) 
					- (*src2_plane_data_base++));
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}

    case IpsK_SubtractSrc1FromSrc2:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        result = ((*src2_plane_data_base++) 
					- (*src1_plane_data_base++));

		        if ((result < 0) || (result > 65535))
			    {
			    if (result < 0)
			        *dst_word_ptr++ = 0;
                            else 
		                *dst_word_ptr++ = 65535;
			    *result_flag = IpsK_SUCCESS_CLIP;
			    }
		        else
		            *dst_word_ptr++ = result;
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        *dst_word_ptr++ = ((*src2_plane_data_base++) 
					- (*src1_plane_data_base++));
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_Multiplication:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        result = ((*src2_plane_data_base++) 
					* (*src1_plane_data_base++));
		        if ((result < 0) || (result > 65535))
			    {
			    if (result < 0)
			        *dst_word_ptr++ = 0;
                            else 
		                *dst_word_ptr++ = 65535;
			    *result_flag = IpsK_SUCCESS_CLIP;
			    }
		        else
		            *dst_word_ptr++ = result;
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        *dst_word_ptr++ = ((*src2_plane_data_base++) 
					* (*src1_plane_data_base++));
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_DivideSrc1BySrc2:
	{
	for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if (*src2_plane_data_base != 0)
                    *dst_word_ptr++ = ((*src1_plane_data_base++) 
					/ (*src2_plane_data_base++));
		else
		    {
		    src2_plane_data_base++;
		    *dst_word_ptr++ = *src1_plane_data_base++;
		    }
	        }/* end ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
	    } /*end iy loop */
	break;
	}

    case IpsK_DivideSrc2BySrc1:
	{
	for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if (*src1_plane_data_base != 0)
                            *dst_word_ptr++ = ((*src2_plane_data_base++) 
					     / (*src1_plane_data_base++));
		else
		    {
		    src1_plane_data_base++;
		    *dst_word_ptr++ = *src2_plane_data_base++;
		    }
		}/* end ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
	    } /*end iy loop */
        break;
	}
    case IpsK_Minimum:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                *dst_word_ptr++ = MIN_(*src1_plane_data_base, 
					*src2_plane_data_base);
		src2_plane_data_base++;
		src1_plane_data_base++;
                } /* end of ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop */
	break;
	}
    case IpsK_Maximum:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                *dst_word_ptr++ = MAX_(*src1_plane_data_base, 
					*src2_plane_data_base);
		src2_plane_data_base++;
		src1_plane_data_base++;
                } /* end of ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop */
	break;
	}
    case IpsK_Src1ModuloSrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if (*src2_plane_data_base != 0)
                    *dst_word_ptr++ = ((*src1_plane_data_base++) 
					% (*src2_plane_data_base++));
		else 
		    {
		    dst_word_ptr++;
		    src2_plane_data_base++;
		    src1_plane_data_base++;
		    }
		}/* end ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /*end iy loop */
	break;
	}

    case IpsK_SetToSrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                *dst_word_ptr++ = *src2_plane_data_base++;
	    dst_word_ptr +=  dst_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop */
	break;
	}

    default:
        return (IpsX_UNSOPTION);
        break;
    }
return (IpsX_SUCCESS);
}/* end of _IpsArithmeticW */

/*****************************************************************************
**  _IpsArithmeticWCpp - 
**
**  FUNCTIONAL DESCRIPTION:
**	Performs arithmetic operations on corresponding values from the 
**      two unigned word type source images to produce results for the 
** 	destination image (of datatype unsigned word) on a point by point 
**	basis.  
**
**      This routine tests the bits in the CPP plane corresponding to
**	the pixels being operated on.
** 
**	    If the CPP bit is set, it performs the operation and
**	    places the result in the corresponding destination plane pixel
**	    location.
**
**	    If the CPP bit is not set, the pixel value of the sourc1
**	    plane is placed in the corresponding destination plane pixel
**	    location.
** 
** 
**  FORMAL PARAMETERS:
**
**      src1_udp
**	src2_udp
**	dst_udp
**      cpp
**	operator
**      control
**	result_flag
**
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsArithmeticWCpp(src1_udp, src2_udp,dst_udp,cpp,operator,control,result_flag)
struct UDP *src1_udp;      /* word data type first source udp      */
struct UDP *src2_udp;      /* word data type second source udp     */
struct UDP *dst_udp;       /* destination data type                */
struct UDP *cpp;           /* control processing plane             */
unsigned long operator;    /* arithmetic operation to be performed */
unsigned long control;     /* overflow/underflow control option    */
unsigned long *result_flag; /* indicates the nature of the results  */
{
unsigned long      size;                   /* buffer size                 */
unsigned short int *src1_plane_data_base;  /* pointer to source data base */
unsigned short int *src2_plane_data_base;  /* pointer to dest  data base  */
unsigned short int *dst_word_ptr;          /* used for dst image          */
unsigned long      ix,iy;                  /* loop counters               */
unsigned char      *cpp_ptr;               /* control proc plane base     */
unsigned long      cpp_stride;             /* control proc plane stride   */
unsigned long	   src1_stride;            /* src1 scanline stride        */
unsigned long      src2_stride;		   /* src2 scanline stride        */
unsigned long      dst_stride;		   /* dst scanline stride         */
unsigned long      src1_pad;               /* src1 pad		          */
unsigned long      src2_pad;               /* src2 pad                    */
unsigned long      dst_pad;                /* dst pad		          */
long		   result;		   /* temp var for true result    */

src1_plane_data_base = (unsigned short int *)src1_udp->UdpA_Base + 
                    ((src1_udp->UdpL_Pos + 
		    (src1_udp->UdpL_ScnStride * src1_udp->UdpL_Y1) +
		    (src1_udp->UdpL_X1 * src1_udp->UdpL_PxlStride) )>>4);

src2_plane_data_base = (unsigned short int *)src2_udp->UdpA_Base + 
                    ((src2_udp->UdpL_Pos + 
		    (src2_udp->UdpL_ScnStride * src2_udp->UdpL_Y1) +
		    (src2_udp->UdpL_X1 * src2_udp->UdpL_PxlStride) )>>4);

dst_word_ptr = (unsigned short int *) dst_udp->UdpA_Base + 
                    ((dst_udp->UdpL_Pos + 
		    (dst_udp->UdpL_ScnStride * dst_udp->UdpL_Y1) +
		    (dst_udp->UdpL_X1 * dst_udp->UdpL_PxlStride) )>>4);


cpp_ptr = (unsigned char *) cpp->UdpA_Base
                + (((cpp->UdpL_Pos +
		  (cpp->UdpL_ScnStride * cpp->UdpL_Y1) +
		   cpp->UdpL_X1)+7)/8);

cpp_stride = (cpp->UdpL_ScnStride >> 3);
src1_stride = (src1_udp->UdpL_ScnStride >> 4);
src2_stride = (src2_udp->UdpL_ScnStride >> 4);
dst_stride = (dst_udp->UdpL_ScnStride >> 4);
src1_pad = src1_stride  - src1_udp->UdpL_PxlPerScn;
src2_pad = src2_stride - src2_udp->UdpL_PxlPerScn;
dst_pad = dst_stride - dst_udp->UdpL_PxlPerScn;

switch (operator)
    {
    case IpsK_Addition:
        {
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
			if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
			    {
                            result = ((*src1_plane_data_base++) 
					+ (*src2_plane_data_base++));

		            if ((result < 0) || (result > 65535))
				{
			        if (result < 0)
			            *dst_word_ptr++ = 0;
                                else 
		                    *dst_word_ptr++ = 65535;
			        *result_flag = IpsK_SUCCESS_CLIP;
				}
		            else
		                *dst_word_ptr++ = result;
			    }
			else
			    {
                            *dst_word_ptr++ = *src1_plane_data_base++;
                            src2_plane_data_base++;
                            }
 		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
                    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            *dst_word_ptr++ = ((*src1_plane_data_base++) 
					+ (*src2_plane_data_base++));
			else
			    { 
                            *dst_word_ptr++ = *src1_plane_data_base++;
                            src2_plane_data_base++;
			    }
 		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
                    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_SubtractSrc2FromSrc1:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            {
                            result = ((*src1_plane_data_base++) 
					- (*src2_plane_data_base++));
		            if ((result < 0) || (result > 65535))
				{
			        if (result < 0)
			            *dst_word_ptr++ = 0;
                                else 
		                    *dst_word_ptr++ = 65535;
			        *result_flag = IpsK_SUCCESS_CLIP;
				}
		            else
		                *dst_word_ptr++ = result;
			    }
                        else
                            {
                            *dst_word_ptr++ = *src1_plane_data_base++;
                            src2_plane_data_base++;
                            }
 		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
                    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            *dst_word_ptr++ = ((*src1_plane_data_base++) 
					- (*src2_plane_data_base++));
                        else
                            {
                            *dst_word_ptr++ = *src1_plane_data_base++;
                            src2_plane_data_base++;
                            }
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
                    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}

    case IpsK_SubtractSrc1FromSrc2:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            {
                            result = ((*src2_plane_data_base++) 
					- (*src1_plane_data_base++));
		            if ((result < 0) || (result > 65535))
				{
			        if (result < 0)
			            *dst_word_ptr++ = 0;
                                else 
		                    *dst_word_ptr++ = 65535;
			        *result_flag = IpsK_SUCCESS_CLIP;
				}
		            else
		                *dst_word_ptr++ = result;
			    }
                       else
                            {
                            *dst_word_ptr++ = *src1_plane_data_base++;
                            src2_plane_data_base++;
                            }
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
                    cpp_ptr += cpp_stride;
		    } /* end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            *dst_word_ptr++ = ((*src2_plane_data_base++) 
					- (*src1_plane_data_base++));
                        else
                            {
                            *dst_word_ptr++ = *src1_plane_data_base++;
                            src2_plane_data_base++;
                            }
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
                    cpp_ptr += cpp_stride;
		    } /* end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}

    case IpsK_Multiplication:
	{
	switch (control)
	    {
	    case IpsK_Clip:
	        {
		*result_flag = IpsK_SUCCESS_NOCLIP;
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            {
                            result = ((*src2_plane_data_base++) 
					* (*src1_plane_data_base++));
		            if ((result < 0) || (result > 65535))
				{
			        if (result < 0)
			            *dst_word_ptr++ = 0;
                                else 
		                    *dst_word_ptr++ = 65535;
			        *result_flag = IpsK_SUCCESS_CLIP;
				}
		            else
		                *dst_word_ptr++ = result;
			    }
			else
                            {
                            *dst_word_ptr++ = *src1_plane_data_base++;
                            src2_plane_data_base++;
                            }
		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
                    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    case IpsK_Wrap:
	    default:
	        {
                for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
                    {
                    for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                        {
                        if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                            *dst_word_ptr++ = ((*src2_plane_data_base++) 
					* (*src1_plane_data_base++));
                        else
                            {
                            *dst_word_ptr++  = *src1_plane_data_base++;
                            src2_plane_data_base++;
                            }
 		        }/* end ix loop */
		    dst_word_ptr +=  dst_pad;
		    src1_plane_data_base  += src1_pad;
		    src2_plane_data_base += src2_pad;
                    cpp_ptr += cpp_stride;
		    } /*end iy loop */
		break;
	        }
	    }/* end switch on control */
        break;
	}
    case IpsK_DivideSrc1BySrc2:
	{
	for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if ((*src2_plane_data_base != 0) &&
                           ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE))
                    *dst_word_ptr++ = ((*src1_plane_data_base++) 
					/ (*src2_plane_data_base++));
		else
		    {
		    src2_plane_data_base++;
		    *dst_word_ptr++ = *src1_plane_data_base++;
		    }
	        }/* end ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
	    } /*end iy loop */
        break;
	}

    case IpsK_DivideSrc2BySrc1:
	{
	for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                    {
                    if (*src1_plane_data_base != 0)
                        *dst_word_ptr++ = ((*src2_plane_data_base++) 
					     / (*src1_plane_data_base++));
		    else
		        {
		        src1_plane_data_base++;
		        *dst_word_ptr++ = *src2_plane_data_base++;
		        }
		    }
                else
                    {
                    *dst_word_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
 		}/* end ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
	    } /*end iy loop */
	break;
	}
    case IpsK_Minimum:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                    {
                    *dst_word_ptr++ = MIN_(*src1_plane_data_base, 
					*src2_plane_data_base);
		    src2_plane_data_base++;
		    src1_plane_data_base++;
		    }
                else
                    {
                    *dst_word_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                }/* end of ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop */
	break;
	}
    case IpsK_Maximum:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                    {
                    *dst_word_ptr++ = MAX_(*src1_plane_data_base, 
					*src2_plane_data_base);
		    src2_plane_data_base++;
		    src1_plane_data_base++;
		    }
                else
                    {
                    *dst_word_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop */
	break;
	}
    case IpsK_Src1ModuloSrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if (((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                    && (*src2_plane_data_base != 0))
                    *dst_word_ptr++ = ((*src1_plane_data_base++) 
					% (*src2_plane_data_base++));
                else
                    {
                    *dst_word_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
		}/* end ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end iy loop */
	break;
	}
    case IpsK_SetToSrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
		    {
                    *dst_word_ptr++ = *src2_plane_data_base++;
		    src1_plane_data_base++;
		    }
                else
                    {
                    *dst_word_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop */
	    dst_word_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop */
	break;
	}
    default:
        return (IpsX_UNSOPTION);
        break;
    }
return (IpsX_SUCCESS);
}/* end of _IpsArithmeticWCpp */

/*****************************************************************************
**  _IpsArithmeticFlt - 
**
**  FUNCTIONAL DESCRIPTION:
**	Performs arithmetic operations on corresponding values from the 
**      two floating point datatype source images to produce results for 
**      the floating point destination image on a point by point basis.  
**
**  FORMAL PARAMETERS:
**
**      src1_udp
**	src2_udp
**	dst_udp
**	operator
**	
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsArithmeticFlt(src1_udp, src2_udp, dst_udp, operator)
struct UDP *src1_udp;  /* source 1 float dtype udp */
struct UDP *src2_udp;  /* source 2 float dtype udp */
struct UDP *dst_udp;   /* destination udp          */
unsigned long operator;/* arithmetic operation     */
{
float	        *src1_plane_data_base;  /* pointer to source data base */
float	        *src2_plane_data_base;  /* pointer to dest  data base  */
float           *dst_float_ptr;		/* used for dst image          */
unsigned long   size;                   /* buffer size                 */
unsigned long   ix,iy;                  /* loop counters               */
unsigned long	src1_stride;		/* source 1 scanline stride    */
unsigned long	src2_stride;            /* source 2 scanline stride    */
unsigned long	dst_stride;             /* dst scanline stride	       */
unsigned long   src1_pad;               /* src1 pad		       */
unsigned long   src2_pad;               /* src2 pad                    */
unsigned long   dst_pad;                /* dst pad		       */

src1_plane_data_base = (float *)src1_udp->UdpA_Base + 
                    ((src1_udp->UdpL_Pos + 
		    (src1_udp->UdpL_ScnStride * src1_udp->UdpL_Y1) +
		    (src1_udp->UdpL_X1 * src1_udp->UdpL_PxlStride) )>>5);

src2_plane_data_base = (float *)src2_udp->UdpA_Base + 
                    ((src2_udp->UdpL_Pos + 
		    (src2_udp->UdpL_ScnStride * src2_udp->UdpL_Y1) +
		    (src2_udp->UdpL_X1 * src2_udp->UdpL_PxlStride) )>>5);

dst_float_ptr = (float *) dst_udp->UdpA_Base + 
                    ((dst_udp->UdpL_Pos + 
		    (dst_udp->UdpL_ScnStride * dst_udp->UdpL_Y1) +
		    (dst_udp->UdpL_X1 * dst_udp->UdpL_PxlStride) )>>5);

src1_stride = (src1_udp->UdpL_ScnStride >> 5);
src2_stride = (src2_udp->UdpL_ScnStride >> 5);
dst_stride = (dst_udp->UdpL_ScnStride >> 5);
src1_pad = src1_stride  - src1_udp->UdpL_PxlPerScn;
src2_pad = src2_stride - src2_udp->UdpL_PxlPerScn;
dst_pad = dst_stride - dst_udp->UdpL_PxlPerScn;
dst_udp->UdpL_Levels = 0;

switch (operator)
    {
    case IpsK_Addition:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                *dst_float_ptr++ = ((*src2_plane_data_base++)
					+  (*src1_plane_data_base++));
                } /* end of ix loop */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop */
            break;
	}
    case IpsK_SubtractSrc2FromSrc1:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                    *dst_float_ptr++ = ((*src1_plane_data_base++)
					-  (*src2_plane_data_base++));
                } /* end of ix loop */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop */
	break;
	}
    case IpsK_SubtractSrc1FromSrc2:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                *dst_float_ptr++ = ((*src2_plane_data_base++)
					-  (*src1_plane_data_base++));
                } /* end of ix loop */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop */
	break;
	}
    case IpsK_Multiplication:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                *dst_float_ptr++ = ((*src1_plane_data_base++)
					*  (*src2_plane_data_base++));
                } /* end of ix loop */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop */
	break;
	}

    case IpsK_DivideSrc1BySrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if (*src2_plane_data_base != 0)
                    *dst_float_ptr++ = ((*src1_plane_data_base++)
					/ (*src2_plane_data_base++));
		else
		    {
		    dst_float_ptr++;
		    src1_plane_data_base++;
		    src2_plane_data_base++;
		    };
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop      */
	break;
	}
    case IpsK_DivideSrc2BySrc1:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if (*src1_plane_data_base != 0)
                    *dst_float_ptr++ = ((*src2_plane_data_base++)
					/ (*src1_plane_data_base++));
		else
		    {
		    src1_plane_data_base++;
		    src2_plane_data_base++;
		    dst_float_ptr++;
		    };
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop      */
	break;
	}
    case IpsK_Minimum:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                *dst_float_ptr++ = MIN_(*src1_plane_data_base, 
					*src2_plane_data_base);
		src2_plane_data_base++;
		src1_plane_data_base++;
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop      */
	break;
	}
    case IpsK_Maximum:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                *dst_float_ptr++ = MAX_(*src1_plane_data_base, 
					*src2_plane_data_base);
		src2_plane_data_base++;
		src1_plane_data_base++;
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop      */
	break;
	}
    case IpsK_Src1ModuloSrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if (*src2_plane_data_base != 0)
                    *dst_float_ptr  = ((long)(*src1_plane_data_base++) 
					% (long)(*src2_plane_data_base++));
		else 
		    {
		    dst_float_ptr++;
		    src2_plane_data_base++;
		    src1_plane_data_base++;
		    }
		}/* end ix loop */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            } /*end iy loop */
	break;
	}

    case IpsK_SetToSrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                *dst_float_ptr++ = *src2_plane_data_base++;

	    dst_float_ptr +=  dst_pad;
	    src2_plane_data_base += src2_pad;
            } /* end of iy loop      */
	break;
	}

    default:
        return (IpsX_UNSOPTION);
        break;
    }
return (IpsX_SUCCESS);
}/* end of _IpsArithmeticFlt */

/*****************************************************************************
**  _IpsArithmeticFltCpp - 
**
**  FUNCTIONAL DESCRIPTION:
**	Performs arithmetic operations on corresponding values from the 
**      two floating point datatype source images to produce results for 
**      the floating point destination image on a point by point basis.  
**
**      This routine tests the bits in the CPP plane corresponding to
**	the pixels being operated on.
** 
**	    If the CPP bit is set, it performs the operation and
**	    places the result in the corresponding destination plane pixel
**	    location.
**
**	    If the CPP bit is not set, the pixel value of the sourc1
**	    plane is placed in the corresponding destination plane pixel
**	    location.
**
**  FORMAL PARAMETERS:
**
**      src1_udp
**	src2_udp
**	dst_udp
**      cpp
**	operator
**
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsArithmeticFltCpp(src1_udp, src2_udp, dst_udp, cpp, operator)
struct UDP *src1_udp;  /* source 1 float dtype udp */
struct UDP *src2_udp;  /* source 2 float dtype udp */
struct UDP *dst_udp;   /* destination udp          */
struct UDP *cpp;       /* control proc plane       */
unsigned long operator;/* arithmetic operation     */
{
float	        *src1_plane_data_base;  /* pointer to source data base */
float	        *src2_plane_data_base;  /* pointer to dest  data base  */
float           *dst_float_ptr;		/* used for dst image          */
unsigned long   size;                   /* buffer size                 */
unsigned long   ix,iy;                  /* loop counters               */
unsigned char   *cpp_ptr;               /* control proc plane base     */
unsigned long   cpp_stride;		/* control proc plane stride   */
unsigned long	src1_stride;	        /* source 1 scanline stride    */
unsigned long   src2_stride;		/* source 2 scanline stride    */
unsigned long   dst_stride;		/* dst scanline stride	       */
unsigned long   src1_pad;               /* src1 pad		       */
unsigned long   src2_pad;               /* src2 pad                    */
unsigned long   dst_pad;                /* dst pad		       */

src1_plane_data_base = (float *)src1_udp->UdpA_Base + 
                    ((src1_udp->UdpL_Pos + 
		    (src1_udp->UdpL_ScnStride * src1_udp->UdpL_Y1) +
		    (src1_udp->UdpL_X1 * src1_udp->UdpL_PxlStride) )>>5);

src2_plane_data_base = (float *)src2_udp->UdpA_Base + 
                    ((src2_udp->UdpL_Pos + 
		    (src2_udp->UdpL_ScnStride * src2_udp->UdpL_Y1) +
		    (src2_udp->UdpL_X1 * src2_udp->UdpL_PxlStride) )>>5);

dst_float_ptr = (float *) dst_udp->UdpA_Base + 
                    ((dst_udp->UdpL_Pos + 
		    (dst_udp->UdpL_ScnStride * dst_udp->UdpL_Y1) +
		    (dst_udp->UdpL_X1 * dst_udp->UdpL_PxlStride) )>>5);

cpp_ptr = (unsigned char *) cpp->UdpA_Base
                + (((cpp->UdpL_Pos +
		  (cpp->UdpL_ScnStride * cpp->UdpL_Y1) +
		   cpp->UdpL_X1)+7)/8);

src1_stride = (src1_udp->UdpL_ScnStride >> 5);
src2_stride = (src2_udp->UdpL_ScnStride >> 5);
dst_stride = (dst_udp->UdpL_ScnStride >> 5);
src1_pad = src1_stride  - src1_udp->UdpL_PxlPerScn;
src2_pad = src2_stride - src2_udp->UdpL_PxlPerScn;
dst_pad = dst_stride - dst_udp->UdpL_PxlPerScn;
cpp_stride = (cpp->UdpL_ScnStride >> 3);
dst_udp->UdpL_Levels = 0;

switch (operator)
    {
    case IpsK_Addition:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                    *dst_float_ptr++ = ((*src2_plane_data_base++)
					+  (*src1_plane_data_base++));
                else
                    {
                    *dst_float_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop      */
            break;
	}
    case IpsK_SubtractSrc2FromSrc1:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                    *dst_float_ptr++ = ((*src1_plane_data_base++)
					-  (*src2_plane_data_base++));
                else
                    {
                    *dst_float_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop      */
	break;
	}
    case IpsK_SubtractSrc1FromSrc2:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                    *dst_float_ptr++ = ((*src2_plane_data_base++)
					-  (*src1_plane_data_base++));
                else
                    {
                    *dst_float_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop      */
	break;
	}
    case IpsK_Multiplication:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
                    *dst_float_ptr++ = ((*src1_plane_data_base++)
					*  (*src2_plane_data_base++));
                else
                    {
                    *dst_float_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop      */
	break;
	}

    case IpsK_DivideSrc1BySrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if ((*src2_plane_data_base != 0) &&
                    ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE))
                    *dst_float_ptr++ = ((*src1_plane_data_base++)
					/ (*src2_plane_data_base++));
		else
                    {
                    *dst_float_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop */
	break;
	}
    case IpsK_DivideSrc2BySrc1:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if ((*src1_plane_data_base != 0) &&
                    ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE))
                    *dst_float_ptr++ = ((*src2_plane_data_base++)
					/ (*src1_plane_data_base++));
                else
                    {
                    *dst_float_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop      */
	break;
	}
    case IpsK_Minimum:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
		    {
                    *dst_float_ptr++ = MIN_(*src1_plane_data_base, 
					*src2_plane_data_base);
		    src2_plane_data_base++;
		    src1_plane_data_base++;
		    }
                else
                    {
                    *dst_float_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop      */
	break;
	}
    case IpsK_Maximum:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
		    {
                    *dst_float_ptr++ = MAX_(*src1_plane_data_base, 
					*src2_plane_data_base);
		    src2_plane_data_base++;
		    src1_plane_data_base++;
		    }
                else
                    {
                    *dst_float_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop      */
	break;
	}
    case IpsK_Src1ModuloSrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
		if ((*src2_plane_data_base != 0) &&
                    ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE))
                    *dst_float_ptr++ = ((long)(*src1_plane_data_base++) 
					% (long)(*src2_plane_data_base++));
		else
                    {
                    *dst_float_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
		}/* end ix loop */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /*end iy loop */
	break;
	}

    case IpsK_SetToSrc2:
	{
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((GET_BIT_VALUE_(cpp_ptr,ix)) == TRUE)
		    {
                    *dst_float_ptr++ = *src2_plane_data_base++;
		    src1_plane_data_base++;
		    }
                else
                    {
                    *dst_float_ptr++ = *src1_plane_data_base++;
                    src2_plane_data_base++;
                    }
                } /* end of ix loop      */
	    dst_float_ptr +=  dst_pad;
	    src1_plane_data_base  += src1_pad;
	    src2_plane_data_base += src2_pad;
            cpp_ptr += cpp_stride;
            } /* end of iy loop      */
	break;
	}

    default:
        return (IpsX_UNSOPTION);
        break;
    }
return (IpsX_SUCCESS);
}/* end of _IpsArithmeticFltCpp */
