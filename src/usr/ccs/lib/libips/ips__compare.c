/************************************************************************
**
**  Copyright (c) Digital Equipment Corporation, 1990-1991 All Rights Reserved.
**  Unpublished rights reserved under the copyright laws of the United States.
**  The software contained on this media is proprietary to and embodies the
**  confidential technology of Digital Equipment Corporation.  Possession, use,
**  duplication or dissemination of the software and media is authorized only
**  pursuant to a valid written license from Digital Equipment Corporation.
**  RESTRICTED RIGHTS LEGEND   Use, duplication, or disclosure by the U.S.
**  Government is subject to restrictions as set forth in Subparagraph
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.
**/

/************************************************************************
**
**  FACILITY:
**
**      Image Processing Services
**
**  ABSTRACT:
**
**      This module contains the user level service and support routines
**	for comparison operations of two input images of matching data types
**      and generates a destination image bitmap based on the results of the
**      comparison.
**
**  ENVIRONMENT:
**
**      VAX/VMS, VAX/ULTRIX, RISC/ULTRIX
**
**  AUTHOR(S):
**
**      Karen Rodwell
**
**  CREATION DATE:
**
**      24-MAR-1990
**
************************************************************************/

/*
**  Table of contents
*/
#ifdef NODAS_PROTO
long _IpsCompare();		    /* main entry routine, tests dtype     */
long _IpsCompareByt();		    /* comparison operations on byte dtype */
long _IpsCompareW();		    /* comparison operations on word dtype */
long _IpsCompareFlt();  	    /* comparison operations on float dtype*/
#endif

/*
**  Include files
*/
#include <IpsDef.h>			    /* IPS Image Definitions	     */
#include <IpsMacros.h>			    /* IPS Macro Definitions	     */
#include <IpsMemoryTable.h>                 /* IPS Memory Mgt Functions      */
#include <IpsStatusCodes.h>		    /* IPS Status Codes		     */
#ifndef NODAS_PROTO
#include <ipsprot.h>			    /* Ips prototypes */
#endif

/*
**  External references
*/
#ifdef NODAS_PROTO
long _IpsVerifyNotInPlace();
#endif


/*****************************************************************************
**  _IpsCompare - 
**
**  FUNCTIONAL DESCRIPTION:
**	Performs comparison operations on corresponding values from the 
**      two source images to produce results for the destination image on 
**      a point by point basis.  
**
**  FORMAL PARAMETERS:
**
**      src1_udp -- Pointer to first source udp
**	src2_udp -- Pointer to second source udp
**	dst_udp  -- Pointer to destination udp (uninitialized)
**	operator -- Compare operation to be performed on two planes
**	result_flag -- Specifies the nature of the results.
**
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsCompare(src1_udp, src2_udp, dst_udp, operator,result_flag)
struct UDP *src1_udp;       /* First Source UDP for comparison            */
struct UDP *src2_udp;       /* Second Source UDP for comparison           */
struct UDP *dst_udp;        /* Destination UDP generated by comparison op */
long operator;	            /* Comparison operator                        */
unsigned long *result_flag; /* Specfies the nature of the results         */
{
unsigned long mem_allocated; /* flag to indicate memory was allocated here */
long status;
long byte_boundary_padbits;
long size;
if  (src1_udp->UdpB_Class != UdpK_ClassA)
    return (IpsX_UNSOPTION);

/* The comparison routine does not support in place operations */
/* meaning that the destination base can not be equal to the source. */

/* return mismatch error if the dimensions are mismatched */
if ((src1_udp->UdpL_ScnCnt != src2_udp->UdpL_ScnCnt) ||
    (src1_udp->UdpL_PxlPerScn != src2_udp->UdpL_PxlPerScn) ||
    (src1_udp->UdpB_DType != src2_udp->UdpB_DType))
    return (IpsX_NOMATCH);

if ((src1_udp->UdpB_DType == UdpK_DTypeVU) ||
    (src1_udp->UdpB_DType == UdpK_DTypeV) ||
    (src2_udp->UdpB_DType == UdpK_DTypeVU) ||
    (src2_udp->UdpB_DType == UdpK_DTypeV))
    return (IpsX_INVDTYPE);

dst_udp->UdpL_PxlPerScn = src1_udp->UdpL_PxlPerScn;
dst_udp->UdpL_ScnCnt = src1_udp->UdpL_ScnCnt;
dst_udp->UdpL_X1 = 0;
dst_udp->UdpL_Y1 = 0;
dst_udp->UdpL_X2 = src1_udp->UdpL_PxlPerScn - 1;
dst_udp->UdpL_Y2 = src1_udp->UdpL_ScnCnt - 1;
byte_boundary_padbits = (8 - (src1_udp->UdpL_PxlPerScn % 8)) % 8;
dst_udp->UdpL_ScnStride = src1_udp->UdpL_PxlPerScn + byte_boundary_padbits;
dst_udp->UdpW_PixelLength = 1;
dst_udp->UdpL_PxlStride = 1;
dst_udp->UdpB_DType = UdpK_DTypeVU;
dst_udp->UdpB_Class = UdpK_ClassUBA;
size = dst_udp->UdpL_ScnStride * dst_udp->UdpL_ScnCnt;
if (dst_udp->UdpA_Base != 0)
    {
    /* No in place allowed */
    status = _IpsVerifyNotInPlace (src1_udp, dst_udp);
        if (status != IpsX_SUCCESS) return (status);
    if ((dst_udp->UdpL_ArSize - dst_udp->UdpL_Pos) < size)
        return (IpsX_INSVIRMEM);

    }
else
    {
    dst_udp->UdpA_Base = (unsigned char *)
        (*IpsA_MemoryTable[IpsK_AllocateDataPlane])
                (((size + 7) >> 3),IpsM_InitMem, 0);
    if (!dst_udp->UdpA_Base) return (IpsX_INSVIRMEM);
    mem_allocated = TRUE;
    dst_udp->UdpL_ArSize = size;
    dst_udp->UdpL_Pos = 0;
    }
dst_udp->UdpL_Levels = 2;  

*result_flag = 0;
switch (src1_udp->UdpB_DType)
    {
    case UdpK_DTypeBU:
	/* byte op byte = byte */
	status = _IpsCompareByt
		    (src1_udp, src2_udp, dst_udp, operator,result_flag);
    break;

    case UdpK_DTypeWU:
	/* word op word = word */
	status = _IpsCompareW
		    (src1_udp, src2_udp, dst_udp, operator,result_flag);
    break;

    case UdpK_DTypeF:
	/* float op float = float */
	/* control is ignored with float operations */
	status = _IpsCompareFlt
		    (src1_udp, src2_udp, dst_udp, operator,result_flag);
    break;

    case UdpK_DTypeLU: 
    default:
	status = IpsX_UNSOPTION;
    break;

    };  /* end switch on DType */

if ((status != IpsX_SUCCESS) && (mem_allocated == TRUE))
    (*IpsA_MemoryTable[IpsK_FreeDataPlane]) (dst_udp->UdpA_Base);

return (status);
}

/*****************************************************************************
**  _IpsCompareByt - 
**
**  FUNCTIONAL DESCRIPTION:
**	Performs comparison operations on corresponding values from the 
**      two unsigned byte source images to produce results for the bitmap
**      destination image on a point by point basis.  
**
**  FORMAL PARAMETERS:
**
**      src1_udp -- Pointer to first source udp.
**	src2_udp -- Pointer to second source udp.
**	dst_udp  -- Pointer to destination udp.
**	operator -- Comparison operation to be performed.
**	result_flag -- specifies the nature of the results.
**
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsCompareByt(src1_udp, src2_udp, dst_udp, operator,result_flag)
struct UDP    *src1_udp;    /* first source udp                    */
struct UDP    *src2_udp;    /* second source udp                   */
struct UDP    *dst_udp;     /* destination udp                     */
unsigned long operator;     /* type of operation to be performed   */
unsigned long *result_flag; /* specifies the nature of the results */
{
unsigned long   size;                   /* buffer size                 */
unsigned char   *src1_plane_data_base;  /* pointer to source data base */
unsigned char   *src2_plane_data_base;  /* pointer to dest  data base  */
unsigned char   *dst_ptr;               /* used for dst image          */
unsigned long   ix,iy;                  /* loop counters               */
unsigned long	dst_stride;		/* dst(cpp) stride	       */
unsigned long   src1_stride;            /* src1 stride in bytes	       */
unsigned long   src2_stride;            /* src2 stride in bytes        */
unsigned long   src1_pad;               /* src1 pad                    */
unsigned long   src2_pad;               /* src2 pad                    */
unsigned long   set = 0;		/* counter for result_flag info*/

src1_plane_data_base = (unsigned char *)src1_udp->UdpA_Base + 
                    ((src1_udp->UdpL_Pos +
                    (src1_udp->UdpL_ScnStride * src1_udp->UdpL_Y1) +
                    (src1_udp->UdpL_X1 * src1_udp->UdpL_PxlStride) )>>3);

src2_plane_data_base = (unsigned char *)src2_udp->UdpA_Base + 
                    ((src2_udp->UdpL_Pos +
                    (src2_udp->UdpL_ScnStride * src2_udp->UdpL_Y1) +
                    (src2_udp->UdpL_X1 * src2_udp->UdpL_PxlStride) )>>3);

dst_ptr = (unsigned char *) dst_udp->UdpA_Base +
                   ((dst_udp->UdpL_Pos +
                    (dst_udp->UdpL_ScnStride * dst_udp->UdpL_Y1) +
                    (dst_udp->UdpL_X1))>>3);
 
dst_stride =  (dst_udp->UdpL_ScnStride >> 3);  /* stride is bumped by byte */
src1_stride = (src1_udp->UdpL_ScnStride >> 3); 
src2_stride = (src2_udp->UdpL_ScnStride >> 3);
src1_pad = src1_stride - src1_udp->UdpL_PxlPerScn;
src2_pad = src2_stride - src1_udp->UdpL_PxlPerScn;

switch (operator)
    {
    case IpsK_EQ:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					== (*src2_plane_data_base++))
		    {
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
 	    dst_ptr +=  dst_stride;
            } /*end iy loop */
        break;
	}/*end EQ */
    case IpsK_NE:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					!= (*src2_plane_data_base++))
                    {
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end NE */

    case IpsK_LT:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					< (*src2_plane_data_base++))
		    {	
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end LT */

    case IpsK_LE:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					<= (*src2_plane_data_base++))
		    {	
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end LE */

    case IpsK_GT:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					> (*src2_plane_data_base++))
		    {	
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end GT */
    case IpsK_GE:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					>= (*src2_plane_data_base++))
		    {			
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end GE */

    default:
        return (IpsX_UNSOPTION);
        break;
    }
if (set == 0)
    *result_flag = IpsK_SUCCESS_CLEAR;
else 
    {
    if (set == (src1_udp->UdpL_PxlPerScn * src1_udp->UdpL_ScnCnt))
        *result_flag = IpsK_SUCCESS_SET;
    else
	*result_flag = IpsK_SUCCESS_SOME;
    }
return (IpsX_SUCCESS);
}/* end of _IpsCompareByt */

/*****************************************************************************
**  _IpsCompareW - 
**
**  FUNCTIONAL DESCRIPTION:
**	Performs comparison operations on corresponding values from the 
**      two unigned word type source images to produce results for the 
** 	destination image bitmap on a point by point basis.  
**
**  FORMAL PARAMETERS:
**
**      src1_udp
**	src2_udp
**	dst_udp
**	operator
**	result_flag
**
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsCompareW(src1_udp, src2_udp, dst_udp, operator, result_flag)
struct UDP    *src1_udp;    /* word data type first source UDP      */
struct UDP    *src2_udp;    /* word data type second source UDP     */
struct UDP    *dst_udp;     /* destination UDP			    */
unsigned long operator;     /* comparison operation to be performed */
unsigned long *result_flag; /* specifies the nature of the result   */
{
unsigned short int *src1_plane_data_base;  /* pointer to source data base */
unsigned short int *src2_plane_data_base;  /* pointer to dest  data base  */
unsigned long      size;                   /* buffer size                 */
unsigned char      *dst_ptr;               /* destination image plane     */
unsigned long      ix,iy;                  /* loop counters               */
unsigned long	   dst_stride;		   /* stride of resultant plane   */
unsigned long      src1_stride;            /* src1 stride in bytes        */
unsigned long      src2_stride;            /* src2 stride in bytes        */
unsigned long      src1_pad;               /* src1 pad                    */
unsigned long      src2_pad;               /* src2 pad                    */
unsigned long      set = 0;		   /* counter for result_flag info*/

src1_plane_data_base = (unsigned short int *)src1_udp->UdpA_Base +
                    ((src1_udp->UdpL_Pos +
                    (src1_udp->UdpL_ScnStride * src1_udp->UdpL_Y1) +
                    (src1_udp->UdpL_X1 * src1_udp->UdpL_PxlStride) )>>4);

src2_plane_data_base = (unsigned short int *)src2_udp->UdpA_Base +
                    ((src2_udp->UdpL_Pos +
                    (src2_udp->UdpL_ScnStride * src2_udp->UdpL_Y1) +
                    (src2_udp->UdpL_X1 * src2_udp->UdpL_PxlStride) )>>4);

dst_ptr = (unsigned char *) dst_udp->UdpA_Base +
                   ((dst_udp->UdpL_Pos +
                    (dst_udp->UdpL_ScnStride * dst_udp->UdpL_Y1) +
                    (dst_udp->UdpL_X1))>>3);

dst_stride = (dst_udp->UdpL_ScnStride >> 3); /* stride in bytes */
src1_stride = (src1_udp->UdpL_ScnStride >> 4);
src2_stride = (src2_udp->UdpL_ScnStride >> 4);
src1_pad = src1_stride - src1_udp->UdpL_PxlPerScn;
src2_pad = src2_stride - src1_udp->UdpL_PxlPerScn;

switch (operator)
    {
    case IpsK_EQ:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					== (*src2_plane_data_base++))
                    {
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end EQ */
    case IpsK_NE:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					!= (*src2_plane_data_base++))
		    {	
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end NE */

    case IpsK_LT:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					< (*src2_plane_data_base++))
		    {
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end LT */

    case IpsK_LE:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					<= (*src2_plane_data_base++))
		    {	
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end LE */

    case IpsK_GT:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					> (*src2_plane_data_base++))
		    {	
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end GT */
    case IpsK_GE:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					>= (*src2_plane_data_base++))
		    {
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end GE */

    default:
        return (IpsX_UNSOPTION);
        break;
    }
if (set == 0)
    *result_flag = IpsK_SUCCESS_CLEAR;
else 
    {
    if (set == (src1_udp->UdpL_PxlPerScn * src1_udp->UdpL_ScnCnt))
        *result_flag = IpsK_SUCCESS_SET;
    else
	*result_flag = IpsK_SUCCESS_SOME;
    }
return (IpsX_SUCCESS);
}/* end of _IpsCompareW */

/*****************************************************************************
**  _IpsCompareFlt - 
**
**  FUNCTIONAL DESCRIPTION:
**	Performs comparison operations on corresponding values from the 
**      two floating point datatype source images to produce results for 
**      the bitmap destination image on a point by point basis.  
**
**  FORMAL PARAMETERS:
**
**      src1_udp
**	src2_udp
**	dst_udp
**	operator
**	result_flag
** 
**  IMPLICIT INPUTS:  none
**  IMPLICIT OUTPUTS: none
**  FUNCTION VALUE:   none
**  SIGNAL CODES:     none
**  SIDE EFFECTS:     none
**
************************************************************************/
long _IpsCompareFlt(src1_udp, src2_udp, dst_udp, operator, result_flag)
struct UDP *src1_udp;	  /* first source floating dtype udp   */
struct UDP *src2_udp;     /* second source floating dtype udp  */
struct UDP *dst_udp;      /* destination udp		       */
unsigned long operator;   /* arithmetic operation              */
unsigned long *result_flag;/* flag indicating nature of results */
{
float	        *src1_plane_data_base;  /* pointer to source data base */
float	        *src2_plane_data_base;  /* pointer to dest  data base  */
unsigned long   size;                   /* buffer size                 */
unsigned char   *dst_ptr;		/* used for dst image          */
unsigned long   ix,iy;                  /* loop counters               */
unsigned long	dst_stride;		/* dst(cpp) stride	       */
unsigned long   src1_stride;            /* src1 stride in bytes	       */
unsigned long   src2_stride;            /* src2 stride in bytes        */
unsigned long   src1_pad;               /* src1 pad                    */
unsigned long   src2_pad;               /* src2 pad                    */
unsigned long   set = 0;		/* counter for result_flag info*/

src1_plane_data_base = (float *)src1_udp->UdpA_Base +
                    ((src1_udp->UdpL_Pos +
                    (src1_udp->UdpL_ScnStride * src1_udp->UdpL_Y1) +
                    (src1_udp->UdpL_X1 * src1_udp->UdpL_PxlStride) )>>5);
 
src2_plane_data_base = (float *)src2_udp->UdpA_Base +
                    ((src2_udp->UdpL_Pos +
                    (src2_udp->UdpL_ScnStride * src2_udp->UdpL_Y1) +
                    (src2_udp->UdpL_X1 * src2_udp->UdpL_PxlStride) )>>5);
 
dst_ptr = (unsigned char *) dst_udp->UdpA_Base +
                   ((dst_udp->UdpL_Pos +
                    (dst_udp->UdpL_ScnStride * dst_udp->UdpL_Y1) +
                    (dst_udp->UdpL_X1))>>3);

dst_stride =  (dst_udp->UdpL_ScnStride >> 3); /* stride in bytes */
src1_stride = (src1_udp->UdpL_ScnStride >> 5);
src2_stride = (src2_udp->UdpL_ScnStride >> 5);
src1_pad = src1_stride - src1_udp->UdpL_PxlPerScn;
src2_pad = src2_stride - src1_udp->UdpL_PxlPerScn;

switch (operator)
    {
    case IpsK_EQ:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					== (*src2_plane_data_base++))
		    {
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end EQ */
    case IpsK_NE:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					!= (*src2_plane_data_base++))
		    {	
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end NE */

    case IpsK_LT:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					< (*src2_plane_data_base++))
		    {
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end LT */

    case IpsK_LE:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					<= (*src2_plane_data_base++))
		    {
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end LE */

    case IpsK_GT:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					> (*src2_plane_data_base++))
		    {
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end GT */
    case IpsK_GE:
        {
        for (iy = 0; iy < src1_udp->UdpL_ScnCnt; iy++)
            {
            for (ix = 0; ix < src1_udp->UdpL_PxlPerScn; ix++)
                {
                if ((*src1_plane_data_base++) 
					>= (*src2_plane_data_base++))
		    {
		    PUT_BIT_VALUE_(dst_ptr,ix,TRUE);
		    set++;	    
		    }
		}/* end ix loop */
            src1_plane_data_base  += src1_pad;
            src2_plane_data_base += src2_pad;
	    dst_ptr += dst_stride;
            } /*end iy loop */
        break;
	}/*end GE */
    default:
        return (IpsX_UNSOPTION);
        break;
    }
if (set == 0)
    *result_flag = IpsK_SUCCESS_CLEAR;
else 
    {
    if (set == (src1_udp->UdpL_PxlPerScn * src1_udp->UdpL_ScnCnt))
        *result_flag = IpsK_SUCCESS_SET;
    else
	*result_flag = IpsK_SUCCESS_SOME;
    }

return (IpsX_SUCCESS);
}/* end of _IpsCompareFlt */
