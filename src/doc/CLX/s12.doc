<!OPS, Version = 5.2>

<!Document,
	Print Rev Bars =	no,
	Final Output Device =	"ps",
	Default Printer =	"nearest-adps">

<!Font Definitions,
	F2 = Times 10 Italic,
	F3 = Times 10,
	F4 = Times 8 Italic,
	F5 = Times 18 Bold,
	F6 = Times 10 Bold,
	F7 = Times 18,
	F8 = Times 12 Bold,
	F9 = Symbol_B 8>

<!Page,
	Bottom Margin =		1 inches,
	Left Margin =		1 inches,
	Right Margin =		1.15 inches,
	First Page =		Right,
	Starting Page # = 	Inherit,
	Page # Prefix =		"12<#1e>",
	Hyphenation =		on,
	Consecutive Hyphens =	2,
	Vert. Just. =		off>

<!Autonumber Stream, List, 2,
	Level 2 Suffix =	,
	Level 2 Starting Value = 0,
	Level 2 Show =		no>

<!Autonumber Stream, Outline, 3,
	Level 1 Symbol Type =	UPPER ROMAN,
	Level 2 Symbol Type =	UPPER ALPHA>

<!Autonumber Stream, figure, 2,
	Level 1 Prefix =	"Figure ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	,
	Level 2 Starting Value = 0,
	Level 2 Show =		no>

<!Autonumber Stream, figurelet, 2,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Prefix =	"Figure ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	"<#04>">

<!Autonumber Stream, invisible, 1,
	Level 1 Suffix =	,
	Level 1 Show =		no>

<!Autonumber Stream, item, 2,
	Level 2 Symbol Type =	LOWER ALPHA,
	Level 2 Trail =		yes>

<!Autonumber Stream, paralet, 4,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Suffix =	,
	Level 1 Show =		no,
	Level 2 Prefix =	.,
	Level 2 Suffix =	,
	Level 3 Prefix =	.,
	Level 3 Suffix =	,
	Level 4 Prefix =	.,
	Level 4 Suffix =	>

<!Autonumber Stream, paranum, 4,
	Level 1 Suffix =	,
	Level 1 Show =		no,
	Level 2 Prefix =	.,
	Level 2 Suffix =	,
	Level 3 Prefix =	.,
	Level 3 Suffix =	,
	Level 4 Prefix =	.,
	Level 4 Suffix =	>

<!Autonumber Stream, table, 2,
	Level 1 Prefix =	"Table ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	>

<!Autonumber Stream, tablelet, 2,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Prefix =	"Table ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	"<#04>">

<!Class, arg,
	Bottom Margin =		0.08 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F2,
	Left Tab =		-0.25/0 inches>

<!Class, bullet,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		-0.50/0 inches>

<!Class, caption,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Font =			F4>

<!Class, endrule,
	Bottom Margin =		0.15 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Left Tab =		0/1.75/2.30/3.50/7.50 inches>

<!Class, fig,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Left,
	Font =			F5>

<!Class, indentA,
	Bottom Margin =		0.08 inches,
	Left Margin =		1.85 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		-0.50/0 inches>

<!Class, indentB,
	Bottom Margin =		0.153 inches,
	Left Margin =		2.10 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		-0.50/0 inches>

<!Class, item,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		0 inches,
	Right Tab =		-0.50 inches,
	Autonumber Name =	item>

<!Class, keyword2,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F6,
	Left Tab =		-0.50/0 inches>

<!Class, newpage,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Alignment =		Left,
	Font =			F7,
	Hyphenation =		off,
	New Page =		yes,
	Left Tab =		>

<!Class, "note",
	Top Margin =		0.177 inches,
	Bottom Margin =		0.334 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		0 inches,
	Right Tab =		6.50 inches>

<!Class, p1para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F8,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-1.70/0 inches>

<!Class, p1rule,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches>

<!Class, p1stacked,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1 lines,
	Font =			F6,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-1.60/-0.17/0 inches>

<!Class, p2para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		0 inches,
	Right Tab =		-1.60/-0.17 inches,
	TOC Doc Name =		TOC>

<!Class, p2rule,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1 lines,
	Alignment =		Left,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches>

<!Class, p2stacked,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F6,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		0 inches,
	Right Tab =		-1.60/-0.17 inches>

<!Class, para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		0/0.75*13 inches>

<!Class, return,
	Bottom Margin =		0.077 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<!Class, ritabhd1,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		0/1.30/2.30/3.50/7.50 inches>

<!Class, sbullet,
	Bottom Margin =		0.153 inches,
	Left Margin =		2.10 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		-0.50/0 inches>

<!Class, secno,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Left,
	Font =			F5,
	Autonumber Name =	paranum>

<!Class, secrule,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches,
	Autonumber Name =	table>

<!Class, sectitle,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Alignment =		Right,
	Font =			F5,
	Hyphenation =		off,
	New Page =		yes,
	Left Tab =		0/0.75*13 inches>

<!Class, ssbullet,
	Bottom Margin =		0.153 inches,
	Left Margin =		2.35 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		-0.50/0 inches>

<!Class, syntax,
	Bottom Margin =		0.077 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		8 inches>

<!Class, syntax0,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		8 inches>

<!Class, "table",
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Font =			F6,
	Autonumber Name =	table>

<!Class, title,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Right,
	Font =			F5,
	TOC Doc Name =		TOC>

<!Master Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			0.41 inches,
	Height =		0.137 inches,
	Vertical Alignment =	0.03 inches,
	Diagram =
V4,
(g9,32767,0
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,1,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<!Master Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,0.006667,0.066723,6.326667,0.066611,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<!Master Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,4.733333,0.066611,0.006667,0.066723,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<First Page Header, Frame =
V4,
(g9,0,0
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,1,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Right Page Header, Frame =
V4,
(g9,1,0
 (T8,1,12,4.533333,0.306667,1.8,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,
  102,1101,2,
<caption,
	Alignment =		Right>

Events and Input

<End Text>)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Left Page Header, Frame =
V4,
(g9,1,0
 (T8,1,12,0,0.293333,2.4,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,102,110
  1,2,
<caption>

Events and Input

<End Text>)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Right Page Footer, Frame =
V4,
(g9,1,0
 (t8,1,4,6.333333,0.266667,2,17,@nntimsps10b,\240)
 (t8,2,4,0.006667,0.266667,0,17,@nntimsps8i,CLX\ Programmer's\ Reference)
 (v4,3,0,0,0.066667,6.333333,0.066554,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Left Page Footer, Frame =
V4,
(g9,1,0
 (t8,1,4,0,0.266667,0,17,@nntimsps10b,\240)
 (t8,2,4,6.333333,0.266667,2,17,@nntimsps8i,CLX\ Programmer's\ Reference)
 (v4,3,0,0.026667,0.066667,6.333333,0.066554,17,2,0)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<sectitle,
	Allow Page Break Within = no,
	Allow Page Break After = no>

<|,"12<#1e>119">
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			4.72 inches,
	Height =		0.94 inches,
	Vertical Alignment =	0.03 inches,
	Diagram =
V4,
(g9,1,0
 (T8,1,12,0.133333,0.72,4.563333,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512
  ,102,1101,3,
<title>

EVENTS AND INPUT

<End Text>)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			1.626 inches,
	Height =		0.938 inches,
	Vertical Alignment =	0 inches,
	Diagram =
V4,
(g9,1,0
 (T8,1,12,0.066667,0.276667,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,10
  2,1101,3,
<secno,
	TOC Doc Name =		TOC>

<Autonum, paranum, 1, First = Yes>

<End Text>)
 (T8,2,12,0.026667,0.733333,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,10
  2,1101,3,
<"table">

<Autonum, table, 1, First = Yes>

<End Text>)
 (T8,3,12,0.066667,0.6,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,102,110
  1,3,
<fig,
	Alignment =		Both,
	Font =			F6,
	Autonumber Name =	figure>

<Autonum, figure, 1, First = Yes>

<End Text>)
 (g9,5,0
   (p7,5,8,19
     (g9,5,0
       (g9,5,0
         (v4,5,0,0.266667,0,1.6,0,17,1,0)
         (v4,6,0,1.6,0,1.6,0.933333,17,1,0)
         (v4,7,0,1.6,0.933333,0.266667,0.933333,17,1,0)
         (v4,8,0,0.266667,0.933333,0.266667,0,17,1,0))))
   (g9,10,0
     (g9,10,8
       (p7,10,1032,13
         (g9,10,0
           (g9,10,0
             (v4,10,0,1.487894,0.934816,1.487894,0.784694,17,1,0)
             (v4,11,0,1.487894,0.784694,1.216842,0.784694,17,1,0)
             (v4,12,0,1.216842,0.784694,1.487894,0.503213,17,1,0)
             (v4,13,0,1.487894,0.503213,1.487894,0.259259,17,1,0)
             (v4,14,0,1.487894,0.259259,1.379473,0.14667,17,1,0)
             (v4,15,0,1.379473,0.14667,1.12649,0.14667,17,1,0)
             (v4,16,0,1.12649,0.14667,1.018068,0.259259,17,1,0)
             (v4,17,0,1.018068,0.259259,1.018068,0.371851,17,1,0)
             (v4,18,0,1.018068,0.371851,1.1807,0.371851,17,1,0)
             (v4,19,0,1.1807,0.371851,1.1807,0.296792,17,1,0)
             (v4,20,0,1.1807,0.296792,1.325262,0.296792,17,1,0)
             (v4,21,0,1.325262,0.296792,1.325262,0.46568,17,1,0)
             (v4,22,0,1.325262,0.46568,1.018068,0.784694,17,1,0)
             (v4,23,0,1.018068,0.784694,1.018068,0.934816,17,1,0)
             (v4,24,0,1.018068,0.934816,1.487894,0.934816,17,1,0))))
       (g9,25,2048
         (v4,25,33,1,1.16,1,1.16,17,0,0)
         (v4,26,33,1,0.14667,1,0.14667,17,0,0)
         (v4,27,33,1.524033,0.14667,1.524033,0.14667,17,0,0)
         (v4,28,33,1.524033,1.16,1.524033,1.16,17,0,0)))
     (g9,30,8
       (p7,30,1032,13
         (g9,30,0
           (g9,30,0
             (v4,30,0,0.914386,0.934816,0.914386,0.14667,17,1,0)
             (v4,31,0,0.914386,0.14667,0.769824,0.14667,17,1,0)
             (v4,32,0,0.769824,0.14667,0.625263,0.296792,17,1,0)
             (v4,33,0,0.625263,0.296792,0.625263,0.371851,17,1,0)
             (v4,34,0,0.625263,0.371851,0.751755,0.371851,17,1,0)
             (v4,35,0,0.751755,0.371851,0.751755,0.934816,17,1,0)
             (v4,36,0,0.751755,0.934816,0.914386,0.934816,17,1,0))))
       (g9,37,2048
         (v4,37,33,0.607192,0.14667,0.607192,0.14667,17,0,0)
         (v4,38,33,0.607192,1.16,0.607192,1.16,17,0,0)
         (v4,39,33,0.986667,1.16,0.986667,1.16,17,0,0)
         (v4,40,33,0.986667,0.14667,0.986667,0.14667,17,0,0)))))
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<secrule,
	Allow Page Break Within = no,
	Allow Page Break After = yes,
	Autonumber Name =	>

<Index, "event", To Named = sectitle>
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,0.006667,0.066723,6.333333,0.066611,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<p1para,
	Bottom Margin =		0 inches,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Introduction<Tab><F6>12.1<F0><#04>A client application uses 
CLX functions to send <F2>requests<F0> to an X server over a display 
connection returned by the <F6>open<#1e>display<F0> function. In 
return, the X server sends back <F2>replies<F0> and <F2>events<F0>. 
Replies are synchronized with specific requests and return requested 
server information. Events typically occur asynchronously. Device 
events are generated by user input from both the keyboard and pointer 
devices. Other events are side<#1e>effects of the requests sent by 
CLX functions. The types of events returned by an X server are summarized 
below.

<ritabhd1,
	Left Tab =		0/2.30/3.50/7.50 inches>

<Tab-><Tab-><Tab-><HR>
Device Events<Tab>Events Returned<Index, "device events"><Index, "event", "device"><Index, "device events", "events returned"><Index, "event", "device", "events returned"><HR>
<Tab-><Tab-><Tab->

<ritabhd1,
	Bottom Margin =		0.04 inches,
	Left Tab =		0/2.30/3.50/7.50 inches>

<F3>Keyboard<Tab><F0>:key<#1e>press<F3><HR>
<Tab><F0>:key<#1e>release

<ritabhd1,
	Left Tab =		0/2.30/3.50/7.50 inches>

<F3>Pointer<Tab><F0>:button<#1e>press<HR>
<Tab>:button<#1e>release<HR>
<Tab>:enter<#1e>notify<HR>
<Tab>:leave<#1e>notify<HR>
<Tab>:motion<#1e>notify

<endrule,
	Bottom Margin =		0 inches>

<Tab-><Tab-><Tab-><Tab->

<ritabhd1,
	Left Tab =		0/2.30/3.50/7.50 inches>

<Tab-><Tab-><Tab-><HR>
Side<#1e>Effect Events<Tab>Events Returned<Index, "side<#1e>effect events"><Index, "event", "side<#1e>effect"><Index, "side<#1e>effect events", "events returned"><Index, "event", "side<#1e>effect", "events returned"><HR>
<Tab-><Tab-><Tab->

<ritabhd1,
	Bottom Margin =		0.04 inches,
	Left Tab =		0/2.30/3.50/7.50 inches>

<F3>Client communication<Tab><F0>:client<#1e>message<HR>
<Tab>:property<#1e>notify<HR>
<Tab>:selection<#1e>clear<HR>
<Tab>:selection<#1e>notify<F3><HR>
<Tab><F0>:selection<#1e>request

<ritabhd1,
	Bottom Margin =		0.05 inches,
	Left Tab =		0/2.30/3.50/7.50 inches>

<F3>Color map state<Tab><F0>:colormap<#1e>notify

<ritabhd1,
	Bottom Margin =		0.04 inches,
	Left Tab =		0/2.30/3.50/7.50 inches>

<F3>Exposure<Tab><F0>:exposure<F3><HR>
<Tab><F0>:graphics<#1e>exposure<HR>
<Tab>:no<#1e>exposure

<F3>Input focus<Tab><F0>:focus<#1e>in<HR>
<Tab>:focus<#1e>out

<F3>Keyboard and pointer state<Tab><F0>:keymap<#1e>notify<HR>
<Tab>:mapping<#1e>notify

<F3>Structure control<Tab><F0>:circulate<#1e>request<HR>
<Tab>:configure<#1e>request<HR>
<Tab>:map<#1e>request

<ritabhd1,
	Left Tab =		0/2.30/3.50/7.50 inches>

<F3><Tab><F0>:resize<#1e>request<HR>
<F3>Window state<Tab><F0>:circulate<#1e>notify<HR>
<Tab>:configure<#1e>notify<HR>
<Tab>:create<#1e>notify<HR>
<Tab>:destroy<#1e>notify<HR>
<Tab>:gravity<#1e>notify<HR>
<Tab>:map<#1e>notify<HR>
<Tab>:reparent<#1e>notify<HR>
<Tab>:unmap<#1e>notify<HR>
<Tab>:visibility<#1e>notify

<endrule>

<Tab-><Tab-><Tab-><Tab->

<para>

<|,"12<#1e>120">Client programs can override the server's normal distribution 
of events by<F2><SP>grabbing<F0> the pointer or the keyboard. Grabbing 
causes events from the<SP>pointer or keyboard device to be reported 
to a single specified window, rather<SP>than to their ordinary destinations. 
It can also cause the server to <F2>freeze<F0><SP>the grabbed device, 
sending queued events only when explicitly requested by<SP>the grabbing 
client. Two kinds of grabs are possible:<Index, "grab types">

<bullet>

<F9>w<Tab><F0>Active <#1f> Events are immediately grabbed.

<F9>w<Tab><F0>Passive <#1f> Events are grabbed later, as soon as 
a specified device event occurs.

<para>

Grabbing an input device is performed rarely and usually only by special<SP>cli
ents, such as window managers.

This section describes the CLX functions used to:

<bullet>

<F9>w<Tab><F0>Select events

<F9>w<Tab><F0>Process an event on the event queue

<F9>w<Tab><F0>Manage the event queue

<F9>w<Tab><F0>Send events to other applications

<F9>w<Tab><F0>Read and change the pointer position

<F9>w<Tab><F0>Manage the keyboard input focus

<F9>w<Tab><F0>Grab pointer and keyboard events

<F9>w<Tab><F0>Release queued events

<para>

This section also contains a detailed description of the content of 
each type of event. 

<p1rule>

<Index, "event", "selecting", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Selecting Events<Tab><F6>12.2<F0><#04>A client <F2>selects<F0> 
which types of events it receives from a specific window. The window 
event<#1e>mask attribute, set by the client, determines which event 
types are selected (see <F6>window<#1e>event<#1e>mask<F0> in paragraph 
4.3, Window Attributes). Most types of events are received by a client 
only if they are selected for some window.

<para>

In the X protocol, an event<#1e>mask is represented as a bit string. 
CLX also allows an event mask to be defined by a list of <F6>event<#1e>mask<#1e>
class<F0> keywords. The functions <F6>make<#1e>event<#1e>keys<F0> 
and <F6>make<#1e>event<#1e>mask<F0> can be used to convert between 
these two forms of an event<#1e>mask. In general, including an <F6>event<#1e>m
ask<#1e>class<F0> keyword in an event<#1e>mask causes one or more 
related event types to be selected. The following table describes 
the event types selected by each <F6>event<#1e>mask<#1e>class<F0> 
keyword.

<ritabhd1,
	Left Tab =		0/2.10/3.50/7.50 inches>

<|,"12<#1e>121"><Tab-><Tab-><Tab-><HR>
<Index, "event mask", "keywords"><Index, "event mask", "keywords", "event types selected">Event Mask Keyword<Tab>Event 
Types Selected<HR>
<Tab-><Tab-><Tab->

:button<#1e>1<#1e>motion<Tab>:motion<#1e>notify<F3> when <F0>:button<#1e>1
<F3> is down

:button<#1e>2<#1e>motion<Tab>:motion<#1e>notify <F3>when<F0> :button<#1e>2
<F3> is down

:button<#1e>3<#1e>motion<Tab>:motion<#1e>notify <F3>when<F0> :button<#1e>3
<F3> is down

:button<#1e>4<#1e>motion<Tab>:motion<#1e>notify <F3>when<F0> :button<#1e>4 
<F3>is down

:button<#1e>5<#1e>motion<Tab>:motion<#1e>notify <F3>when<F0> :button<#1e>5
<F3> is down

:button<#1e>motion<Tab>:motion<#1e>notify<F3> when any pointer<HR>
<Tab><#04>button is down

:button<#1e>press<Tab>:button<#1e>press

:button<#1e>release<Tab>:button<#1e>release 

:colormap<#1e>change<Tab>:colormap<#1e>notify

:enter<#1e>window<Tab>:enter<#1e>notify

:exposure<Tab>:exposure

:focus<#1e>change<Tab>:focus<#1e>in, :focus<#1e>out

:key<#1e>press<Tab>:key<#1e>press 

:key<#1e>release<Tab>:key<#1e>release 

:keymap<#1e>state<Tab>:keymap<#1e>notify

:leave<#1e>window<Tab>:leave<#1e>notify

:owner<#1e>grab<#1e>button<Tab><F3>Pointer events while button is 
grabbed

:pointer<#1e>motion<Tab>:motion<#1e>notify

:pointer<#1e>motion<#1e>hint <Tab><F3>Single <F0>:motion<#1e>notify<F3> 
only

:property<#1e>change<Tab>:property<#1e>notify

:resize<#1e>redirect<Tab>:resize<#1e>request

:structure<#1e>notify<Tab>:circulate<#1e>notify, :configure<#1e>notify,

<Tab>  :destroy<#1e>notify, : gravity<#1e>notify,<HR>
<Tab>  :map<#1e>notify, :reparent<#1e>notify,<HR>
<Tab>  :unmap<#1e>notify

:substructure<#1e>redirect<Tab>:circulate<#1e>request, :configure<#1e>request,<HR>
<Tab>  :map<#1e>request

:visibility<#1e>change<Tab>:visibility<#1e>notify

<endrule>

<Tab-><Tab-><Tab-><Tab->

<para>

Some types of events do not have to be selected to be received and 
therefore are not represented in an event<#1e>mask. For example, the <F6>copy<#1e>
plane<F0> and <F6>copy<#1e>area<F0> functions cause <F6>:graphics<#1e>expos
ure<F0> and <F6>:no<#1e>exposure<F0> events to be reported, unless 
exposures are turned <F6>:off<F0> in the graphics context (see <F6>copy<#1e>
area<F0> and <F6>copy<#1e>plane<F0> in paragraph 6.2, Area and 
Plane Operations, and <F6>gcontext<#1e>exposures<F0> in paragraph 
5.4.6, Exposures). Also, <F6>:selection<#1e>clear<F0>, <F6>:selection<#1e>re
quest<F0>, <F6>:selection<#1e>notify<F0> and <F6>:client<#1e>message<F0> 
events can be received at any time, but they are generally sent only 
to clients using selections (see paragraph 12.12.7, Client Communications 
Events). <F6>:mapping<#1e>notify <F0>is always sent to clients when 
the keyboard mapping is changed.

Any client can select events for any window. A window maintains a 
separate event<#1e>mask for each interested client. In general, multiple 
clients can select for the same events on a window. After the X server 
generates an event, it sends it to all clients which selected it. 
However, the following restrictions apply to sharing window events 
among multiple clients. For a given window:

<bullet>

<F9>w<Tab><F0>Only one client at a time can include <F6>:substructure<#1e>re
direct<F0> in its event<#1e>mask

<F9>w<Tab><F0>Only one client at a time can can include <F6>:button<#1e>pres
s<F0> in its event<#1e>mask

<F9>w<Tab><F0>Only one client at a time can include <F6>:resize<#1e>redirect
<F0> in its event<#1e>mask

<p1rule>

<|,"12<#1e>122"><Index, "event", "processing", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8>Processing<Tab><F6>12.3<F0><#04>Events received by a CLX client 
are stored in an <F2>event queue<F0> until<FJ>

<p1para,
	Bottom Margin =		0.13 inches,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Events<Tab><F0>they are read and processed. Events are processed 
by <F2>handler functions<F0>.

<syntax0>

<Index, Doc = operations, "xlib:handler<#1e>function", Sort String = "handler<#1e>function">handler<#1e>function <F3>&rest <F2>event<#1e>slots <F3>&
key <F0>:display :event<#1e>key :send<#1e>event<#1e>p <Tab><F3>Function<HR>
&allow<#1e>other<#1e>keys 

<return>

<Tab><F3>Returns: <F2><HR>
  handled<#1e>p<F3> <#1f> Type <F0>boolean<F3>.<F0> 

<para,
	Bottom Margin =		0.12 inches>

The arguments to a handler function are keyword<#1e>value pairs that 
describe the contents of an event. The actual <F2>event<#1e>slots<F0> 
passed depend on the event type, except that <F6>:display<F0>, <F6>:event<#1e>
key<F0>, and <F6>:send<#1e>event<#1e>p<F0> are given for all event 
types. The keyword symbols used for each event type are event slot 
names defined by the <F6>declare<#1e>event<F0> macro and are described 
in paragraph 12.12.8, Declaring Event Types.

If a handler returns non<#1e><F6>nil<F0>, the event is considered <F2>proces
sed<F0> and can be removed from the event queue. Otherwise, if a 
handler function returns <F6>nil<F0>, the event can remain in the 
event queue for later processing.

<keyword2>

:display<F3> <#1f> A <F0>display<F3> for the connection that returned 
the event.

:event<#1e>key<F3> <#1f> An <F0>event<#1e>key<F3> keyword specifying 
the event type.

:send<#1e>event<#1e>p <F3><#1f> If true, the event was sent from 
another application using the <F0>send<#1e>event<F3> function.

<syntax0>

process<#1e>event <F2>display<F0> <F3>&key<F0> :handler :timeout 
:peek<#1e>p :discard<#1e>p <Tab><F3>Function<Index, Doc = operations, "xlib:process<#1e>event", Sort String = "process<#1e>event"><F0><HR>
(:force<#1e>output<#1e>p t) 

<return>

<Tab><F3>Returns:<HR>
<F0>  <F2>handled<#1e>p<F0> <F3><#1f> Type <F0>boolean<F3>.

<para,
	Bottom Margin =		0.12 inches>

Invokes <F6>:handler<F0> on each queued event until <F6>:handler<F0> 
returns non<#1e><F6>nil<F0>. Then, the non<#1e><F6>nil<F0> <F6>:handler
<F0> value is returned by <F6>process<#1e>event<F0>. If <F6>:handler<F0> 
returns <F6>nil<F0> for each event in the event queue, <F6>process<#1e>event
<F0> waits for another event to arrive. If timeout is non<#1e><F6>nil<F0> 
and no event arrives within the specified timeout interval (given 
in seconds), <F6>process<#1e>event<F0> returns <F6>nil<F0>; if 
timeout is <F6>nil<F0>, <F6>process<#1e>event<F0> will not return 
until <F6>:handler<F0> returns non<#1e><F6>nil<F0>. <F6>process<#1e>event
<F0> may wait only once on network data, and therefore timeout prematurely.

If <F6>:force<#1e>output<#1e>p<F0> is true, <F6>process<#1e>event<F0> 
first invokes <F6>display<#1e>force<#1e>output<F0> to send any buffered 
requests. If <F6>:peek<#1e>p<F0> is true, a processed event is not 
removed from the queue. If <F6>:discard<#1e>p<F0> is true, unprocessed 
events are removed from the queue; otherwise, unprocessed events are 
left in place.

If <F6>:handler<F0> is a sequence, it is expected to contain handler 
functions for each event type. The sequence index of the handler function 
for a particular event type is given by (<F6>position event<#1e>key 
*event<#1e>key<#1e>vector*<F0>).

<arg>

display <#1f> <F3>A <F6>display<F3>.

<keyword2>

:handler<F3> <#1f><F0> <F3>A handler function or a sequence of 
handler functions.

:timeout <F3><#1f> Specifies the timeout delay in seconds.

:peek<#1e>p <F3><#1f> If <F0>nil<F3>, events are removed from the 
event queue after processing.

:discard<#1e>p <F3><#1f> If true, unprocessed events are discarded.

:force<#1e>output<#1e>p <F3><#1f> If true, buffered output requests 
are sent.

<syntax0>

<|,"12<#1e>123">event<#1e>case <F2>display <F3>&key <F0>:timeout :peek<#1e>p 
:discard<#1e>p (:force<#1e>output<#1e>p t)<Tab><F3>Macro<Index, Doc = operations, "xlib:event<#1e>case", Sort String = "event<#1e>case"><HR>
&body <F2>clauses

<return>

<Tab><F3>Returns: <F2><HR>
  handled<#1e>p<F3> <#1f> Type <F0>boolean<F3>.

<para>

Executes the matching clause for each queued event until a clause 
returns non<#1e><F6>nil<F0>. The non<#1e><F6>nil<F0> clause value 
is then returned. Each of the clauses is a list of the form (<F2>event<#1e>mat
ch<F0> [<F2>event<#1e>slots<F0>] &rest <F2>forms<F0>), where:

<arg>

event<#1e>match<F6> <F3><#1f> Either an <F6>event<#1e>key<F3>, 
a list of <F6>event<#1e>keys<F3>, otherwise, or <F6>t<F3>. It 
is an error for the same key to appear in more than one clause.

event<#1e>slots <F3><#1f> If given, a list of (non<#1e>keyword) event 
slot symbols defined for the specified event type(s). See paragraph 
12.12.8, Declaring Event Types.

forms <F3><#1f> A list of forms that process the specified event 
type(s). The value of the last form is the value returned by the clause.

<para>

A clause matches an event if the <F6>event<#1e>key<F0> is equal 
to or a member of the <F2>event<#1e>match<F0>, or if the <F2>event<#1e>match
<F0> is <F6>t<F0> or <F6>otherwise<F0>. If no <F6>t<F0> or <F6>otherwis
e<F0> clause appears, it is equivalent to having a final clause that 
returns <F6>nil<F0>. If <F2>event<#1e>slots<F0> is given, these 
symbols are bound to the value of the corresponding event slot in 
the clause forms. Each element of <F2>event<#1e>slots<F0> can also 
be a list of the form (<F2>event<#1e>slot<#1e>keyword variable<F0>), 
in which case the <F2>variable<F0> symbol is bound to the value 
of the event slot specified by the <F2>event<#1e>slot<#1e>keyword<F0>.

If every clause returns <F6>nil<F0> for each event in the event 
queue, <F6>event<#1e>case<F0> waits for another event to arrive. 
If <F6>:timeout<F0> is non<#1e><F6>nil<F0> and no event arrives 
within the specified timeout interval (given in seconds), <F6>event<#1e>case
<F0> returns <F6>nil<F0>; if <F6>:timeout<F0> is <F6>nil<F0>, <F6>event
<#1e>case<F0> will not return until a clause returns non<#1e><F6>nil<F0>. 
<F6>event<#1e>case<F0> may wait only once on network data and therefore 
timeout prematurely.

If <F6>:force<#1e>output<#1e>p<F0> is true, <F6>event<#1e>case<F0> 
first invokes <F6>display<#1e>force<#1e>output<F0> to send any buffered 
requests. If <F6>:peek<#1e>p<F0> is true, a processed event is not 
removed from the queue. If <F6>:discard<#1e>p<F0> is true, unprocessed 
events are removed from the queue; otherwise, unprocessed events are 
left in place.

<arg>

display <F3><#1f> A <F6>display<F3>.

<keyword2>

:handler<F3> <#1f> A handler function or a sequence of handler functions.

:timeout<F3> <#1f> Specifies the timeout delay, in seconds.

:peek<#1e>p<F3> <#1f> If <F0>nil<F3>, events are removed from the 
event queue after processing.

:discard<#1e>p<F3> <#1f> If true, unprocessed events are discarded.

:force<#1e>output<#1e>p<F3> <#1f> If true, buffered output requests 
are sent.

<arg>

clauses<F6> <F3><#1f> Code to process specified event types.

<syntax0>

event<#1e>cond <F2>display <F3>&key <F0>:timeout :peek<#1e>p :discard<#1e>p 
(:force<#1e>output<#1e>p t)<Tab><F3>Macro<Index, Doc = operations, "xlib:event<#1e>cond", Sort String = "event<#1e>cond"><HR>
&body <F2>clauses

<return>

<Tab><F3>Returns: <F2><HR>
  handled<#1e>p<F3> <#1f> Type <F0>boolean<F3>.

<para>

Similar to <F6>event<#1e>case<F0> except that each of the clauses 
is a list of the form (<F2>event<#1e>match<F0> [<F2>event<#1e>slots<F0>] 
<F2>test<#1e>form<F0> &rest <F2>forms<F0>). Executes the <F2>test<#1e>form
<F0> of the clause that matches each queued event until a <F2>test<#1e>form
<F0> returns non<#1e><F6>nil<F0>. The body <F2>forms<F0> of the 
clause are then executed. The values returned by the last clause body 
form are then returned by <F6>event<#1e>cond<F0>.

<|,"12<#1e>124">When a <F2>test<#1e>form<F0> returns true and <F6>:peek<#1e>p<F0> 
is <F6>nil<F0>, or when a <F2>test<#1e>form<F0> returns <F6>nil<F0> 
and <F6>:discard<#1e>p<F0> is true, the matching event is removed 
from the event queue before the body <F2>forms<F0> are executed.

<arg>

display <#1f> <F3>A <F6>display<F3>.

<keyword2>

:handler<F3> <#1f> A handler function or a sequence of handler functions.

:timeout<F3> <#1f> Specifies the timeout delay in seconds.

:peek<#1e>p<F3> <#1f> If <F0>nil<F3>, events are removed from the 
event queue after processing.

:discard<#1e>p<F3> <#1f> If true, unprocessed events are discarded.

:force<#1e>output<#1e>p<F3> <#1f> If true, buffered output requests 
are sent.

<arg>

clauses<F6> <F3><#1f> Code to process specified event types.

<p1rule>

<Index, "event", "managing", "event queue", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8>Managing the<Tab><F6>12.4<F0><#04>The following paragraphs 
describe CLX functions and macros used to:

<p1para,
	Bottom Margin =		0 inches,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Event Queue<Tab><F6><#04>

<bullet>

<F9>w<Tab><F0>Put a new event on the event queue

<F9>w<Tab><F0>Discard the current event

<F9>w<Tab><F0>Return the current length of the event queue

<F9>w<Tab><F0>Gain exclusive access to the event queue for a client 
process

<syntax>

queue<#1e>event <F2>display<F0> <F2>event<#1e>key <F3>&rest <F2>event<#1e>
slots<F3> &key <F0>:append<#1e>p <F3><Tab>Function<Index, Doc = operations, "xlib:queue<#1e>event", Sort String = "queue<#1e>event"><HR>
&allow<#1e>other<#1e>keys 

<para>

Places an event of the type given by <F2>event<#1e>key<F0> into 
the event queue. When <F6>:append<#1e>p<F0> is true, the event is 
placed at the tail of the queue; otherwise, the event is placed at 
the head of the queue. The actual <F2>event<#1e>slots<F0> passed 
depend on the event type. The keyword symbols used for each event 
type are event slot names defined by the <F6>declare<#1e>event<F0> 
macro and are described in paragraph 12.12.8, Declaring Event Types.

<arg>

display <F3><#1f> A <F6>display<F3>.

event<#1e>key<F6> <F3><#1f> Specifies the type of event placed in 
the queue.

event<#1e>slots<F6> <F3><#1f> Keyword<#1e>value pairs that describe 
the contents of an event.

<keyword2>

:append<#1e>p<F3> <#1f> If true, the event is placed at the tail 
of the queue; otherwise, the event is placed at the head of the queue.

<syntax0>

discard<#1e>current<#1e>event <F2>display<Tab><F3>Function<Index, Doc = operations, "xlib:discard<#1e>current<#1e>event", Sort String = "discard<#1e>current<#1e>event">

<return>

<Tab><F3>Returns:<HR>
  <F2>discarded<#1e>p<F0> <F3><#1f> Type <F0>boolean<F3>.

<para>

Discards the current event for the <F2>display<F0>. Returns <F6>nil<F0> 
when the event queue is empty; otherwise, returns <F6>t<F0>. This 
function provides extra flexibility for discarding events, but it 
should be used carefully; use <F6>event<#1e>cond<F0> instead, if 
possible. Typically, <F6>discard<#1e>current<#1e>event<F0> is called 
inside a handler function or a clause of an <F6>event<#1e>case<F0> 
form and is followed by another call to <F6>process<#1e>event<F0>, <F6>event
<#1e>case<F0>, or <F6>event<#1e>cond<F0>.

<arg>

display <#1f> <F3>A <F6>display<F3>.

<syntax0>

<|,"12<#1e>125">event<#1e>listen <F2>display<F0> <F3>&optional<F0> <F3>(<F0>timeout 
<F3>0)<F0><Tab><F3>Function<Index, Doc = operations, "xlib:event<#1e>listen", Sort String = "event<#1e>listen">

<return>

<Tab><F3>Returns:<F0><HR>
  <F2>event<#1e>count <F3><#1f> Type <F0>(or null integer)<F3>.

<para>

Returns the number of events queued locally. If the event queue is 
empty, <F6>event<#1e>listen<F0> waits for an event to arrive. If 
timeout is non<#1e><F6>nil<F0> and no event arrives within the specified 
timeout interval (given in seconds), <F6>event<#1e>listen<F0> returns <F6>ni
l<F0>; if timeout is <F6>nil<F0>, <F6>event<#1e>listen<F0> will 
not return until an event arrives.

<arg>

display <F3><#1f> A <F6>display<F3>.

timeout <F3><#1f> The number of seconds to wait for events.

<syntax>

with<#1e>event<#1e>queue <F2>display<F0> <F3>&body<F2> body<F0><Tab><F3>M
acro<Index, Doc = operations, "xlib:with<#1e>event<#1e>queue", Sort String = "with<#1e>event<#1e>queue">

<para>

Executes the <F2>body<F0> in a critical region in which the executing 
client process has exclusive access to the event queue. 

<arg>

display <#1f><F3> A <F6>display<F3>.

body <F3><#1f> Forms to execute.

<p1rule>

<Index, "event", "sending", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Sending Events<Tab><F6>12.5<F0><#04>A client can send an event 
to a window. Clients selecting this window event will receive it just 
like any other event sent by the X server.

<syntax>

send<#1e>event <F2>window<F0> <F2>event<#1e>key event<#1e>mask <F3>&rest 
<F2>event<#1e>slots<F3> &key <F0><Tab><F3>Function<Index, Doc = operations, "xlib:send<#1e>event", Sort String = "send<#1e>event"><HR>
<F0>:propagate<#1e>p :display <F3>&allow<#1e>other<#1e>keys

<para>

Sends an event specified by the <F2>event<#1e>key<F0> and <F2>event<#1e>slot
s<F0> to the given destination <F2>window<F0>. Any active grabs 
are ignored. The <F2>event<#1e>slots<F0> passed depend on the event 
type. The keyword symbols used for each event type are event slot 
names defined by the <F6>declare<#1e>event<F0> macro and are described 
in paragraph 12.12.8, Declaring Event Types.

If the <F2>window<F0> is <F6>:pointer<#1e>window<F0>, the destination 
<F2>window<F0> is replaced with the window containing the pointer. 
If the <F2>window<F0> is <F6>:input<#1e>focus<F0>, the destination <F2>win
dow<F0> is replaced with the descendant of the focus window that 
contains the pointer or (if no such descendant exists) the focus window. 
The <F6>:display<F0> keyword is only required if the <F2>window<F0> 
is <F6>:pointer<#1e>window<F0> or <F6>:input<#1e>focus<F0>.

The <F2>event<#1e>key<F0> must be one of the core events, or one 
of the events defined by an extension, so the server can send the 
event with the correct byte<#1e>order. The contents of the event are 
otherwise unaltered and unchecked by the server, except that the <F6>send<#1e>
event<#1e>p<F0> event slot is set to true.

If the <F2>event<#1e>mask<F0> is <F6>nil<F0>, the event is sent 
to the client that created the destination <F2>window<F0> with an <F2>event<#1e>
mask<F0> of 0; if that client no longer exists, no event is sent. 
Otherwise, the event is sent to every client selecting any of the 
event types specified by <F2>event<#1e>mask<F0> on the destination <F2>windo
w<F0>.

If <F6>:propagate<#1e>p<F0> is true and no clients have selected 
any of the event types in <F2>event<#1e>mask<F0> on the destination <F2>wind
ow<F0>, the destination is replaced with the closest ancestor of <F2>window
<F0> for which some client has selected a type in <F2>event<#1e>mask<F0> 
and no intervening window has that type in its do<#1e>not<#1e>propagate 
mask. If no such window exists, or if the <F2>window<F0> is an ancestor 
of the focus window and <F6>:input<#1e>focus<F0> was originally 
specified as the destination, the event is not sent to any clients. 
Otherwise, the event is reported to every client selecting on the 
final destination any of the types specified in <F2>event<#1e>mask<F0>.

<arg>

window <F3><#1f> The destination <F6>window<F3> for the event.

event<#1e>key <F3><#1f> An <F6>event<#1e>key<F3> defining the type 
of event to send.

<|,"12<#1e>126">event<#1e>mask <F3><#1f> Specifies the event types that receiving 
clients must select.

event<#1e>slots<F3> <#1f> Keyword<#1e>value pairs that describe the 
contents of an event.

<keyword2>

:propagate<#1e>p <F3><#1f> If true, the event can be propagated to 
ancestors of the destination window.

:display <F3><#1f> A <F0>display<F3>.

<p1rule>

<Index, "pointer", "position", To Named = p1rule><Index, "event", "pointer", "position", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Pointer Position<Tab><F6>12.6<#04><F0>The CLX functions affecting 
pointer position are discussed in the following paragraphs.

<syntax0>

query<#1e>pointer<F2> window<F0><Tab><F3>Function<Index, Doc = operations, "xlib:query<#1e>pointer", Sort String = "query<#1e>pointer">

<return,
	Left Tab =		-0.90/0/0.10/7.50 inches>

<Tab><F3>Returns:<F2><HR>
<Tab>x<F0> <F3><#1f> Type<F0> int16<F3>.<F0><HR>
<Tab><F2>y<F3> <#1f> Type <F0>int16<F3>.<F0><HR>
<F2><Tab>same<#1e>screen<#1e>p <F3><#1f> Type <F0>boolean<F3>.<F0><HR>
<Tab><F2>child <F3><#1f> Type <F0>window<F3> or <F0>null<F3>.<F0><HR>
<Tab><F2>state<#1e>mask<F3> <#1f> Type <F0>card16<F3>.<F0><HR>
<Tab><F2>root<#1e>x <F3><#1f> Type<F0> int16<F3>.<HR>
<Tab><F2>root<#1e>y<F3> <#1f> Type <F0>int16<F3>.<HR>
<Tab><F2>root<F3> <#1f> Type <F0>window<F3>.

<para>

Returns the current pointer coordinates relative to the given <F2>window<F0>. 
If <F6>query<#1e>pointer<F0> returns <F6>nil<F0> for <F2>same<#1e>screen<#1e>
p<F0>, the pointer is not on the same screen as the <F2>window<F0>. 
In this case, <F6>query<#1e>pointer<F0> returns a value of <F6>nil<F0> 
for <F2>child<F0> and a value of zero for <F2>x<F0> and <F2>y<F0>. 
If <F6>query<#1e>pointer<F0> returns true for <F2>same<#1e>screen<#1e>p
<F0>, the returned <F2>x<F0> and <F2>y<F0> are relative to the 
origin of window. The <F2>child<F0> is the child of the window containing 
the pointer, if any. The <F2>state<#1e>mask<F0> returned gives the 
current state of the modifier keys and pointer buttons. The returned <F2>root
<F0> is the root window currently containing the pointer. The returned <F2>ro
ot<#1e>x<F0> and <F2>root<#1e>y<F0> specify the pointer coordinates 
relative to <F2>root<F0>.

<arg>

window <F3><#1f> A <F6>window<F3> specifying the coordinate system 
for the returned position.

<syntax0>

global<#1e>pointer<#1e>position <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:global<#1e>pointer<#1e>position", Sort String = "global<#1e>pointer<#1e>position">

<return,
	Left Tab =		-0.90/0/0.10/7.50 inches>

<F2><Tab><F3>Returns:<HR>
<F2><Tab>root<#1e>x <#1f><F3> Type <F0>int16<F3>.<F0><HR>
<F2><Tab>root<#1e>y<F3> <#1f> Type<F0> int16<F3>.<F0><HR>
<F2><Tab>root <F3><#1f> Type <F0>window<F3>.

<para>

Returns the <F2>root<F0> window currently containing the <F2>display<F0> 
pointer and the current position of the pointer relative to the <F2>root<F0>.

<arg>

display<F3> <#1f> A <F6>display<F3>.

<syntax0>

pointer<#1e>position <F2>window<F0><Tab><F3>Function<Index, Doc = operations, "xlib:pointer<#1e>position", Sort String = "pointer<#1e>position">

<return,
	Left Tab =		-0.90/0/0.10/7.50 inches>

<Tab><F3>Returns:<HR>
<Tab><F2>x <F3><#1f> Type<F0> int16<F3>.<F0><HR>
<Tab><F2>y<F3> <#1f> Type <F0>int16<F3>.<HR>
<Tab><F2>same<#1e>screen<#1e>p <F3><#1f> Type <F0>boolean<F3>.<HR>
<F2><Tab>child <F3><#1f> Type <F0>window<F3> or <F0>null<F3>.

<para>

Returns the current pointer coordinates relative to the given <F2>window<F0>. 
If <F6>pointer<#1e>position<F0> returns <F6>nil<F0> for <F2>same<#1e>scree
n<#1e>p<F0>, the pointer is not on the same screen as the <F2>window<F0>. 
In this case, <F6>pointer<#1e>position<F0> returns a value of <F6>nil<F0> 
for <F2>child<F0> and a value of zero for <F2>x<F0> and <F2>y<F0>. 
If <F6>pointer<#1e>position<F0> returns true for <F2>same<#1e>screen<#1e>p
<F0>, the returned <F2>x<F0> and <F2>y<F0> are relative to the 
origin of <F2>window<F0>.

<arg>

window <F3><#1f> A <F6>window<F3> specifying the coordinate system 
for the returned position.

<syntax0>

<|,"12<#1e>127">motion<#1e>events<F2> <F3>w<F2>indow<F0> <F3>&key<F0> 
:start :stop <F3>(<F0>:result<#1e>type 'list<F3>)<F0><Tab><F3>Function<Index, Doc = operations, "xlib:motion<#1e>events", Sort String = "motion<#1e>events">

<return,
	Left Tab =		-0.90/0/1.10 inches,
	Right Tab =		7.50 inches>

<Tab><F3>Returns:<F0> <HR>
<F2>  motion<#1e>events<F0> <F3><#1f> Type<F0> (repeat<#1e>seq 
(int16 x) (int16 y) (timestamp<HR>
<Tab>          time))<F3>.

<para>

Many X server implementations maintain a more precise history of pointer 
motion between event notifications. The pointer position at each pointer 
hardware interrupt can be stored into a buffer for later retrieval.This 
is called the <F2>motion history buffer<F0>. A paint program, for 
example, may want to have a precise history of where the pointer traveled, 
even though for most other applications this amount of detail is grossly 
excessive.

The <F6>motion<#1e>events<F0> function returns all events in the 
motion history buffer that fall between the specified <F6>:start<F0> 
and <F6>:stop<F0> timestamps (inclusive) and have coordinates that 
lie within the specified <F2>window<F0> (including borders) at its 
present placement. If the <F6>:start<F0> time is later than the <F6>:stop
<F0> time or if the <F6>:start<F0> time is in the future, no events 
are returned.

<arg>

window <F3><#1f> The <F6>window<F3> containing the returned motion 
events.

<keyword2>

:start, :stop <F3><#1f> <F0>timestamp<F3> values for the time interval 
for returned motion events.

<arg>

<F6>:result<#1e>type<F0> <F3><#1f> The form of the returned motion 
events.

<syntax>

warp<#1e>pointer <F2>destination<F0> <F2>destination<#1e>x destination<#1e>y
<F0><Tab><F3>Function<Index, Doc = operations, "xlib:warp<#1e>pointer", Sort String = "warp<#1e>pointer">

<para>

Moves the pointer to the given coordinates relative to the <F2>destination
<F0> window. <F6>warp<#1e>pointer<F0> should be rarely be used 
since the user should normally be in control of the pointer position. <F6>warp
<#1e>pointer<F0> generates events just as if the user had instantaneously 
moved the pointer from one position to another.

<F6>warp<#1e>pointer<F0> cannot move the pointer outside the confine<#1e>to 
window of an active pointer grab; an attempt to do so only moves the 
pointer as far as the closest edge of the confine<#1e>to window.

<arg>

destination <F3><#1f> The <F6>window<F3> into which the pointer 
is moved.

destination<#1e>x, destination<#1e>y <F3><#1f><F0> <F3>The new 
position of the pointer relative to the destination.

<syntax>

warp<#1e>pointer<#1e>relative <F2>display x<#1e>offset y<#1e>offset<F0><Tab>
<F3>Function<Index, Doc = operations, "xlib:warp<#1e>pointer<#1e>relative", Sort String = "warp<#1e>pointer<#1e>relative">

<para>

Moves the pointer by the given offsets. This function should rarely 
be used since the user should normally be in control of the pointer 
position. <F6>warp<#1e>pointer<#1e>relative<F0> generates events 
just as if the user had instantaneously moved the pointer from one 
position to another.

<F6>warp<#1e>pointer<#1e>relative<F0> cannot move the pointer outside 
the confine<#1e>to window of an active pointer grab; an attempt to 
do so only moves the pointer as far as the closest edge of the confine<#1e>to 
window.

<arg>

display <F3><#1f> A <F6>display<F3>.

x<#1e>offset, y<#1e>offset <F3><#1f> The offsets used to adjust the 
pointer position.

<syntax>

warp<#1e>pointer<#1e>if<#1e>inside <F2>destination destination<#1e>x 
destination<#1e>y <F0><Tab><F3>Function<Index, Doc = operations, "xlib:warp<#1e>pointer<#1e>if<#1e>inside", Sort String = "warp<#1e>pointer<#1e>if<#1e>inside"><F0><HR>
<F2>source source<#1e>x source<#1e>y <F3>&optional (<F2>source<#1e>width
<F3> 0) <HR>
(<F2>source<#1e>height<F3> 0)

<para>

Moves the pointer to the given position relative to the <F2>destination<F0> 
window. However, the move can only take place if the pointer is currently 
contained in a visible portion of the specified rectangle of the <F2>source
<F0> window. If <F2>source<#1e>height<F0> is zero, it is replaced 
with the current height of <F2>source <F0>window minus <F2>source<#1e>y
<F0>. If <F2>source<#1e>width<F0> is zero, it is replaced with 
the current width of <F2>source <F0>window minus <F2>source<#1e>x<F0>.

<|,"12<#1e>128"><F6>warp<#1e>pointer<#1e>if<#1e>inside<F0> generates events 
just as if the user had instantaneously moved the pointer from one 
position to another. <F6>warp<#1e>pointer<#1e>if<#1e>inside<F0> 
cannot move the pointer outside the confine<#1e>to window of an active 
pointer grab; an attempt to do so only moves the pointer as far as 
the closest edge of the confine<#1e>to window.

<arg>

destination <F3><#1f> The <F6>window<F3> into which the pointer 
is moved.

destination<#1e>x, destination<#1e>y <F3><#1f><F0> <F3>The new 
position of the pointer relative to the <F0>destination<F3>.

source<F3> <#1f> The <F6>window<F3> that must currently contain 
the pointer.

source<#1e>x, source<#1e>y, source<#1e>width, source<#1e>height <F3><#1f>The 
source rectangle that must currently contain the pointer.<F0> 

<syntax>

warp<#1e>pointer<#1e>relative<#1e>if<#1e>inside <F2>x<#1e>offset 
y<#1e>offset source source<#1e>x source<#1e>y<F0><Tab><F3>Function<Index, Doc = operations, "xlib:warp<#1e>pointer<#1e>relative<#1e>if<#1e>inside", Sort String = "warp<#1e>pointer<#1e>relative<#1e>if<#1e>inside">
<F0><HR>
<F3>&optional (<F2>source<#1e>width<F3> 0) (<F2>source<#1e>height<F3> 
0)

<para>

Moves the pointer by the given offsets. However, the move can only 
take place if the pointer is currently contained in a visible portion 
of the specified rectangle of the <F2>source<F0> window. If <F2>source<#1e>h
eight<F0> is zero, it is replaced with the current height of <F2>source<#1e>w
indow<F0> minus <F2>source<#1e>y<F0>. If <F2>source<#1e>width<F0> 
is zero, it is replaced with the current width of <F2>source<#1e>window<F0> 
minus <F2>source<#1e>x<F0>.

<F6>warp<#1e>pointer<#1e>relative<#1e>if<#1e>inside<F0> generates 
events just as if the user had instantaneously moved the pointer from 
one position to another. <F6>warp<#1e>pointer<#1e>relative<#1e>if<#1e>inside
<F0> cannot move the pointer outside the confine<#1e>to window of 
an active pointer grab; an attempt to do so only moves the pointer 
as far as the closest edge of the confine<#1e>to window.

<arg>

x<#1e>offset, y<#1e>offset <F3><#1f> The offsets used to adjust the 
pointer position.

source<F3> <#1f> The <F6>window<F3> that must currently contain 
the pointer.

source<#1e>x, source<#1e>y, source<#1e>width, source<#1e>height <F3><#1f> 
The source rectangle that must currently contain the pointer.<F0> 

<p1rule>

<Index, "event", "managing", "input focus", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8>Managing Input<Tab><F6>12.7<F0><#04>CLX provides the <F6>set<#1e>focus<#1e>
input<F0> and <F6>focus<#1e>input<F0> functions to set<F6><FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Focus<Tab><F0>and get the keyboard input focus window.

<syntax>

set<#1e>input<#1e>focus <F2>display<F0> <F2>focus revert<#1e>to<F0> <F3>&o
ptional<F0> <F2>time<F0><Tab><F3>Function<Index, Doc = operations, "xlib:set<#1e>input<#1e>focus", Sort String = "set<#1e>input<#1e>focus">

<para>

Changes the keyboard input focus and the last<#1e>focus<#1e>change 
time. The function has no effect if the specified <F2>time<F0> is 
earlier than the current last<#1e>focus<#1e>change time or is later 
than the current server time; otherwise, the last<#1e>focus<#1e>change 
time is set to the specified <F2>time<F0>. The <F6>set<#1e>input<#1e>focus
<F0> function causes the X server to generate <F6>:focus<#1e>in<F0> 
and <F6>:focus<#1e>out <F0>events.

If <F6>:none<F0> is specified as the <F2>focus<F0>, all keyboard 
events are discarded until a new focus window is set. In this case, 
the <F2>revert<#1e>to<F0> argument is ignored.

If a window is specified as the <F2>focus<F0> argument, it becomes 
the keyboard's focus window. If a generated keyboard event would normally 
be reported to this window or one of its inferiors, the event is reported 
normally; otherwise, the event is reported with respect to the focus 
window.

If <F6>:pointer<#1e>root<F0> is specified as the <F2>focus<F0> 
argument, the input focus window is set to the root window of the 
screen containing the pointer when each keyboard event occurs. In 
this case, the <F2>revert<#1e>to<F0> argument is ignored.

<|,"12<#1e>129">The specified <F2>focus<F0> window must be viewable at the 
time of the request. If the <F2>focus<F0> window later becomes not 
viewable, the new focus window depends on the <F2>revert<#1e>to<F0> 
argument. If <F2>revert<#1e>to<F0> is specified as <F6>:parent<F0>, 
the <F2>focus<F0> reverts to the parent (or the closest viewable 
ancestor) and the new <F2>revert<#1e>to<F0> value is take to be <F6>:none
<F0>. If <F2>revert<#1e>to<F0> is <F6>:pointer<#1e>root<F0> or <F6>:none
<F0>, the <F2>focus<F0> reverts to that value. When the <F2>focus<F0> 
reverts, <F6>:focus<#1e>in <F0>and <F6>:focus<#1e>out<F0> events 
are generated, but the last<#1e>focus<#1e>change time is not affected.

<arg>

display<F3> <#1f> A <F6>display<F3>.

focus <F3><#1f> The new input focus <F6>window<F3>.

revert<#1e>to <F3><#1f> The focus <F6>window<F3> when focus is 
no longer viewable.

time <F3><#1f> A <F6>timestamp<F3>.

<syntax0>

input<#1e>focus <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:input<#1e>focus", Sort String = "input<#1e>focus">

<return>

<Tab><F3>Returns:<HR>
 <F2> focus <F3><#1f> Type<F0> <F3>(<F0>or window <F3>(<F0>member 
:none :pointer<#1e>root<F3>)).<F0><HR>
 <F2> revert<#1e>to <F3><#1f> Type (<F0>or window <F3>(<F0>member 
:none :pointer<#1e>root :parent<F3>)).

<para>

Returns the <F2>focus<F0> window, <F6>:pointer<#1e>root<F0>, or <F6>:none
<F0>, depending on the current state of the focus window. <F2>revert<#1e>to
<F0> returns the current focus revert<#1e>to state.

<arg>

display <F3><#1f> A <F6>display<F3>.

<p1rule,
	New Page =		yes>

<|,"12<#1e>130"><Index, "grabbing", "pointer", To Named = p1rule><Index, "pointer", "grabbing", To Named = p1rule><Index, "event", "grabbing", "pointer", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8>Grabbing<Tab><F6>12.8<#04><F0>CLX provides the <F6>grab<#1e>pointer
<F0> and <F6>ungrab<#1e>pointer<F0> functions for<FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>the Pointer<Tab><F0>grabbing and releasing pointer control.<F8> 

<syntax0>

grab<#1e>pointer <F2>window event<#1e>mask <F3>&key <F0>:owner<#1e>p 
:sync<#1e>pointer<#1e>p <Tab><F3>Function<Index, Doc = operations, "xlib:grab<#1e>pointer", Sort String = "grab<#1e>pointer"><HR>
<F0>:sync<#1e>keyboard<#1e>p :confine<#1e>to :cursor :time

<return>

<Tab><F3>Returns: <F2><HR>
  grab<#1e>status <#1f> <F3>One of <F0>:already<#1e>grabbed<F3>, <F0>:froze
n<F3>, <F0>:invalid<#1e>time<F3>, <Tab><Tab>                    <F0> 
:not<#1e>viewable<F3>, or <F0>:success<F3>.

<para>

Actively grabs control of the pointer. Further pointer events are 
only reported to the grabbing client. The request overrides any active 
pointer grab by this client.

If <F6>:owner<#1e>p<F0> is <F6>nil<F0>, all generated pointer 
events are reported with respect to <F2>window<F0>, and are only 
reported if selected by <F2>event<#1e>mask<F0>. If <F6>:owner<#1e>p<F0> 
is true, and if a generated pointer event would normally be reported 
to this client, it is reported normally; otherwise the event is reported 
with respect to the <F2>window<F0>, and is only reported if selected 
by <F2>event<#1e>mask<F0>. For either value of <F6>:owner<#1e>p<F0>, 
unreported events are simply discarded.

If <F6>:sync<#1e>pointer<#1e>p<F0> is <F6>nil<F0>, pointer event 
processing continues normally (asynchronously); if the pointer is 
currently frozen by this client, then processing of pointer events 
is resumed. If <F6>:sync<#1e>pointer<#1e>p<F0> is true<F6> <F0>(indicating 
a synchronous action), the pointer (as seen via the protocol) appears 
to freeze, and no further pointer events are generated by the server 
until the grabbing client issues a releasing <F6>allow<#1e>events<F0> 
request. Actual pointer changes are not lost while the pointer is 
frozen; they are simply queued for later processing.

If <F6>:sync<#1e>keyboard<#1e>p<F0> is <F6>nil<F0>, keyboard event 
processing is unaffected by activation of the grab. If <F6>:sync<#1e>keyboard<#1e>
p<F0> is true, the keyboard (as seen via the protocol) appears to 
freeze, and no further keyboard events are generated by the server 
until the grabbing client issues a releasing <F6>allow<#1e>events<F0> 
request. Actual keyboard changes are not lost while the keyboard is 
frozen; they are simply queued for later processing.

If <F6>:cursor<F0> is specified, it is displayed regardless of what 
window the pointer is in. Otherwise, the normal cursor for the <F2>window
<F0> is displayed.

If a <F6>:confine<#1e>to<F0> window is specified, the pointer is 
restricted to stay within that window. The :<F6>confine<#1e>to<F0> 
window does not need to have any relationship to the <F2>window<F0>. 
If the pointer is not initially in the <F6>:confine<#1e>to<F0> window, 
it is warped automatically to the closest edge (with <F6>:enter<F0>/<F6>:lea
ve<#1e>events<F0> generated normally) just before the grab activates. 
If the <F6>:confine<#1e>to<F0> window is subsequently reconfigured, 
the pointer is warped automatically as necessary to keep it contained 
in the window.

<F6>grab<#1e>pointer<F0> generates <F6>:enter<#1e>notify<F0> and <F6>:leav
e<#1e>notify<F0> events. <F6>grab<#1e>pointer<F0> can fail with 
a status of:

<bullet>

<F9>w<Tab><F6>:already<#1e>grabbed<F0> if the pointer is actively 
grabbed by some other client

<F9>w<Tab><F6>:frozen<F0> if the pointer is frozen by an active 
grab of another client

<F9>w<Tab><F6>:not<#1e>viewable<F0> if the <F2>window<F0> or 
the <F6>:confine<#1e>to<F0> window is not viewable, or if the <F6>:confine<#1e>
to<F0> window lies completely outside the boundaries of the root 
window.

<F9>w<Tab><F6>:invalid<#1e>time<F0> if the specified time is earlier 
than the last<#1e>pointer<#1e>grab time or later than the current 
server time. Otherwise, the last<#1e>pointer<#1e>grab time is set 
to the specified time, with current<#1e>time replaced by the current 
server time, and a value of <F6>:success<F0> is returned by <F6>grab<#1e>poi
nter<F0>.

<arg>

<|,"12<#1e>131">window <F3><#1f> The <F6>window<F3> grabbing the pointer.

event<#1e>mask <F3><#1f> A <F6>pointer<#1e>event<#1e>mask<F3>.

<keyword2>

:owner<#1e>p <F3><#1f> If true, all client windows receive pointer 
events normally.

:sync<#1e>pointer<#1e>p <F3><#1f> Indicates whether the pointer is 
in synchronous or asynchronous mode. 

:sync<#1e>keyboard<#1e>p <F3><#1f> Indicates whether the keyboard 
is in synchronous or asynchronous mode. 

:confine<#1e>to <F3><#1f> A <F0>window<F3> to which the pointer 
is confined.

:cursor <F3><#1f> A <F0>cursor<F3>.

:time <F3><#1f> A <F0>timestamp<F3>. A <F0>nil<F3> value means 
the current server time is used.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

ungrab<#1e>pointer <F2>display<F3> &key <F0>:time<Tab><F3>Function<Index, Doc = operations, "xlib:ungrab<#1e>pointer", Sort String = "ungrab<#1e>pointer">

<para>

Releases the pointer if this client has it actively grabbed (from 
either <F6>grab<#1e>pointer<F0>, <F6>grab<#1e>button<F0>, or from 
a normal button press), and releases any queued events. The request 
has no effect if the specified <F6>:time<F0> is earlier than the 
last<#1e>pointer<#1e>grab time or is later than the current server 
time. An <F6>ungrabpointer<F0> is performed automatically if the 
event window or <F6>:confine<#1e>to<F0> window for an active pointer 
grab becomes not viewable. 

This request generates <F6>:enter<#1e>notify<F0> and <F6>:leave<#1e>notify
<F0> events.

<arg>

display <F3><#1f> A <F6>display<F3>.

<keyword2>

:time <F3><#1f> A <F0>timestamp<F3>.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

change<#1e>active<#1e>pointer<#1e>grab <F2>display event<#1e>mask <F3>&option
al<F2> cursor time<F0><Tab><F3>Function<Index, Doc = operations, "xlib:change<#1e>active<#1e>pointer<#1e>grab", Sort String = "change<#1e>active<#1e>pointer<#1e>grab">

<para>

Changes the specified dynamic parameters if the pointer is actively 
grabbed by the client and the specified <F2>time<F0> is no earlier 
than the last<#1e>pointer<#1e>grab time and no later than the current 
server time. The interpretation of <F2>event<#1e>mask<F0> and <F2>cursor
<F0> are as in <F6>grab<#1e>pointer<F0>. <F6>change<#1e>active<#1e>pointer<#1e>
grab<F0> has no effect on the passive parameters of a <F6>grab<#1e>button
<F0>.

<arg>

display <F3><#1f> A <F6>display<F3>.

event<#1e>mask <F3><#1f> A <F6>pointer<#1e>event<#1e>mask<F3>.

cursor <F3><#1f> A <F6>cursor<F3> or <F6>nil<F3>.

time <F3><#1f> A <F6>timestamp<F3>.

<p1rule,
	New Page =		yes>

<|,"12<#1e>132"><Index, "grabbing", "button", To Named = p1rule><Index, "button", "grabbing", To Named = p1rule><Index, "event", "grabbing", "button", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8>Grabbing<Tab><F6>12.9<#04><F0>CLX provides the <F6>grab<#1e>button
<F0> and <F6>ungrab<#1e>button<F0> functions for<FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>a Button<Tab><F0>passively grabbing and releasing pointer control.<#04>
<F8> 

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

grab<#1e>button <F2>window button event<#1e>mask <F3>&key (<F0>:modifiers
<F3> 0) <F0>:owner<#1e>p <Tab><F3>Function<Index, Doc = operations, "xlib:grab<#1e>button", Sort String = "grab<#1e>button"><HR>
<F0>:sync<#1e>pointer<#1e>p :sync<#1e>keyboard<#1e>p<F3> <F0>:confine<#1e>to 
:cursor

<para>

This request establishes a passive grab. If the specified <F2>button<F0> 
is pressed when the specified modifier keys are down (and no other 
buttons or modifier keys are down), and:

<bullet>

<F9>w<Tab><F2>window<F0> contains the pointer

<F9>w<Tab><F0>The <F6>:confine<#1e>to<F0> window (if any) is viewable

<F9>w<Tab><F0>These constraints are not satisfied for any ancestor 
of <F2>window

<para>

then:

<bullet>

<F9>w<Tab><F0>The pointer is actively grabbed as described with <F6>grab<#1e>
pointer

<F9>w<Tab><F0>The last<#1e>pointer<#1e>grab time is set to the time 
that the button was pressed (as transmitted in the <F6>:button<#1e>press<F0> 
event)

<F9>w<Tab><F0>The <F6>:button<#1e>press<F0> event is reported

<para>

The interpretation of the remaining arguments is the same as with <F6>grab<#1e>
pointer<F0>. The active grab is terminated automatically when all 
buttons are released (independent of the state of modifier keys).

A zero <F2>modifier<F0> mask is equivalent to issuing the request 
for all possible modifier<#1e>key combinations (including the combination 
of no modifiers). It is not required that all specified modifiers 
have currently assigned keycodes. A <F2>button<F0> of <F6>:any<F0> 
is equivalent to issuing the request for all possible buttons. Otherwise, 
it is not required that the specified <F2>button<F0> currently be 
assigned to a physical button.

<arg>

window <F3><#1f> A <F6>window<F3>.

button <F3><#1f> The button (type <F6>card8<F3>) pressed or <F6>:any<F3>.

event<#1e>mask <F3><#1f> A <F6>pointer<#1e>event<#1e>mask<F3>.

<keyword2>

:modifiers <F3><#1f> A <F0>modifier<#1e>mask<F3>.

:owner<#1e>p <F3><#1f> If true, all client windows receive pointer 
events normally.

:sync<#1e>pointer<#1e>p <F3><#1f> Indicates whether the pointer is 
handled in a synchronous or asynchronous fashion. 

:sync<#1e>keyboard<#1e>p <F3><#1f> Indicates whether the keyboard 
is in synchronous or asynchronous mode. 

:confine<#1e>to <F3><#1f> A <F0>window<F3> to which the pointer 
is confined. 

:cursor <F3><#1f> A <F0>cursor<F3>.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<|,"12<#1e>133">ungrab<#1e>button <F2>window button <F3>&key (<F0>:modifiers<F3> 
0)<F0><Tab><F3>Function<Index, Doc = operations, "xlib:ungrab<#1e>button", Sort String = "ungrab<#1e>button">

<para>

Releases the passive button/key combination on the specified <F2>window<F0> 
if it was grabbed by this client. A zero <F2>modifier<F0> mask is 
equivalent to issuing the request for all possible modifier combinations 
including the combination of no modifiers. A <F2>button<F0> of <F6>:any
<F0> is equivalent to issuing the request for all possible buttons. 
This has no effect on an active grab.

<arg>

window <F3><#1f> A <F6>window<F3>.

button <F3><#1f> The button (type <F6>card8<F3>) that is released 
or <F6>:any<F3>.

<keyword2>

:modifiers <F3><#1f> A <F0>modifier<#1e>mask<F3>.

<p1rule>

<Index, "grabbing", "keyboard", To Named = p1rule><Index, "keyboard", "grabbing", To Named = p1rule><Index, "event", "grabbing", "keyboard", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8>Grabbing<Tab><F6>12.10<#04><F0>CLX provides the<F6> grab<#1e>keyboard
<F0> and <F6>ungrab<#1e>keyboard<F0> functions<F6><FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>the Keyboard<Tab><F0>for actively grabbing and releasing control 
of the keyboard.<F8> 

<syntax0>

grab<#1e>keyboard <F2>window <F3>&key <F0>:owner<#1e>p :sync<#1e>pointer<#1e>
p :sync<#1e>keyboard<#1e>p <Tab><F3>Function<Index, Doc = operations, "xlib:grab<#1e>keyboard", Sort String = "grab<#1e>keyboard"><HR>
<F0>:time

<return>

<Tab><F3>Returns: <F2><HR>
  grab<#1e>status <#1f> <F3>One of <F0>:already<#1e>grabbed<F3>, <F0>:froze
n<F3>, <F0>:invalid<#1e>time<F3>, <Tab><Tab>                    <F0> 
:not<#1e>viewable<F3>, or <F0>:success<F3>.

<para>

Actively grabs control of the keyboard. Further key events are reported 
only to the grabbing client. The request overrides any active keyboard 
grab by this client. <F6>grab<#1e>keyboard<F0> generates <F6>:focus<#1e>in
<F0> and <F6>:focus<#1e>out<F0> events.

If <F6>:owner<#1e>p<F0> is <F6>nil<F0>, all generated key events 
are reported with respect to <F2>window<F0>. If <F6>:owner<#1e>p<F0> 
is true, then a generated key event that would normally be reported 
to this client is reported normally; otherwise the event is reported 
with respect to the <F2>window<F0>. Both <F6>:key<#1e>press<F0> 
and <F6>:key<#1e>release<F0> events are always reported, independent 
of any event selection made by the client.

If <F6>:sync<#1e>keyboard<#1e>p<F0> is <F6>nil<F0>, keyboard event 
processing continues normally (asynchronously); if the keyboard is 
currently frozen by this client, then processing of keyboard events 
is resumed. If <F6>:sync<#1e>keyboard<#1e>p<F0> is true, the keyboard 
(as seen via the protocol) appears to freeze, and no further keyboard 
events are generated by the server until the grabbing client issues 
a releasing <F6>allow<#1e>events<F0> request. Actual keyboard changes 
are not lost while the keyboard is frozen; they are simply queued 
for later processing.

If <F6>:sync<#1e>pointer<#1e>p<F0> is <F6>nil<F0>, pointer event 
processing is unaffected by activation of the grab. If <F6>:sync<#1e>pointer<#1e>
p<F0> is true, the pointer (as seen via the protocol) appears to 
freeze, and no further pointer events are generated by the server 
until the grabbing client issues a releasing <F6>allow<#1e>events<F0> 
request. Actual pointer changes are not lost while the pointer is 
frozen; they are simply queued for later processing.

The grab can fail with a status of:

<bullet>

<F9>w<Tab><F6>:already<#1e>grabbed<F0> if the keyboard is actively 
grabbed by some other client

<F9>w<Tab><F6>:frozen<F0> if the keyboard is frozen by an active 
grab from another client

<F9>w<Tab><F6>:not<#1e>viewable<F0> if <F2>window<F0> is not 
viewable

<|,"12<#1e>134"><F9>w<Tab><F6>:invalid<#1e>time<F0> if the specified time 
is earlier than the last<#1e>keyboard<#1e>grab time or later than 
the current server time. Otherwise, <F6>grab<#1e>keyboard<F0> returns 
a status of <F6>:success<F0> and last<#1e>keyboard<#1e>grab time 
is set to the specified time, with current<#1e>time replaced by current 
server time.

<arg>

window <F3><#1f> A <F6>window<F3>.

<keyword2>

:owner<#1e>p <F3><#1f> If true, all client windows receive keyboard 
input normally.

:sync<#1e>pointer<#1e>p <F3><#1f> Indicates whether the pointer is 
in synchronous or asynchronous mode. 

:sync<#1e>keyboard<#1e>p <F3><#1f> Indicates whether the keyboard 
is in synchronous or asynchronous mode. 

:time <F3><#1f> A <F0>timestamp<F3>. 

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

ungrab<#1e>keyboard <F2>display <F3>&key <F0>:time<Tab><F3>Function<Index, Doc = operations, "xlib:ungrab<#1e>keyboard", Sort String = "ungrab<#1e>keyboard">

<para>

Releases the keyboard if this client has it actively grabbed (from 
either <F6>grab<#1e>keyboard<F0> or <F6>grab<#1e>key<F0>), and 
releases any queued events. The request has no effect if the specified 
time is earlier than the last<#1e>keyboard<#1e>grab time or is later 
than the current server time. An <F6>ungrab<#1e>keyboard<F0> is 
performed automatically if the event window for an active keyboard 
grab becomes not viewable.

<arg>

display <F3><#1f> A <F6>display<F3>. 

<keyword2>

:time <F3><#1f> A <F0>timestamp<F3>.

<p1rule>

<Index, "grabbing", "key", To Named = sectitle><Index, "key", "grabbing", To Named = sectitle><Index, "event", "grabbing", "key", To Named = sectitle>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Grabbing a Key<Tab><F6>12.11<#04><F0>The following paragraphs 
describe the functions used for passively grabbing and releasing the 
keyboard.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

grab<#1e>key <F2>window key <F3>&key (<F0>:modifiers<F3> 0) <F0>:owner<#1e>
p :sync<#1e>pointer<#1e>p <Tab><F3>Function<Index, Doc = operations, "xlib:grab<#1e>keyboard", Sort String = "grab<#1e>keyboard"><HR>
<F0>:sync<#1e>keyboard<#1e>p :time

<para>

This request establishes a passive grab on the keyboard. If the specified 
<F2>key<F0> (which can also be a modifier key) is pressed (whether 
or not any specified modifier keys are down), and either of the following 
is true:

<bullet>

<F9>w<Tab><F2>window<F0> is an ancestor of (or is) the focus window

<F9>w<Tab><F2>window<F0> is a descendant of the focus window and 
contains the pointer

<F9>w<Tab><F0>These constraints are not satisfied for any ancestor 
of <F2>window<F0>, then the following occurs:

<sbullet>

<F9>w<Tab><F0>The keyboard is actively grabbed as described in <F6>grab<#1e>
keyboard

<F9>w<Tab><F0>The last<#1e>keyboard<#1e>grab time is set to the 
time that the <F2>key<F0> was pressed (as transmitted in the <F6>:key<#1e>pr
ess<F0> event)

<F9>w<Tab><F0>The <F6>:key<#1e>press<F0> event is reported

<para>

The interpretation of the remaining arguments is as for <F6>grab<#1e>keyboard
<F0>. The active grab is terminated automatically when the specified <F2>key
<F0> has been released, independent of the state of the modifier 
keys.

<|,"12<#1e>135">A zero modifier mask is equivalent to issuing the request for 
all possible modifier combinations (including the combination of no 
modifiers). It is not required that all specified modifiers have currently 
assigned keycodes. A <F2>key<F0> of <F6>:any<F0> is equivalent 
to issuing the request for all possible keycodes. Otherwise, the <F2>key<F0> 
must be in the range specified by <F6>display<#1e>min<#1e>keycode<F0> 
and <F6>display<#1e>max<#1e>keycode<F0> in the connection setup.

<arg>

window <F3><#1f> A <F6>window<F3>.

key <F3><#1f> The key (type <F6>card8<F3>) to be grabbed or <F6>:any<F3>.

<keyword2>

:modifiers <F3><#1f> A <F0>modifier<#1e>mask<F3>.

:owner<#1e>p <F3><#1f> If true, all client windows receive keyboard 
input normally.

:sync<#1e>pointer<#1e>p <F3><#1f> Indicates whether the pointer is 
in synchronous or asynchronous mode. 

:sync<#1e>keyboard<#1e>p <F3><#1f> Indicates whether the keyboard 
is in synchronous or asynchronous mode. 

:time <F3><#1f> A <F0>timestamp<F3>. 

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

ungrab<#1e>key <F2>window key <F3>&key (<F0>:modifiers<F3> 0)<F0><Tab>
<F3>Function<Index, Doc = operations, "xlib:ungrab<#1e>key", Sort String = "ungrab<#1e>key">

<para>

Releases the <F2>key<F0> combination on the specified <F2>window<F0> 
if it was grabbed by this client. A zero modifier mask of <F6>:any <F0>is 
equivalent to issuing the request for all possible modifier combinations 
(including the combination of no modifiers). A <F2>key<F0> of <F6>:any<F0> 
is equivalent to issuing the request for all possible keycodes. <F6>ungrab<#1e>
key<F0> has no effect on an active grab.

<arg>

window <F3><#1f> A <F6>window<F3>.

key <F3><#1f> The key (type <F6>card8<F3>) to be released or <F6>:any<F3>.

<keyword2>

:modifiers <F3><#1f> A <F0>modifier<#1e>mask<F3>.

<p1rule>

<Index, "event", "types", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1para,
	Bottom Margin =		0.12 inches,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Event Types<Tab><F6>12.12<F0><#04>The following paragraphs 
contain detailed descriptions of the contents of each event type. 
In CLX, events are not actually represented by structures, but rather 
by lists of keyword values passed to handler functions or by values 
bound to symbols within the clauses of <F6>event<#1e>case<F0> and <F6>event<#1e>
cond<F0> forms. Nevertheless, it is convenient to describe event 
contents in terms of slots and to identify the components of events 
with slot name symbols. In fact, CLX uses the <F6>declare<#1e>event<F0> 
macro to define event slot symbols and to map these symbols to specific 
event data items returned by the X server (see paragraph 12.12.8, 
Declaring Event Types). 

<para,
	Bottom Margin =		0.12 inches>

The following paragraphs describe each event type, listing its <F6>event<#1e>k
ey<F0> keyword symbol and its slot name symbols. An event keyword 
symbol identifies a specific event type. An event keyword symbol can 
be given as an argument to <F6>send<#1e>event<F0> or to an event 
handler function; it can also appear in the <F2>event<#1e>match<F0> 
form of an <F6>event<#1e>case<F0> clause. An event slot name symbol 
identifies a specific event data item. Event slot names appear as 
keywords with associated values among the arguments passed to <F6>send<#1e>eve
nt<F0> or to an event handler function; as non<#1e>keyword symbols, 
they can also be in the <F2>event<#1e>slots<F0> form of an <F6>event<#1e>cas
e<F0> clause.

<para>

In certain cases, more than one name symbol is defined for the same 
event slot. For example, in <F6>:key<#1e>press<F0> events, the symbols <F2>w
indow<F0> and <F2>event<#1e>window<F0> both refer to the same event 
data item.

<p2rule>

<|,"12<#1e>136"><Index, "pointer", "events", To Named = p2rule><Index, "keyboard", "events", To Named = p2rule><Index, "event", "pointer", To Named = p2rule><Index, "event", "keyboard", To Named = p2rule>
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Tab><F6>Keyboard and<Tab>12.12.1<#04><F0>The keyboard and pointer 
events are: <F6>:key<#1e>press, :key<#1e>release,<FJ>

<p2para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break Within = yes,
	Allow Page Break After = yes,
	TOC Doc Name =		>

<F6> <Tab>Pointer Events<F0><Tab><F6>:button<#1e>press, :button<#1e>release
<F0>, <F6>:motion<#1e>notify<F0>, <F6>:enter<#1e>notify<F0>, 
and<F6> :leave<#1e>notify.

<syntax>

<Index, "event", ":key<#1e>press", Sort String = "key<#1e>press"><Index, "event", ":key<#1e>release", Sort String = "key<#1e>release"><Index, "event", ":button<#1e>press", Sort String = "button<#1e>press"><Index, "event", ":button<#1e>release", Sort String = "button<#1e>release"><Index, ":key<#1e>press event", Sort String = "key<#1e>press event"><Index, ":key<#1e>release event", Sort String = "key<#1e>release event"><Index, ":button<#1e>press event", Sort String = "button<#1e>press event"><Index, ":button<#1e>release event", Sort String = "button<#1e>release event">
:key<#1e>press, :key<#1e>release, :button<#1e>press, :button<#1e>release<Tab>
<F3>Event Type

<arg>

Selected by<F3>: <#1f><F6> :key<#1e>press<F3>, <F6>:key<#1e>release<F3>,
<F6> :button<#1e>press<F3>, or <F6>:button<#1e>release<F3>.<F6> 

<para>

<F6>:key<#1e>press<F0>, and<F6> :key<#1e>release<F0> events are 
generated when a key or pointer button changes state. Note that<F6> 
:key<#1e>press <F0>and <F6>:key<#1e>release<F0> are generated for 
all keys, even those mapped to modifiers. All of these event types 
have the same slots. The window containing the pointer at the time 
of the event is referred to as the <F2>source<F0> window. The <F2>event 
window<F0> is the window to which the event is actually reported. 
The event window is found by starting with the source window and looking 
up the hierarchy for the first window on which any client has selected 
interest in the event (provided no intervening window prohibits event 
generation by including the event type in its do<#1e>not<#1e>propagate<#1e>mask
). The actual window used for reporting can be modified by active 
grabs and, in the case of keyboard events, can be modified by the 
focus window.

<para,
	Bottom Margin =		0.08 inches>

A <F6>:button<#1e>press<F0> event has the effect of a temporary <F6>grab<#1e>
button<F0>. When a pointer button is pressed and no active pointer 
grab is in progress, the ancestors of the source window are searched 
from the <F2>root<F0> down, looking for a passive grab to activate. 
If no matching passive grab on the button exists, then an active grab 
is started automatically for the client receiving the <F6>:button<#1e>press
<F0> event, and the last<#1e>pointer<#1e>grab time is set to the 
current server time. The effect is essentially equivalent to calling <F6>grab<#1e>
button<F0> with the following arguments:

<ritabhd1,
	Left Tab =		0/1.60/3.50/7.50 inches>

<Tab-><Tab-><Tab-><HR>
Argument<Tab>Description<HR>
<Tab-><Tab-><Tab->

<F2>window<F3><Tab>The event window.<HR>
<F2>button<F3><Tab>The button that was pressed.

<F2>event<#1e>mask<F3><Tab>The client's selected pointer events 
on the event <Tab><Tab><Tab> window.<F0><HR>
:modifiers<Tab><F3>0<F0><HR>
:owner<#1e>p<Tab>t<F3> if the client has <F0>:owner<#1e>grab<#1e>button<F3> 
selected <Tab><Tab><Tab> on the event window; otherwise<F2> <F0>nil<F3>.
<F0><HR>
:sync<#1e>pointer<#1e>p<Tab>nil<HR>
:sync<#1e>keyboard<#1e>p<Tab>nil<HR>
:confine<#1e>to<Tab>nil<HR>
:cursor<Tab>nil

<endrule,
	Bottom Margin =		0.08 inches>

<Tab-><Tab-><Tab-><Tab->

<para>

The <F6>:button<#1e>press<F0> grab is terminated automatically when 
all buttons are released. The functions <F6>ungrab<#1e>pointer<F0> 
and <F6>change<#1e>active<#1e>pointer<#1e>grab<F0> can both be used 
to modify the <F6>:button<#1e>press<F0> grab.

<indentA>

<F2>window, event<#1e>window<F0> <#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>code<F6> <F0><#1f> Type <F6>card8<F0>.

<indentB>

The <F2>code<F0> argument varies with the event type. For <F6>:key<#1e>press
<F0> and <F6>:key<#1e>release<F0>, <F2>code<F0> is the keycode 
(see paragraph 14.4, Keyboard Encodings). For <F6>:button<#1e>press<F0> 
and <F6>:button<#1e>release<F0>, <F2>code<F0> is the pointer button 
number.

<indentA,
	New Page =		yes>

<|,"12<#1e>137"><F2>x<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

If <F2>event<#1e>window<F0> is on the same screen as root, then <F2>x<F0> 
and <F2>y<F0> are the pointer coordinates relative to the <F2>event<#1e>wind
ow<F0>; otherwise <F2>x<F0> and <F2>y<F0> are zero.

<indentA>

<F2>y<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

If <F2>event<#1e>window<F0> is on the same screen as root, then <F2>x<F0> 
and <F2>y<F0> are the pointer coordinates relative to the <F2>event<#1e>wind
ow<F0>; otherwise <F2>x<F0> and <F2>y<F0> are zero.

<indentA>

<F2>state<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

A mask that gives the state of the buttons and modifier keys just 
before the event.

<indentA>

<F2>time<F6> <F0><#1f> Type <F6>card32<F0>.

<indentB>

A timestamp for the moment when the event occurred.

<indentA>

<F2>root<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The root window of the source window.

<indentA>

<F2>root<#1e>x<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

The x coordinate of the pointer position relative to root at the time 
of the event.

<indentA>

<F2>root<#1e>y<F0> <#1f><F2> <F0>Type <F6>int16<F0>.

<indentB>

The y coordinate of the pointer position relative to root at the time 
of the event<F2>.

<indentA>

<F2>child <F0><#1f> Type (<F6>or null window<F0>).

<indentB>

If the source window is an inferior of the <F2>event<#1e>window<F0>, <F2>chi
ld<F0> is set to the child of <F2>event<#1e>window<F0> that is 
an ancestor of (or is) the source window; otherwise, it is set to<F2> <F6>nil
<F2>.

<indentA>

<F2>same<#1e>screen<#1e>p <F0><#1f> Type <F6>boolean<F0>.

<indentB>

True if <F2>event<#1e>window<F0> and root are on the same screen.

<syntax>

<Index, "event", ":motion<#1e>notify", Sort String = "motion<#1e>notify"><Index, ":motion<#1e>notify event", Sort String = "motion<#1e>notify event">:motion<#1e>notify<Tab><F3>Event 
Type

<arg>

Selected by: <F3><#1f> <F6>:button<#1e>1<#1e>motion<F3>,<F6> :button<#1e>2<#1e>
motion<F3>,<F6> :button<#1e>3<#1e>motion<F3>,<HR>
<F6>:button<#1e>4<#1e>motion<F3>,<F6> :button<#1e>5<#1e>motion<F3>, <F6>:b
utton<#1e>motion<F3>, or<F6> :pointer<#1e>motion<F3>.

<para>

The <F6>:motion<#1e>notify<F0> event is generated when the pointer 
moves. A <F6>:motion<#1e>notify<F0> event has the same slots as <F6>:button<#1e>
press,<F0> <F6>:button<#1e>release<F0>, <F6>:key<#1e>press<F0>, 
and <F6>:key<#1e>release <F0>events, with the exception that the <F2>code
<F0> slot is replaced by the <F2>hint<#1e>p<F0> slot. As with these 
other events, the event window for <F6>:motion<#1e>notify<F0> is 
found by starting with the source window and looking up the hierarchy 
for the first window on which any client has selected interest in 
the event (provided no intervening window prohibits event generation 
by including <F6>:motion<#1e>notify<F0> in its do<#1e>not<#1e>propagate<#1e>m
ask).The actual window used for reporting can be modified by active 
grabs.

<|,"12<#1e>138"><F6>:motion<#1e>notify<F0> events are generated only when 
the motion begins and ends in the window. The granularity of motion 
events is not guaranteed, but a client selecting for motion events 
is guaranteed to get at least one event when the pointer moves and 
comes to rest. Selecting <F6>:pointer<#1e>motion<F0> generates <F6>:motion<#1e>
notify<F0> events regardless of the state of the pointer buttons. 
By selecting some subset of <F6>:button[1<#1e>5]<#1e>motion<F0> 
instead, <F6>:motion<#1e>notify<F0> events are only received when 
one or more of the specified buttons are pressed. By selecting <F6>:button<#1e>
motion<F0>, <F6>:motion<#1e>notify<F0> events are only received 
when at least one button is pressed. If <F6>:pointer<#1e>motion<#1e>hint<F0> 
is also selected, the server is free to send only one <F6>:motion<#1e>notify
<F0>, until either the key or button state changes, the pointer leaves 
the event window, or the client calls <F6>query<#1e>pointer<F0> 
or <F6>motion<#1e>events<F0>.

<indentA>

<F2>hint<#1e>p<F6> <F0><#1f> Type <F6>boolean<F0>.

<indentB>

True if the event is a hint generated by selecting <F6>:pointer<#1e>motion<#1e>
hint<F0>.

<syntax>

<Index, "event", ":enter<#1e>notify", Sort String = "enter<#1e>notify"><Index, "event", ":leave<#1e>notify", Sort String = "leave<#1e>notify"><Index, ":enter<#1e>notify event", Sort String = "enter<#1e>notify event"><Index, ":leave<#1e>notify event", Sort String = "leave<#1e>notify event">
:enter<#1e>notify, :leave<#1e>notify<Tab><F3>Event Type

<arg>

Selected by: <F3><#1f><F0> <F6>:enter<#1e>window<F0> <F3>or<F0> <F6>:lea
ve<#1e>window<F3>.

<para>

If pointer motion or a window hierarchy change causes the pointer 
to be in a different window than before, <F6>:enter<#1e>notify<F0> 
and <F6>:leave<#1e>notify<F0> events are generated instead of a <F6>:motion<#1e>
notify<F0> event. All <F6>:enter<#1e>notify<F0> and <F6>:leave<#1e>notify
<F0> events caused by a hierarchy change are generated after any 
hierarchy event (<F6>:unmap<#1e>notify<F0>,<F6> :map<#1e>notify<F0>, <F6>:
configure<#1e>notify<F0>, <F6>:gravity<#1e>notify<F0>,<F2> <F0>or <F6>:ci
rculate<#1e>notify<F0>) caused by that change, but the ordering of <F6>:enter
<#1e>notify<F0> and <F6>:leave<#1e>notify<F0> events with respect 
to <F6>:focus<#1e>out<F0>, <F6>:visibility<#1e>notify<F0>, and <F6>:exposu
re<F0> events is not constrained by the X protocol. An <F6>:enter<#1e>notify
<F0> or <F6>:leave<#1e>notify <F0>event can also be generated when 
a client application calls <F6>change<#1e>active<#1e>pointer<#1e>grab<F0>,
<F6> grab<#1e>pointer<F0>, or <F6>ungrab<#1e>pointer<F0>.

<indentA>

<F2>window, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>x <F0><#1f><F2> <F0>Type <F6>int16<F0>.

<indentB>

The final pointer position. If <F2>event<#1e>window<F0> is on the 
same screen as root, then <F2>x<F0> and <F2>y<F0> are the pointer 
coordinates relative to the <F2>event<#1e>window<F0>; otherwise <F2>x<F0> 
and <F2>y<F0> are zero.

<indentA>

<F2>y<F0> <#1f> Type <F6>int16<F0>.

<indentB>

The final pointer position. If <F2>event<#1e>window<F0> is on the 
same screen as root, then <F2>x<F0> and <F2>y<F0> are the pointer 
coordinates relative to the <F2>event<#1e>window<F0>; otherwise <F2>x<F0> 
and <F2>y<F0> are zero.

<indentA>

<F2>mode <F0><#1f><F6> <F0>Type (<F6>member :normal :grab :ungrab<F0>).

<indentB>

Events caused when the pointer is actively grabbed have mode <F6>:grab<F0>. 
Events caused when an active pointer grab deactivates have mode <F6>:ungrab
<F0>. In all other cases, mode is <F6>:normal<F0>.

<indentA,
	New Page =		yes>

<|,"12<#1e>139"><F2>kind<F6> <F0><#1f> Type (<F6>member :ancestor :virtual 
:inferior :nonlinear                                 :nonlinear<#1e>virtual
<F0>).

<indentB>

When the pointer moves from window A to window B, and A is an inferior 
of B:

<ssbullet>

<F9>w<Tab><F6>:leave<#1e>notify<F0> with <F2>kind<F0> <F6>:ancestor<F0> 
is generated on A

<F9>w<Tab><F6>:leave<#1e>notify<F0> with <F2>kind<F0> <F6>:virtual <F0>i
s generated on each window between A and B exclusive (in that order) 

<F9>w<Tab><F6>:enter<#1e>notify <F0>with <F2>kind<F0> <F6>:inferior 
<F0>is generated on B

<indentB>

When the pointer moves from window A to window B, and B is an inferior 
of A:

<ssbullet>

<F9>w<Tab><F6>:leave<#1e>notify<F0> with <F2>kind<F0> <F6>:inferior<F0> 
is generated on A

<F9>w<Tab><F6>:enter<#1e>notify<F0> with <F2>kind<F0> <F6>:virtual<F0> 
is generated on each window between A and B exclusive (in that order)

<F9>w<Tab><F6>:enter<#1e>notify<F0> with <F2>kind<F0> <F6>:ancestor<F0> 
is generated on B

<indentB>

When the pointer moves from window A to window B, with window C being 
their least common ancestor:

<ssbullet>

<F9>w<Tab><F6>:leave<#1e>notify<F0> with <F2>kind<F0> <F6>:nonlinear
<F0> is generated on A

<F9>w<Tab><F6>:leave<#1e>notify<F0> with <F2>kind<F0> <F6>:nonlinear<#1e>
virtual<F0> is generated on each window between A and C exclusive 
(in that order)

<F9>w<Tab><F6>:enter<#1e>notify<F0> with <F2>kind<F0> <F6>:nonlinear<#1e>
virtual<F0> is generated on each window between C and B exclusive 
(in that order) 

<F9>w<Tab><F6>:enter<#1e>notify<F0> with <F2>kind<F0> <F6>:nonlinear
<F0> is generated on B

<indentB>

When the pointer moves from window A to window B, on different screens:

<ssbullet>

<F9>w<Tab><F6>:leave<#1e>notify<F0> with <F2>kind<F0> <F6>:nonlinear
<F0> is generated on A

<F9>w<Tab><F0>If A is not a root window, <F6>:leave<#1e>notify<F0> 
with <F2>kind<F0> <F6>:nonlinear<#1e>virtual<F0> is generated 
on each window above A up to and including its root (in order)

<F9>w<Tab><F0>If B is not a root window, <F6>:enter<#1e>notify<F0> 
with <F2>kind<F0> <F6>:nonlinear<#1e>virtual<F0> is generated 
on each window from B's root down to but not including B (in order)

<F9>w<Tab><F6>:enter<#1e>notify<F0> with <F2>kind<F0> <F6>:nonlinear
<F0> is generated on B

<indentB>

When a pointer grab activates (but after any initial warp into a confine<#1e>to 
window, and before generating any actual <F6>:button<#1e>press<F0> 
event that activates the grab), with <F2>G<F0> the <F6>grab<#1e>window<F0> 
for the grab and <F2>P<F0> the window the pointer is in, then <F6>:enter<#1e>
notify<F0> and <F6>:leave<#1e>notify<F0> events with mode <F6>:grab<F0> 
are generated (as for <F6>:normal<F0> above) as if the pointer were 
to suddenly warp from its current position in <F2>P<F0> to some 
position in <F2>G<F0>. However, the pointer does not warp, and the 
pointer position is used as both the <F2>initial<F0> and <F2>final<F0> 
positions for the events.

<|,"12<#1e>140">When a pointer grab deactivates (but after generating any actual <F6>:bu
tton<#1e>release<F0> event that deactivates the grab), with <F2>G<F0> 
the <F6>grab<#1e>window<F0> for the grab and <F2>P<F0> the window 
the pointer is in, then <F6>:enter<#1e>notify<F0> and <F6>:leave<#1e>notify
<F0> events with mode <F6>:ungrab<F0> are generated (as for <F6>:normal
<F0> above) as if the pointer were to suddenly warp from from some 
position in <F2>G<F0> to its current position in <F2>P<F0>. However, 
the pointer does not warp, and the current pointer position is used 
as both the <F2>initial<F0> and <F2>final<F0> positions for the 
events.

<indentA>

<F2>focus<#1e>p<F0> <#1f> Type <F6>boolean<F0>.

<indentB>

If <F2>event<#1e>window<F0> is the focus window or an inferior of 
the focus window, then <F2>focus<#1e>p<F0> is <F6>t<F0>; otherwise, <F2>fo
cus<#1e>p<F0> is <F6>nil<F0>.

<indentA>

<F2>state<F0> <#1f> Type <F6>card16<F0>.

<indentB>

A mask that gives the state of the buttons and modifier keys just 
before the event.

<indentA>

<F2>time<F0> <#1f> Type <F6>card32<F0>.

<indentB>

A timestamp for the moment when the event occurred.

<indentA>

<F2>root<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The root window containing the final pointer position.

<indentA>

<F2>root<#1e>x<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

The x coordinate of the pointer position relative to root at the time 
of the event.

<indentA>

<F2>root<#1e>y<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

The y coordinate of the pointer position relative to root at the time 
of the event.

<indentA>

<F2>child<F6> <F0><#1f> Type (<F6>or null window<F0>).

<indentB>

In a <F6>:leave<#1e>notify<F0> event, if a child of the <F2>event<#1e>window
<F0> contains the initial position of the pointer, the <F2>child<F0> 
slot is set to that child; otherwise, the <F2>child<F0> slot is <F6>nil
<F0>. For an <F6>:enter<#1e>notify<F0> event, if a child of the <F2>event<#1e>
window<F0> contains the final pointer position, the <F2>child<F0> 
slot is set to that child; otherwise, the <F2>child<F0> slot is <F6>nil
<F0>.

<indentA>

<F2>same<#1e>screen<#1e>p<F6> <F0><#1f> Type <F6>boolean<F0>.

<indentB>

True if <F2>event<#1e>window<F0> and root are on the same screen.

<p2rule>

<Index, "input", "focus events", To Named = p2rule><Index, "event", "input focus", To Named = p2rule>
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Tab><F6>Input Focus<Tab>12.12.2<F0><#04>The input focus events 
are <F6>:focus<#1e>in<F0> and <F6>:focus<#1e>out<F0>.<F6><#04>

<p2para>

 <Tab>Events<Tab>

<syntax0>

<Index, "event", ":focus<#1e>in", Sort String = "focus<#1e>in"><Index, "event", ":focus<#1e>out", Sort String = "focus<#1e>out"><Index, ":focus<#1e>in event", Sort String = "focus<#1e>in event"><Index, ":focus<#1e>out event", Sort String = "focus<#1e>out event">
:focus<#1e>in, :focus<#1e>out<Tab><F3>Event Type

<return>

<Tab><F3> <F0><HR>
<F2>Selected by:<F0> <F3><#1f><F0> :focus<#1e>change<F3>.

<para>

<F6>:focus<#1e>in<F0> and <F6>:focus<#1e>out<F0> events are generated 
when the input focus changes. All <F6>:focus<#1e>out<F0> events 
caused by a window <F6>:unmap<F0> are generated after any <F6>:unmap<#1e>not
ify<F0> event, but the ordering of <F6>:focus<#1e>out<F0> with 
respect to generated <F6>:enter<#1e>notify<F0>, <F6>:leave<#1e>notify<F0>, 
<F6>:visibility<#1e>notify<F0>, and <F6>:expose<F0> events is 
not constrained.

<indentA>

<F2>window, event<#1e>window <F0><#1f> Type <F6>window<F0>.

<indentB>

For <F6>:focus<#1e>in<F0>, the new input focus window. For<F6> 
:focus<#1e>out,<F0> the previous input focus window.

<indentA>

<|,"12<#1e>141"><F2>mode<F6> <F0><#1f> Type <F6>(member :normal :while<#1e>grabbed 
:grab :ungrab)<F0>.

<indentB>

Events generated by <F6>set<#1e>input<#1e>focus<F0> when the keyboard 
is not grabbed have mode <F6>:normal<F0>. Events generated by <F6>set<#1e>in
put<#1e>focus<F0> when the keyboard is grabbed have mode <F6>:while<#1e>grabb
ed<F0>. Events generated when a keyboard grab activates have mode <F6>:grab
<F0>, and events generated when a keyboard grab deactivates have 
mode <F6>:ungrab<F0>.

<indentA>

<F2>kind<F6> <F0><#1f> Type (<F6>member :ancestor :virtual :inferior 
:nonlinear                                 :nonlinear<#1e>virtual 
:pointer :pointer<#1e>root :none<F0>).

<indentB>

When the focus moves from window A to window B, and A is an inferior 
of B, with the pointer in window P:

<ssbullet>

<F9>w<Tab><F6>:focus<#1e>out<F0> with <F2>kind<F0> <F6>:ancestor<F0> 
is generated on A

<F9>w<Tab><F6>:focus<#1e>out<F0> with <F2>kind<F0> <F6>:virtual<F0> 
is generated on each window between A and B exclusive (in that order)

<F9>w<Tab><F6>:focus<#1e>in<F0> with <F2>kind<F0> <F6>:inferior<F0> 
is generated on B

<F9>w<Tab><F0>If P is an inferior of B, but P is not A or an inferior 
of A or an ancestor of A, <F6>:focus<#1e>in<F0> with <F2>kind<F0> <F6>:poi
nter<F0> is generated on each window below B down to and including 
P (in order)

<indentB>

When the focus moves from window A to window B, and B is an inferior 
of A, with the pointer in window P:

<ssbullet>

<F9>w<Tab><F0>If P is an inferior of A, but P is not A or an inferior 
of B or an ancestor of B, <F6>:focus<#1e>out <F0>with <F2>kind<F0> <F6>:po
inter<F0> is generated on each window from P up to but not including 
A (in order)

<F9>w<Tab><F6>:focus<#1e>out<F0> with <F2>kind<F0> <F6>:inferior<F0> 
is generated on A

<F9>w<Tab><F6>:focus<#1e>in<F0> with <F2>kind<F0> <F6>:virtual <F0>is 
generated on each window between A and B exclusive (in that order)

<F9>w<Tab><F6>:focus<#1e>in<F0> with <F2>kind<F0> <F6>:ancestor<F0> 
is generated on B

<indentB,
	New Page =		yes>

<|,"12<#1e>142">When the focus moves from window A to window B, with window 
C being their least common ancestor, and with the pointer in window 
P:

<ssbullet>

<F9>w<Tab><F0>If P is an inferior of A, <F6>:focus<#1e>out<F0> 
with <F2>kind<F0> <F6>:pointer<F0> is generated on each window 
from P up to but not including A (in order)

<F9>w<Tab><F6>:focus<#1e>out<F0> with <F2>kind<F0> <F6>:nonlinear<F0> 
is generated on A

<F9>w<Tab><F6>:focus<#1e>out <F0>with <F2>kind<F0> <F6>:nonlinear<#1e>vir
tual<F0> is generated on each window between A and C exclusive (in 
that order)

<F9>w<Tab><F6>:focus<#1e>in<F0> with <F2>kind<F0> <F6>:nonlinear<#1e>virt
ual<F0> is generated on each window between C and B exclusive (in 
that order)

<F9>w<Tab><F0>:focus<#1e>in with <F2>kind<F0> <F6>:nonlinear<F0> 
is generated on B

<F9>w<Tab><F0>If P is an inferior of B, <F6>:focus<#1e>in<F0> 
with <F2>kind<F0> <F6>:pointer<F0> is generated on each window 
below B down to and including P (in order)

<indentB>

When the focus moves from window A to window B, on different screens, 
with the pointer in window P:

<ssbullet>

<F9>w<Tab><F0>If P is an inferior of A, <F6>:focus<#1e>out<F0> 
with <F2>kind<F0> <F6>:pointer<F0> is generated on each window 
from P up to but not including A (in order)

<F9>w<Tab><F6>:focus<#1e>out<F0> with <F2>kind<F0> <F6>:nonlinear<F0> 
is generated on A

<F9>w<Tab><F0>If A is not a root window, <F6>:focus<#1e>out<F0> 
with <F2>kind<F0> <F6>:nonlinear<#1e>virtual <F0>is generated 
on each window above A up to and including its root (in order)

<F9>w<Tab><F0>If B is not a root window, <F6>:focus<#1e>in <F0>with <F2>ki
nd<F0> <F6>:nonlinear<#1e>virtual<F0> is generated on each window 
from B's root down to but not including B (in order)

<F9>w<Tab><F6>:focus<#1e>in<F0> with <F2>kind<F0> <F6>:nonlinear<F0> 
is generated on B

<F9>w<Tab><F0>If P is an inferior of B, <F6>:focus<#1e>in<F0> 
with <F2>kind<F0> <F6>:pointer<F0> is generated on each window 
below B down to and including P (in order)

<indentB>

When the focus moves from window A to <F6>:pointer<#1e>root<F0> 
(or <F6>:none<F0>), with the pointer in window P: 

<ssbullet>

<F9>w<Tab><F0>If P is an inferior of A, <F6>:focus<#1e>out<F0> 
with <F2>kind<F0> <F6>:pointer<F0> is generated on each window 
from P up to but not including A (in order)

<F9>w<Tab><F6>:focus<#1e>out<F0> with <F2>kind<F0> <F6>:nonlinear<F0> 
is generated on A

<F9>w<Tab><F0>If A is not a root window, <F6>:focus<#1e>out<F0> 
with <F2>kind<F0> <F6>:nonlinear<#1e>virtual <F0>is generated 
on each window above A up to and including its root (in order)

<F9>w<Tab><F6>:focus<#1e>in<F0> with <F2>kind<F0> <F6>:pointer<#1e>root 
<F0>(or <F6>:none<F0>) is generated on all root windows

<F9>w<Tab><F0>If the new focus is <F6>:pointer<#1e>root<F0>, <F6>:focus<#1e>
in<F0> with <F2>kind<F0> <F6>:pointer<F0> is generated on each 
window from P's root down to and including P (in order)

<indentB>

<|,"12<#1e>143">When the focus moves from <F6>:pointer<#1e>root <F0>(or <F6>:none
<F0>) to window A, with the pointer in window P:

<ssbullet>

<F9>w<Tab><F0>If the old focus is <F6>:pointer<#1e>root<F0>, <F6>:focus<#1e>
out<F0> with <F2>kind<F0> <F6>:pointer<F0> is generated on each 
window from P up to and including P's root (in order) 

<F9>w<Tab><F6>:focus<#1e>out<F0> with <F2>kind<F6> :pointer<#1e>root<F0> 
(or <F6>:none<F0>) is generated on all root windows

<F9>w<Tab><F0>If A is not a root window, <F6>:focus<#1e>in<F0> 
with <F2>kind<F0> <F6>:nonlinear<#1e>virtual<F0> is generated 
on each window from A's root down to but not including A (in order)

<F9>w<Tab><F6>:focus<#1e>in<F0> with <F2>kind<F0> <F6>:nonlinear<F0> 
is generated on A

<F9>w<Tab><F0>If P is an inferior of A, <F6>:focus<#1e>in<F0> 
with <F2>kind<F0> <F6>:pointer<F0> is generated on each window 
below A down to and including P (in order)

<indentB>

When the focus moves from <F6>:pointer<#1e>root <F0>to <F6>:none<F0> 
(or vice versa), with the pointer in window P:

<ssbullet>

<F9>w<Tab><F0>If the old focus is <F6>:pointer<#1e>root<F0>, <F6>:focus<#1e>
out<F0> with <F2>kind<F0> <F6>:pointer<F0> is generated on each 
window from P up to and including P's root (in order)

<F9>w<Tab><F6>:focus<#1e>out<F0> with <F2>kind<F0> <F6>:pointer<#1e>root
<F0> (or <F6>:none<F0>) is generated on all root windows

<F9>w<Tab><F6>:focus<#1e>in<F0> with <F2>kind<F0> <F6>:none<F0> 
(or <F6>:pointer<#1e>root<F0>) is generated on all root windows

<F9>w<Tab><F0>If the new focus is <F6>:pointer<#1e>root<F0>, <F6>:focus<#1e>
in <F0>with <F2>kind<F0> <F6>:pointer<F0> is generated on each 
window from P's root down to and including P (in order)

<indentB>

When a keyboard grab activates (but before generating any actual <F6>:key<#1e>
press<F0> event that activates the grab), with <F2>G<F0> the <F6>grab<#1e>w
indow<F0> for the grab and <F2>F<F0> the current focus, then <F6>:focus<#1e>
in<F0> and <F6>:focus<#1e>out <F0>events with mode <F6>:grab<F0> 
are generated (as for <F6>:normal<F0> above) as if the focus were 
to change from <F2>F<F0> to <F2>G<F0>.

When a keyboard grab deactivates (but after generating any actual <F6>:key<#1e>
release<F0> event that deactivates the grab), with <F2>G<F0> the <F6>grab<#1e>
window<F0> for the grab and <F2>F<F0> the current focus, then <F6>:focus<#1e>
in<F0> and <F6>:focus<#1e>out<F0> events with mode <F6>:ungrab<F0> 
are generated (as for <F6>:normal <F0>above) as if the focus were 
to change from <F2>G<F0> to <F2>F<F0>.

<p2rule,
	New Page =		yes>

<|,"12<#1e>144"><Index, "pointer", "state event", To Named = p2rule><Index, "keyboard", "state event", To Named = p2rule><Index, "event", "pointer", "state", To Named = p2rule><Index, "event", "keyboard", "state", To Named = p2rule>
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Tab><F6>Keyboard and<Tab>12.12.3<#04><F0>The keyboard and pointer 
state events are <F6>:keymap<#1e>notify<F0> and<FJ>

<p2stacked>

<Tab>Pointer State<F3><Tab><F0>:mapping<#1e>notify.

<p2para>

<Tab>Events<Tab>

<syntax0>

<Index, "event", ":keymap<#1e>notify", Sort String = "keymap<#1e>notify"><Index, ":keymap<#1e>notify event", Sort String = "keymap<#1e>notify event">:keymap<#1e>notify<Tab><F3>Event 
Type

<return>

<Tab><F3> <F0><HR>
<F2>Selected by:<F3> <#1f><F0> <F3>:<F0>keymap<#1e>state<F3>.

<para>

The <F6>:keymap<#1e>notify<F0> event returns the current state of 
the keyboard. <F6>:keymap<#1e>notify<F0> is generated immediately 
after every <F6>:enter<#1e>notify<F0> and <F6>:focus<#1e>in<F0>.

<indentA>

<F2>window, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving an <F6>:enter<#1e>notify<F0> or <F6>:focus<#1e>in<F0> 
event.

<indentA>

<F2>keymap<F6> <F0><#1f> Type (<F6>bit<#1e>vector 256<F0>).

<indentB>

A bit<#1e>vector containing the logical state of the keyboard. Each 
bit set to 1 indicates that the corresponding key is currently pressed. 
The vector is represented as 32 bytes. For <F2>n<F0> from 0 to 7, 
byte <F2>n<F0> (from 0) contains the bits for keys 8<F2>n<F0> 
to 8<F2>n<F0>+7, with the least significant bit in the byte representing 
key 8<F2>n<F0>.

<syntax>

<Index, "event", ":mapping<#1e>notify", Sort String = "mapping<#1e>notify"><Index, ":mapping<#1e>notify event", Sort String = "mapping notify event">:mapping<#1e>notify<Tab><F3>Event 
Type

<para>

The X server reports <F6>:mapping<#1e>notify<F0> events to all clients. 
There is no mechanism to express disinterest in this event. The X 
server generates this event type whenever a client application calls 
one of the following:

<bullet>

<F9>w<Tab><F6>set<#1e>modifier<#1e>mapping<F0> to indicate which 
keycodes to use as modifiers (the status reply must be <F6>:mapping<#1e>succes
s<F0>)

<F9>w<Tab><F6>change<#1e>keyboard<#1e>mapping<F0> to change the 
keyboard mapping 

<F9>w<Tab><F0>s<F6>et<#1e>pointer<#1e>mapping<F0> to set the pointer 
mapping (the status reply must be <F6>:mapping<#1e>success<F0>)

<indentA>

<F2>request<F0> <#1f><F6> <F0>Type (<F6>member :modifier :keyboard 
:pointer<F0>).

<indentB>

Indicates the kind of change that occurred<#1f><F6>:modifier<F0> 
for a successful <F6>set<#1e>modifier<#1e>mapping<F0>, <F6>:keyboard<F0> 
for a successful <F6>change<#1e>keyboard<#1e>mapping<F0>, and <F6>:pointer
<F0> for a successful <F6>set<#1e>pointer<#1e>mapping<F0>.

<indentA>

<F2>start <F0><#1f> Type <F6>card8<F0>.

<indentB>

If request is<F6> :keyboard<F0>, then <F2>start<F0> and <F2>count<F0> 
indicate the range of altered keycodes.

<indentA>

<F2>count<F6> <F0><#1f> Type <F6>card8<F0>.

<indentB>

If request is <F6>:keyboard<F0>, then <F2>start<F0> and <F2>count<F0> 
indicate the range of altered keycodes.

<p2rule,
	New Page =		yes>

<|,"12<#1e>145"><Index, "exposure events", To Named = p2rule><Index, "event", "exposure", To Named = p2rule>
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break Within = yes,
	Allow Page Break After = yes,
	TOC Doc Name =		>

<Tab><F6>Exposure Events<Tab>12.12.4<F0><#04>The X server cannot 
guarantee that a window's content is preserved when the window is 
obscured or reconfigured. X requires client applications to be capable 
of restoring the contents of a previously<#1e>invisible window region 
whenever it is exposed. Therefore, the X server sends events describing 
the exposed window and its exposed region. For a simple window, a 
client can choose to redraw the entire content whenever any region 
is exposed. For a complex window, a client can redraw only the exposed 
region.

<syntax0>

<Index, "event", ":exposure", Sort String = exposure><Index, ":exposure event", Sort String = "exposure event">:exposure<Tab><Tab><F3>Event 
Type

<return>

<Tab><F3> <F2><HR>
Selected by:<F0> <F3><#1f><F0> :exposure<F3>.

<para>

An <F6>:exposure<F0> event is sent when redisplay is needed for 
a window region whose content has been lost. Redisplay is needed when 
one of the following occurs:

<bullet>

<F9>w<Tab><F0>A region is exposed for a window and the X server 
has no backing store for the region

<F9>w<Tab><F0>A region of a viewable window is obscured and the 
X server begins to honor the window's backing<#1e>store attribute 
of <F6>:always<F0> or <F6>:when<#1e>mapped

<F9>w<Tab><F0>The X server begins to honor an unviewable window's 
backing<#1e>store attribute of <F6>:always<F0> or :<F6>when<#1e>mapped<F0>.

<para>

The regions needing redisplay are decomposed into an arbitrary set 
of rectangles, and an <F6>:exposure<F0> event is generated for each 
rectangle. For a given action causing <F6>:exposure<F0> events, 
the set of events for a given window are guaranteed to be reported 
contiguously.

<F6>:exposure<F0> events are never generated for <F6>:input<#1e>only<F0> 
windows.

All <F6>:exposure<F0> events caused by a hierarchy change are generated 
after any hierarchy event (<F6>:unmap<#1e>notify<F0>, <F6>:map<#1e>notify
<F0>, <F6>:configure<#1e>notify<F0>,<F6>:gravity<#1e>notify<F0>, 
or <F6>:circulate<#1e>notify<F0>) caused by that change. All <F6>:exposure
<F0> events on a given window are generated after any <F6>:visibility<#1e>not
ify<F0> event on that window, but it is not required that all <F6>:exposure
<F0> events on all windows be generated after all visibility events 
on all windows. The ordering of :<F6>exposure<F0> events with respect 
to <F6>:focus<#1e>out<F0>, <F6>:enter<#1e>notify<F0>, and <F6>:leave<#1e>n
otify<F0> events is not constrained.

<indentA>

<F2>window, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window needing redisplay.

<indentA>

<F2>x <F0><#1f> Type <F6>card16<F0>.

<indentB>

The position of the left edge of the region to redisplay, relative 
to the <F2>event<#1e>window<F0>.

<indentA>

<F2>y <F0><#1f><F6> <F0>Type <F6>card16<F0>.

<indentB>

The position of the top edge of the region to redisplay, relative 
to the <F2>event<#1e>window<F0>.

<indentA>

<F2>width<F0> <#1f> Type <F6>card16<F0>.

<indentB>

The width of the region to redisplay.

<indentA,
	New Page =		yes>

<|,"12<#1e>146"><F2>height<F0> <#1f> Type <F6>card16<F0>.

<indentB>

The height of the region to redisplay.

<indentA>

<F2>count<F0> <#1f><F6> <F0>Type <F6>card16<F0>.

<indentB>

If count is zero, then no more <F6>:exposure<F0> events for this 
window follow. If count is nonzero, then at least that many more <F6>:exposure
<F0> events for this window follow (and possibly more).

<syntax>

<Index, "event", ":graphics<#1e>exposure", Sort String = "graphics<#1e>exposure"><Index, ":graphics<#1e>exposure event", Sort String = "graphics<#1e>exposure event">:graphics<#1e>exposure<Tab><F3>Event 
Type

<para>

A <F6>:graphics<#1e>exposure<F0> event is generated by a call to <F6>copy<#1e>
area<F0> or <F6>copy<#1e>plane<F0> when the exposures attribute 
of the graphics context is <F6>:on<F0>. A <F6>:graphics<#1e>exposure<F0> 
event reports a destination region whose content cannot be computed 
because the content of the corresponding source region has been lost. 
For example, the missing source region may be obscured or may lie 
outside the current source drawable size. For a given action causing <F6>:grap
hics<#1e>exposure<F0> events, the set of events for a given destination 
are guaranteed to be reported contiguously.

<indentA>

<F2>drawable, event<#1e>window<F6> <F0><#1f> Type <F6>drawable<F0>.

<indentB>

The destination drawable for the <F6>copy<#1e>area<F0> or <F6>copy<#1e>plane
<F0> function.

<indentA>

<F2>x<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

The position of the left edge of the destination region, relative 
to the <F2>drawable<F0>.

<indentA>

<F2>y<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

The position of the top edge of the destination region, relative to 
the <F2>drawable<F0>.

<indentA>

<F2>width<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

The width of the destination region.

<indentA>

<F2>height<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

The height of the destination region.

<indentA>

<F2>count<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

If count is zero then no more <F6>:graphics<#1e>exposure<F0> events 
for the <F2>drawable<F0> follow. If count is nonzero then at least 
that many more <F6>:graphics<#1e>exposure<F0> events for the <F2>drawable
<F0> follow (and possibly more).

<indentA>

<F2>major<F0> <#1f> Type <F6>card8<F0>.

<indentB>

The major opcode for the graphics request generating the event<FJ>
(62 for <F6>copy<#1e>area<F0>, 63 for <F6>copy<#1e>plane<F0>).

<indentA>

<F2>minor<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

The minor opcode for the graphics request generating the event<FJ>
(0 for both <F6>copy<#1e>area<F0> and <F6>copy<#1e>plane<F0>).

<syntax>

<Index, "event", ":no<#1e>exposure", Sort String = "no<#1e>exposure"><Index, ":no<#1e>exposure event", Sort String = "no<#1e>exposure event">:no<#1e>exposure<Tab><Tab><F3>Event 
Type

<para,
	Bottom Margin =		0.12 inches>

A <F6>:no<#1e>exposure<F0> event is generated by a call to <F6>copy<#1e>area
<F0> or <F6>copy<#1e>plane<F0> when the exposures attribute of 
the graphics context is <F6>:on<F0>. If no <F6>:graphics<#1e>exposure<F0> 
events are generated, then a single <F6>:no<#1e>exposure<F0> event 
is sent.

<indentA>

<F2>drawable, event<#1e>window<F6> <F0><#1f> Type <F6>drawable<F0>.

<indentB>

<|,"12<#1e>147">The destination drawable for the <F6>copy<#1e>area<F0> or <F6>copy<#1e>
plane<F0> function.

<indentA>

<F2>major<F0> <#1f> Type <F6>card8<F0>.

<indentB>

The major opcode for the graphics request generating the event<FJ>
(62 for <F6>copy<#1e>area<F0>, 63 for <F6>copy<#1e>plane<F0>).

<indentA>

<F2>minor<F0> <#1f> Type <F6>card16<F0>.

<indentB>

The minor opcode for the graphics request generating the event<FJ>
(0 for both <F6>copy<#1e>area<F0> and <F6>copy<#1e>plane<F0>).

<p2rule>

<Index, "window", "state events", To Named = p2rule><Index, "event", "window state", To Named = p2rule>
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Tab><F6>Window State<Tab>12.12.5<F0><#04>The following paragraphs 
describe the events that can be received

<p2para,
	Bottom Margin =		0.12 inches,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break Within = yes,
	Allow Page Break After = yes,
	TOC Doc Name =		>

<Tab><F6>Events<Tab><F0>when a window becomes:

<bullet,
	Bottom Margin =		0.12 inches>

<F9>w<Tab><F0>Created

<F9>w<Tab><F0>Destroyed

<F9>w<Tab><F0>Invisible

<F9>w<Tab><F0>Mapped

<F9>w<Tab><F0>Moved

<F9>w<Tab><F0>Reparented

<F9>w<Tab><F0>Resized

<F9>w<Tab><F0>Restacked 

<F9>w<Tab><F0>Unmapped

<F9>w<Tab><F0>Visible

<syntax0>

<Index, "event", ":circulate<#1e>notify", Sort String = "circulate<#1e>notify"><Index, ":circulate<#1e>notify event", Sort String = "circulate<#1e>notify event">:circulate<#1e>notify<Tab><F3>Event 
Type

<return,
	Left Tab =		-0.90/0.97/7.50 inches>

<Tab><F3> <F2><HR>
Selected by: <F3><#1f> <F0>:structure<#1e>notify <F3>on a window 
or<F0> :substructure<#1e>notify<HR>
<Tab><F3>on its parent.

<para,
	Bottom Margin =		0.12 inches>

A <F6>:circulate<#1e>notify<F0> event is generated whenever a window 
is actually restacked as a result of a client application calling <F6>circulat
e<#1e>window<#1e>up<F0> or <F6>circulate<#1e>window<#1e>down<F0>.

<indentA>

<F2>event<#1e>window <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window that was restacked.

<indentA>

<F2>place <F0><#1f> Type (<F6>member :top :bottom<F0>).

<indentB>

If place is <F6>:top<F0>, the <F2>window<F0> is now on top of 
all siblings. Otherwise, it is below all siblings.

<syntax0,
	New Page =		yes>

<|,"12<#1e>148"><Index, "event", ":configure<#1e>notify", Sort String = "configure<#1e>notify"><Index, ":configure<#1e>notify event", Sort String = "configure<#1e>notify event">:configure<#1e>notify<Tab><F3>Ev
ent Type

<return,
	Left Tab =		-0.90/0.97/7.50 inches>

<Tab><F3> <F2><HR>
Selected by: <F3><#1f><F2> <F0>:structure<#1e>notify <F3>on a 
window<F0> <F3>or<F0> :substructure<#1e>notify<HR>
<Tab><F3>on its parent.

<para>

The <F6>:configure<#1e>notify<F0> event is generated when the position 
or size of a window actually changes as a result of a client application 
setting its <F2>x<F0>, <F2>y<F0>, <F2>width<F0>, <F2>height<F0>, 
or <F2>border<#1e>width<F0> attributes. 

<indentA>

<F2>event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window that was moved or resized.

<indentA>

<F2>x<F0> <#1f> Type <F6>int16<F0>.

<indentB>

<F2>x<F0> and <F2>y<F0> specify the new upper<#1e>left corner 
position of the <F2>window<F0> relative to its parent.

<indentA>

<F2>y<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

<F2>x<F0> and <F2>y<F0> specify the new upper<#1e>left corner 
position of the <F2>window<F0> relative to its parent.

<indentA>

<F2>width<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

<F2>width<F0> and <F2>height<F0> specify the new size of the <F2>window
<F0> interior.

<indentA>

<F2>height<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

<F2>width<F0> and <F2>height<F0> specify the new size of the <F2>window
<F0> interior.

<indentA>

<F2>border<#1e>width<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

The new <F2>window<F0> border width.

<indentA>

<F2>above<#1e>sibling<F6> <F0><#1f> Type (<F6>or null window<F0>).

<indentB>

The sibling immediately below the <F2>window<F0>. If above<#1e>sibling 
is <F6>nil<F0>, then the <F2>window<F0> is below all of its siblings.

<indentA>

<F2>override<#1e>redirect<#1e>p<F6> <F0><#1f> Type <F6>boolean<F0>.

<indentB>

<F2>override<#1e>redirect<#1e>p<F0> is true if the override<#1e>redirect 
attribute of the <F2>window<F0> is <F6>:on<F0>; otherwise, it 
is <F6>nil<F0>. See <F6>window<#1e>override<#1e>redirect<F0> in 
paragraph 4.3, Window Attributes.

<para>

The X server can report <F6>:create<#1e>notify<F0> events to clients 
wanting information about creation of windows. The X server generates 
this event whenever a client application creates a window by calling <F6>creat
e<#1e>window<F0>.

To receive this event type in a client application, you <F6>setf<F0> 
the <F6>:substructure<#1e>notify<F0> as the event<#1e>mask in the 
parent window's event<#1e>mask slot.

<syntax0,
	New Page =		yes>

<|,"12<#1e>149"><Index, "event", ":create<#1e>notify", Sort String = "create<#1e>notify"><Index, ":create<#1e>notify event", Sort String = "create<#1e>notify event">:create<#1e>notify<Tab><F3><Tab>
Event Type

<return>

<Tab><F3> <F2><HR>
Selected by: <F0>:substructure<#1e>notify<F3>.<F0> 

<para>

The <F6>:create<#1e>notify<F0> event is generated when a <F2>window<F0> 
is created and is sent to the <F2>parent<F0> window.

<indentA>

<F2>parent, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The parent window receiving the event.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The new window created.

<indentA>

<F2>x<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

<F2>x<F0> and <F2>y<F0> specify the initial upper<#1e>left corner 
position of the <F2>window<F0> relative to the parent.

<indentA>

<F2>y<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

<F2>x<F0> and <F2>y<F0> specify the initial upper<#1e>left corner 
position of the <F2>window<F0> relative to the parent.

<indentA>

<F2>width<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

<F2>width<F0> and <F2>height<F0> specify the initial size of the <F2>windo
w<F0> interior.

<indentA>

<F2>height<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

<F2>width<F0> and <F2>height<F0> specify the initial size of the <F2>windo
w<F0> interior.

<indentA>

<F2>border<#1e>width<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

The initial <F2>window<F0> border width.

<indentA>

<F2>override<#1e>redirect<#1e>p<F6> <F0><#1f> Type <F6>boolean<F0>.

<indentB>

<F2>override<#1e>redirect<#1e>p<F0> is true if the override<#1e>redirect 
attribute of the <F2>window<F0> is <F6>:on<F0>; otherwise, it 
is <F6>nil<F0>. See <F6>window<#1e>override<#1e>redirect<F0> in 
paragraph 4.3, Window Attributes.

<syntax0>

<Index, "event", ":destroy<#1e>notify", Sort String = "destroy<#1e>notify"><Index, ":destroy<#1e>notify event", Sort String = "destroy<#1e>notify event">:destroy<#1e>notify<Tab><F3>Event 
Type

<return,
	Left Tab =		-0.90/0/0.93 inches,
	Right Tab =		7.50 inches>

<Tab><F3> <F2><HR>
Selected by <F3><#1f><F2> <F0>:structure<#1e>notify <F3>on a window 
or<F0> :substructure<#1e>notify<HR>
<Tab><F3>on its parent.

<para>

The <F6>:destroy<#1e>notify<F0> event is generated when a <F2>window<F0> 
is destroyed. The ordering of the <F6>:destroy<#1e>notify<F0> events 
is such that for any given window, <F6>:destroy<#1e>notify<F0> is 
generated on all inferiors of a window before <F6>:destroy<#1e>notify<F0> 
is generated on the <F2>window<F0>. The ordering among siblings 
and across subhierarchies is not otherwise constrained.

<indentA>

<F2>event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window that was destroyed.

<syntax0>

<|,"12<#1e>150"><Index, "event", ":gravity<#1e>notify", Sort String = "gravity<#1e>notify"><Index, ":gravity<#1e>notify event", Sort String = "gravity<#1e>notify event">:gravity<#1e>notify<Tab><F3>Even
t Type

<return,
	Left Tab =		-0.90/0.97 inches,
	Right Tab =		7.50 inches>

<Tab><F3> <HR>
<F2>Selected by: <F3><#1f><F2> <F0>:structure<#1e>notify <F3>on 
a window or<F0> :substructure<#1e>notify<HR>
<Tab><F3>on its parent.

<para>

The X server can report <F6>:gravity<#1e>notify<F0> events to clients 
wanting information about when a <F2>window<F0> is moved because 
of a change in the size of its parent. The X server generates this 
event whenever a client application actually moves a child window 
as a result of resizing its parent by calling <F6>with<#1e>state<F0> 
with the appropriate arguments set.

<indentA>

<F2>event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window that was moved.

<indentA>

<F2>x<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

x and y specify the new upper<#1e>left corner position of the <F2>window<F0> 
relative to its parent.

<indentA>

<F2>y<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

x and y specify the new upper<#1e>left corner position of the <F2>window<F0> 
relative to its parent.

<syntax0>

<Index, "event", ":map<#1e>notify", Sort String = "map<#1e>notify"><Index, ":map<#1e>notify event", Sort String = "map<#1e>notify event">:map<#1e>notify<Tab><Tab><F3>Event 
Type

<return,
	Left Tab =		-0.90/0.97 inches,
	Right Tab =		7.50 inches>

<Tab><F3> <F2><HR>
Selected by: <F3><#1f><F2> <F0>:structure<#1e>notify <F3>on a 
window or<F0> :substructure<#1e>notify<HR>
<Tab><F3>on its parent.

<para>

The X server can report <F6>:map<#1e>notify<F0> events to clients 
wanting information about which windows are mapped. The X server generates 
this event type whenever a client application changes the <F2>window<F0>'s 
state from unmapped to mapped by calling <F6>map<#1e>window<F0> 
or <F6>map<#1e>subwindow<F0>.

To receive this event type, you <F6>setf<F0> <F6>:structure<#1e>notify<F0> 
as the event<#1e>mask on the <F2>window<F0>'s <F6>event<#1e>mask<F0> 
slot. You can also receive this event type by <F6>setf<F0>ing the <F6>:subst
ructure<#1e>notify<F0> event<#1e>mask on the parent window.

<indentA>

<F2>event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window that was mapped.

<indentA>

<F2>override<#1e>redirect<#1e>p<F6> <F0><#1f> Type <F6>boolean<F0>.

<indentB>

<F2>override<#1e>redirect<#1e>p<F0> is true if the override<#1e>redirect 
attribute of the <F2>window<F0> is <F6>:on<F0>; otherwise, it 
is <F6>nil<F0>. See <F6>window<#1e>override<#1e>redirect<F0> in 
paragraph 4.3, Window Attributes.

<syntax0,
	New Page =		yes>

<|,"12<#1e>151"><Index, "event", ":reparent<#1e>notify", Sort String = "reparent<#1e>notify"><Index, ":reparent<#1e>notify event", Sort String = "reparent<#1e>notify event">:reparent<#1e>notify<Tab><F3>Eve
nt Type

<return,
	Left Tab =		-0.90/0.97/1.08/7.50 inches>

<Tab><F3> <HR>
<F2>Selected by: <F3><#1f><F2> <F0>:structure<#1e>notify <F3>on 
a window or<F0> :substructure<#1e>notify<HR>
  <F3><Tab>on its old or new parent.

<para>

The <F6>:reparent<#1e>notify<F0> event is generated when a <F2>window<F0> 
is reparented.

<indentA>

<F2>event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window that was reparented.

<indentA>

<F2>parent<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The new parent of the <F2>window<F0>.

<indentA>

<F2>x<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

x and y specify the upper<#1e>left corner position of the <F2>window<F0> 
relative to its new <F2>parent<F0>.

<indentA>

<F2>y<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

x and y specify the upper<#1e>left corner position of the <F2>window<F0> 
relative to its new <F2>parent<F0>.

<indentA>

<F2>override<#1e>redirect<#1e>p<F6> <F0><#1f> Type <F6>boolean<F0>.

<indentB>

<F2>override<#1e>redirect<#1e>p<F0> is true if the override<#1e>redirect 
attribute of the <F2>window<F0> is <F6>:on<F0>; otherwise, it 
is <F6>nil<F0>. See <F6>window<#1e>override<#1e>redirect<F0> in 
paragraph 4.3, Window Attributes.

<syntax0>

<Index, "event", ":unmap<#1e>notify", Sort String = "unmap<#1e>notify"><Index, ":unmap<#1e>notify event", Sort String = "unmap<#1e>notify event">:unmap<#1e>notify<Tab><F3>Event 
Type

<return,
	Left Tab =		-0.90/0/0.97/7.50 inches>

<Tab><F3> <HR>
<F2>Selected by:<F3> <#1f><F2> <F0>:structure<#1e>notify <F3>on 
a window or<F0> :substructure<#1e>notify<HR>
<Tab><F3>on its parent.

<para>

The <F6>:unmap<#1e>notify<F0> event is generated when a mapped <F2>window
<F0> is unmapped.

<indentA>

<F2>event<#1e>window <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window that was unmapped.

<indentA>

co<F2>nfigure<#1e>p <F0><#1f> Type <F6>boolean<F0>.

<indentB>

<F2>configure<#1e>p<F0> is true if the <F2>window<F0> has a win<#1e>gravity 
attribute of <F6>:unmap<F0>, and the event was generated because <F2>window
<F0>'s parent was resized.

<syntax0,
	New Page =		yes>

<|,"12<#1e>152"><Index, "event", ":visibility<#1e>notify", Sort String = "visibility<#1e>notify"><Index, ":visibility<#1e>notify event", Sort String = "visibility<#1e>notify event">:visibility<#1e>notify<Tab><F3>E
vent Type

<return>

<Tab><F3> <F2><HR>
Selected by: <F3><#1f><F2> <F0>:visibility<#1e>change<F3>.

<para>

The <F6>:visibility<#1e>notify<F0> event is sent when the visibility 
of a <F2>window<F0> changes. <F6>:visibility<#1e>notify <F0>events 
are never generated on <F6>:input<#1e>only <F0>windows. For the 
purposes of this event, the visibility of the <F2>window<F0> is 
not affected by its subwindows.

All<F6> :visibility<#1e>notify<F0> events caused by a hierarchy 
change are generated after any hierarchy event caused by that change 
(for example, <F6>:unmap<#1e>notify<F0>, <F6>:map<#1e>notify<F0>, <F6>:con
figure<#1e>notify<F0>, <F6>:gravity<#1e>notify<F0>, or <F6>:circulate<#1e>n
otify<F0>). Any <F6>:visibility<#1e>notify<F0> event on a given 
window is generated before any <F6>:exposure <F0>events on that 
window, but it is not required that all <F6>:visibility<#1e>notify <F0>events 
on all windows be generated before all <F6>:exposure<F0> events 
on all windows. The ordering of<F6> :visibility<#1e>notify<F0> events 
with respect to <F6>:focus<#1e>out<F0>, <F6>:enter<#1e>notify<F0>, 
and <F6>:leave<#1e>notify<F0> events is not constrained.

<indentA>

<F2>window, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window that changed in visibility.

<indentA>

<F2>state<F6> <F0><#1f> Type (<F6>member :unobscured :partially<#1e>obscure
d <HR>
                 :fully<#1e>obscured<F0>).

<indentB>

When the <F2>window<F0> was either unviewable or it was viewable 
and at least partially obscured, and the <F2>window<F0> changed 
to viewable and completely unobscured, then <F2>state<F0> is <F6>:unobscured
<F0>.

When the <F2>window<F0> was either unviewable or it was viewable 
and completely obscured, and the <F2>window<F0> changed to viewable 
and partially obscured, then <F2>state<F0> is <F6>:partially<#1e>obscured
<F0>.

When the <F2>window<F0> was either unviewable or it was at least 
partially visible, and the <F2>window<F0> changed to viewable and 
completely obscured, then <F2>state<F0> is <F6>:fully<#1e>obscured<F0>.

<p2rule>

<Index, "structure control events", To Named = p2rule><Index, "event", "structure control", To Named = p2rule>
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Tab><F6>Structure<Tab>12.12.6<F0><#04>The following paragraphs 
describe events used to <F2>redirect<F0> client<FJ>

<p2para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break Within = yes,
	Allow Page Break After = yes,
	TOC Doc Name =		>

<Tab><F6>Control Events<Tab><F0>requests that reconfigure, restack, 
or map a window. Structure control events are typically used only 
by window managers and not by ordinary client applications. Structure 
control events report redirected requests, allowing a window manager 
to modify the requests before they are actually performed. However, 
if the override<#1e>redirect attribute of a window is <F6>:on<F0>, 
then no requests are redirected and no structure control events are 
generated.<F6> 

<syntax>

<Index, "event", ":circulate<#1e>request", Sort String = "circulate<#1e>request"><Index, ":circulate<#1e>request event", Sort String = "circulate<#1e>request event">:circulate<#1e>request<Tab><F3>Event 
Type

<para>

The <F6>:circulate<#1e>request<F0> event is generated when a client 
application calls <F6>circulate<#1e>window<#1e>up<F0> or <F6>circulate<#1e>w
indow<#1e>down<F0> with a window that has the override<#1e>redirect 
attribute <F6>:off<F0>. The <F2>window<F0> argument specifies 
the window to be restacked, and <F2>place<F0> specifies what the 
new position in the stacking order should be (either <F6>:top<F0> 
or <F6>:bottom<F0>).

<indentA>

<F2>Selected by: <F0><#1f><F2> <F6>:substructure<#1e>redirect <F0>on 
<F2>parent<F0>.

<F2>parent, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event. The receiving client must have selected <F6>:s
ubstructure<#1e>redirect<F0> on this window.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window to be restacked.

<indentA>

<|,"12<#1e>153"><F2>place<F0> <#1f> Type <F6>(member :top :bottom)<F0>.

<indentB>

The new stacking priority requested for <F2>window<F0>.

<syntax0>

<Index, "event", ":colormap<#1e>notify", Sort String = "colormap<#1e>notify"><Index, ":colormap<#1e>notify event", Sort String = "colormap<#1e>notify event">:colormap<#1e>notify<Tab><F3>Event 
Type

<return>

<Tab><F3> <F2><HR>
Selected by: <F3><#1f> <F0>:colormap<#1e>change<F3>.

<para>

The <F6>:colormap<#1e>notify<F0> event is generated with <F2>new<#1e>p<F0> 
<F6>t<F0> when the <F2>colormap<F0> associated with a <F2>window<F0> 
is changed, installed, or uninstalled.

<indentA>

<F2>window, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>colormap<F6> <F0><#1f> Type <F6>(or null colormap)<F0>.

<indentB>

The colormap attribute of the window.

<indentA>

<F2>new<#1e>p <F0><#1f> Type <F6>boolean<F0>.

<indentB>

If <F2>new<#1e>p<F0> is true, then the <F2>window<F0>'s colormap 
attribute has changed to the given <F2>colormap<F0>. Otherwise, 
the <F2>window<F0>'s colormap attribute has not, but the <F2>colormap<F0> 
has been installed or uninstalled.

<indentA>

<F2>installed<#1e>p<F6> <F0><#1f> Type <F6>boolean<F0>.

<indentB>

If <F2>installed<#1e>p<F0> is true, then the <F2>colormap<F0> 
is currently installed.

<syntax0>

<Index, "event", ":configure<#1e>request", Sort String = "configure<#1e>request"><Index, ":configure<#1e>request event", Sort String = "configure<#1e>request event">:configure<#1e>request<Tab><F3>Event 
Type

<return>

<Tab><F3> <F2><HR>
Selected by: <F3><#1f><F2> <F0>:substructure<#1e>redirect <F3>on 
parent.

<para>

The <F6>:configure<#1e>request<F0> event is generated when a client 
program sets the <F2>x<F0>, <F2>y<F0>, <F2>width<F0>, <F2>heigh<F0>t, 
<F2>border<#1e>width<F0> or stacking priority attributes of a window 
that has the override<#1e>redirect attribute <F6>:off<F0>.

<indentA>

<F2>parent, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event. The receiving client must have selected <F6>:s
ubstructure<#1e>redirect<F0> on this window.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window to be reconfigured.

<indentA>

<F2>x <F0><#1f> Type <F6>int16<F0>.

<indentB>

<F2>x<F0> and <F2>y<F0> specify the requested upper<#1e>left corner 
position of the <F2>window<F0> relative to the parent. If either <F2>x<F0> 
or <F2>y<F0> is not specified in the value<#1e>mask, then it is 
set to the current window position.

<indentA>

<F2>y<F6> <F0><#1f> Type <F6>int16<F0>.

<indentB>

<F2>x<F0> and <F2>y<F0> specify the requested upper<#1e>left corner 
position of the <F2>window<F0> relative to the <F2>parent<F0>. 
If either <F2>x<F0> or <F2>y<F0> is not specified in the <F2>value<#1e>mas
k<F0>, then it is set to the current window position.

<indentA,
	New Page =		yes>

<|,"12<#1e>154"><F2>width, height<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

<F2>width<F0> and <F2>height<F0> specify the requested size of 
the <F2>window<F0> interior. If either <F2>width<F0> or <F2>height<F0> 
is not specified in the <F2>value<#1e>mask<F0>, then it is set to 
the current window size.

<indentA>

<F2>border<#1e>width<F6> <F0><#1f> Type <F6>card16

<indentB>

The requested <F2>window<F0> border width. If <F2>border<#1e>width<F0> 
is not specified in the <F2>value<#1e>mask<F0>, then it is set to 
the current window <F2>border<#1e>width<F0>.

<indentA>

<F2>stack<#1e>mode<F6> <F0><#1f> Type <F6>(member :above :below 
:top<#1e>if :bottom<#1e>if                                       :opposite)
<F0>.

<indentB>

<F2>stack<#1e>mode<F0> and <F2>above<#1e>sibling<F0> specify the 
requested stacking priority of the <F2>window<F0>. If <F2>stack<#1e>mode
<F0> is not specified in the <F2>value<#1e>mask<F0>, then it is 
set to <F6>:above<F0>.

<indentA>

<F2>above<#1e>sibling<F0> <#1f> Type (<F6>or null window<F0>).

<indentB>

<F2>stack<#1e>mode<F0> and <F2>above<#1e>sibling<F0> specify the 
requested stacking priority of the <F2>window<F0>. If <F2>above<#1e>sibling
<F0> is not specified in the <F2>value<#1e>mask<F0>, then it is 
set to <F6>nil<F0>.

<indentA>

<F2>value<#1e>mask <F0><#1f><F6> <F0>Type <F6>mask16<F0>.

<indentB>

Specifies the changed <F2>window<F0> attributes contained in the 
redirected client request. Each 1 bit specifies that the corresponding 
attribute was changed.

<syntax0>

<Index, "event", ":map<#1e>request", Sort String = "map<#1e>request"><Index, ":map<#1e>request event", Sort String = "map<#1e>request event">:map<#1e>request<Tab><Tab><F3>Event 
Type

<return>

<Tab><F3> <F2><HR>
Selected by: <F3><#1f><F2> <F0>:substructure<#1e>redirect <F3>on 
parent.

<para>

The <F6>:map<#1e>request<F0> event is generated when a client application 
maps a <F2>window<F0> that has the override<#1e>redirect attribute <F6>:off
<F0>.

<indentA>

<F2>parent, event<#1e>window<F0> <#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event. The receiving client must have selected <F6>:s
ubstructure<#1e>redirect<F0> on this window.

<indentA>

<F2>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window to be mapped.

<syntax0>

<Index, "event", ":resize<#1e>request", Sort String = "resize<#1e>request"><Index, ":resize<#1e>request event", Sort String = "resize<#1e>request event">:resize<#1e>request<Tab><F3>Event 
Type

<return>

<Tab><F3> <HR>
<F2>Selected by: <F3><#1f><F0> :resize<#1e>redirect<F3>.

<para>

The <F6>:resize<#1e>request<F0> event is generated when a client 
program sets the <F2>width<F0> or <F2>height<F0> attributes of 
a <F2>window<F0> that has the override<#1e>redirect attribute <F6>:off<F0>.

<indentA>

wi<F2>ndow, event<#1e>window <F0><#1f> Type <F6>window<F0>.

<indentB>

The window to be resized.

<indentA>

<F2>width, height<F6> <F0><#1f> Type <F6>card16<F0>.

<indentB>

<F2>width<F0> and <F2>height<F0> specify the requested size of 
the wi<F2>ndow<F0> interior. If either <F2>width<F0> or <F2>height<F0> 
was unchanged in the client request, then it is set to the current 
window size.

<p2rule,
	New Page =		yes>

<|,"12<#1e>155"><Index, "client", "communications events", To Named = p2rule><Index, "event", "client communications", To Named = p2rule>
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Tab><F6>Client<Tab>12.12.7 <F0>The client communications events 
discussed in the following<FJ>

<p2stacked>

<Tab>Communications<Tab><F3>paragraphs are: <F0>:client<#1e>message<F3>, 
<F0>:property<#1e>notify<F3>, <F0>:selection<#1e>clear<F3>,<FJ>

<p2para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break Within = yes,
	Allow Page Break After = yes,
	TOC Doc Name =		>

<Tab><F6>Events<Tab>:selection<#1e>request<F0>,<F6> <F0>and <F6>:selection
<#1e>notify<F0>.

<syntax>

<Index, "event", ":client<#1e>message", Sort String = "client<#1e>message"><Index, ":client<#1e>message event", Sort String = "client<#1e>message event">:client<#1e>message<Tab><F3>Event 
Type

<para>

The <F6>:client<#1e>message <F0>event is generated exclusively by 
client calls to <F6>send<#1e>event<F0>. The X server places no interpretation 
on the <F2>type<F0> or content of <F2>data<F0> sent in a <F6>:client<#1e>m
essage<F0>. A client can neither select <F6>:client<#1e>message <F0>events 
nor avoid receiving them.

<indentA>

<F2>window, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>type<F6> <F0><#1f> Type <F6>keyword<F0>.

<indentB>

An xatom keyword that specifies the type of client message. Interpretation 
of the type is determined solely by agreement between the sending 
and receiving clients.

<indentA>

<F2>format<F0> <#1f> Type (<F6>member 8 16 32<F0>).

<indentB>

An integer that specifies whether <F2>data<F0> should be viewed 
as a sequence of 8<#1e>bit, 16<#1e>bit, or 32<#1e>bit quantities.

<indentA>

<F2>data<F0> <#1f> Type <F6>(sequence integer)<F0>.

<indentB>

The data content of the client message. <F2>data<F0> always consists 
of 160 bytes <#1f> depending on format, either 20 8<#1e>bit values, 
10 16<#1e>bit values or 5 32<#1e>bit values. The amount of this data 
actually used by a particular client message depends on the type.

<syntax0>

<Index, "event", ":property<#1e>notify", Sort String = "property<#1e>notify"><Index, ":property<#1e>notify event", Sort String = "property<#1e>notify event">:property<#1e>notify<Tab><F3>Event 
Type

<return>

<Tab><F3> <HR>
<F2>Selected by: <F3><#1f><F2> <F0>:property<#1e>change<F3>.<F0> 

<para>

The <F6>:property<#1e>notify<F0> event is generated when a window 
property is changed or deleted.

<indentA>

<F2>window, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window receiving the event.

<indentA>

<F2>atom<F0> <#1f> Type <F6>keyword<F0>.

<indentB>

The property that was changed or deleted.

<indentA>

<F2>state<F6> <F0><#1f> Type <F6>(member :new<#1e>value :deleted)<F0>.

<indentB>

<F2>state<F0> is <F6>:new<#1e>value<F0> if the property was changed 
using <F6>change<#1e>property<F0> or <F6>rotate<#1e>properties<F0>, 
even if zero<#1e>length data was added or if all or part of the property 
was replaced with identical data. <F2>state<F0> is <F6>:deleted <F0>if 
the property was deleted using <F6>delete<#1e>property<F0> or <F6>get<#1e>pr
operty<F0>.

<indentA>

<F2>time<F0> <#1f> Type <F6>timestamp<F0>.

<indentB>

The server time when the property was changed or deleted.

<syntax>

<Index, "event", ":selection<#1e>clear", Sort String = "selection<#1e>clear"><Index, ":selection<#1e>clear event", Sort String = "selection<#1e>clear event">:selection<#1e>clear<Tab><F3>Event 
Type

<para>

The <F6>:selection<#1e>clear<F0> event is reported to the previous 
owner of a <F2>selection<F0> when the owner of the <F2>selection<F0> 
is changed. The selection owner is changed by a client using <F6>setf<F0>. 
A client can neither select <F6>:selection<#1e>clear<F0> events 
nor avoid receiving them.

<indentA>

<|,"12<#1e>156"><F2>window, event<#1e>window<F0> <#1f> Type <F6>window<F0>.

<indentB>

The window losing ownership of the <F2>selection<F0>.

<indentA>

<F2>selection<F6> <F0><#1f> Type <F6>keyword<F0>.

<indentB>

The name of the selection.

<indentA>

<F2>time<F6> <F0><#1f> Type <F6>timestamp<F0>.

<indentB>

The last<#1e>change time recorded for the <F2>selection<F0>.

<syntax>

<Index, "event", ":selection<#1e>notify", Sort String = "selection<#1e>notify"><Index, ":selection<#1e>notify event", Sort String = "selection<#1e>notify event">:selection<#1e>notify<Tab><F3>Event 
Type

<para,
	Bottom Margin =		0.10 inches>

The <F6>:selection<#1e>notify<F0> event is sent to a client calling <F6>conv
ert<#1e>selection<F0>. <F6>:selection<#1e>notify<F0> reports the 
result of the client request to return the current value of a <F2>selection
<F0> into a particular form.<F6> :selection<#1e>notify<F0> is sent 
using <F6>send<#1e>event<F0> by the owner of the selection or (if 
no owner exists) by the X server. A client can neither select <F6>:selection<#1e>
notify<F0> events nor avoid receiving them.

<"note",
	Top Margin =		0.15 inches,
	Bottom Margin =		0.15 inches>

<Tab-><HR>
<F6>NOTE: <F0>Standard conventions for inter<#1e>client communication 
require the<SP>following additional steps in processing a <F6>:selection<#1e>n
otify<F0> event:

<item,
	Bottom Margin =		0.10 inches>

<Autonum, item, 1, First = Yes, Restart = Yes><Tab>The<SP>client receiving this event 
should call <F6>get<#1e>property<F0> to return the converted<SP>selection 
value.

<item,
	Bottom Margin =		0 inches>

<Autonum, item, 1><Tab>After receiving the selection value, the property 
should then<SP>be deleted (either by using the <F6>:delete<#1e>p<F0> 
argument to <F6>get<#1e>property<F0> or by<SP>calling <F6>delete<#1e>propert
y<F0>).

<endrule>

<Tab-><Tab-><Tab-><Tab->

<indentA>

<F2>window, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The requestor window given in the call to <F6>convert<#1e>selection<F0>.

<indentA>

<F2>selection<F0> <#1f> Type <F6>keyword<F0>.

<indentB>

The selection to be converted.

<indentA>

<F2>target <F0><#1f><F6> <F0>Type <F6>keyword<F0>.

<indentB>

An <F6>xatom<F0> specifying the type of the converted selection 
value. This is the same target type given in the call to <F6>convert<#1e>selec
tion<F0>.

<indentA>

<F2>property<F6> <F0><#1f> Type <F6>(or null keyword)<F0>.

<indentB>

The window property containing the converted selection. If the property 
is <F6>nil<F0>, then either the <F2>selection<F0> has no owner 
or the owner could not perform the conversion to the <F2>target<F0> 
type.

<indentA>

<F2>time<F6> <F0><#1f> Type <F6>timestamp<F0>.

<indentB>

The timestamp from the client call to <F6>convert<#1e>selection<F0>.

<syntax>

<Index, "event", ":selection<#1e>request", Sort String = "selection<#1e>request"><Index, ":selection<#1e>request event", Sort String = "selection<#1e>request event">:selection<#1e>request<Tab><F3>Event 
Type

<para,
	Bottom Margin =		0.10 inches>

The <F6>:selection<#1e>request<F0> event is reported to the owner 
of a selection when a client calls <F6>convert<#1e>selection<F0>. 
This event requests the selection owner to convert the current value 
of a <F2>selection<F0> into a specified form and to return it to 
the requestor. A client can neither select <F6>:selection<#1e>request<F0> 
events nor avoid receiving them.

The selection owner should respond to a <F6>:selection<#1e>request<F0> 
event by performing the following steps:

<item,
	Bottom Margin =		0.10 inches>

<|,"12<#1e>157"><Autonum, item, 1, Restart = Yes><Tab>Convert the current <F2>selection
<F0> value to the <F2>target<F0> type.

<item>

<Autonum, item, 1><Tab>Store the converted selection value in the <F2>property
<F0>. If <F2>property<F0> is <F6>nil<F0>, then the owner should 
choose the <F2>property<F0>.

<item,
	Bottom Margin =		0.05 inches>

<Autonum, item, 1><Tab>Call <F6>send<#1e>event<F0> to send a <F6>:selection<#1e>
notify<F0> event to the <F2>requestor<F0> containing the <F2>property<F0> 
with the converted value. If the <F2>selection<F0> could not be 
converted to the <F2>target<F0> type, then a <F6>nil<F0> <F2>property
<F0> should be sent. The <F6>:selection<F0>,<F6> :target<F0>, 
and <F6>:time<F0> arguments to <F6>send<#1e>event<F0> should be 
the same as those received in the <F6>:selection<#1e>request<F0> 
event. The event<#1e>mask argument to <F6>send<#1e>event<F0> should 
be <F6>nil<F0>; that is, the <F6>:selection<#1e>notify<F0> event 
should be sent to client that created the <F2>requestor<F0>.

<"note",
	Top Margin =		0.15 inches,
	Bottom Margin =		0.15 inches>

<Tab-><HR>
<F6>NOTE: <F0>Standard conventions for inter<#1e>client communication 
require the<SP>following additional steps in processing a <F6>:selection<#1e>r
equest<F0> event: 

<item,
	Bottom Margin =		0.10 inches>

<Autonum, item, 1, Restart = Yes><Tab>The<SP>property used to store 
the selection value must belong to the requestor. 

<Autonum, item, 1><Tab>If<SP>the property is <F6>nil<F0>, the target 
type <F6>atom<F0> should be used as the property<SP>name.

<item,
	Bottom Margin =		0 inches>

<Autonum, item, 1><Tab>If the window did not actually own the selection 
at the given time,<SP>the request should be refused, just as if it 
could not be converted to<SP>the target type.

<endrule>

<Tab-><Tab-><Tab-><Tab->

<indentA>

<F2>window, event<#1e>window<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The selection owner receiving the event.

<indentA>

<F2>requestor<F6> <F0><#1f> Type <F6>window<F0>.

<indentB>

The window requesting the converted <F2>selection<F0>.

<indentA>

<F2>selection<F6> <F0><#1f> Type <F6>keyword<F0>.

<indentB>

The selection to be converted.

<indentA>

<F2>target <F0><#1f> Type <F6>keyword<F0>.

<indentB>

An <F6>xatom<F0> specifying the type of the converted <F2>selection<F0> 
value.

<indentA>

<F2>property<F6> <F0><#1f> Type <F6>(or null keyword)<F0>.

<indentB>

A requestor window property. 

<indentA>

<F2>time <F0><#1f><F6> <F0>Type <F6>timestamp<F0>.

<indentB>

The timestamp sent in the client <F6>convert<#1e>selection<F0> request.

<p2rule>

<Index, "event", "types", "declaring">
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Tab><F6>Declaring<Tab>12.12.8<F0><#04>CLX uses the <F6>declare<#1e>event
<F0> macro to define the event slot symbols

<p2para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break Within = yes,
	Allow Page Break After = yes,
	TOC Doc Name =		>

<Tab><F6>Event Types<Tab><F0>that access the contents of X events. 
Most client applications do not need to use <F6>declare<#1e>event<F0> 
because the declarations for all core X events are already defined 
by CLX. Programmers using extensions to the X protocol can use <F6>declare<#1e>
event<F0> to allow CLX to handle new event types returned by an extended 
X server. 

<syntax>

declare<#1e>event<F2> event<#1e>codes<F0> <F3>&rest<F0> <F2>slot<#1e>decla
rations<F0><Tab><F3>Macro<Index, Doc = operations, "xlib:declare<#1e>event", Sort String = "declare<#1e>event">

<para>

Defines a mapping between event slot symbols and the data items in 
event messages received from an X server.

<|,"12<#1e>158">The <F2>event<#1e>codes<F0> argument gives the event type 
keyword for the event described. If several event types share the 
same slots, then <F2>event<#1e>codes<F0> can be a list of event 
type keywords. <F2>slot<#1e>declarations<F0> is a list containing 
an element for each event data item. The order of <F2>slot<#1e>declarations
<F0> corresponds to the order of event data items defined by the 
X protocol.

Each element of <F2>slot<#1e>declarations<F0> is a list of the form 
(<F2>type slot<#1e>name<F0>*), where <F2>type<F0> is a Common 
Lisp type specifier and <F2>slot<#1e>name<F0> is a slot name symbol. 
The effect of such a list is to declare that the next data items in 
the event have the given data <F2>type<F0> and are associated with 
the given <F2>slot<#1e>name<F0> symbols. <F2>slot<#1e>name<F0> 
can also be a list of slot name symbols; in this case, each symbol 
in the list is an alias that refers to the same event data item.

<arg>

event<#1e>codes <#1f><F3> An event type keyword or a list of event 
type keywords.

slot<#1e>declarations <#1f> <F3>A list of clauses defining event 
slot symbols.

<p1rule>

<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8>Releasing<Tab><F6>12.13<#04><F0>A client grabbing the keyboard 
or pointer can freeze the reporting of<FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Queued Events<Tab><F0>events<SP>on that device. When an input 
device is thus frozen, the server queues events<SP>until explicitly 
requested to release them by the grabbing client. CLX<SP>programs 
can use the <F6>allow<#1e>events<F0> function to release queued 
events from a frozen input device.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

allow<#1e>events<Tab><F2>display mode<F3> &optional <F2>time<F0><Tab><F3>F
unction<Index, Doc = operations, "xlib:allow<#1e>events", Sort String = "allow<#1e>events">

<para>

Releases some queued events if the client has caused a device to freeze. 
The request has no effect if the <F2>time<F0> is earlier than the 
last<#1e>grab time of the most recent active grab for the client, 
or if the <F2>time<F0> is later than the current server time. If <F2>time
<F0> is <F6>nil<F0>, the current server time is used. The effect 
of this function depends on the specified <F2>mode<F0>.

<bullet>

<F9>w<Tab><F6>:async<#1e>pointer<F0> <#1f> If the pointer is frozen 
by the client, pointer event processing continues normally. If the 
pointer is frozen twice by the client on behalf of two separate grabs, <F6>:as
ync<#1e>pointer<F0> releases events for both grab<F2>s<F0>. <F6>:async<#1e>
pointer<F0> has no effect if the pointer is not frozen by the client, 
but the pointer need not be grabbed by the client.

<F9>w<Tab><F6>:sync<#1e>pointer<F0> <#1f> If the pointer is frozen 
and actively grabbed by the client, pointer event processing continues 
normally until the next <F6>:button<#1e>press <F0>or <F6>:button<#1e>release
<F0> event is reported to the client, at which time the pointer again 
appears to freeze. However, if the reported event causes the pointer 
grab to be released, the pointer does not freeze. <F6>:sync<#1e>pointer<F0> 
has no effect if the pointer is not frozen by the client, or if the 
pointer is not grabbed by the client.

<F9>w<Tab><F6>:replay<#1e>pointer<F0> <#1f> If the pointer is actively 
grabbed by the client and is frozen as the result of an event having 
been sent to the client (either from the activation of a <F6>grab<#1e>button
<F0>, or from a previous <F6>allow<#1e>events<F0> with mode <F6>:sync<#1e>p
ointer<F0>, but not from a <F6>grab<#1e>pointer<F0>), the pointer 
grab is released and that event is completely reprocessed, but this 
time ignoring any passive grabs at or above (towards the root) the <F6>grab<#1e>
window<F0> of the grab just released. The request has no effect if 
the pointer is not grabbed by the client, or if the pointer is not 
frozen as the result of an event.

<F9>w<Tab><F6>:async<#1e>keyboard<F0> <#1f> If the keyboard is 
frozen by the client, keyboard event processing continues normally. 
If the keyboard is frozen twice by the client on behalf of two separate 
grabs, <F6>:async<#1e>keyboard<F0> releases events for both grabs. <F6>:asyn
c<#1e>keyboard<F0> has no effect if the keyboard is not frozen by 
the client, but the keyboard need not be grabbed by the client.

<|,"12<#1e>159"><F9>w<Tab><F6>:sync<#1e>keyboard<F0> <#1f> If the keyboard 
is frozen and actively grabbed by the client, keyboard event processing 
continues normally until the next <F6>:key<#1e>press<F0> or <F6>:key<#1e>rel
ease<F0> event is reported to the client, at which time the keyboard 
again appears to freeze. However if the reported event causes the 
keyboard grab to be released, the keyboard does not freeze. <F6>:sync<#1e>keyb
oard<F0> has no effect if the keyboard is not frozen by the client, 
or if the keyboard is not grabbed by the client.

<F9>w<Tab><F6>:replay<#1e>keyboard<F0> <#1f> If the keyboard is 
actively grabbed by the client and is frozen as the result of an event 
having been sent to the client (either from the activation of a grab<#1e>key, 
or from a previous <F6>allow<#1e>events<F0> with mode <F6>:sync<#1e>keyboard
<F0>, but not from a <F6>grab<#1e>keyboard<F0>), the keyboard grab 
is released and that event is completely reprocessed, but this time 
ignoring any passive grabs at or above (towards the root) the <F6>grab<#1e>win
dow<F0> of the grab just released. The request has no effect if the 
keyboard is not grabbed by the client, or if the keyboard is not frozen 
as the result of an event.

<F9>w<Tab><F6>:sync<#1e>both<F0> <#1f> If both pointer and keyboard 
are frozen by the client, event processing (for both devices) continues 
normally until the next <F6>:button<#1e>press<F0>, <F6>:button<#1e>release
<F0>, <F6>:key<#1e>press<F0>, or <F6>:key<#1e>release<F0> event 
is reported to the client for a grabbed device (button event for the 
pointer, key event for the keyboard). At this time, the devices again 
appear to freeze. If the reported event causes the grab to be released, 
the devices do not freeze. However, if the other device is still grabbed, 
then a subsequent event for it will still cause both devices to freeze. <F6>:s
ync<#1e>both<F0> has no effect unless both pointer and keyboard are 
frozen by the client. If the pointer of keyboard is frozen twice by 
the client on behalf of two separate grabs, <F6>:sync<#1e>both<F0> <F2>thaws
<F0> for both, but a subsequent freeze for <F6>:sync<#1e>both<F0> 
will only freeze each device once.

<F9>w<Tab><F6>:async<#1e>both<F0> <#1f> If the pointer and the 
keyboard are frozen by the client, event processing for both devices 
continues normally. If a device is frozen twice by the client on behalf 
of two separate grabs, <F6>:async<#1e>both<F0> <F2>thaws<F0> for 
both. <F6>:async<#1e>both<F0> has no effect unless both pointer 
and keyboard are frozen by the client.

<para>

<F6>:async<#1e>pointer<F0>, <F6>:sync<#1e>pointer<F0>, and <F6>:replay<#1e>
pointer<F0> have no effect on processing of keyboard events. <F6>:async<#1e>k
eyboard<F0>, <F6>:sync<#1e>keyboard<F0>, and <F6>:replay<#1e>keyboard<F0> 
have no effect on processing of pointer events.

It is possible for both a pointer grab and a keyboard grab to be active 
simultaneously by the same or different clients. When a device is 
frozen on behalf of either grab, no event processing is performed 
for the device. It is possible for a single device to be frozen due 
to both grabs. In this case, the freeze must be released on behalf 
of both grabs before events can again be processed.

<arg>

display <F3><#1f> A <F6>display<F3>.

mode<F3> <#1f> One of: <F6>:async<#1e>pointer<F3>,<F6> :sync<#1e>pointer
<F3>,<F6> :reply<#1e>pointer<F3>,<F6> :async<#1e>keyboard<F3>, <F6>:sync<#1e>
keyboard<F3>,<F6> :replay<#1e>keyboard<F3>,<F6> :async<#1e>both<F3>,<F6> 
:sync<#1e>both<F3>. 

time<F3> <#1f> A <F6>timestamp<F3>.

<newpage>

<|,"12<#1e>160">
