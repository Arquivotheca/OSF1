<!OPS, Version = 5.2>

<!Document,
	Print Rev Bars =	no,
	Final Output Device =	"ps",
	Default Printer =	"nearest-adps">

<!Font Definitions,
	F2 = Times 10 Italic,
	F3 = Times 10,
	F4 = Times 8 Italic,
	F5 = Times 18 Bold,
	F6 = Times 10 Bold,
	F7 = Times 12 Bold,
	F8 = Symbol_B 8,
	F9 = Courier 8>

<!Page,
	Bottom Margin =		1 inches,
	Left Margin =		1 inches,
	Right Margin =		1.15 inches,
	First Page =		Right,
	Starting Page # = 	Inherit,
	Page # Prefix =		"2<#1e>",
	Hyphenation =		on,
	Consecutive Hyphens =	2,
	Vert. Just. =		off>

<!Autonumber Stream, List, 2,
	Level 2 Suffix =	,
	Level 2 Starting Value = 0,
	Level 2 Show =		no>

<!Autonumber Stream, Outline, 3,
	Level 1 Symbol Type =	UPPER ROMAN,
	Level 2 Symbol Type =	UPPER ALPHA>

<!Autonumber Stream, figure, 2,
	Level 1 Prefix =	"Figure ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	,
	Level 2 Starting Value = 0,
	Level 2 Show =		no>

<!Autonumber Stream, figurelet, 2,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Prefix =	"Figure ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	"<#04>">

<!Autonumber Stream, invisible, 1,
	Level 1 Suffix =	,
	Level 1 Show =		no>

<!Autonumber Stream, item, 2,
	Level 2 Symbol Type =	LOWER ALPHA,
	Level 2 Trail =		yes>

<!Autonumber Stream, paralet, 4,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Suffix =	,
	Level 1 Show =		no,
	Level 2 Prefix =	.,
	Level 2 Suffix =	,
	Level 3 Prefix =	.,
	Level 3 Suffix =	,
	Level 4 Prefix =	.,
	Level 4 Suffix =	>

<!Autonumber Stream, paranum, 4,
	Level 1 Suffix =	,
	Level 1 Show =		no,
	Level 2 Prefix =	.,
	Level 2 Suffix =	,
	Level 3 Prefix =	.,
	Level 3 Suffix =	,
	Level 4 Prefix =	.,
	Level 4 Suffix =	>

<!Autonumber Stream, table, 2,
	Level 1 Prefix =	"Table ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	>

<!Autonumber Stream, tablelet, 2,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Prefix =	"Table ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	"<#04>">

<!Class, arg,
	Bottom Margin =		0.08 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F2,
	Left Tab =		-0.25/0 inches>

<!Class, bullet,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		-0.50/0 inches>

<!Class, caption,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Font =			F4>

<!Class, cardlist,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F3,
	Left Tab =		0/1.50/2.25/3.75/5.25/6 inches>

<!Class, fig,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Left,
	Font =			F5>

<!Class, keyword2,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F6,
	Left Tab =		-0.50/0 inches>

<!Class, p1para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F7,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-1.70/0 inches>

<!Class, p1rule,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches>

<!Class, p1stacked,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1 lines,
	Font =			F6,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-1.60/-0.17/0 inches>

<!Class, para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		0/0.75*13 inches>

<!Class, return,
	Bottom Margin =		0.077 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<!Class, return0,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<!Class, secno,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Left,
	Font =			F5,
	Autonumber Name =	paranum>

<!Class, secrule,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches,
	Autonumber Name =	table>

<!Class, sectitle,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Alignment =		Right,
	Font =			F5,
	Hyphenation =		off,
	New Page =		yes,
	Left Tab =		0/0.75*13 inches>

<!Class, syntax,
	Bottom Margin =		0.077 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		8 inches>

<!Class, syntax0,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		8 inches>

<!Class, "table",
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Font =			F6,
	Autonumber Name =	table>

<!Class, title,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Right,
	Font =			F5,
	TOC Doc Name =		TOC>

<!Master Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			0.41 inches,
	Height =		0.137 inches,
	Vertical Alignment =	0.03 inches,
	Diagram =
V4,
(g9,32767,0
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<!Master Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,0.006667,0.066723,6.326667,0.066611,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<First Page Header, Frame =
V4,
(g9,0,0
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,1,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Right Page Header, Frame =
V4,
(g9,1,0
 (T8,1,12,5.866667,0.293333,0.466667,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048
  ,512,102,1101,2,
<caption>

Displays

<End Text>)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Left Page Header, Frame =
V4,
(g9,1,0
 (T8,1,12,0,0.333333,0.933333,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,10
  2,1101,2,
<caption>

Displays

<End Text>)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,2,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Right Page Footer, Frame =
V4,
(g9,1,0
 (t8,1,4,6.333333,0.266667,2,17,@nntimsps10b,\240)
 (t8,2,4,0.006667,0.266667,0,17,@nntimsps8i,CLX\ Programmer's\ Reference)
 (v4,3,0,0,0.066667,6.333333,0.066554,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Left Page Footer, Frame =
V4,
(g9,1,0
 (t8,1,4,0,0.266667,0,17,@nntimsps10b,\240)
 (t8,2,4,6.333333,0.266667,2,17,@nntimsps8i,CLX\ Programmer's\ Reference)
 (v4,3,0,0.026667,0.066667,6.333333,0.066554,17,2,0)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<sectitle,
	Allow Page Break Within = no,
	Allow Page Break After = no>

<|,"2<#1e>23">
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			4.72 inches,
	Height =		0.94 inches,
	Vertical Alignment =	0.03 inches,
	Diagram =
V4,
(g9,1,0
 (T8,1,12,0.133333,0.72,4.563333,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512
  ,102,1101,3,
<title>

DISPLAYS<HR>

<End Text>)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			1.626 inches,
	Height =		0.938 inches,
	Vertical Alignment =	0 inches,
	Diagram =
V4,
(g9,1,0
 (T8,1,12,0.066667,0.276667,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,10
  2,1101,3,
<secno,
	TOC Doc Name =		TOC>

<Autonum, paranum, 1, First = Yes>

<End Text>)
 (T8,2,12,0.026667,0.733333,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,10
  2,1101,3,
<"table">

<Autonum, table, 1, First = Yes>

<End Text>)
 (T8,3,12,0.066667,0.6,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,102,110
  1,3,
<fig,
	Alignment =		Both,
	Font =			F6,
	Autonumber Name =	figure>

<Autonum, figure, 1, First = Yes>

<End Text>)
 (g9,5,0
   (p7,5,8,19
     (g9,5,0
       (g9,5,0
         (v4,5,0,0.266667,0,1.6,0,17,1,0)
         (v4,6,0,1.6,0,1.6,0.933333,17,1,0)
         (v4,7,0,1.6,0.933333,0.266667,0.933333,17,1,0)
         (v4,8,0,0.266667,0.933333,0.266667,0,17,1,0))))
   (g9,10,8
     (p7,10,1032,13
       (g9,10,0
         (g9,10,0
           (v4,10,0,1.461755,0.934813,1.461755,0.784691,17,1,0)
           (v4,11,0,1.461755,0.784691,1.124914,0.784691,17,1,0)
           (v4,12,0,1.124914,0.784691,1.461755,0.50321,17,1,0)
           (v4,13,0,1.461755,0.50321,1.461755,0.259256,17,1,0)
           (v4,14,0,1.461755,0.259256,1.327019,0.146667,17,1,0)
           (v4,15,0,1.327019,0.146667,1.012632,0.146667,17,1,0)
           (v4,16,0,1.012632,0.146667,0.877895,0.259256,17,1,0)
           (v4,17,0,0.877895,0.259256,0.877895,0.371848,17,1,0)
           (v4,18,0,0.877895,0.371848,1.08,0.371848,17,1,0)
           (v4,19,0,1.08,0.371848,1.08,0.296789,17,1,0)
           (v4,20,0,1.08,0.296789,1.25965,0.296789,17,1,0)
           (v4,21,0,1.25965,0.296789,1.25965,0.465676,17,1,0)
           (v4,22,0,1.25965,0.465676,0.877895,0.784691,17,1,0)
           (v4,23,0,0.877895,0.784691,0.877895,0.934813,17,1,0)
           (v4,24,0,0.877895,0.934813,1.461755,0.934813,17,1,0))))
     (g9,25,2048
       (v4,25,33,0.85544,1.159997,0.85544,1.159997,17,0,0)
       (v4,26,33,0.85544,0.146667,0.85544,0.146667,17,0,0)
       (v4,27,33,1.506667,0.146667,1.506667,0.146667,17,0,0)
       (v4,28,33,1.506667,1.159997,1.506667,1.159997,17,0,0))))
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<secrule,
	Allow Page Break Within = no,
	Allow Page Break After = yes,
	Autonumber Name =	>

<Index, "display", To Named = sectitle>
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,0.006667,0.066723,6.333333,0.066611,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F7>Introduction<Tab><F6>2.1<F0><#04>A particular X server, together 
with its screens and input devices, is called a <F2>display<F0>. 
The CLX <F6>display<F0> object contains all the information about 
the particular display and its screens, as well as the state that 
is needed to communicate with the display over a particular connection.<F6><#04>

<para>

Before your program can use a display, you must establish a connection 
to the X server driving your display. Once you have established a 
connection, you then can use the CLX macros and functions discussed 
in this section to return information about the display. This section 
discusses how to: 

<bullet>

<F8>w<Tab><F0>Open (connect) a display 

<F8>w<Tab><F0>Obtain information about a display 

<F8>w<Tab><F0>Access and change display attributes 

<F8>w<Tab><F0>Close (disconnect) a display 

<p1rule>

<Index, "display", "opening", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F7>Opening the<Tab><F6>2.2<F0><#04>The <F6>open<#1e>display<F0> 
function is used to open a connection to an X server.

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F7>Display<Tab><F0> 

<syntax0>

open<#1e>display <F2>host &<F3>key <F0>:display<F3> <F0>:protocol<Tab>
<F3>Function<Index, Doc = operations, "xlib:open<#1e>display", Sort String = "open<#1e>display">

<return>

<Tab><F3>Returns: <F2><HR>
  display <F3><#1f> Type <F0>display<F3>. 

<para>

Returns a <F6>display<F0> that serves as the connection to the X 
server and contains all the information about that X server. 

<arg>

host <#1f> <F3>Specifies the name of the <F0>host<F3> machine on 
which the server executes. A string must be acceptable as a <F0>host<F3>, 
but otherwise the possible types are not constrained and will likely 
be very system dependent. 

<keyword2>

:display<F3> <#1f> An integer that specifies which display device 
on the <F2>host<F3> should be used for this connection. This is 
needed since multiple displays can be controlled by a single X server. 
The default is display 0 (zero). 

:protocol <F3><#1f><F0> <F3>A keyword argument that specifies which 
network protocol should be used for connecting to the server (for 
example, <F0>:tcp<F3>, <F0>:dna<F3>, or <F0>:chaos<F3>). The 
set of possible values and the default value are implementation specific. 

<para>

Authorization, if any, is assumed to come from the environment. After 
a successful call to <F6>open<#1e>display<F0>, all screens on the 
display can be used by the client application. 

<p1rule,
	New Page =		yes>

<|,"2<#1e>24"><Index, "display", "attributes", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F7>Display <Tab><F6>2.3<F0><#04>The complete set of display attributes 
is discussed in the following<F6><FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F7>Attributes<Tab><F0>paragraphs.

<syntax0>

display<#1e>authorization<#1e>data<F3> <F2>display<F0><Tab><F3>Function
<F0><Index, "authorization", "data of display"><Index, "display", "authorization", "data"><Index, Doc = operations, "xlib:display<#1e>authorization<#1e>data", Sort String = "display<#1e>authorization<#1e>data">

<return>

<Tab><F3>Returns: <F2><HR>
  authorization<#1e>data <F3><#1f> Type <F0>string<F3>. 

<para>

Returns the authorization data string for <F2>display<F0> that was 
transmitted to the server by <F6>open<#1e>display<F0> during connection 
setup. The data is specific to the particular authorization protocol 
that was used. The <F6>display<#1e>authorization<#1e>name<F0> function 
returns the protocol used. 

<arg>

display <#1f> <F3>A <F6>display<F3> object.

<syntax0>

display<#1e>authorization<#1e>name<F3> <F2>display<F0><Tab><F3>Function
<F0><Index, "authorization", "name of display"><Index, "display", "authorization", "name"><Index, Doc = operations, "xlib:display<#1e>authorization<#1e>name", Sort String = "display<#1e>authorization<#1e>name">

<return>

<Tab><F3>Returns: <F2><HR>
  authorization<#1e>name <F3><#1f> Type <F0>string<F3>. 

<para>

Returns the authorization protocol namestring for <F2>display<F0> 
that was transmitted by <F6>open<#1e>display<F0> to the server during 
connection setup. The <F2>authorization<#1e>name<F0> indicates what 
authorization protocol the client expects the server to use. Specification 
of valid authorization mechanisms is not part of the X protocol. A 
server that implements a different protocol than the client expects, 
or a server that only implements the host<#1e>based mechanism, can 
simply ignore this information. If both name and data strings are 
empty, this is to be interpreted as <#7f>no explicit authorization."

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>bitmap<#1e>format<F9> <F2>display<F0><Tab><F3>Function<F0><Index, "bitmap", "format of display"><Index, "display", "bitmap format"><Index, Doc = operations, "xlib:display<#1e>bitmap<#1e>format", Sort String = "display<#1e>bitmap<#1e>format">

<return>

<Tab><F3>Returns: <F2><HR>
  bitmap<#1e>format <F3><#1f> Type <F0>bitmap<#1e>format<F3>. 

<para>

Returns the <F2>bitmap<#1e>format<F0> information for the specified <F2>disp
lay<F0>.

<arg>

display <#1f> <F3>A <F6>display<F3> object.

<syntax0>

display<#1e>byte<#1e>order<F3> <F2>display<F0><Tab><F3>Function<F0><Index, "byte order of display"><Index, "display", "byte order"><Index, Doc = operations, "xlib:display<#1e>byte<#1e>order", Sort String = "display<#1e>byte<#1e>order">

<return>

<Tab><F3>Returns: <F2><HR>
  byte<#1e>order <F3><#1f> Either <F0>:lsbfirst<F3> or <F0>:msbfirst<F3>. 

<para>

Returns the <F2>byte<#1e>order<F0> to be employed in communication 
with the server for the given <F2>display<F0>. The possible values 
are as follows: 

<bullet>

<F8>w<Tab><F6>:lsbfirst<F0> <#1f> Values are transmitted least 
significant byte first.

<F8>w<Tab><F6>:msbfirst<F0> <#1f> Values are transmitted most significant 
byte first.

<para>

Except where explicitly noted in the protocol, all 16<#1e>bit and 
32<#1e>bit quantities sent by the client must be transmitted with 
this <F2>byte<#1e>order<F0>, and all 16<#1e>bit and 32<#1e>bit quantities 
returned by the server are transmitted with this <F2>byte<#1e>order<F0>. 

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>display<F3> <F2>display<F0><Tab><F3>Function<F0><Index, "number of display"><Index, "display", "number"><Index, Doc = operations, "xlib:display<#1e>display", Sort String = "display<#1e>display">

<return>

<Tab><F3>Returns: <F2><HR>
  display<#1e>number <F3><#1f> Type <F0>integer<F3>. 

<para>

Returns the <F2>display<#1e>number<F0> for the host associated with <F2>disp
lay<F0>. 

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

<|,"2<#1e>25">display<#1e>error<#1e>handler<F3> <F2>display<F0><Tab><F3>Function
<F0><Index, "error handler of display"><Index, "display", "error handler"><Index, Doc = operations, "xlib:display<#1e>error<#1e>handler", Sort String = "display<#1e>error<#1e>handler">

<return0,
	Bottom Margin =		0.08 inches>

<Tab><F3>Returns: <F2><HR>
  error<#1e>handler <F3><#1f> Type <F0>function<F3> or <F0>sequence<F3>. 

<para>

Returns and (with <F6>setf<F0>) sets the <F2>error<#1e>handler<F0> 
function for the given <F2>display<F0>. CLX calls (one of) the display 
error handler functions to handle server errors returned to the connection. 
The default error handler, <F6>default<#1e>error<#1e>handler<F0>, 
signals conditions as they occur. See Section 16, Errors, for a list 
of the conditions that CLX can signal. For more information about 
errors and error handling, refer to the section entitled Common Lisp 
Condition System in the <F2>Lisp Reference<F0> manual.

If the value of <F2>error<#1e>handler<F0> is a sequence, it is expected 
to contain a handler function for each specific error. The error code 
is used as an index into the sequence to fetch the appropriate handler 
function. If this element is a function, it is called for all errors. 
Any results returned by the handler are ignored since it is assumed 
the handler either takes care of the error completely or else signals. 
The arguments passed to the handler function are the <F6>display<F0> 
object, a symbol naming the type of error, and a set of keyword<#1e>value 
argument pairs that vary depending on the type of error. For all core 
errors, the keyword<#1e>value argument pairs are: 

<cardlist>

<F6>:current<#1e>sequence<F0><Tab><F6>card16<F0><HR>
<F6>:major<F0><Tab><F6>card8<F0><HR>
<F6>:minor<F0><Tab><F6>card16<F0><HR>
<F6>:sequence<F0><Tab><F6>card16<F0> 

<para>

For <F6>colormap<F0>, <F6>cursor<F0>, <F6>drawable<F0>, <F6>font<F0>, 
<F6>gcontext<F0>, <F6>id<#1e>choice<F0>, <F6>pixmap<F0>, and <F6>window
<F0> errors, the keyword<#1e>value pairs are the core error pairs 
plus: 

<cardlist>

<F6>:resource<#1e>id<F0><Tab><F6>card32 

<para>

For <F6>:atom<F0> errors, the keyword<#1e>value pairs are the core 
error pairs plus: 

<cardlist>

<F6>:atom<#1e>id<F0><Tab><F6>card32 

<para>

For <F6>:value<F0> errors, the keyword<#1e>value pairs are the core 
error pairs plus: 

<cardlist>

<F6>:value<F0><Tab><F6>card32<F0> 

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>image<#1e>lsb<#1e>first<#1e>p<F3> <F2>display<F0><Tab><F3>Funct
ion<F0><Index, "image", "leftmost bit of display"><Index, "display", "image leftmost bit"><Index, Doc = operations, "xlib:display<#1e>image<#1e>lsb<#1e>first<#1e>p", Sort String = "display<#1e>image<#1e>lsb<#1e>first<#1e>p">

<return>

<Tab><F3>Returns: <F2><HR>
  image<#1e>lsb<#1e>first<#1e>p <F3><#1f> Type <F0>boolean<F3>. 
<SP>

<para>

Although the server is generally responsible for byte swapping communication 
data to match the client, images (pixmaps/bitmaps) are always transmitted 
and received in formats (including byte order) specified by the server. 
Within images for each scan<#1e>line unit in bitmaps or for each pixel 
value in pixmaps, the leftmost bit in the image as displayed on the 
screen is either the least or most significant bit in the unit. For 
the given <F2>display<F0>, <F6>display<#1e>image<#1e>lsb<#1e>first<#1e>p
<F0> returns non<#1e><F6>nil<F0> if the leftmost bit is the least 
significant bit; otherwise, it returns <F6>nil<F0>. 

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>keycode<#1e>range <F2>display<F0><Tab><F3>Function<F0><Index, "keycode", "range of display"><Index, "display", "keycode", "range"><Index, Doc = operations, "xlib:display<#1e>keycode<#1e>range", Sort String = "display<#1e>keycode<#1e>range">

<return>

<Tab><F3>Returns: <F2><HR>
  min<#1e>keycode<F3>, <F2>max<#1e>keycode <F3><#1f> Type <F0>card8<F3>. 

<para>

Returns <F2>min<#1e>keycode<F0> and <F2>max<#1e>keycode<F0> as 
multiple values. See the <F6>display<#1e>max<#1e>keycode<F0> and <F6>display
<#1e>min<#1e>keycode<F0> functions for additional information.

<arg>

<|,"2<#1e>26">display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>max<#1e>keycode <F2>display<F0><Tab><F3>Function<F0><Index, "keycode", "maximum value of display"><Index, "display", "keycode", "maximum value"><Index, Doc = operations, "xlib:display<#1e>max<#1e>keycode", Sort String = "display<#1e>max<#1e>keycode">

<return>

<Tab><F3>Returns: <F2><HR>
  max<#1e>keycode <F3><#1f> Type <F0>card8<F3>. 

<para>

Returns the maximum keycode value for the specified <F2>display<F0>. 
This value is never greater than 255. Not all keycodes in the allowed 
range are required to have corresponding keys. 

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>max<#1e>request<#1e>length <F2>display<F0><Tab><F3>Function
<F0><Index, "request maximum length of display"><Index, "display", "request maximum length"><Index, Doc = operations, "xlib:display<#1e>max<#1e>request<#1e>length", Sort String = "display<#1e>max<#1e>request<#1e>length">

<return>

<Tab><F3>Returns: <F2><HR>
  max<#1e>request<#1e>length <F3><#1f> Type <F0>card16<F3>. 

<para>

Returns the maximum length of a request, in four<#1e>byte units, that 
is accepted by the specified <F2>display<F0>. Requests larger than 
this generate a length error, and the server will read and simply 
discard the entire request. This length is always at least 4096 (that 
is, requests of length up to and including 16384 bytes are accepted 
by all servers).

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>min<#1e>keycode<F3> <F2>display<F0><Tab><F3>Function<F0><Index, "keycode", "minimum value of display"><Index, "display", "keycode", "minimum value"><Index, Doc = operations, "xlib:display<#1e>min<#1e>keycode", Sort String = "display<#1e>min<#1e>keycode">

<return>

<Tab><F3>Returns: <F2><HR>
  min<#1e>keycode <F3><#1f> Type <F0>card8<F3>. 

<para>

Returns the minimum keycode value for the specified <F2>display<F0>. 
This value is never less than eight. Not all keycodes in the allowed 
range are required to have corresponding keys. 

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>motion<#1e>buffer<#1e>size<F9> <F2>display<F0><Tab><F3>Function
<F0><Index, "motion buffer size of display"><Index, "display", "motion buffer size"><Index, Doc = operations, "xlib:display<#1e>motion<#1e>buffer<#1e>size", Sort String = "display<#1e>motion<#1e>buffer<#1e>size">

<return>

<Tab><F3>Returns: <F2><HR>
  motion<#1e>buffer<#1e>size <F3><#1f> Type <F0>card32<F3>. 

<para>

Returns the approximate size of the motion buffer for the specified <F2>displa
y<F0>. The server can retain the recent history of pointer motion 
at a finer granularity than is reported by <F6>:motion<#1e>notify<F0> 
events. Such history is available through the <F6>motion<#1e>events<F0> 
function. 

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>p<F3> <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:display<#1e>p", Sort String = "display<#1e>p">

<return>

<Tab><F3>Returns: <F2><HR>
  display<#1e>p <F3><#1f> Type <F0>boolean<F3>.

<para>

Returns non<#1e><F6>nil<F0> if <F2>display<F0> is a <F6>display<F0> 
object; otherwise, returns <F6>nil<F0>. 

<syntax0>

display<#1e>pixmap<#1e>formats<F3> <F2>display<F0><Tab><F3>Function<F0><Index, "pixmap", "formats of display"><Index, "display", "pixmap formats"><Index, Doc = operations, "xlib:display<#1e>pixmap<#1e>formats", Sort String = "display<#1e>pixmap<#1e>formats">

<return>

<Tab><F3>Returns: <F2><HR>
  pixmap<#1e>formats <F3><#1f> Type <F0>list<F3>.

<para>

Returns the list of <F6>pixmap<#1e>format<F2> <F0>values for the 
given <F2>display<F0>. This list contains one entry for each depth 
value. The entry describes the format used to represent images of 
that depth. An entry for a depth is included if any screen supports 
that depth, and all screens supporting that depth must support (only) 
the format for that depth. 

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

<|,"2<#1e>27">display<#1e>plist<F3> <F2>display<F0><Tab><F3>Function<F0><Index, "property list", "display"><Index, "display", "property list"><Index, Doc = operations, "xlib:display<#1e>plist", Sort String = "display<#1e>plist">

<return>

<Tab><F3>Returns: <F2><HR>
  plist <F3><#1f> Type <F0>list<F3>. 

<para>

Returns and (with <F6>setf<F0>) sets the property list for the specified 
<F2>display<F0>. This function provides a hook where extensions 
can add data.

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>protocol<#1e>major<#1e>version <F2>display<F0><Tab><F3>Function
<F0><Index, "protocol", "major version of display"><Index, "display", "protocol", "major version"><Index, Doc = operations, "xlib:display<#1e>protocol<#1e>major<#1e>version", Sort String = "display<#1e>protocol<#1e>major<#1e>version">

<return>

<Tab><F3>Returns: <F2><HR>
  protocol<#1e>major<#1e>version <F3><#1f> Type <F0>card16<F3>. 

<para>

Returns the major version number of the X protocol associated with 
the specified <F2>display<F0>. In general, the major version would 
increment for incompatible changes. The returned protocol version 
number indicates the protocol the server actually supports. This might 
not equal the version supported by the client. The server can (but 
need not) refuse connections from clients that offer a different version 
than the server supports. A server can (but need not) support more 
than one version simultaneously. 

<arg>

display <#1f> <F3>A <F6>display<F3> object.

<syntax0>

display<#1e>protocol<#1e>minor<#1e>version <F2>display<F0><Tab><F3>Function
<F0><Index, "protocol", "minor version of display"><Index, "display", "protocol", "minor version"><Index, Doc = operations, "xlib:display<#1e>protocol<#1e>minor<#1e>version", Sort String = "display<#1e>protocol<#1e>minor<#1e>version">

<return>

<Tab><F3>Returns: <F2><HR>
  protocol<#1e>minor<#1e>version <F3><#1f> Type <F0>card16<F3>. 

<para>

Returns the minor protocol revision number associated with the specified <F2>d
isplay<F0>. In general, the minor version would increment for small 
upward compatible changes in the X protocol. 

<arg>

display <#1f> <F3>A <F6>display<F3> object.

<syntax0>

display<#1e>protocol<#1e>version <F2>display<F0><Tab><F3>Function<F0><Index, "protocol", "version of display"><Index, "display", "protocol", "version"><Index, Doc = operations, "xlib:display<#1e>protocol<#1e>version", Sort String = "display<#1e>protocol<#1e>version">

<return>

<Tab><F3>Returns:<HR>
  <F2>protocol<#1e>major<#1e>version<F3>,<F2> protocol<#1e>minor<#1e>version 
<F3><#1f> Type <F0>card16<F3>. 

<para>

Returns <F2>protocol<#1e>major<#1e>version <F0>and <F2>protocol<#1e>minor<#1e>
version<F0> as multiple values. See the <F6>display<#1e>protocol<#1e>major<#1e>
version<F0> and <F6>display<#1e>protocol<#1e>minor<#1e>version<F0> 
functions for additional information.

<arg>

display <#1f> <F3>A <F6>display<F3> object.

<syntax0>

display<#1e>resource<#1e>id<#1e>base <F2>display<F0><Tab><F3>Function<F0><Index, "resource<#1e>id", "base of display"><Index, "display", "resource<#1e>id", "base"><Index, Doc = operations, "xlib:display<#1e>resource<#1e>id<#1e>base", Sort String = "display<#1e>resource<#1e>id<#1e>base">

<return>

<Tab><F3>Returns: <F2><HR>
  resource<#1e>id<#1e>base <F3><#1f> Type <F0>resource<#1e>id<F3>. 

<para>

Returns the <F2>resource<#1e>id<#1e>base<F0> value that was returned 
from the server during connection setup for the specified <F2>display<F0>. 
This is used in combination with the <F2>resource<#1e>id<#1e>mask<F0> 
to construct valid IDs for this connection. 

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

<|,"2<#1e>28">display<#1e>resource<#1e>id<#1e>mask <F2>display<F0><Tab><F3>Function
<F0><Index, "resource<#1e>id", "mask of display"><Index, "display", "resource<#1e>id", "mask"><Index, Doc = operations, "xlib:display<#1e>resource<#1e>id<#1e>mask ", Sort String = "display<#1e>resource<#1e>id<#1e>mask ">

<return>

<Tab><F3>Returns: <F2><HR>
  resource<#1e>id<#1e>mask <F3><#1f> Type <F0>resource<#1e>id<F3>. 

<para>

Returns the <F2>resource<#1e>id<#1e>mask<F0> that was returned from 
the server during connection setup for the specified <F2>display<F0>. 
The <F2>resource<#1e>id<#1e>mask<F0> contains a single contiguous 
set of bits (at least 18) which the client uses to allocate resource 
IDs for types <F6>window<F0>, <F6>pixmap<F0>, <F6>cursor<F0>, <F6>font
<F0>, <F6>gcontext<F0>, and <F6>colormap<F0> by choosing a value 
with (only) some subset of these bits set, and <F6>or<F0>ing it 
with the <F2>resource<#1e>id<#1e>base<F0>. Only values constructed 
in this way can be used to name newly created server resources over 
this connection. Server resource IDs never have the top three bits 
set. The client is not restricted to linear or contiguous allocation 
of server resource IDs. Once an ID has been freed, it can be reused, 
but this should not be necessary. 

An ID must be unique with respect to the IDs of all other server resources, 
not just other server resources of the same type. However, note that 
the value spaces of server resource identifiers, atoms, visualids, 
and keysyms are distinguished by context, and as such are not required 
to be disjoint (for example, a given numeric value might be both a 
valid window ID, a valid atom, and a valid keysym.)

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>roots<F3> <F2>display<F0><Tab><F3>Function<F0><Index, "root", "display"><Index, "display", "roots"><Index, Doc = operations, "xlib:display<#1e>roots", Sort String = "display<#1e>roots">

<return>

<Tab><F3>Returns: <F2><HR>
  roots <F3><#1f> A list of screens. 

<para>

Returns a list of all the <F6>screen<F0> structures available for 
the given <F2>display<F0>. 

<arg>

display <#1f> <F3>A <F6>display<F3> object.

<syntax0>

display<#1e>vendor <F2>display<F0><Tab><F3>Function<F0><Index, "vendor", "display"><Index, "display", "vendor"><Index, Doc = operations, "xlib:display<#1e>vendor", Sort String = "display<#1e>vendor">

<return>

<Tab><F3>Returns: <F2><HR>
  vendor<#1e>name<F3>, <F2>release<#1e>number <F3><#1f> Type <F0>card32
<F3>. 

<para>

Returns <F2>vendor<#1e>name<F0> and <F2>release<#1e>number<F0> 
as multiple values. See the <F6>display<#1e>vendor<#1e>name<F0> 
and <F6>display<#1e>release<#1e>number<F0> functions for additional 
information.

<arg>

display <#1f> <F3>A <F6>display<F3> object. 

<syntax0>

display<#1e>vendor<#1e>name <F2>display<F0><Tab><F3>Function<F0><Index, "vendor", "name of display"><Index, "display", "vendor", "name"><Index, Doc = operations, "xlib:display<#1e>vendor<#1e>name", Sort String = "display<#1e>vendor<#1e>name">

<return>

<Tab><F3>Returns: <F2><HR>
  vendor<#1e>name <F3><#1f> Type <F0>string<F3>. 

<para>

Returns a string that provides some vendor identification of the X 
server implementation associated with the specified <F2>display<F0>. 

<arg>

display <#1f> <F3>A <F6>display<F3> object.

<syntax0>

display<#1e>version<#1e>number <F2>display<F0><Tab><F3>Function<F0><Index, "version number of display"><Index, "display", "version number"><Index, Doc = operations, "xlib:display<#1e>version<#1e>number", Sort String = "display<#1e>version<#1e>number">

<return>

<Tab><F3>Returns: <F2><HR>
  version<#1e>number <F3><#1f> Type <F0>card16<F3>. 

<para>

Returns the X protocol version number for this implementation of CLX. 

<arg>

display <#1f> <F3>A <F6>display<F3> object.

<syntax0>

display<#1e>xid <F2>display<F0><Tab><F3>Function<F0><Index, "server", "resource ID of display", Sort String = "resource id of display"><Index, "display", "server resource ID", Sort String = "server resource id"><Index, Doc = operations, "xlib:display<#1e>xid", Sort String = "display<#1e>xid">

<return>

<Tab><F3>Returns: <F2><HR>
  resource<#1e>allocator <F3><#1f> Type <F0>function<F3>. 

<para>

Returns the function that is used to allocate server resource IDs 
for this <F2>display<F0>. 

<arg>

display <#1f> <F3>A <F6>display<F3> object.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<|,"2<#1e>29">with<#1e>display<F3> <F2>display<F3> &body <F2>body<F0><Tab><F3>Mac
ro<F0><Index, "window", "attributes", "batching"><Index, Doc = operations, "xlib:with<#1e>display", Sort String = "with<#1e>display">

<para>

This macro is for use in a multi<#1e>process environment. <F6>with<#1e>display
<F0> provides exclusive access to the local <F6>display<F0> object 
for multiple request generation. It need not provide immediate exclusive 
access for replies. That is, if another process is waiting for a reply 
(while not in a <F6>with<#1e>display<F0>), then synchronization 
need not (but can) occur immediately. Except where noted, all routines 
effectively contain an implicit <F6>with<#1e>display<F0> where needed, 
so that correct synchronization is always provided at the interface 
level on a per<#1e>call basis. Nested uses of this macro work correctly. 
This macro does not prevent concurrent event processing (see <F6>with<#1e>even
t<#1e>queue<F0>). 

<arg>

display <#1f> <F3>A <F6>display<F3>. 

<p1rule>

<Index, "output buffer management", To Named = p1rule><Index, "display", "output buffer management", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F7>Managing the <Tab><F6>2.4<F0><#04>Most CLX functions cause 
output requests to be generated to an X<FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F7>Output Buffer<Tab><F0>server. Output requests are not transmitted 
immediately but instead are stored in an <F2>output buffer<F0> for 
the appropriate display. Requests in the output buffer are typically 
sent only when the buffer is filled. Alternatively, buffered requests 
can be sent prior to processing an event in the input event queue 
(see paragraph 12.3, Processing Events). In either case, CLX sends 
the output buffer automatically without explicit instructions from 
the client application. 

<para>

However, in some cases, explicit control over the output buffer is 
needed, typically to ensure that the X server is in a consistent state 
before proceeding further. The <F6>display<#1e>force<#1e>output<F0> 
and <F6>display<#1e>finish<#1e>output<F0> functions allow a client 
program to synchronize with buffered output requests.

<syntax0>

display<#1e>after<#1e>function <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:display<#1e>after<#1e>function", Sort String = "display<#1e>after<#1e>function">

<return0,
	Bottom Margin =		0.08 inches>

<Tab><F3>Returns: <F2><HR>
  after<#1e>function <F3><#1f> Type <F0>function<F3> or <F0>null<F3>.

<para>

Returns and (with <F6>setf<F0>) sets the <F2>after<#1e>function<F0> 
for the given <F2>display<F0>. If <F2>after<#1e>function<F0> is 
non<#1e><F6>nil<F0>, it is a function that is called after every 
protocol request is generated, even those inside an explicit <F6>with<#1e>disp
lay<F0>, but never called from inside the <F2>after<#1e>function<F0>. 
The function is called inside the effective <F6>with<#1e>display<F0> 
for the associated request. The default value is <F6>nil<F0>. This 
can be set, for example, to #'<F6>display<#1e>force<#1e>output<F0> 
or #'<F6>display<#1e>finish<#1e>outpu<F0>t. 

<arg>

display <F3><#1f> A <F6>display<F3> object.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

display<#1e>force<#1e>output<F3> <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:display<#1e>force<#1e>output", Sort String = "display<#1e>force<#1e>output">

<para>

Forces any buffered output to be sent to the X server.

<arg>

display <F3><#1f> A <F6>display<F3> object.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

display<#1e>finish<#1e>output<F3> <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:display<#1e>finish<#1e>output", Sort String = "display<#1e>finish<#1e>output">

<para>

Forces any buffered output to be sent to the X server and then waits 
until all requests have been received and processed. Any errors generated 
are read and handled by the display error handler. Any events generated 
by output requests are read and stored in the event queue.

<arg>

display <F3><#1f> A <F6>display<F3> object.

<p1rule>

<Index, "display", "closing">
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F7>Closing the<Tab><F6>2.5<F0><#04>To close or disconnect a display 
from the X server, use <F6>close<#1e>display<F0>. <F6><#04>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F7>Display<Tab>

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<|,"2<#1e>30">close<#1e>display<F3> <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:close<#1e>display", Sort String = "close<#1e>display">

<para>

Closes the connection to the X server for the specified <F2>display<F0>. 
It destroys all server resources (<F6>window<F0>, <F6>font<F0>, <F6>pixmap
<F0>, <F6>colormap<F0>, <F6>cursor<F0>, and <F6>gcontext<F0>), 
that the client application has created on this display, unless the 
close down mode of the server resource has been changed (see <F6>set<#1e>close
<#1e>down<#1e>mode<F0>). Therefore, these server resources should 
never be referenced again. In addition, this function discards any 
output requests that have been buffered but have not yet been sent. 

<arg>

display <#1f> <F3>A <F6>display<F3> object.

