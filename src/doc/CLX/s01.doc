<!OPS, Version = 5.2>

<!Document,
	Print Rev Bars =	no,
	Final Output Device =	"ps",
	Default Printer =	"nearest-adps">

<!Font Definitions,
	F2 = Times 10 Italic,
	F3 = Times 10,
	F4 = Times 8 Italic,
	F5 = Times 18 Bold,
	F6 = Courier 8,
	F7 = Times 12 Bold,
	F8 = Times 10 Bold,
	F9 = Symbol_B 8,
	F10 = Symbol_B 10,
	F11 = Symbol_A 10>

<!Page,
	Bottom Margin =		1 inches,
	Left Margin =		1 inches,
	Right Margin =		1.15 inches,
	First Page =		Right,
	Starting Page # = 	Inherit,
	Page # Prefix =		"1<#1e>",
	Hyphenation =		on,
	Consecutive Hyphens =	2,
	Vert. Just. =		off>

<!Autonumber Stream, List, 2,
	Level 2 Suffix =	,
	Level 2 Starting Value = 0,
	Level 2 Show =		no>

<!Autonumber Stream, Outline, 3,
	Level 1 Symbol Type =	UPPER ROMAN,
	Level 2 Symbol Type =	UPPER ALPHA>

<!Autonumber Stream, figure, 2,
	Level 1 Prefix =	"Figure ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	,
	Level 2 Starting Value = 0,
	Level 2 Show =		no>

<!Autonumber Stream, figurelet, 2,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Prefix =	"Figure ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	"<#04>">

<!Autonumber Stream, invisible, 1,
	Level 1 Suffix =	,
	Level 1 Show =		no>

<!Autonumber Stream, item, 2,
	Level 2 Symbol Type =	LOWER ALPHA,
	Level 2 Trail =		yes>

<!Autonumber Stream, paralet, 4,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Suffix =	,
	Level 1 Show =		no,
	Level 2 Prefix =	.,
	Level 2 Suffix =	,
	Level 3 Prefix =	.,
	Level 3 Suffix =	,
	Level 4 Prefix =	.,
	Level 4 Suffix =	>

<!Autonumber Stream, paranum, 4,
	Level 1 Suffix =	,
	Level 1 Show =		no,
	Level 2 Prefix =	.,
	Level 2 Suffix =	,
	Level 3 Prefix =	.,
	Level 3 Suffix =	,
	Level 4 Prefix =	.,
	Level 4 Suffix =	>

<!Autonumber Stream, table, 2,
	Level 1 Prefix =	"Table ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	>

<!Autonumber Stream, tablelet, 2,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Prefix =	"Table ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	"<#04>">

<!Class, arg,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F2,
	Left Tab =		-0.50/0 inches>

<!Class, argtable,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		0/0.60/1.80/2.50/2.80/3.80/6.75/0.75*4 inches>

<!Class, bullet,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		-0.50/0 inches>

<!Class, caption,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Font =			F4>

<!Class, fig,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Left,
	Font =			F5>

<!Class, lisp,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.140 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Left Tab =		0/0.20*26/6/7/8 inches>

<!Class, p1para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F7,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-1.70/0 inches>

<!Class, p1rule,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches>

<!Class, p1stacked,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1 lines,
	Font =			F8,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-1.60/-0.17/0 inches>

<!Class, p2para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F8,
	Left Tab =		0 inches,
	Right Tab =		-1.60/-0.17 inches>

<!Class, p2rule,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1 lines,
	Alignment =		Left,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches>

<!Class, p2stacked,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F8,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		0 inches,
	Right Tab =		-1.60/-0.17 inches>

<!Class, para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		0/0.75*13 inches>

<!Class, return,
	Bottom Margin =		0.077 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F8,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<!Class, secno,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Left,
	Font =			F5,
	Autonumber Name =	paranum>

<!Class, secrule,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches,
	Autonumber Name =	table>

<!Class, sectitle,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Alignment =		Right,
	Font =			F5,
	Hyphenation =		off,
	New Page =		yes,
	Left Tab =		0/0.75*13 inches>

<!Class, synpara,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		0/0.75/1/2.25/0.75*10 inches>

<!Class, syntax,
	Bottom Margin =		0.077 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F8,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		8 inches>

<!Class, "table",
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Font =			F8,
	Autonumber Name =	table>

<!Class, thinrule,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1 lines,
	Alignment =		Left,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches>

<!Class, title,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Right,
	Font =			F5,
	TOC Doc Name =		TOC>

<!Master Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			0.41 inches,
	Height =		0.137 inches,
	Vertical Alignment =	0.03 inches,
	Diagram =
V4,
(g9,32767,0
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<!Master Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,0.2,0.066667,6.333333,0.066667,13,1,0)
 (v4,2,0,6.326667,0.066667,0.006667,0.066667,17,2,0)
 (E10,0,0,0,-1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.06
  6667,6))>

<!Master Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,4.733333,0.066611,0.006667,0.066723,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<First Page Header, Frame =
V4,
(g9,0,0
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,1,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Right Page Header, Frame =
V4,
(g9,1,0
 (T8,1,12,5.24,0.293333,1.133333,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512
  ,102,1101,2,
<caption>

Introduction to CLX

<End Text>)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Left Page Header, Frame =
V4,
(g9,1,0
 (T8,1,12,0,0.293333,2.866667,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,10
  2,1101,2,
<caption>

Introduction to CLX

<End Text>)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Right Page Footer, Frame =
V4,
(g9,1,0
 (t8,1,4,6.333333,0.266667,2,17,@nntimsps10b,\240)
 (t8,2,4,0.006667,0.266667,0,17,@nntimsps8i,CLX\ Programmer's\ Reference)
 (v4,3,0,0,0.066667,6.333333,0.066554,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Left Page Footer, Frame =
V4,
(g9,1,0
 (t8,1,4,0,0.266667,0,17,@nntimsps10b,\240)
 (t8,2,4,6.333333,0.266667,2,17,@nntimsps8i,CLX\ Programmer's\ Reference)
 (v4,3,0,0.026667,0.066667,6.333333,0.066554,17,2,0)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<sectitle,
	Allow Page Break Within = no,
	Allow Page Break After = no>

<|,"1<#1e>1">
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			4.72 inches,
	Height =		0.94 inches,
	Vertical Alignment =	0.03 inches,
	Diagram =
V4,
(g9,1,0
 (T8,1,12,0.133333,0.72,4.563333,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512
  ,102,1101,3,
<title>

INTRODUCTION TO CLX

<End Text>)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			1.626 inches,
	Height =		0.938 inches,
	Vertical Alignment =	0 inches,
	Diagram =
V4,
(g9,1,0
 (T8,1,12,0.066667,0.276667,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,10
  2,1101,3,
<secno,
	TOC Doc Name =		TOC>

<Autonum, paranum, 1, First = Yes>

<End Text>)
 (T8,2,12,0.026667,0.733333,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,10
  2,1101,3,
<"table">

<Autonum, table, 1, First = Yes>

<End Text>)
 (T8,3,12,0.066667,0.6,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,102,110
  1,3,
<fig,
	Alignment =		Both,
	Font =			F8,
	Autonumber Name =	figure>

<Autonum, figure, 1, First = Yes>

<End Text>)
 (g9,5,0
   (p7,5,8,19
     (g9,5,0
       (g9,5,0
         (v4,5,0,0.266667,0,1.6,0,17,1,0)
         (v4,6,0,1.6,0,1.6,0.933333,17,1,0)
         (v4,7,0,1.6,0.933333,0.266667,0.933333,17,1,0)
         (v4,8,0,0.266667,0.933333,0.266667,0,17,1,0))))
   (g9,10,8
     (p7,10,0,13
       (g9,10,0
         (g9,10,0
           (v4,10,0,1.471112,0.927404,1.471112,0.159997,17,1,0)
           (v4,11,0,1.471112,0.159997,1.293333,0.159997,17,1,0)
           (v4,12,0,1.293333,0.159997,1.115556,0.306168,17,1,0)
           (v4,13,0,1.115556,0.306168,1.115556,0.379256,17,1,0)
           (v4,14,0,1.115556,0.379256,1.271111,0.379256,17,1,0)
           (v4,15,0,1.271111,0.379256,1.271111,0.927404,17,1,0)
           (v4,16,0,1.271111,0.927404,1.471112,0.927404,17,1,0))))
     (g9,17,2048
       (v4,17,33,1.093333,0.159997,1.093333,0.159997,17,0,0)
       (v4,18,33,1.093333,1.146663,1.093333,1.146663,17,0,0)
       (v4,19,33,1.56,1.146663,1.56,1.146663,17,0,0)
       (v4,20,33,1.56,0.159997,1.56,0.159997,17,0,0))))
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<secrule,
	Allow Page Break Within = no,
	Allow Page Break After = yes,
	Autonumber Name =	>

<Index, "CLX", Sort String = clx, "overview", To Named = sectitle>
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,0.006667,0.066723,6.333333,0.066611,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<p1para,
	Font =			F3,
	Allow Page Break After = yes>

<F7>Introduction<Tab><F8>1.1<F0><#04>This manual assumes a basic 
understanding of window systems and the Common Lisp programming language. 
To provide an introduction to the Common Lisp X Interface (CLX) programming, 
this section discusses the following:<#04>

<bullet>

<F9>w<Tab><F0>Overview of the X Window System 

<F9>w<Tab><F0>Naming and argument conventions 

<F9>w<Tab><F0>Programming considerations 

<p1rule>

<Index, "X Window System", Sort String = "x window system", "overview", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F7>The X Window<Tab><F8>1.2<F0><#04>The X Window System was developed 
at the Massachusetts Institute of

<p1para,
	Font =			F3,
	Allow Page Break After = yes>

<F7>System<Tab><F0>Technology (MIT) and first released in 1985. 
Since then, the X Window System has become an industry<#1e>standard 
product available on virtually every type of bit<#1e>mapped workstation. 
The current version of X, Version 11, has been implemented for several 
different computer architectures, for a wide variety of display hardware, 
and also for many different operating systems. X Version 11 represents 
the fulfillment of the original design goals proposed by MIT, as follows:<#04>

<bullet>

<F9>w<Tab><F0>Portable <#1f> Support virtually any bitmap display 
and any interactive input device (including keyboards, mice, tablets, 
joysticks, and touch screens). Make it easy to implement the window 
system on different operating systems.

<F9>w<Tab><F0>Device<#1e>Independent Applications <#1f> Avoid rewriting, 
recompiling, or even relinking in order to use different display/input 
hardware. Make it easy for an application to work on both monochrome 
and color hardware.

<F9>w<Tab><F0>Network Transparent <#1f> Let an application run on 
one computer while using another computer's display, even if the other 
computer has a different operating system or hardware architecture.

<F9>w<Tab><F0>Multitasking <#1f> Support multiple applications being 
displayed simultaneously.

<F9>w<Tab><F0>No User Interface Policy <#1f> Since no one agrees 
on what constitutes the best user interface, make it possible for 
a broad range of user interface styles (or policies) to be implemented, 
external to the window system and to the application programs.

<F9>w<Tab><F0>Cheap Windows <#1f> Windows should be abundant, and 
ubiquitous. Provide overlapping windows and a simple mechanism for 
window hierarchy.

<F9>w<Tab><F0>High<#1e>Performance Graphics <#1f> Provide powerful 
interfaces for synthesizing 2<#1e>D images (geometric primitives, 
high<#1e>quality text with multiple typefaces, and scanned images).

<F9>w<Tab><F0>Extensible <#1f> Include a mechanism for adding new 
capabilities. Allow separate sites to develop independent extensions 
without becoming incompatible with remote applications.

<para>

<|,"1<#1e>2"><Index, "client">Some of these goals lead directly to the 
basic X architecture <#1f> the client<#1e>server model. The basic 
window system is implemented by the X <F2>server<F0> program. An 
application program (the <F2>client<F0>) sends window system <F2>requests
<F0> to the X server through a reliable two<#1e>way byte<#1e>stream. 

In general, the server and the client can be executing on separate 
host computers, in which case the byte<#1e>stream is implemented via 
some network protocol (TCP, DECnet<F10>]<F0>, Chaosnet, and so forth). 
The X server, which is connected to several client programs running 
concurrently, executes client requests in round<#1e>robin fashion. 
The server is responsible for drawing client graphics on the display 
screen and for making sure that graphics output to a window stays 
inside its boundary.

<Index, "reply"><Index, "event">The other primary job of the 
X server is to channel input from the keyboard, pointer, and other 
input devices back to the appropriate client programs. Input arrives 
at the client asynchronously in the form of input <F2>events<F0> 
representing up/down transitions of keys or pointer buttons, changes 
in the pointer position, and so on. In some cases, a request generates 
a return value (or <F2>reply<F0>) from the server, which is another 
kind of client input. Replies and input events are received via the 
same byte<#1e>stream connecting the client with the server.

<p2rule>

<Index, "display"><Index, "screen">
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2para,
	Font =			F3>

<Tab><F8>Windows<Tab>1.2.1<F0><#04>The X Window System supports 
one or more screens containing overlapping windows and subwindows. 
A <F2>screen<F0> is a physical monitor and hardware, which can be 
either color or black and white. There can be multiple screens per 
display workstation. A single server can provide display services 
for any number of screens. A set of screens for a single user with 
one keyboard and one mouse is called a <F2>display<F0>.

<para>

<Index, "root">All windows in an X server are arranged in a strict 
hierarchy. At the top of the hierarchy are the <F2>root windows<F0>, 
which cover each of the display screens. Each root window is either 
partially or completely covered by child windows. All windows, except 
for root windows, have parents. Any window can in turn have its own 
children. In this way, an application program can create a window 
tree of arbitrary depth on each screen.

<Index, "window", "obscure"><Index, "obscuring window">A child window can be larger 
than its parent. That is, part or all of the child window can extend 
beyond the boundaries of the parent. However, all output to a window 
is clipped by the boundaries of its parent window. If several children 
of a window have overlapping locations, one of the children is considered 
to be on top of/or raised over the others, <F2>obscuring<F0> them. 
Window output to areas that are covered by other windows is suppressed. 

A window has a border that is zero or more pixels in width and can 
be any pattern (pixmap) or solid color. A window usually has a background 
pattern that is drawn by the X server. Each window has its own coordinate 
system. Child windows obscure their parents unless the child windows 
have no background. Graphics operations in the parent window are usually 
clipped by the children.

<Index, "drawable"><Index, "tile"><Index, "bitmap"><Index, "pixmap">
X also provides objects called <F2>pixmaps<F0> for off<#1e>screen 
storage of graphics. Single<#1e>plane pixmaps (that is, of depth 1) 
are sometimes referred to as <F2>bitmaps<F0>. Both pixmaps and windows 
can be used interchangeably in most graphics functions. Pixmaps are 
also used in various graphics operations to define patterns, or <F2>tiles
<F0>. Windows and pixmaps together are referred to as <F2>drawables<F0>.

<p2rule>

<Index, "input", "event"><Index, "event", "input">
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2para,
	Font =			F3>

<Tab><F8>Input Events<Tab>1.2.2<F0><#04>The X input mechanism is 
conceptually simple yet quite powerful. Most events are attached to 
a particular window (that is, contain an identifier for the window 
receiving the event). A client program can receive multiple window 
input streams, all multiplexed over the single byte<#1e>stream connection 
to the server.

<para>

<|,"1<#1e>3">Clients can tailor their input by expressing interest in only 
certain event types. The server uses special event types to send important 
messages to the client. For example, the client can elect to receive 
an <F8>:enter<#1e>notify<F0> event when the pointer cursor moves 
into a certain window. Another vital message from the server is an <F8>:exposu
re<F0> event. This is a signal to the client indicating that at least 
some portion of the window has suddenly become visible (perhaps the 
user moved another window which had been overlapping it). The client 
is then responsible for doing what is necessary to redisplay the window's 
image. Client programs must be prepared to regenerate the contents 
of windows in this way on demand.

Input is also subject to policy decisions about which client window 
receives keyboard and pointer events. Since the pointer is free to 
roam between windows, just clicking on a window is often enough to 
send a pointer event to that window. Keyboard events, however, must 
go to a keyboard focus window which has to be designated in some other 
way. Usually, the arbiter of such input management policy is a program 
called the <F2>window manager<F0>. The window manager gives the 
human user a way to make a window the keyboard focus, to manage the 
layout of windows on the screen, to represent windows with icons, 
and so forth. In fact, the window manager client determines most of 
the so<#1e>called look and feel of the X Window System.

<p1rule>

<Index, "examples", "CLX", Sort String = clx, See = "CLX examples"><Index, "CLX", Sort String = clx, "examples", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F7>A Quick Tour<Tab><F8>1.3<F0><#04>The X Window System is defined 
by the X Window System Protocol<FJ>

<p1para,
	Font =			F3,
	Allow Page Break After = yes>

<F7>of CLX<Tab><F0>Specification, a detailed description of the 
encoding and the meaning of requests and events sent between a client 
and a server. This standard protocol does not depend on any particular 
programming language. As a result, each programming language must 
define its own functional interface for using the X protocol. The 
standard X interface used by Common Lisp programmers is called CLX. 
CLX is a set of data types, functions, and macros which allow a Common 
Lisp client program to interact with an X server to send requests 
and to receive input events and replies.<F8><#04>

<para>

For the most part, CLX functions are closely tied to the underlying 
requests in the X protocol. Many CLX functions simply add requests 
to an output buffer. These requests later execute asynchronously on 
the X display server. However, some functions of CLX lie outside the 
scope of the protocol<#1f>for example, reading events and managing 
a client<#1e>side event queue. CLX is also responsible for important 
batching and caching tasks that minimize network communication.

The following paragraphs show an example of a CLX client program. 
All CLX functions and macros are shown in upper case. Note that some 
of the terms used are unique to X, while other terms that are common 
to other window systems have different meanings in X. It may be helpful 
to refer to the glossary when you are uncertain of a term's meaning 
in the context of the X Window System.

<p2rule>

<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2para,
	Font =			F3>

<Tab><Index, "CLX", Sort String = clx, "examples", "definition of menu structure"><F8>A Simple Menu<Tab>1.3.1<F0><#04>The 
example client program creates and displays a simple pop<#1e>up menu 
consisting of a column of strings<#1f>a title string followed by selectable 
menu item strings. The implementation uses one window to represent 
the entire menu, plus a set of subwindows, one for each menu item. 
Here is the definition of a structure which represents such a menu.

<lisp,
	Left Tab =		0/0.15/0.40/0.20*24/6/7/8 inches>

<|,"1<#1e>4">(defstruct (menu)<HR>
<Tab><#7f>A simple menu of text strings."<HR>
<Tab>(title <#7f>Choose an item:")<HR>
<Tab>item-alist              ;((item-window item-string))<HR>
<Tab>window<HR>
<Tab>gcontext<HR>
<Tab>width<HR>
<Tab>title-width<HR>
<Tab>item-width<HR>
<Tab>item-height<HR>
<Tab>(geometry-changed-p t)) ;nil if unchanged since displayed 

<para>

The <F6>window<F0> slot will contain the <F8>window<F0> object 
that represents the menu. The <F6>item<#1e>alist<F0> represents 
the relationship between the menu items and their associated subwindows. 
Each entry in <F6>item<#1e>alist<F0> is a list whose first element 
is a (sub)window object and whose second element is the corresponding 
item string. A <F8>window<F0> object is an instance of a CLX<#1e>defined 
data type which represents X windows. A <F8>window<F0> object actually 
carries two pieces of information: an X window ID integer and a <F8>display
<F0> object. A <F8>display<F0> is another CLX<#1e>defined data 
type that represents a connection to a specific X display server. 
The <F6>gcontext<F0> slot contains an instance of a CLX data type 
known as a <F2>graphics context<F0>. A graphics context is a set 
of display attribute values, such as foreground color, fill style, 
line style, text font, and so forth. Each X graphics request (and 
hence each CLX graphics function call) must supply a graphics context 
to use in displaying the request. The menu's <F6>gcontext<F0> will 
thus hold all of the attribute values used during menu display.

<para,
	New Page =		yes>

<|,"1<#1e>5"><Index, "CLX", Sort String = clx, "examples", "creating menu window">The first thing to do is make an instance 
of a <F6>menu<F0> object:

<lisp,
	Left Margin =		0.50 inches,
	Left Tab =		0/0.15/0.28/0.60/0.20*6/2.08/2.40/0.20*14/6/7/8 inches>

(defun create-menu (parent-window text-color background-color<HR>
<#04>text-font)<HR>
<Tab>(make-menu<HR>
<Tab><Tab>;; Create menu graphics context<HR>
<Index, Doc = operations, "xlib:create<#1e>gcontext", Sort String = "create<#1e>gcontext", "example"><Tab><Tab>:gcontext (CREATE-GCONTEXT :drawable   
parent-window<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab>:foreground text-color<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab>:background background-color<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab>:font       text-font)<HR>
<HR>
<Tab><Tab>;; Create menu window<HR>
<Index, Doc = operations, "xlib:create<#1e>window", Sort String = "create<#1e>window", "example"><Tab><Tab>:window   (CREATE-WINDOW<HR>
<Tab><Tab><Tab><Tab><Tab>:parent       parent-window<HR>
<Tab><Tab><Tab><Tab><Tab>:class        :input-output<HR>
<Tab><Tab><Tab><Tab><Tab>:x            0                 ;temporary 
value<HR>
<Tab><Tab><Tab><Tab><Tab>:y            0                 ;temporary 
value<HR>
<Tab><Tab><Tab><Tab><Tab>:width        16                ;temporary 
value<HR>
<Tab><Tab><Tab><Tab><Tab>:height       16                ;temporary 
value  <HR>
<Tab><Tab><Tab><Tab><Tab>:border-width 2<HR>
<Tab><Tab><Tab><Tab><Tab>:border       text-color<HR>
<Tab><Tab><Tab><Tab><Tab>:background   background-color<HR>
<Tab><Tab><Tab><Tab><Tab>:save-under   :on<HR>
<Tab><Tab><Tab><Tab><Tab>:override-redirect :on          ;override 
window mgr when positioning<HR>
<Index, Doc = operations, "xlib:make<#1e>event<#1e>mask", Sort String = "make<#1e>event<#1e>mask", "example"><Tab><Tab><Tab><Tab><Tab>:event-mask   (MAKE-EVENT-MASK 
:leave-window  <HR>
<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab> 
:exposure))))

<para>

<F8>create<#1e>window<F0> is one of the most important CLX functions, 
since it creates and returns a <F8>window<F0> object. Several of 
its options are shown here. The default window class is <F8>:input<#1e>output
<F0>, but X provides for <F8>:input<#1e>only<F0> windows, too. 
Every window must have a parent window, except for a system<#1e>defined <F2>ro
ot window<F0>, which represents an entire display screen. The <F8>:event<#1e>
mask<F0> keyword value, a CLX <F8>event<#1e>mask<F0> data type, 
says that an input event will be received for the menu window when 
the window is exposed and also when the pointer cursor leaves the 
window. The window border is a pattern<#1e>filled or (as in this case) 
a solid<#1e>colored boundary which is maintained automatically by 
the X server; a client cannot draw in a window's border, since all 
graphics requests are relative to the origin (upper<#1e>left corner) 
of the window's interior and are clipped by the server to this inside 
region. Turning on the <F8>:save<#1e>under<F0> option is a hint 
to the X server that, when this window is made visible, it may be 
more efficient to save the pixels it obscures, rather than require 
several client programs to refresh their windows when the pop<#1e>up 
menu disappears. This is a way to work around X's client<#1e>managed 
refresh policy when only a small amount of screen space is needed 
temporarily. 

Why is <F8>:override<#1e>redirect<F0> turned on for the menu window? 
This is actually a little unusual, because it prevents any window 
manager client from <F2>redirecting<F0> the position of the menu 
when it is popped up. Remember that the window manager represents 
the user's policy for controlling the positions of his windows, so 
this kind of redirection is ordinarily correct. However, in this case, 
as a favor to the user, the menu avoids redirection in order to pop 
up the menu at a very specific location; that is, under the pointer 
cursor.

<Index, "CLX", Sort String = clx, "examples", "creating subwindows", To Next>What about the item subwindows? The <F6>menu<#1e>set<#1e>i
tem<#1e>list<F0> function in the following example creates them whenever 
the menu's item list is changed. The upper<#1e>left x and y coordinates 
and the width and height are not important yet, because they are computed 
just before the menu is displayed. This function also calls <F8>create<#1e>win
dow<F0>, demonstrating the equal treatment of parent and children 
windows in the X window hierarchy.

<lisp,
	Left Margin =		1 inches,
	Left Tab =		0/0.15/0.40/0.53/1/0.20*21/6/7/8 inches>

<|,"1<#1e>6">(defun menu-set-item-list (menu &rest item-strings)<HR>
<Tab>;; Assume the new items will change the menu's width and height<HR>
<Tab>(setf (menu-geometry-changed-p menu) t)<HR>
<HR>
<Tab>;; Destroy any existing item windows<HR>
<Tab>(dolist (item (menu-item-alist menu))<HR>
<Index, Doc = operations, "xlib:destroy<#1e>window", Sort String = "destroy<#1e>window", "example"><Tab>  (DESTROY-WINDOW (first item)))<HR>
<HR>
<Tab>;; Add (item-window item-string) elements to item-alist<HR>
<Tab>(setf (menu-item-alist menu)<HR>
<Tab><Tab><Tab>(let (alist)<HR>
<Tab><Tab><Tab>  (dolist (item item-strings (nreverse alist))<HR>
<Index, Doc = operations, "xlib:create<#1e>window", Sort String = "create<#1e>window", "example"><Tab><Tab><Tab>    (push (list (CREATE-WINDOW<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab>  :parent     (menu-window menu)<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab>  :x          0         ;temporary 
value<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab>  :y          0         ;temporary 
value<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab>  :width      16        ;temporary 
value<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab>  :height     16        ;temporary 
value<HR>
<Index, Doc = operations, "xlib:gcontext<#1e>background", Sort String = "gcontext<#1e>background", "example"><Tab><Tab><Tab><Tab><Tab><Tab><Tab>  :background 
(GCONTEXT-BACKGROUND (menu-gcontext menu))<HR>
<Index, Doc = operations, "xlib:make<#1e>event<#1e>mask", Sort String = "make<#1e>event<#1e>mask", "example"><Tab><Tab><Tab><Tab><Tab><Tab><Tab>  :event-mask 
(MAKE-EVENT-MASK :enter-window<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab>    
:leave-window<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab>    
:button-press<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab><Tab>    
:button-release))<HR>
<Tab><Tab><Tab><Tab><Tab><Tab><Tab>item)<HR>
<Tab><Tab> <Tab><Tab><Tab>alist)))))

<p2rule>

<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Tab><Index, "CLX", Sort String = clx, "examples", "calculating menu size", To Next><F8>Displaying<Tab>1.3.2<F0><#04>The <F6>menu<#1e>r
ecompute<#1e>geometry<F0> function (shown in the following<F8><FJ>

<p2para,
	Font =			F3>

<Tab><F8>the Menu<Tab><F0>example) handles the job of calculating 
the size of the menu, based on its current item list and its current 
text font. CLX provides a way to inquire the geometrical properties 
of a font object (for example, its ascent and descent from the baseline) 
and also a <F8>text<#1e>extents<F0> function. <F8>text<#1e>extents<F0> 
returns the geometry of a given string as displayed in a given font. 
Notice the use of the <F8>with<#1e>state<F0> macro when setting 
a window's geometry attributes. CLX strives to preserve the familiar <F8>setf
<F0> style of accessing individual window attributes, even though 
an attribute access actually involves sending a request to a (possibly 
remote) server and/or waiting for a reply. <F8>with<#1e>state<F0> 
tells CLX to batch together all read and write accesses to a given 
window, using a local cache to minimize the number of server requests. 
This CLX feature can result in a dramatic improvement in client performance 
without burdening the programmer interface.<F8><#04>

<para>

<F6>menu<#1e>recompute<#1e>geometry<F0> causes all the item subwindows 
to become <F2>mapped<F0>. Mapping a window means attempting to make 
it visible on the screen. However, a subwindow will not actually be <F2>visibl
e<F0> until it and all of its ancestors are mapped. Even then, another 
window might be covering up the subwindow.

<lisp,
	Left Margin =		0.50 inches,
	Left Tab =		0/0.15/0.40/0.20*24/6/7/8 inches>

<|,"1<#1e>7"><Index, Doc = operations, "xlib:gcontext<#1e>font", Sort String = "gcontext<#1e>font", "example"><Index, Doc = operations, "xlib:text<#1e>extents", Sort String = "text<#1e>extents", "example"><Index, Doc = operations, "xlib:font<#1e>ascent", Sort String = "font<#1e>ascent", "example"><Index, Doc = operations, "xlib:font<#1e>descent", Sort String = "font<#1e>descent", "example"><Index, Doc = operations, "xlib:with<#1e>state", Sort String = "with<#1e>state", "example"><Index, Doc = operations, "xlib:drawable<#1e>width", Sort String = "drawable<#1e>width", "example"><Index, Doc = operations, "xlib:drawable<#1e>height", Sort String = "drawable<#1e>height", "example"><Index, Doc = operations, "xlib:drawable<#1e>x", Sort String = "drawable<#1e>x", "example"><Index, Doc = operations, "xlib:drawable<#1e>y", Sort String = "drawable<#1e>y", "example"><Index, Doc = operations, "xlib:map<#1e>subwindows", Sort String = "map<#1e>subwindows", "example">
(defun menu-recompute-geometry (menu)<HR>
  (when (menu-geometry-changed-p menu)<HR>
    (let* ((menu-font   (GCONTEXT-FONT (menu-gcontext menu)))<HR>
          (title-width (TEXT-EXTENTS menu-font (menu-title menu)))<HR>
          (item-height (+ (FONT-ASCENT menu-font)<HR>
                          (FONT-DESCENT menu-font)<HR>
                          *menu-item-margin*))<HR>
          (item-width  0)<HR>
          (items       (menu-item-alist menu))<HR>
          menu-width)<HR>
<HR>
     ;; Find max item string width<HR>
     (setf item-width<HR>
           (+ *menu-item-margin*<HR>
              (dolist (next-item items item-width)<HR>
                (setf item-width (max item-width <HR>
                                      (TEXT-EXTENTS menu-font (second 
next-item)))))))<HR>
<HR>
     ;; Compute final menu width, taking margins into account<HR>
     (setf menu-width (max title-width (+ item-width *menu-item-margin*)))<HR>
     (let ((window  (menu-window menu)))<HR>
 <HR>
<Tab>   ;; Update width and height of menu window <HR>
     (WITH-STATE (window)<HR>
       (setf (DRAWABLE-WIDTH  window) menu-width<HR>
             (DRAWABLE-HEIGHT window) (* (1+ (length items)) item-height)))<HR>
<HR>
<Tab>   ;; Update width, height, position of item windows<HR>
<Tab>   (let ((item-left     (round (- menu-width item-width) 2))<HR>
           (next-item-top (- item-height (round *menu-item-margin* 
2))))<HR>
       (dolist (next-item items)<HR>
         (let ((window (first next-item)))<HR>
           (WITH-STATE (window)<HR>
             (setf (DRAWABLE-HEIGHT window) item-height<HR>
                   (DRAWABLE-WIDTH  window) item-width<HR>
                   (DRAWABLE-X      window) item-left<HR>
                   (DRAWABLE-Y      window) next-item-top)))<HR>
         (incf next-item-top item-height))))<HR>
<HR>
     ;; Map all item windows<HR>
     (MAP-SUBWINDOWS (menu-window menu))<HR>
<HR>
     ;; Save item geometry<HR>
     (setf (menu-item-width menu)         item-width<HR>
           (menu-item-height menu)        item-height<HR>
           (menu-width menu)              menu-width<HR>
           (menu-title-width menu)        title-width<HR>
           (menu-geometry-changed-p menu) nil))))

<para>

Of course, the sample client must know how to draw/redraw the menu 
and its items, so the function <F6>menu<#1e>refresh<F0> is defined 
next to handle that task (shown in the following example). Note that 
the location of window output is given relative to the window origin. 
Windows and subwindows have different coordinate systems. The location 
of the origin (upper<#1e>left corner) of a subwindow's coordinate 
system is given with respect to its parent window's coordinate system. 
Negative coordinates are valid, although only output to the +x/+y 
quadrant of a window's coordinate system will ever be visible.<Index, "CLX", Sort String = clx, "examples", "drawing/redrawing menus", To Next>

<lisp>

<|,"1<#1e>8"><Index, Doc = operations, "xlib:font<#1e>ascent", Sort String = "font<#1e>ascent", "example"><Index, Doc = operations, "xlib:gcontext<#1e>font", Sort String = "gcontext<#1e>font", "example"><Index, Doc = operations, "xlib:gcontext<#1e>background", Sort String = "gcontext<#1e>background", "example"><Index, Doc = operations, "xlib:gcontext<#1e>foreground", Sort String = "gcontext<#1e>foreground", "example"><Index, Doc = operations, "xlib:with<#1e>gcontext", Sort String = "with<#1e>gcontext", "example"><Index, Doc = operations, "xlib:draw<#1e>image<#1e>glyphs", Sort String = "draw<#1e>image<#1e>glyphs", "example">
(defun menu-refresh (menu)<HR>
 (let* ((gcontext   (menu-gcontext menu))<HR>
        (baseline-y (FONT-ASCENT (GCONTEXT-FONT gcontext))))<HR>
   ;; Show title centered in <#7f>reverse-video"<HR>
   (let ((fg (GCONTEXT-BACKGROUND gcontext))<HR>
         (bg (GCONTEXT-FOREGROUND gcontext)))<HR>
     (WITH-GCONTEXT (gcontext :foreground fg :background bg)<HR>
       (DRAW-IMAGE-GLYPHS<HR>
         (menu-window menu)<HR>
         gcontext<HR>
         (round (- (menu-width menu)<HR>
                   (menu-title-width menu)) 2)  ;start x<HR>
         baseline-y                             ;start y<HR>
         (menu-title menu))))<HR>
<HR>
   ;; Show each menu item (position is relative to item window)<HR>
   (let ((box-margin (round *menu-item-margin*  2)))<HR>
     (dolist (item (menu-item-alist menu))<HR>
       (DRAW-IMAGE-GLYPHS<HR>
         (first item) gcontext<HR>
         box-margin                             ;start x<HR>
         (+ baseline-y box-margin)              ;start y<HR>
         (second item))))))

<para>

<F8>with<#1e>gcontext<F0> is a CLX macro that allows you temporarily 
to modify a graphics context within the dynamic scope of the macro 
body. <F8>draw<#1e>image<#1e>glyphs<F0> is a CLX text drawing function 
which produces a terminal<#1e>like rendering: foreground character 
on a background block. (More sophisticated text rendering functions 
are also available.) The strange use of <F2>glyphs<F0> instead of <F2>string
<F0> here actually highlights an important fact: X and Common Lisp 
have totally different concepts of a character. A Common Lisp character 
is an object whose implementation can comprehend a vast universe of 
text complexities (typefaces, type styles, international character 
sets, symbols, and so forth). However, to X, a string is just a sequence 
of integer indexes into the array of bitmaps represented by a CLX 
font object. In general, <F8>draw<#1e>image<#1e>glyphs<F0>, <F8>text<#1e>ext
ents<F0>, and other CLX text functions accept a <F8>:translate<F0> 
keyword argument. Its value is a function which translates the characters 
of a string argument into the appropriate font<#1e>and<#1e>index pairs 
needed by CLX. This example relies upon the default translation function, 
which simply uses <F8>char<#1e>code<F0> to compute an index into 
the current font.

<p2rule>

<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2para,
	Font =			F3>

<Tab><Index, "CLX", Sort String = clx, "examples", "menu processing of user input", To Next><F8>Menu Input<Tab>1.3.3<F0><#04>Now that 
a menu can be displayed, the sample client program must define how 
the menu will process user input. The <F6>menu<#1e>choose<F0> function 
(shown in the following example) has the classic structure of an X 
client program. First, do some initialization (for example, present 
the menu at a given location). Then, enter an input event loop. Read 
an input event, process it, and repeat the loop until a termination 
event is received. The <F8>event<#1e>case<F0> macro continues reading 
an event from the menu window's display object until one of its clauses 
returns non<#1e><F8>nil<F0>. These clauses specify the action to 
be taken for each event type and also bind values from the event report 
to local variables, such as the <F8>event<#1e>window<F0> receiving 
the event. Notice that the <F8>:force<#1e>output<#1e>p<F0> option 
is enabled, causing <F8>event<#1e>case<F0> to begin by sending any 
client requests which CLX has not yet output to the server. To improve 
performance, CLX quietly queues up requests and periodically sends 
them off in a batch. However, in an interactive feedback loop such 
as this, it is important to keep the display crisply up<#1e>to<#1e>date.

<lisp,
	Left Margin =		1.25 inches>

<|,"1<#1e>9"><Index, Doc = operations, "xlib:event<#1e>case", Sort String = "event<#1e>case", "example"><Index, Doc = operations, "xlib:drawable<#1e>display", Sort String = "drawable<#1e>display", "example"><F8><Index, "event", ":exposure", Sort String = exposure, "example"><Index, ":exposure event", Sort String = "exposure event", "example"><Index, ":button<#1e>release event", Sort String = "button<#1e>release event", "example"><Index, "event", ":button<#1e>release", Sort String = "button<#1e>release", "example"><Index, ":enter<#1e>notify event", Sort String = "enter<#1e>notify event", "example"><Index, "event", ":enter<#1e>notify", Sort String = "enter<#1e>notify", "example"><Index, ":leave<#1e>notify event", Sort String = "leave<#1e>notify event", "example"><Index, "event", ":leave<#1e>notify", Sort String = "leave<#1e>notify", "example"><Index, Doc = operations, "xlib:unmap<#1e>window", Sort String = "unmap<#1e>window", "example">
<F0>(defun menu-choose (menu x y)<HR>
  ;; Display the menu so that first item is at x,y.<HR>
  (menu-present menu x y)<HR>
<HR>
   (let ((items (menu-item-alist menu))<HR>
         (mw    (menu-window menu))<HR>
         selected-item)<HR>
   <HR>
    ;; Event processing loop<HR>
    (do () (selected-item)<HR>
      (EVENT-CASE ((DRAWABLE-DISPLAY mw) :force-output-p t)<HR>
        (:exposure<HR>
          (count)<HR>
          ;; Discard all but final :exposure then display the menu<HR>
          (when (zerop count) (menu-refresh menu))<HR>
          t)<HR>
<HR>
        (:button-release<HR>
          (event-window)<HR>
          ;;Select an item<HR>
          (setf selected-item (second (assoc event-window items)))<HR>
          t)<HR>
<HR>
        (:enter-notify<HR>
          (window)<HR>
          ;;Highlight an item<HR>
          (menu-highlight-item menu (find window items :key #'first))<HR>
          t)<HR>
<HR>
        (:leave-notify<HR>
          (window kind)<HR>
          (if (eql mw window)<HR>
              ;; Quit if pointer moved out of main menu window<HR>
              (setf selected-item (when (eq kind :ancestor) :none))<HR>
              ;; Otherwise, unhighlight the item window left<HR>
              (menu-unhighlight-item menu (find window items :key 
#'first)))<HR>
            t) <HR>
<HR>
          (otherwise<HR>
            ()<HR>
            ;;Ignore and discard any other event<HR>
            t)))<HR>
<HR>
        ;; Erase the menu<HR>
        (UNMAP-WINDOW mw)<HR>
<HR>
        ;; Return selected item string, if any<HR>
        (unless (eq selected-item :none) selected-item)))    

<para>

The event loop in <F6>menu<#1e>choose<F0> demonstrates an idiom 
used in all X programs: the contents of a window are displayed (in 
this case, by calling <F6>menu<#1e>refresh<F0>) only when an <F8>:exposure
<F0> event<F8> <F0>is received, signaling that the server has actually 
made the window <F2>viewable<F0>. The handling of <F8>:exposure<F0> 
in <F6>menu<#1e>choose<F0> also implements a little trick for improving 
efficiency. In general, when a window is exposed after being previously 
obscured (perhaps only partially), the server is free to send several <F8>:exp
osure<F0> events, one for each rectangular tile of the exposed region. 
For small windows like this menu, it is not worth the trouble to redraw 
the image one tile at a time. So the code above just ignores all but 
the last tile exposure and redraws everything in one call to <F6>menu<#1e>refr
esh<F0>.

<p2rule,
	New Page =		yes>

<|,"1<#1e>10">
<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Tab><Index, "CLX", Sort String = clx, "examples", "main client program"><F8>The Main<Tab>1.3.4<F0><#04>After all 
the preceding build<#1e>up and the other functions referenced<F8><FJ>

<p2para,
	Font =			F3>

<Tab><F8> Program<Tab><F0>(but not shown here) have been implemented, 
the code for the main client program is very small.

<lisp,
	Left Margin =		1.45 inches>

<Index, Doc = operations, "xlib:open<#1e>display", Sort String = "open<#1e>display", "example"><Index, Doc = operations, "xlib:display<#1e>roots", Sort String = "display<#1e>roots", "example"><Index, Doc = operations, "xlib:screen<#1e>black<#1e>pixel", Sort String = "screen<#1e>black<#1e>pixel", "example"><Index, Doc = operations, "xlib:screen<#1e>white<#1e>pixel", Sort String = "screen<#1e>white<#1e>pixel", "example"><Index, Doc = operations, "xlib:open<#1e>font", Sort String = "open<#1e>font", "example"><Index, Doc = operations, "xlib:screen<#1e>root", Sort String = "screen<#1e>root", "example"><Index, Doc = operations, "xlib:query<#1e>pointer", Sort String = "query<#1e>pointer", "example"><Index, Doc = operations, "xlib:close<#1e>display", Sort String = "close<#1e>display", "example">
(defun just-say-lisp (host &optional (font-name <#7f>fg-16"))<HR>
  (let* ((display   (OPEN-DISPLAY host))<HR>
         (screen    (first (DISPLAY-ROOTS display)))<HR>
         (fg-color  (SCREEN-BLACK-PIXEL screen))<HR>
         (bg-color  (SCREEN-WHITE-PIXEL screen))<HR>
         (nice-font (OPEN-FONT display font-name))<HR>
<HR>
         ;; Create a menu as a child of the root window.<HR>
         (a-menu    (create-menu (SCREEN-ROOT screen)<HR>
                                 fg-color bg-color nice-font)))<HR>
<HR>
    (setf (menu-title a-menu) <#7f>Please pick your favorite language:")<HR>
    (menu-set-item-list a-menu <#7f>Fortran" <#7f>APL" <#7f>Forth" 
<#7f>Lisp")<HR>
<HR>
    ;; Bedevil the user until he picks a nice programming language<HR>
    (unwind-protect<HR>
        (loop<HR>
          ;; Determine the current root window position of the pointer<HR>
          (multiple-value-bind (x y) (QUERY-POINTER (SCREEN-ROOT screen))<HR>
<HR>
           (let ((choice (menu-choose a-menu x y)))<HR>
             (when (string-equal <#7f>Lisp" choice)<HR>
               (return))))) <HR>
<HR>
<HR>
     (CLOSE-DISPLAY display))))

<para>

Note that the main program event loop lies in the body of an <F8>unwind<#1e>pr
otect<F0> form. This is a good programming technique because, without 
this protection, an unexpected error could cause the program to terminate 
without freeing the <F2>server resources<F0> it has created. Server 
resources are CLX objects which refer to objects actually stored on 
the X server. Examples of these are <F8>window<F0>,<F8> font<F0>,<F8> 
pixmap<F0>,<F8> cursor<F0>,<F8> colormap<F0>, and <F8>gcontext <F0>objec
ts. These server resources are created and destroyed by user requests. 
Server resources created by a client are also destroyed when its display 
connection is closed. If client resources are repeatedly created without 
being destroyed, then the server will eventually run out of memory 
and fail.

Most server resources are potentially sharable between applications. 
In fact, windows are manipulated explicitly by window manager programs. 
Fonts and cursors are typically shared automatically since the X server 
loads and unloads font storage as needed. <F8>gcontext<F0> objects 
are not ordinarily shared between client applications.

<p2rule>

<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Tab><F8>Debugging<Tab>1.3.5<F0><#04>Typically, most CLX programs 
do not need to control the buffering<F8><FJ>

<p2para,
	Font =			F3>

<Tab><F8>With CLX<Tab><F0>of output requests directly. However, 
CLX programmers need to be aware of the asynchronous nature of client<#1e>serve
r communication. It may be convenient to control the CLX output buffer 
more directly, especially during debugging.

<para>

A client that wants a request to execute immediately instead of asynchronously 
can follow it with a call to <F8>display<#1e>force<#1e>output<F0>. 
This function <F2>blocks<F0> (does not return) until all previously 
buffered output requests have been sent. Otherwise, the output buffer 
is always flushed by a call to any function which returns a value 
from the server or which waits for input (for example, <F8>get<#1e>property
<F0>). Certain output requests can cause input events to be sent. 
For example, <F8>map<#1e>window<F0> can cause <F8>:exposure<F0> 
events to be sent. Synchronizing output with the resulting input can 
be done with the <F8>display<#1e>finish<#1e>output<F0> function. 
This function blocks until all previously buffered output has been 
sent and all resulting input events have been received.

<|,"1<#1e>11">Functions that return information from the server block until 
an explicit reply is received or an error occurs. If a nonblocking 
call results in an error, the error is generally not reported until 
later. All errors (synchronous and asynchronous) are processed by 
calling an error handler defined for the display. If the handler is 
a sequence it is expected to contain handler functions specific to 
each error. The error code is used to index the sequence, fetching 
the appropriate handler. Any results returned by the handler are ignored 
since it is assumed that the handler either takes care of the error 
completely, or else signals.

<p1rule>

<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F7>Naming and<Tab><F8>1.4<F0><#04>Throughout CLX, a number of 
conventions for naming and syntax of<FJ>

<p1stacked,
	Left Tab =		-1.60/0 inches>

<F7>Argument<F0><Tab><F3>the CLX functions have been followed. 
These conventions are intended to<FJ>

<p1para,
	Font =			F3,
	Allow Page Break After = yes>

<F7>Conventions<Tab><F0>make the syntax of the functions more predictable. 
<F8><#04>

<para>

The major naming conventions are as follows: 

<bullet>

<F9>w<Tab><F0>To better differentiate the CLX symbols from other 
symbols, they have all been placed in the package XLIB. External symbols 
have been explicitly exported. 

<F9>w<Tab><F0>The <F2>display<F0> argument, where used, is always 
first in the argument list. 

<F9>w<Tab><F0>All server resource objects, where used, occur at 
the beginning of the argument list, immediately after the display 
variable. 

<F9>w<Tab><F0>When a graphics context (<F2>gcontext<F0>) is present 
together with another type of server resource (most commonly, a <F2>drawable
<F0>), the graphics context occurs in the argument list after the 
other server resource. Drawables out rank all other server resources.

<F9>w<Tab><F0>Source arguments always precede the destination arguments 
in the argument list. 

<F9>w<Tab><F0>The <F2>x<F0> argument always precedes the <F2>y<F0> 
argument in the argument list. 

<F9>w<Tab><F0>The <F2>width<F0> argument always precedes the <F2>height
<F0> argument in the argument list. 

<bullet,
	Bottom Margin =		0.14 inches>

<F9>w<Tab><F0>Where the <F2>x<F0>, <F2>y<F0>, <F2>width<F0> 
and <F2>height<F0> arguments are used together, the <F2>x<F0> 
and <F2>y<F0> arguments always precede the <F2>width<F0> and <F2>height
<F0> arguments. 

<F9>w<Tab><F0>Where a <F2>mask<F0> is accompanied with a <F2>structure
<F0>, the mask always precedes the structure in the argument list. 

<p1rule>

<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F7>Programming<Tab><F8>1.5<F0><#04>The major programming considerations 
are as follows: <F8><#04>

<p1para,
	Bottom Margin =		0 inches,
	Font =			F3,
	Allow Page Break After = yes>

<F7>Considerations<Tab>

<bullet,
	Bottom Margin =		0.14 inches>

<F9>w<Tab><F0>Keyboards are the greatest variable between different 
manufacturer's workstations. If you want your program to be portable, 
you should be particularly conservative here. 

<F9>w<Tab><F0>Many display systems have limited amounts of off<#1e>screen 
memory. If you can, you should minimize use of pixmaps and backing 
store. 

<F9>w<Tab><F0>The user should have control of his screen real<#1e>estate. 
Therefore, you should write your applications to react to window management, 
rather than presume control of the entire screen. What you do inside 
of your top level window, however, is up to your application. 

<|,"1<#1e>12"><F9>w<Tab><F0>Coordinates and sizes in X are actually 16<#1e>bit 
quantities. They usually are declared as an <F8>int16<F0> in the 
functions. Values larger than 16 bits can be truncated silently. Sizes 
(width and height) are unsigned quantities. 

<F9>w<Tab><F0>The types <F8>color<F0>, <F8>colormap<F0>, <F8>cursor
<F0>, <F8>display<F0>, <F8>font<F0>, <F8>gcontext<F0>, <F8>pixmap<F0>, 
<F8>screen<F0>, and <F8>window<F0> are defined solely by a functional 
interface. Even though they are treated like structures in this document, 
it is not specified whether they are implemented as structures or 
classes. Although some interfaces are described as functions, they 
are not required to be defined using <F8>defun.<F0> (It is a requirement 
that they be functions as opposed to macros or special forms.) 

<p1rule>

<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F7>Data Types<Tab><F8>1.6<F0><#04>The following are some data 
type definitions that are commonly used in

<p1para,
	Font =			F3,
	Allow Page Break After = yes>

<F7><Tab><F0>CLX function definitions.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

alist <F3>(<F2>key<#1e>type<#1e>and<#1e>name datum<#1e>type<#1e>and<#1e>name
<F3>) <F0>'list<F3><Tab>Type<Index, Doc = flavors, "xlib:alist", Sort String = alist>

<para>

<F8>alist<F0> defines an association list. An association list is 
a sequence, containing zero or more repetitions of the given elements 
with each of the elements expressed as (<F2>type name<F0>). 

<syntax>

angle <F3>`(<F0>number<F3> ,(* -2pi) ,(* 2pi))<Tab>Type<Index, Doc = flavors, "xlib:angle", Sort String = angle>

<para>

<F8>angle<F0> defines an angle in units of radians and is bounded 
by (-2<F11>p<F0>) and (2<F11>p<F0>). Note that we are explicitly 
using a different angle representation than what is actually transmitted 
in the protocol. 

<syntax>

arc<#1e>seq <F3>'(<F0>repeat<#1e>seq<F3> (<F0>int16<F3> <F2>x<F3>) 
(<F0>int16<F3> <F2>y<F3>) (<F0>card16<F3> <F2>width<F3>) (<F0>card16
<F3> <F2>height<F3>) <Tab>Type<Index, Doc = flavors, "xlib:arc<#1e>seq", Sort String = "arc<#1e>seq"><HR>
(<F0>angle<F3> <F2>angle1<F3>) (<F0>angle<F3> <F2>angle2<F3>))

<para>

<F8>arc<#1e>seq<F0> defines a six<#1e>tuple sequence of the form 
(<F2>x<F0>, <F2>y<F0>, <F2>width<F0>, <F2>height<F0>, <F2>angle1<F0>, 
<F2>angle2<F0>). The points <F2>x<F0> and <F2>y<F0> are signed, 
16<#1e>bit quantities with a range from -32,768 to 32,767. The <F2>width<F0> 
and <F2>height<F0> values are unsigned, 16<#1e>bit quantities and 
range from 0 to 65,535. <F2>angle1<F0> and <F2>angle2<F0> are 
in units of radians, and bounded by (-2<F11>p<F0>) and (2<F11>p<F0>). 

<syntax>

array<#1e>index <F3>`(<F0>integer<F3> 0 ,<F2>array<#1e>dimension<#1e>limit
<F3>)<Tab>Type<Index, Doc = flavors, "xlib:array<#1e>index", Sort String = "array<#1e>index">

<para>

<F8>array<#1e>index<F0> defines a type which is a subtype of the 
integers and can be used to describe all variables that can be array 
indices. The range is inclusive because start and end array index 
specifiers can be one (1) past the end. 

<syntax,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

bit<#1e>gravity <F3>'<F6>(<F0>member <F2>gravity*<F3>)<Tab>Type<Index, Doc = flavors, "xlib:bit<#1e>gravity", Sort String = "bit<#1e>gravity">

<para>

A keyword that specifies which region of a window should be retained 
when the window is resized.

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

 gravity <F3><#1f> One of the following:

<argtable,
	Left Tab =		0/0.80/1.80/2.50/2.80/3.80/6.75/0.75*4 inches>

<F8>:center<Tab>:north<Tab>:south<Tab><Tab>:static<F0><HR>
<F8>:east<Tab>:north<#1e>east<Tab>:south<#1e>east<Tab>:west<F0><HR>
<F8>:forget<Tab>:north<#1e>west<Tab>:south<#1e>west

<para>

If a window is reconfigured without changing its inside width or height, 
then the contents of the window moves with the window and are not 
lost. Otherwise, the contents of a resized window are either moved 
or lost, depending on its bit<#1e>gravity attribute. See <F8>window<#1e>bit<#1e>
gravity<F0>, in paragraph 4.3, Window Attributes, for additional 
information.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

bitmap <F3>'(<F0>array bit<F3> (* *))<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:bitmap", Sort String = bitmap>

<para>

Specifies a two<#1e>dimensional array of bits.

<thinrule,
	Left Margin =		0 inches>

<|,"1<#1e>13"><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab->

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

bitmap<#1e>format<Tab><F3>Structure<Index, Doc = flavors, "xlib:bitmap<#1e>format", Sort String = "bitmap<#1e>format">

<para>

A structure that describes the storage format of a bitmap.

The <F8>bitmap<#1e>format<F0> structure contains slots for <F8>unit<F0>, 
<F8>pad<F0>, and <F8>lsb<#1e>first<#1e>p<F0>. The <F8>unit<F0> 
member indicates the unit of increments used to maintain the bitmap 
data. The units available for use are 8, 16, or 32 bits. The <F8>pad<F0> 
member indicates how many bits are needed to pad the left edge of 
the scan<#1e>line. The <F8>lsb<#1e>first<#1e>p<F0> member is a predicate 
which indicates the ordering of bits with the bitmap unit.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

unit<Tab><F3><Tab>Slot of <F0>bitmap<#1e>format

<synpara>

Type: (<F8>member <F0>8 16 32).

<para>

The size of a contiguous grouping of bits, which can be 8, 16, or 
32. The default is 8.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

pad<Tab><F3><Tab>Slot of <F0>bitmap<#1e>format

<synpara>

Type: (<F8>member <F0>8 16 32).

<para>

The number of bits to left<#1e>pad the scan<#1e>line, which can be 
8, 16, or 32. The default is 8.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

lsb<#1e>first<#1e>p<Tab><F3><Tab>Slot of <F0>bitmap<#1e>format

<synpara>

Type: <F8>boolean<F0>.

<para>

A predicate indicating whether the least significant bit comes first 
(<F8>true<F0>) or not (<F8>nil<F0>).

<thinrule,
	Left Margin =		0 inches>

<Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab->

<syntax,
	New Page =		yes>

<|,"1<#1e>14">boolean <F3>'(<F0>or<F3> <F0>nil<F3> (<F0>not<F3> <F0>nil<F3>))<Tab>
Type<Index, Doc = flavors, "xlib:boolean", Sort String = boolean>

<para>

<F8>boolean<F0> defines a type which is all inclusive. It is used 
for variables that can take on a true (non<#1e><F8>nil<F0>) or false 
(<F8>nil<F0>) value. 

<syntax>

boole<#1e>constant <F3>`(<F0>member<F3> <F2>value<F3>*)<Tab> 
Type<Index, Doc = flavors, "xlib:boole<#1e>constant", Sort String = "boole<#1e>constant">

<para>

<F8>boole-constant<F0> defines a type that is a set of the values 
associated with the 16 boolean operation<#1e>code constants for the 
Common Lisp language. It is used for the set of allowed source and 
destination combination functions in a graphics context. 

<arg>

value <#1f> <F3>One of the following:

<argtable,
	Left Tab =		0/0.60/1.10/1.50/2.10/2.60/3.10/9.75 inches>

<F8>boole<#1e>1<Tab><Tab>boole<#1e>c1<Tab>boole<#1e>nand<Tab>boole<#1e>xor<HR>
boole<#1e>2<Tab><Tab>boole<#1e>c2<Tab>boole<#1e>nor<Tab><HR>
boole<#1e>and<Tab>boole<#1e>clr<Tab>boole<#1e>orc1<Tab><HR>
boole<#1e>andc1<Tab>boole<#1e>eqv<Tab>boole<#1e>orc2<Tab><HR>
boole<#1e>andc2<Tab>boole<#1e>ior<Tab>boole<#1e>set<F0><Tab>

<syntax>

card8 <F3>'(<F0>unsigned<#1e>byte<F3> 8)<Tab>Type<Index, Doc = flavors, "xlib:card8", Sort String = card8>

<para>

An unsigned integer value that is a maximum of eight bits long. This 
gives a number of this type a range from 0 to 255. 

<syntax>

card16 <F3>'(<F0>unsigned<#1e>byte<F3> 16)<Tab>Type<Index, Doc = flavors, "xlib:card16", Sort String = card16>

<para>

An unsigned integer value that is a maximum of 16 bits long. This 
gives a number of this type a range from 0 to 65,535. 

<syntax>

card29 <F3>'(<F0>unsigned<#1e>byte<F3> 29)<Tab>Type<Index, Doc = flavors, "xlib:card29", Sort String = card29>

<para>

An unsigned integer value that is a maximum of 29 bits long. This 
gives a number of this type a range from 0 to 536,870,911. 

<syntax>

card32 <F3>'(<F0>unsigned<#1e>byte<F3> 32)<Tab>Type<Index, Doc = flavors, "xlib:card32", Sort String = card32>

<para>

An unsigned integer value that is a maximum of 32 bits long. This 
gives a number of this type a range from 0 to 4,294,967,295. 

<syntax>

color <F3>'(<F0>satisfies<F3> <F0>color<#1e>p<F3>)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:color", Sort String = color>

<para>

A <F8>color<F0>. See paragraph 9.2, Color Functions, for additional 
information.

<syntax>

colormap <F3>'(<F0>satisfies<F3> <F0>colormap<#1e>p<F3>)<F0><Tab><F3>Typ
e<Index, Doc = flavors, "xlib:colormap", Sort String = colormap>

<para>

A <F8>colormap<F0>. See paragraph 9.3, Colormap Functions, for additional 
information.

<syntax>

cursor <F3>'(<F0>satisfies<F3> <F0>cursor<#1e>p<F3>)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:cursor", Sort String = cursor>

<para>

A <F8>cursor<F0>. See Section 10, Cursors, for additional information. 

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

device<#1e>event<#1e>mask <F3>'(<F0>or mask32<F3> (<F0>list device<#1e>even
t<#1e>mask<#1e>class<F3>))<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:device<#1e>event<#1e>mask", Sort String = "device<#1e>event<#1e>mask">

<para>

Provides a way to specify a set of bits for an event bitmask. Two 
ways of specifying the bits are allowed: by setting the event bits 
in a 32 bit mask, or by listing the keyword names of the device related 
event bits in a list.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

device<#1e>event<#1e>mask<#1e>class <F3>'<F6>(<F0>member <F2>event*<F3>)
<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:device<#1e>event<#1e>mask<#1e>class", Sort String = "device<#1e>event<#1e>mask<#1e>class">

<para>

A keyword name, for a device related event, that corresponds to a 
particular bit in an event bitmask. The set of names is a subset of 
the names in the type <F8>event<#1e>mask<#1e>class<F0>.

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

event <#1f> <F3>One of the following:

<argtable,
	Left Tab =		0/0.60/1.35/2.50/2.80/3.80/6.75/0.75*4 inches>

<|,"1<#1e>15"><F8>:button<#1e>1<#1e>motion<Tab>:button<#1e>motion<Tab><Tab><HR>
:button<#1e>2<#1e>motion<Tab>:button<#1e>press<Tab><Tab><HR>
:button<#1e>3<#1e>motion<Tab>:key<#1e>press<Tab><Tab><HR>
:button<#1e>4<#1e>motion<Tab>:key<#1e>release<Tab><Tab><HR>
:button<#1e>5<#1e>motion<Tab>:pointer<#1e>motion<Tab><Tab>

<syntax>

display <F3>'(<F0>satisfies<F3> <F0>display<#1e>p<F3>)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:display", Sort String = display>

<para>

A connection to an X server. See Section 2, Displays, for additional 
information.

<syntax>

drawable <F3>'(<F0>or window pixmap<F3>)<Tab>Type<Index, Doc = flavors, "xlib:drawable", Sort String = drawable>

<para>

Both <F8>windows<F0> and <F8>pixmaps<F0> can be used as sources 
and destinations in graphics operations. <F8>windows<F0> and <F8>pixmaps
<F0> together are known as <F2>drawables<F0>. However, an <F8>:input<#1e>on
ly<F0> window cannot be used as a source or destination in a graphics 
operation. 

<syntax>

draw<#1e>direction <F3>'(<F0>member<F3> <F0>:left<#1e>to<#1e>right<F3> 
<F0>:right<#1e>to<#1e>left<F3>)<Tab>Type<Index, Doc = flavors, "xlib:draw<#1e>direction", Sort String = "draw<#1e>direction">

<para>

Defines a list of rotation directions for drawing arcs and fonts. <F8>draw<#1e>
direction<F0> can have the values of <F8>:left<#1e>to<#1e>right<F0> 
or <F8>:right<#1e>to<#1e>left<F0>. 

<syntax>

error<#1e>key <F3>'(<F0>member<F3> <F2>error<F3>*)<Tab>Type<Index, Doc = flavors, "xlib:error<#1e>key", Sort String = "error<#1e>key">

<para,
	Bottom Margin =		0.14 inches>

Defines a list of all predefined errors. All errors (synchronous and 
asynchronous) are processed by calling an error handler in the display. 
The handler is called with the display as the first argument and the 
error<#1e>key as its second argument. 

<arg>

error<F3> <#1f> One of the following:

<argtable,
	Left Tab =		0/0.85/1.10/2/3.20/3.80/6.75/0.75*4 inches>

<F8>:access<F0><Tab><F8>:drawable<F0><Tab><F8>:implementation<Tab>:value
<F0><HR>
<F8>:alloc<F0><Tab><F8>:font<F0><Tab><F8>:length<F0><Tab><F8>:window
<F0><HR>
<F8>:atom<F0><Tab><F8>:gcontext<F0><Tab><F8>:match<F0><Tab><HR>
<F8>:colormap<F0><Tab><F8>:id<#1e>choice<F0><Tab><F8>:name<F0><Tab><HR>
<F8>:cursor<F0><Tab><F8>:illegal<#1e>request<Tab>:pixmap<F0><Tab>

<syntax>

event<#1e>key <F3>'(<F0>member<F3> <F2>event<#1e>type<F3>*) <Tab>Type<Index, Doc = flavors, "xlib:event<#1e>key", Sort String = "event<#1e>key">

<para,
	Bottom Margin =		0.14 inches>

Defines a list that specifies all predefined event<#1e>types. Clients 
are informed of information asynchronously by means of events. These 
events can be either asynchronously generated from devices or generated 
as side effects of client requests. 

<arg>

event<#1e>type<F3> <#1f> One of the following:

<argtable,
	Left Tab =		0/1.40/2.90/3.80/6.75/0.75*4 inches>

<F8>:button<#1e>press<F0><Tab><F8>:exposure<F0><Tab><F8>:motion<#1e>notify
<F0><HR>
<F8>:button<#1e>release<F0><Tab><F8>:focus<#1e>in <F0><Tab><F8>:no<#1e>exp
osure <F0><HR>
<F8>:circulate<#1e>notify<F0><Tab><F8>:focus<#1e>out<F0><Tab><F8>:property
<#1e>notify<F0><HR>
<F8>:circulate<#1e>request<F0><Tab><F8>:graphics<#1e>exposure<F0><Tab>
<F8>:reparent<#1e>notify<F0><HR>
<F8>:client<#1e>message<F0><Tab><F8>:gravity<#1e>notify<Tab>:resize<#1e>requ
est<F0><HR>
<F8>:colormap<#1e>notify<F0><Tab><F8>:keymap<#1e>notify<F0><Tab><F8>:selec
tion<#1e>clear<F0><HR>
<F8>:configure<#1e>notify <F0><Tab><F8>:key<#1e>press <F0><Tab><F8>:select
ion<#1e>notify<F0><HR>
<F8>:configure<#1e>request<F0><Tab><F8>:key<#1e>release<F0><Tab><F8>:selec
tion<#1e>request <F0><HR>
<F8>:create<#1e>notify<F0><Tab><F8>:leave<#1e>notify<F0><Tab><F8>:unmap<#1e>
notify<F0><HR>
<F8>:destroy<#1e>notify<F0><Tab><F8>:map<#1e>notify<F0><Tab><F8>:visibilit
y<#1e>notify<F0><HR>
<F8>:enter<#1e>notify<F0><Tab><F8>:map<#1e>request <F0><Tab>

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

event<#1e>mask <F3>'(<F0>or mask32<F3> (<F0>list<F3> <F0>event<#1e>mask<#1e>
class<F3>))<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:event<#1e>mask", Sort String = "event<#1e>mask">

<para>

Provides a way to specify a set of bits for an event bitmask. Two 
ways of specifying the bits are allowed: by setting the event bits 
in a 32 bit mask, or by listing the keyword names of the event bits 
in a list.

<thinrule,
	Left Margin =		0 inches>

<|,"1<#1e>16"><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab->

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

event<#1e>mask<#1e>class <F3>'<F6>(<F0>member <F2>event*<F3>)<F0><Tab>
<F3>Type<Index, Doc = flavors, "xlib:event<#1e>mask<#1e>class", Sort String = "event<#1e>mask<#1e>class">

<para>

The elements of the type<F8> event<#1e>mask<#1e>class<F0> are keyword 
names that correspond to a particular bit in an event bitmask.

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

event <#1f> <F3>One of the following:

<argtable,
	Left Tab =		0/0.60/1.35/2.50/2.80/3.80/6.75/0.75*4 inches>

<F8>:button<#1e>1<#1e>motion<Tab>:enter<#1e>window<Tab><Tab>:pointer<#1e>motio
n<#1e>hint<HR>
:button<#1e>2<#1e>motion<Tab>:exposure<Tab><Tab>:property<#1e>change<HR>
:button<#1e>3<#1e>motion<Tab>:focus<#1e>change<Tab><Tab>:resize<#1e>redirect<HR>
:button<#1e>4<#1e>motion<Tab>:key<#1e>press<Tab><Tab>:structure<#1e>notify<HR>
:button<#1e>5<#1e>motion<Tab>:key<#1e>release<Tab><Tab>:substructure<#1e>notify<HR>
:button<#1e>motion<Tab>:keymap<#1e>state<Tab><Tab>:substructure<#1e>redirect<HR>
:button<#1e>press<Tab>:leave<#1e>window<Tab><Tab>:visibility<#1e>change<HR>
:button<#1e>release<Tab>:owner<#1e>grab<#1e>button<Tab><HR>
:colormap<#1e>change<Tab>:pointer<#1e>motion<Tab><Tab>

<syntax,
	Bottom Margin =		0 inches,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

make<#1e>event<#1e>keys <F2>event<#1e>mask<F0><Tab><F3>Function<Index, Doc = operations, "xlib:make<#1e>event<#1e>keys", Sort String = "make<#1e>event<#1e>keys">

<return>

<Tab><F3>Returns:<F2> event<#1e>keywords <F3><#1f> Type <F0>list<F3>.

<para>

Returns a list of <F8>event<#1e>mask<#1e>class<F0> keyword names 
for the event bits that are set in the specified event mask. 

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

event<#1e>mask <F3><#1f> An event mask (type <F8>mask32<F3>).

<syntax,
	Bottom Margin =		0 inches,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

make<#1e>event<#1e>mask<F3> &rest <F2>keys<F0><Tab><F3>Function<Index, Doc = operations, "xlib:make<#1e>event<#1e>mask", Sort String = "make<#1e>event<#1e>mask">

<return>

<Tab><F3>Returns:<F2> <HR>
  event<#1e>mask <F3><#1f> Type <F0>mask32<F3>.

<para>

Constructs an event mask from a set of <F8>event<#1e>mask<#1e>class<F0> 
keyword names.

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

keys <F3><#1f> <F8>event<#1e>mask<#1e>class<F3> keywords.

<thinrule,
	Left Margin =		0 inches>

<Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab->

<syntax>

font <F3>'(<F0>satisfies<F3> <F0>font<#1e>p<F3>)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:font", Sort String = font>

<para>

A text font. See Section 8, Fonts and Characters, for additional information. 

<syntax>

fontable <F3>'(<F0>or stringable font<F3>)<Tab>Type<Index, Doc = flavors, "xlib:fontable", Sort String = fontable>

<para,
	Bottom Margin =		0.14 inches>

A <F8>fontable<F0> is either a <F8>font<F0> object or the name 
of one of the fonts in the font database. 

<syntax>

font<#1e>props <F3>'<F0>list<Tab><F3>Type<Index, Doc = flavors, "xlib:font<#1e>props", Sort String = "font<#1e>props">

<para,
	Bottom Margin =		0.14 inches>

A <F8>list<F0> that contains alternating keywords and integers. 

<syntax>

gcontext <F3>'(<F0>satisfies<F3> <F0>gcontext<#1e>p<F3>)<F0><Tab><F3>Typ
e<Index, Doc = flavors, "xlib:gcontext", Sort String = gcontext>

<para>

A graphics context. See Section 5, Graphics Contexts, for additional 
information.

<syntax>

gcontext<#1e>key <F3>'(<F0>member<F3> <F2>type<F3>*)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:gcontext<#1e>key", Sort String = "gcontext<#1e>key">

<para,
	Bottom Margin =		0.14 inches>

A list of predefined types for use in <F8>gcontext<F0> processing. 
Various information for graphics output is stored in a graphics context 
(GC or GContext), such as foreground pixel, background pixel, line 
width, clipping region, and so forth. 

<arg>

type<F3> <#1f> One of the following:

<argtable,
	Left Tab =		0/0.60/1/2/2.80/3.80/6.75/0.75*4 inches>

<|,"1<#1e>17"><F8>:arc<#1e>mode<F0><Tab><F8>:exposures<F0><Tab><F8>:line<#1e>width 
<F0><Tab><HR>
<F8>:background<F0><Tab><F8>:fill<#1e>rule<F0><Tab><F8>:plane-mask<HR>
:cap<#1e>style<F0><Tab><F8>:fill<#1e>style <F0><Tab><F8>:stipple<HR>
:clip<#1e>mask <F0><Tab><F8>:font<F0><Tab><F8>:subwindow<#1e>mode<F0><HR>
<F8>:clip<#1e>x<F0><Tab><F8><Tab>:foreground<F0><Tab><F8>:tile<F0><HR>
<F8>:clip<#1e>y<F0><Tab><F8><Tab>:function<F0><Tab><F8>:ts<#1e>x<F0><HR>
<F8>:dash<#1e>offset  <F0><Tab><F8>:join<#1e>style<F0><Tab><F8>:ts<#1e>y
<F0><HR>
<F8>:dashes<F0><Tab><F8><Tab>:line<#1e>style

<syntax>

grab<#1e>status <F3>'(<F0>member<F3> <F2>grab<#1e>type<F3>*)<F0><Tab>
<F3>Type<Index, Doc = flavors, "xlib:grab<#1e>status", Sort String = "grab<#1e>status">

<para,
	Bottom Margin =		0.14 inches>

There are two kinds of grabs: active and passive. An <F2>active grab <F0>occu
rs when a single client grabs the keyboard and/or pointer explicitly. 
Clients can also grab a particular keyboard key or pointer button 
in a window. The grab activates when the key or button is actually 
pressed, and is called a <F2>passive grab<F0>. Passive grabs can 
be very convenient for implementing reliable pop<#1e>up menus. 

<arg>

<F3> <F0>grab<#1e>type<F3> <#1f> One of the following:

<argtable>

<F8>:already<#1e>grabbed<F0><HR>
<F8>:frozen<F0><Tab><HR>
<F8>:invalid<#1e>time<F0><HR>
<F8>:not<#1e>viewable<F0><HR>
<F8>:success<F0><Tab>

<syntax>

image<#1e>depth <F3>'(<F0>integer<F3> 0 32)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:image<#1e>depth", Sort String = "image<#1e>depth">

<para,
	Bottom Margin =		0.14 inches>

Used in determining the depth of a pixmap, window, or image. The value 
specifies the number of bits deep<F2> <F0>that a given pixel has 
within a given pixmap, window, or image. 

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

index<#1e>size <F3>'(<F0>member :default<F3> 8 16)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:index<#1e>size", Sort String = "index<#1e>size">

<para>

Used to control the element size of the destination buffer given to 
the translate function when drawing glyphs. If <F8>:default<F0> 
is specified, the size is based on the current font, if known; otherwise, 
16 is used.

<syntax>

int8 <F3>'(<F0>signed<#1e>byte<F3> 8)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:int8", Sort String = int8>

<para,
	Bottom Margin =		0.14 inches>

A signed integer value that is a maximum of eight bits long. A number 
of this type can have a range from -128 to 127. 

<syntax>

int16 <F3>'(<F0>signed<#1e>byte<F3> 16)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:int16", Sort String = int16>

<para>

A signed integer value that is a maximum of 16 bits long. A number 
of this type can have a range from -32,768 to 32,767. 

<syntax>

int32 <F3>'(<F0>signed<#1e>byte<F3> 32)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:int32", Sort String = int32>

<para>

A signed integer value that is a maximum of 32 bits long. A number 
of this type can have a range from -2,147,483,648 to 2,147,483,647. 

<syntax>

keysym <F3>'<F0>card32<Tab><F3>Type<Index, Doc = flavors, "xlib:keysym", Sort String = keysym>

<para>

Used as an encoding of a symbol on a keycap on a keyboard. It is an 
unsigned integer value represented in a maximum of 32 bits long. A <F8>keysym
<F0> type can have a range from 0 to 4,294,967,295. 

<syntax>

mask16 <F3>' <F0>card16<Tab><F3>Type<Index, Doc = flavors, "xlib:mask16", Sort String = mask16>

<para>

A positional bitmask that contains 16 boolean flags. 

<syntax>

<|,"1<#1e>18">mask32 <F3>' <F0>card32<Tab><F3>Type<Index, Doc = flavors, "xlib:mask32", Sort String = mask32>

<para>

A positional bitmask that contains 32 boolean flags. 

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

modifier<#1e>key <F3>'(<F0>member <F2>modifier<F0>*<F3>)<F0><Tab><F3>Typ
e<Index, Doc = flavors, "xlib:modifier<#1e>key", Sort String = "modifier<#1e>key">

<para>

A keyword identifying one of the modifier keys on the keyboard device.

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

modifier <F3><#1f> One of the following:

<argtable,
	Left Tab =		0/0.90/1.80/2.50/2.80/3.80/6.75/0.75*4 inches>

<F8>:shift<Tab>:mod<#1e>2<F0><HR>
<F8>:lock<Tab>:mod<#1e>3<F0><HR>
<F8>:control<Tab>:mod<#1e>4<F0><HR>
<F8>:mod<#1e>1<Tab>:mod<#1e>5

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

modifier<#1e>mask <F3>'(<F0>or <F3>(<F0>member :any<F3>)<F0> 
mask16 <F3>(<F0>list modifier<#1e>key<F3>))<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:modifier<#1e>mask", Sort String = "modifier<#1e>mask">

<para>

A bitmask or list of keywords that specifies a set of modifier keys. 
The keyword <F8>:any<F0> is equivalent to any subset of modifier 
key.

<syntax>

pixarray <F3>'(<F0>or<F3> (<F0>array pixel<F3> (* *))<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:pixarray", Sort String = pixarray><HR>
        (<F0>array card16<F3> (* *))<HR>
        (<F0>array card8<F3> (* *))<HR>
        (<F0>array<F3> (<F0>unsigned<#1e>byte 4<F3>) (* *))<HR>
        (<F0>array bit<F3> (* *)))

<para>

Specifies a two<#1e>dimensional array of pixels.  

<syntax>

pixel <F3>'(<F0>unsigned<#1e>byte<F3> 32)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:pixel", Sort String = pixel>

<para>

An unsigned integer value that is a maximum of 32 bits long. This 
gives a pixel type a value range from 0 to 4,294,967,295. Useful values 
are dependent on the class of colormap being used. 

<syntax>

pixmap <F3>'(<F0>satisfies<F3> <F0>pixmap<#1e>p<F3>)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:pixmap", Sort String = pixmap>

<para>

A <F8>pixmap<F0>. See paragraph 4.8, Pixmaps, for additional information. 

<thinrule,
	Left Margin =		0 inches>

<Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab->

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

pixmap<#1e>format<Tab><F3>Structure<Index, Doc = flavors, "xlib:pixmap<#1e>format", Sort String = "pixmap<#1e>format">

<para>

A structure that describes the storage format of a pixmap. 

The <F8>pixmap<#1e>format<F0> structure contains slots for <F8>depth<F0>, 
<F8>bits<#1e>per<#1e>pixel<F0>, and <F8>scanline<#1e>pad<F0>. 
The <F8>depth<F0> member indicates the number of bit planes in the 
pixmap. The <F8>bits<#1e>per<#1e>pixel<F0> member indicates the 
number of bits used to represent a single pixel. For X, a pixel can 
be 1, 4, 8, 16, 24, or 32 bits wide. As for <F8>bitmap<#1e>format<F0>, 
the <F8>scanline<#1e>pad<F0> member indicates how many pixels are 
needed to pad the left edge of the scan<#1e>line.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

depth<Tab><F3><Tab>Slot of <F0>pixmap<#1e>format

<synpara>

Type: <F8>image<#1e>depth<F0>.

<para>

The number of bit planes in the pixmap.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

bits<#1e>per<#1e>pixel<Tab><F3><Tab>Slot of <F0>pixmap<#1e>format

<synpara>

Type: (<F8>member <F0>1 4 8 16 24 32).

<para>

The number of consecutive bits used to encode a single pixel. The 
default<FJ>
is 8.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<|,"1<#1e>19">scanline<#1e>pad<Tab><F3><Tab>Slot of <F0>pixmap<#1e>format

<synpara>

Type: (<F8>member <F0>8 16 32).

<para>

The number of bits to left<#1e>pad the scan<#1e>line, which can be 
8, 16, or 32. The default is 8.

<thinrule,
	Left Margin =		0 inches>

<Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab->

<syntax>

point<#1e>seq <F3>'(<F0>repeat<#1e>seq<F3> (<F0>int16<F3> <F2>x<F3>) 
(<F0>int16<F3> <F2>y<F3>))<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:point<#1e>seq", Sort String = "point<#1e>seq">

<para>

The <F8>point<#1e>seq<F0> type is used to define sequences of (<F2>x<F0>,
<F2>y<F0>) pairs of points. The paired values are 16<#1e>bit, signed 
integer quantities. This gives the points in this type a range from 
-32,768 to 32,767. 

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

pointer<#1e>event<#1e>mask <F3>'(<F0>or mask32<F3> (<F0>list pointer<#1e>ev
ent<#1e>mask<#1e>class<F3>))<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:pointer<#1e>event<#1e>mask", Sort String = "pointer<#1e>event<#1e>mask">

<para>

Provides a way to specify a set of bits for an event bitmask. Two 
ways of specifying the bits are allowed: by setting the event bits 
in a 32 bit mask, or by listing the keyword names of the pointer related 
event bits in a list.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

pointer<#1e>event<#1e>mask<#1e>class <F3>'<F6>(<F0>member <F2>event*<F3>)
<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:pointer<#1e>event<#1e>mask<#1e>class", Sort String = "pointer<#1e>event<#1e>mask<#1e>class">

<para>

A keyword name, for a pointer related event, that corresponds to a 
particular bit in an event bitmask. The set of names is a subset of 
the names in the type <F8>event<#1e>mask<#1e>class<F0>.

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

event <#1f> <F3>One of the following:

<argtable,
	Left Tab =		0/0.60/1.35/2.50/2.80/3.80/6.75/0.75*4 inches>

<F8>:button<#1e>1<#1e>motion<Tab>:button<#1e>motion<Tab><Tab>:leave<#1e>window<HR>
:button<#1e>2<#1e>motion<Tab>:button<#1e>press<Tab><Tab>:pointer<#1e>motion<HR>
:button<#1e>3<#1e>motion<Tab>:button<#1e>release<Tab><Tab>:pointer<#1e>motion<#1e>
hint<HR>
:button<#1e>4<#1e>motion<Tab>:enter<#1e>window<Tab><Tab><HR>
:button<#1e>5<#1e>motion<Tab>:keymap<#1e>state<Tab><Tab>

<syntax>

rect<#1e>seq <F3>'(<F0>repeat<#1e>seq<F3> (<F0>int16<F3> <F2>x<F3>) 
(<F0>int16<F3> <F2>y<F3>) (<F0>card16<F3> <F2>width<F3>) (<F0>card16
<F3> <F2>height<F3>))<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:rect<#1e>seq", Sort String = "rect<#1e>seq">

<para>

<F8>rect<#1e>seq<F0> defines a four<#1e>tuple sequence of the form 
(<F2>x<F0>,<F2> y<F0>, <F2>width<F0>, <F2>height<F0>). The 
points <F2>x<F0> and <F2>y<F0> are signed, 16<#1e>bit quantities 
with a range from -32,768 to 32,767. The <F2>width<F0> and <F2>height<F0> 
values are unsigned, 16<#1e>bit quantities and range from 0 to 65,535. 

<syntax>

repeat<#1e>seq <F3>(&rest <F2>elts<F3>) '<F0>sequence<Tab><F3>Type<Index, Doc = flavors, "xlib:repeat<#1e>seq", Sort String = "repeat<#1e>seq">

<para>

A subtype used to define repeating sequences. 

<syntax,
	New Page =		yes>

<|,"1<#1e>20">resource<#1e>id <F3>'<F0>card29<Tab><F3>Type<Index, Doc = flavors, "xlib:resource<#1e>id", Sort String = "resource<#1e>id">

<para>

A numeric identifier that is assigned by the server to a server resource 
object.

<syntax>

rgb<#1e>val <F3>'(<F0>float<F3> 0.0 1.0)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:rgb<#1e>val", Sort String = "rgb<#1e>val">

<para>

An <F8>rgb<#1e>val<F0> is a floating<#1e>point value between 0 and 
1 that specifies a saturation for a red, green, or blue additive primary. 
The 0 value indicates no saturation and 1 indicates full saturation. 

<syntax>

screen <F3>'(<F0>satisfies<F3> <F0>screen<#1e>p<F3>)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:screen", Sort String = screen>

<para>

A display screen. See Section 3, Screens, for further information. 

<syntax>

seg<#1e>seq <F3>'(<F0>repeat<#1e>seq<F3> (<F0>int16<F3> <F2>x1<F3>) 
(<F0>int16<F2> y1<F3>) (<F0>int16<F2> x2<F3>) (<F0>int16<F2> 
y2<F3>))<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:seg<#1e>seq", Sort String = "seg<#1e>seq">

<para>

Defines sequences of (<F2>x1<F0>, <F2>y1<F0>, <F2>x2<F0>, <F2>y2<F0>) 
sets of points. The point values are 16<#1e>bit, signed integer quantities. 
This gives the points in this type a range from -32,768 to 32,767. 

<thinrule,
	Left Margin =		0 inches>

<Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab->

<syntax>

state<#1e>mask<#1e>key <F3>'(<F0>or modifier<#1e>key<F3> (<F0>member<F3> 
<F2>button<F3>*)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:state<#1e>mask<#1e>key", Sort String = "state<#1e>mask<#1e>key">

<para>

A keyword identifying one of the display modifier keys or pointer 
buttons whose state is reported in device events.

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

button <F3><#1f> One of the following:

<argtable,
	Left Tab =		0/0.90/1.80/2.50/2.80/3.80/6.75/0.75*4 inches>

<F8>:button<#1e>1<F0><Tab><F8>:button<#1e>4<F0><HR>
<F8>:button<#1e>2<F0><Tab><F8>:button<#1e>5<F0><HR>
<F8>:button<#1e>3<F0><Tab>

<syntax,
	Bottom Margin =		0 inches,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

make<#1e>state<#1e>keys<F6> <F2>state<#1e>mask<F0><Tab><F3>Function<Index, Doc = operations, "xlib:make<#1e>state<#1e>keys", Sort String = "make<#1e>state<#1e>keys">

<return>

<Tab><F3>Returns:<F2> <HR>
  state<#1e>keywords <F3><#1f> Type <F0>list<F3>.

<para>

Returns a list of <F8>state<#1e>mask<#1e>key<F0> symbols corresponding 
to the <F2>state<#1e>mask<F0>. A symbol belongs to the returned 
list if, and only if, the corresponding <F2>state<#1e>mask<F0> bit 
is 1.

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

state<#1e>mask <F3><#1f> A 16<#1e>bit mask of type <F8>mask16<F3>.

<syntax,
	Bottom Margin =		0 inches,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

make<#1e>state<#1e>mask<F6> <F3>&rest <F2>keys<F0><Tab><F3>Function<Index, Doc = operations, "xlib:make<#1e>state<#1e>mask", Sort String = "make<#1e>state<#1e>mask">

<return>

<Tab><F3>Returns:<F2> <HR>
  mask <F3><#1f> Type <F0>mask16<F3>.

<para>

Returns a 16<#1e>bit <F2>mask<F0> representing the given <F8>state<#1e>mask<#1e>
key<F0> symbols. The returned <F2>mask<F0> contains a 1 bit for 
each keyword.

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

keys <F3><#1f> A list of <F8>state<#1e>mask<#1e>key<F3> symbols.

<thinrule,
	Left Margin =		0 inches>

<Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab->

<syntax>

stringable <F3>'(<F0>or string symbol<F3>)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:stringable", Sort String = stringable>

<para>

Used for naming something. This type can be either a string or a <F8>symbol
<F0> whose <F8>symbol<#1e>name<F0> is used as the string containing 
the name. The case of the characters in the string is ignored when 
comparing stringables. 

<syntax,
	New Page =		yes>

<|,"1<#1e>21">timestamp <F3>'(<F0>or null<F3> <F0>card32<F3>)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:timestamp", Sort String = timestamp>

<para>

An encoding of a time. <F8>nil<F0> stands for the current time. 

<thinrule,
	Left Margin =		0 inches>

<Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab->

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

visual<#1e>info<Tab><Tab><F3>Structure<Index, Doc = flavors, "xlib:visual<#1e>info", Sort String = "visual<#1e>info">

<para>

A structure that represents a visual type. The elements of this structure 
are <F8>id<F0>, <F8>class<F0>, <F8>red<#1e>mask<F0>,<F8> green<#1e>mask
<F0>, <F8>blue<#1e>mask<F0>, <F8>bits<#1e>per<#1e>rgb<F0>, and <F8>colorm
ap<#1e>entries<F0>.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

id<Tab><Tab><F3>Slot of <F0>visual<#1e>info

<synpara>

Type: <F8>card29<F0>.

<para>

A unique identification number.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

class<Tab><Tab><F3>Slot of <F0>visual<#1e>info

<synpara>

Type: (<F8>member<F0> <F8>:direct<#1e>color<F0> <F8>:gray<#1e>scale<F0> 
<F8>:pseudo<#1e>color<F0> <F8>:static<#1e>color<HR>
      <F0> <F8> :static<#1e>gray<F0> <F8>:true<#1e>color<F0>).

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

<F3>The class of the visual type.

<syntax>

red<#1e>mask<F3>,<F0> green<#1e>mask<F3>,<F0> blue<#1e>mask<Tab><F3>Slots 
of <F0>visual<#1e>info

<synpara>

Type:<F8> pixel<F0>.

<para>

The <F8>red<#1e>mask<F0>, <F8>green<#1e>mask<F0>, and <F8>blue<#1e>mask
<F0> elements are only meaningful for the <F8>:direct<#1e>color<F0> 
and <F8>:true<#1e>color<F0> classes. Each mask has one contiguous 
set of bits with no intersections.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

bits<#1e>per<#1e>rgb<Tab><Tab><F3>Slot of <F0>visual<#1e>info

<synpara>

Type: <F8>card8<F0>.

<para>

Specifies the log base 2 of the approximate number of distinct color 
values (individually) of red, green, and blue. Actual RGB values are 
unsigned 16<#1e>bit numbers.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

colormap<#1e>entries<Tab><F3>Slot of <F0>visual<#1e>info

<synpara>

Type: <F8>card16<F0>.

<para>

Defines the number of available colormap entries in a newly created 
colormap. For <F8>:direct<#1e>color<F0> and <F8>:true<#1e>color<F0>, 
this is the size of an individual pixel subfield.

<thinrule,
	Left Margin =		0 inches>

<Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab-><Tab->

<syntax,
	Bottom Margin =		0.08 inches,
	New Page =		yes,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<|,"1<#1e>22">win<#1e>gravity <F3>'<F6>(<F0>member <F2>gravity*<F3>)<Tab>Type<Index, Doc = flavors, "xlib:win<#1e>gravity", Sort String = "win<#1e>gravity">

<para>

A keyword that specifies how to reposition a window when its parent 
is resized.

<arg,
	Bottom Margin =		0.08 inches,
	Left Tab =		-0.25/0 inches>

gravity <F3><#1f> One of the following:

<argtable,
	Left Tab =		0/0.90/1.80/2.50/2.80/3.80/6.75/0.75*4 inches>

<F8>:center<F0><Tab><F8>:north<#1e>west<Tab>:static<Tab><F0><HR>
<F8>:east<F0><Tab><F8>:south<F0><Tab><F8>:unmap<F0><Tab><HR>
<F8>:north<F0><Tab><F8>:south<#1e>east<F0><Tab><F8>:west<F0><Tab><HR>
<F8>:north<#1e>east<F0><Tab><F8>:south<#1e>west<F0><Tab>

<para>

If a parent window is reconfigured without changing its inside width 
or height, then all child windows move with the parent and are not 
changed. Otherwise, each child of the resized parent is moved, depending 
on the child's gravity attribute. See <F8>window<#1e>gravity<F0>, 
in paragraph 4.3, Window Attributes, for additional information.

<syntax>

window <F3>'(<F0>satisfies<F3> <F0>window<#1e>p<F3>)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:window", Sort String = window>

<para>

A window. See Section 4, Windows and Pixmaps, for additional information.

<syntax>

xatom <F3>'(<F0>or string symbol<F3>)<F0><Tab><F3>Type<Index, Doc = flavors, "xlib:xatom", Sort String = xatom>

<para>

A name that has been assigned a corresponding unique ID by the server. <F8>xat
oms<F0> are used to identify properties, selections, and types defined 
in the X server. An <F8>xatom<F0> can be either a <F8>string<F0> 
or <F8>symbol<F0> whose <F8>symbol<#1e>name<F0> is used as the <F8>xatom
<F0> name. The case of the characters in the string are significant 
when comparing <F8>xatoms<F0>. 

