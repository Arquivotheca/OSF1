<!OPS, Version = 5.2>

<!Document,
	Print Rev Bars =	no,
	Final Output Device =	"ps",
	Default Printer =	"nearest-adps">

<!Font Definitions,
	F2 = Times 10 Italic,
	F3 = Times 10,
	F4 = Times 8 Italic,
	F5 = Times 18 Bold,
	F6 = Times 10 Bold,
	F7 = Times 18,
	F8 = Times 12 Bold,
	F9 = Symbol_B 8>

<!Page,
	Bottom Margin =		1 inches,
	Left Margin =		1 inches,
	Right Margin =		1.15 inches,
	First Page =		Right,
	Starting Page # = 	Inherit,
	Page # Prefix =		"14<#1e>",
	Hyphenation =		on,
	Consecutive Hyphens =	2,
	Vert. Just. =		off>

<!Autonumber Stream, List, 2,
	Level 2 Suffix =	,
	Level 2 Starting Value = 0,
	Level 2 Show =		no>

<!Autonumber Stream, Outline, 3,
	Level 1 Symbol Type =	UPPER ROMAN,
	Level 2 Symbol Type =	UPPER ALPHA>

<!Autonumber Stream, figure, 2,
	Level 1 Prefix =	"Figure ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	,
	Level 2 Starting Value = 0,
	Level 2 Show =		no>

<!Autonumber Stream, figurelet, 2,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Prefix =	"Figure ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	"<#04>">

<!Autonumber Stream, invisible, 1,
	Level 1 Suffix =	,
	Level 1 Show =		no>

<!Autonumber Stream, item, 2,
	Level 2 Symbol Type =	LOWER ALPHA,
	Level 2 Trail =		yes>

<!Autonumber Stream, paralet, 4,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Suffix =	,
	Level 1 Show =		no,
	Level 2 Prefix =	.,
	Level 2 Suffix =	,
	Level 3 Prefix =	.,
	Level 3 Suffix =	,
	Level 4 Prefix =	.,
	Level 4 Suffix =	>

<!Autonumber Stream, paranum, 4,
	Level 1 Suffix =	,
	Level 1 Show =		no,
	Level 2 Prefix =	.,
	Level 2 Suffix =	,
	Level 3 Prefix =	.,
	Level 3 Suffix =	,
	Level 4 Prefix =	.,
	Level 4 Suffix =	>

<!Autonumber Stream, table, 2,
	Level 1 Prefix =	"Table ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	>

<!Autonumber Stream, tablelet, 2,
	Level 1 Symbol Type =	UPPER ALPHA,
	Level 1 Prefix =	"Table ",
	Level 1 Suffix =	"<#1e>",
	Level 1 Show =		no,
	Level 2 Suffix =	"<#04>">

<!Class, arg,
	Bottom Margin =		0.08 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F2,
	Left Tab =		-0.25/0 inches>

<!Class, bullet,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		-0.50/0 inches>

<!Class, caption,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Font =			F4>

<!Class, fig,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Left,
	Font =			F5>

<!Class, indentA,
	Bottom Margin =		0.167 inches,
	Left Margin =		1.85 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		-0.50/0 inches>

<!Class, item,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		0 inches,
	Right Tab =		-0.50 inches,
	Autonumber Name =	item>

<!Class, keyword2,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.85 inches,
	First Indent =		-0.25 inches,
	Line Spacing =		1.121 lines,
	Font =			F6,
	Left Tab =		-0.50/0 inches>

<!Class, newpage,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Alignment =		Left,
	Font =			F7,
	Hyphenation =		off,
	New Page =		yes,
	Left Tab =		>

<!Class, p1para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F8,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-1.70/0 inches>

<!Class, p1rule,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches>

<!Class, p1stacked,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1 lines,
	Font =			F6,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-1.60/-0.17/0 inches>

<!Class, p2para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		0 inches,
	Right Tab =		-1.60/-0.17 inches,
	TOC Doc Name =		TOC>

<!Class, p2rule,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1 lines,
	Alignment =		Left,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches>

<!Class, p2stacked,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F6,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		0 inches,
	Right Tab =		-1.60/-0.17 inches>

<!Class, para,
	Bottom Margin =		0.153 inches,
	Left Margin =		1.60 inches,
	Line Spacing =		1.121 lines,
	Font =			F3,
	Allow Page Break Within = no,
	Left Tab =		0/0.75*13 inches>

<!Class, return,
	Bottom Margin =		0.077 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<!Class, secno,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Left,
	Font =			F5,
	Autonumber Name =	paranum>

<!Class, secrule,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Font =			F3,
	Hyphenation =		off,
	Allow Page Break After = no,
	Left Tab =		0/0.75*13 inches,
	Autonumber Name =	table>

<!Class, sectitle,
	Bottom Margin =		0 inches,
	Line Spacing =		1 lines,
	Alignment =		Right,
	Font =			F5,
	Hyphenation =		off,
	New Page =		yes,
	Left Tab =		0/0.75*13 inches>

<!Class, syntax,
	Bottom Margin =		0.077 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		8 inches>

<!Class, syntax0,
	Bottom Margin =		0 inches,
	Left Margin =		1.60 inches,
	First Indent =		-0.90 inches,
	Line Spacing =		1.121 lines,
	Alignment =		Left,
	Font =			F6,
	Hyphenation =		off,
	Allow Page Break Within = no,
	Allow Page Break After = no,
	Left Tab =		-0.90/0 inches,
	Right Tab =		8 inches>

<!Class, "table",
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Font =			F6,
	Autonumber Name =	table>

<!Class, title,
	Top Margin =		0.07 inches,
	Bottom Margin =		0.07 inches,
	Line Spacing =		1.100 lines,
	Alignment =		Right,
	Font =			F5,
	TOC Doc Name =		TOC>

<!Master Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			0.41 inches,
	Height =		0.137 inches,
	Vertical Alignment =	0.03 inches,
	Diagram =
V4,
(g9,32767,0
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,1,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<!Master Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,0.006667,0.066723,6.326667,0.066611,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<!Master Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,4.733333,0.066611,0.006667,0.066723,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<First Page Header, Frame =
V4,
(g9,0,0
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,1,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Right Page Header, Frame =
V4,
(g9,1,0
 (T8,1,12,4.533333,0.306667,1.8,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,
  102,1101,2,
<caption,
	Alignment =		Right>

Control Functions

<End Text>)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,2,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Left Page Header, Frame =
V4,
(g9,1,0
 (T8,1,12,0,0.306667,2.4,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,102,110
  1,2,
<caption>

Control Functions

<End Text>)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,2,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Right Page Footer, Frame =
V4,
(g9,1,0
 (t8,1,4,6.333333,0.266667,2,17,@nntimsps10b,\240)
 (t8,2,4,0.006667,0.266667,0,17,@nntimsps8i,CLX\ Programmer's\ Reference)
 (v4,3,0,0,0.066667,6.333333,0.066554,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<Left Page Footer, Frame =
V4,
(g9,1,0
 (t8,1,4,0,0.266667,0,17,@nntimsps10b,\240)
 (t8,2,4,6.333333,0.266667,2,17,@nntimsps8i,CLX\ Programmer's\ Reference)
 (v4,3,0,0.026667,0.066667,6.333333,0.066554,17,2,0)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<sectitle,
	Allow Page Break Within = no,
	Allow Page Break After = no>

<|,"14<#1e>169">
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			4.72 inches,
	Height =		0.94 inches,
	Vertical Alignment =	0.03 inches,
	Diagram =
V4,
(g9,1,0
 (T8,1,12,0.133333,0.72,4.563333,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512
  ,102,1101,3,
<title>

CONTROL FUNCTIONS

<End Text>)
 (E10,0,0,0,1,0,0.053333,1,15,0,0,1,0,0,0,0,1,0,1,0.066667,0.066667,6,6,0,0.066
  667,6))>
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			1.626 inches,
	Height =		0.938 inches,
	Vertical Alignment =	0 inches,
	Diagram =
V4,
(g9,1,0
 (T8,1,12,0.066667,0.276667,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,10
  2,1101,3,
<secno,
	TOC Doc Name =		TOC>

<Autonum, paranum, 1, First = Yes>

<End Text>)
 (T8,2,12,0.026667,0.733333,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,10
  2,1101,3,
<"table">

<Autonum, table, 1, First = Yes>

<End Text>)
 (T8,3,12,0.066667,0.6,0,1,0.333333,0,516,0,17,0,0,0,0,0,0,1,1,2048,512,102,110
  1,3,
<fig,
	Alignment =		Both,
	Font =			F6,
	Autonumber Name =	figure>

<Autonum, figure, 1, First = Yes>

<End Text>)
 (g9,5,0
   (p7,5,8,19
     (g9,5,0
       (g9,5,0
         (v4,5,0,0.266667,0,1.6,0,17,1,0)
         (v4,6,0,1.6,0,1.6,0.933333,17,1,0)
         (v4,7,0,1.6,0.933333,0.266667,0.933333,17,1,0)
         (v4,8,0,0.266667,0.933333,0.266667,0,17,1,0))))
   (g9,10,8
     (g9,10,1032
       (p7,10,8,13
         (g9,10,0
           (g9,10,0
             (v4,10,0,1.464913,0.934816,1.302281,0.934816,17,1,0)
             (v4,11,0,1.302281,0.934816,1.302281,0.784694,17,1,0)
             (v4,12,32,1.302281,0.784694,1.302281,0.653329,17,0,0)
             (v4,13,0,1.302281,0.653329,1.302281,0.353088,17,1,0)
             (v4,14,32,1.302281,0.353088,1.284211,0.14667,17,0,0)
             (v4,15,0,1.284211,0.14667,1.464913,0.14667,17,1,0)
             (v4,16,0,1.464913,0.14667,1.464913,0.653329,17,1,0)
             (v4,17,0,1.464913,0.653329,1.555264,0.653329,17,1,0)
             (v4,18,0,1.555264,0.653329,1.555264,0.784694,17,1,0)
             (v4,19,0,1.555264,0.784694,1.464913,0.784694,17,1,0)
             (v4,20,0,1.464913,0.784694,1.464913,0.934816,17,1,0))))
       (p7,22,8,13
         (g9,22,0
           (g9,22,0
             (v4,22,32,1.302281,0.784694,1.302281,0.653329,17,0,0)
             (v4,23,0,1.302281,0.653329,1.103508,0.653329,17,1,0)
             (v4,24,0,1.103508,0.653329,1.302281,0.353088,17,1,0)
             (v4,25,32,1.302281,0.353088,1.284211,0.14667,17,0,0)
             (v4,26,0,1.284211,0.14667,0.958948,0.615804,17,1,0)
             (v4,27,0,0.958948,0.615804,0.958948,0.784694,17,1,0)
             (v4,28,0,0.958948,0.784694,1.302281,0.784694,17,1,0)))))
     (g9,29,2048
       (v4,29,33,0.940876,0.14667,0.940876,0.14667,17,0,0)
       (v4,30,33,0.940876,1.16,0.940876,1.16,17,0,0)
       (v4,31,33,1.573333,1.16,1.573333,1.16,17,0,0)
       (v4,32,33,1.573333,0.14667,1.573333,0.14667,17,0,0)))
   (g9,34,8
     (p7,34,1032,13
       (g9,34,0
         (g9,34,0
           (v4,34,0,0.874386,0.934816,0.874386,0.14667,17,1,0)
           (v4,35,0,0.874386,0.14667,0.729824,0.14667,17,1,0)
           (v4,36,0,0.729824,0.14667,0.585263,0.296792,17,1,0)
           (v4,37,0,0.585263,0.296792,0.585263,0.371851,17,1,0)
           (v4,38,0,0.585263,0.371851,0.711755,0.371851,17,1,0)
           (v4,39,0,0.711755,0.371851,0.711755,0.934816,17,1,0)
           (v4,40,0,0.711755,0.934816,0.874386,0.934816,17,1,0))))
     (g9,41,2048
       (v4,41,33,0.567192,0.14667,0.567192,0.14667,17,0,0)
       (v4,42,33,0.567192,1.16,0.567192,1.16,17,0,0)
       (v4,43,33,0.946667,1.16,0.946667,1.16,17,0,0)
       (v4,44,33,0.946667,0.14667,0.946667,0.14667,17,0,0))))
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,1,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<secrule,
	Allow Page Break Within = no,
	Allow Page Break After = yes,
	Autonumber Name =	>

<Index, "control", To Named = sectitle>
<Frame,
	Name =			"At Anchor",
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Diagram =
V4,
(g9,1,0
 (v4,1,0,0.006667,0.066723,6.333333,0.066611,17,2,0)
 (E10,0,0,0,1,1,0.053333,1,15,0,0,1,0,0,0,0,0,1,1,0.066667,0.066667,6,6,0,0.066
  667,6))>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8><Index, "control", "grabbing the server", To Named = p1rule><Index, "server", "grabbing", To Named = p1rule><Index, "grabbing", "server", To Named = p1rule>Grabbing<Tab>
<F6>14.1<#04><F0>Certain cases may require that a client demand 
exclusive access to the<FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>the Server<Tab><F0>server,<SP>causing the processing for all 
other clients to be suspended. Such exclusive<SP>access is referred 
to as <F2>grabbing the server<F0>. CLX provides functions to grab<SP>and 
release exclusive access to the server. These function should be used<SP>rarely 
and always with extreme caution, since they have the potential to<SP>disrupt 
the entire window system for all clients. 

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

grab<#1e>server <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:grab<#1e>server", Sort String = "grab<#1e>server">

<para>

Disables processing of requests and close<#1e>downs on all connections 
other than the one on which this request arrived. 

<arg>

display <F3><#1f> A <F6>display<F3>. 

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

ungrab<#1e>server <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:ungrab<#1e>server", Sort String = "ungrab<#1e>server">

<para>

Restarts processing of requests and close<#1e>downs on other connections.

<arg>

display <F3><#1f> A <F6>display<F3>. 

<syntax,
	Bottom Margin =		0.15 inches,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

with<#1e>server<#1e>grabbed <F2>display <F3>&body<F2> body<F0><Tab><F3>Mac
ro<Index, Doc = operations, "xlib:with<#1e>server<#1e>grabbed", Sort String = "with<#1e>server<#1e>grabbed">

<para>

Grabs the <F2>display<F0> server only within the dynamic extent 
of the <F2>body<F0>. <F6>ungrab<#1e>server<F0> is automatically 
called upon exit from the <F2>body<F0>. This macro provides the 
most reliable way for CLX clients to grab the server.

<arg>

display<F3> <#1f> A <F6>display<F3>.

body<F3> <#1f> The forms to execute while the server is grabbed.

<p1rule>

<Index, "pointer", "control", To Named = p1rule><Index, "control", "pointer", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Pointer Control<Tab><F6>14.2<F0><#04>The following paragraphs 
describe the CLX functions used to:

<bullet>

<F9>w<Tab><F0>Return or change the pointer acceleration and acceleration 
threshold

<F9>w<Tab><F0>Return or change the mapping of pointer button numbers

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

change<#1e>pointer<#1e>control <F2>display<F3> &key <F0>:acceleration 
:threshold<Tab><F3>Function<Index, Doc = operations, "xlib:change<#1e>pointer<#1e>control", Sort String = "change<#1e>pointer<#1e>control">

<para>

Changes the acceleration and/or the acceleration threshold of the 
pointer for<SP>the <F2>display<F0>. The <F6>:acceleration<F0> 
number is used as a multiplier, typically<SP>specified as a rational 
number of the form <F2>C/P<F0>, where <F2>C<F0> is the number 
of pixel<SP>positions of cursor motion displayed for <F2>P<F0> units 
of pointer device motion. The<SP>acceleration only occurs if the pointer 
moves more that <F6>:threshold<F0> pixels at<SP>once, and only applies 
to the motion beyond the <F6>:threshold<F0>. Either<SP><F6>:acceleration
<F0> or <F6>:threshold<F0> can be set to <F6>:default<F0>, that 
restores the default<SP>settings of the server.

<arg>

display <F3><#1f> A <F6>display<F3>.

<keyword2>

:acceleration <F3><#1f> A number for the acceleration ratio.

:threshold <F3><#1f> The number of pixels required for acceleration 
to take effect.

<syntax0>

<|,"14<#1e>170">pointer<#1e>control <F2>displa<F3>y<F0><Tab><F3>Function<Index, Doc = operations, "xlib:pointer<#1e>control", Sort String = "pointer<#1e>control">

<return>

<Tab><F3>Returns: <F2><HR>
  acceleration<F3>, <F2>threshold <F3><#1f> Type <F0>number<F3>.

<para>

Returns the acceleration and threshold for the <F2>display<F0> pointer. 

<arg>

displa<F3>y <#1f> A <F6>display<F3>.

<syntax0>

pointer<#1e>mapping <F2>display<F3> &key (<F0>:result<#1e>type 
'list<F3>)<F0><Tab><F3>Function<Index, Doc = operations, "xlib:pointer<#1e>mapping", Sort String = "pointer<#1e>mapping">

<return>

<Tab><F3>Returns:<HR>
  <F2>mapping<F3> <#1f> Type <F0>sequence<F3> or <F0>card8<F2>.<F3> 

<para>

Returns or (with <F6>setf<F0>) changes the mapping of button numbers 
for the <F2>display<F0><SP>pointer. The <F6>:result<#1e>type<F0> 
is not used when changing the mapping. If element <F2>i<F0> of the 
mapping sequence is <F2>j<F0>, then the events from pointer button<SP><F2>j
<F0> are reported by the server as events for button <F2>i<F0>+1. 
(Note that pointer<SP>buttons are numbered beginning with one, while 
the mapping sequence itself is<SP>indexed normally from zero.) If 
element <F2>i<F0> of the mapping sequence is<SP>zero, then button <F2>i
<F0>+1 is disabled and can no longer generate input<SP>events. No 
two elements of the mapping can have the same non<#1e>zero value.

The length of the mapping sequence indicates the actual number of 
buttons on<SP>the device. When changing the mapping, the new mapping 
must have this same length.

<arg>

display <F3><#1f> A <F6>display<F3>.

<keyword2>

:result<#1e>type <F3><#1f> The type of sequence to return.

<p1rule,
	Allow Page Break After = yes>

<Index, "keyboard", "bell"><Index, "pointer", "button", "obtaining", To Named = p1rule><Index, "pointer", "button", "setting", To Named = p1rule><Index, "bit vector", "keyboard", To Named = p1rule><Index, "keyboard", "bit vector", To Named = p1rule><Index, "keyboard", "mapping", To Named = p1rule><Index, "mouse", "behavior", To Named = p1rule><Index, "key", "click", To Named = p1rule><Index, "bell", To Named = p1rule><Index, "key", "auto<#1e>repeat", To Named = p1rule><Index, "auto<#1e>repeat keys", To Named = p1rule><Index, "keyboard", "control", To Named = p1rule><Index, "control", "keyboard", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8>Keyboard <Tab><F6>14.3<F0><#04>The following paragraphs describe 
the CLX functions used to:

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Control<Tab>

<bullet>

<F9>w<Tab><F0>Return or change keyboard controls

<F9>w<Tab><F0>Ring the keyboard bell

<F9>w<Tab><F0>Return or change the mapping of modifiers

<F9>w<Tab><F0>Return the current up/down state of all keys

<syntax>

bell <F2>display <F3>&optional (<F2>percent<#1e>from<#1e>normal<F3> 
0)<F0><Tab><F3>Function<Index, Doc = operations, "xlib:bell", Sort String = bell>

<para>

Rings the bell on the keyboard at a volume relative to the base volume 
for the keyboard, if possible. Percent can range from -100 to 100 
inclusive, or else a Value error occurs. The following is the bell 
volume when percent is non<#1e>negative:

(- (+ <F2>base percent<F0>) (<F6>quotient<F0> (* <F2>base percent<F0>) 
100))

and when percent is negative: 

(+ <F2>base<F0> (<F6>quotient<F0> (* <F2>base percent<F0>) 100))

<arg>

display<F3> <#1f> A <F6>display<F3>.

percent<#1e>from<#1e>normal<F3> <#1f> An integer (-100 through 100).

<syntax,
	New Page =		yes,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<|,"14<#1e>171">change<#1e>keyboard<#1e>control <F2>display<F3> &key <F0>:key<#1e>clic
k<#1e>percent :bell<#1e>percent<F3> <F0><Tab><F3>Function<Index, Doc = operations, "xlib:change<#1e>keyboard<#1e>control", Sort String = "change<#1e>keyboard<#1e>control"><HR>
<F0>:bell<#1e>pitch :bell<#1e>duration :led :led<#1e>mode :key :auto<#1e>repea
t<#1e>mode

<para>

Changes the various aspects of the keyboard. The keyword arguments 
specify which controls to change. 

The <F6>:key<#1e>click<#1e>percent<F0> keyword sets the volume for 
key clicks, if possible. A value of 0 implies off, while a value of 
100 implies loud. Setting <F6>:key<#1e>click<#1e>percent<F0> to <F6>:default
<F0> restores the default value. 

The <F6>:bell<#1e>percent<F0> sets the base volume for the bell 
between 0 (off) and 100 (loud) if possible. Setting <F6>:bell<#1e>percent
<F0> to <F6>:default<F0> restores the default value. 

The <F6>:bell<#1e>pitch<F0> sets the pitch (specified in Hz) of 
the bell, if possible. Setting the <F6>:bell<#1e>pitch<F0> to <F6>:default 
<F0>restores the default value. The <F6>:bell<#1e>duration<F0> 
sets the duration (specified in milliseconds) of the bell, if possible. 
Setting <F6>:bell<#1e>pitch<F0> to <F6>:default<F0> restores the 
default. Note that a bell generator connected with the console but 
not directly on the keyboard is treated as if it were part of the 
keyboard.

If both <F6>:led<#1e>mode<F0> and <F6>:led<F0> are specified, 
then the state of that LED is changed, if possible. If only <F6>:led<#1e>mode
<F0> is specified, the state of all LEDs are changed, if possible. 
At most 32 LEDs are supported, numbered from one. No standard interpretation 
of the LEDs are defined. 

If both <F6>:auto<#1e>repeat<#1e>mode<F0> and <F6>:key<F0> are 
specified, the auto<#1e>repeat mode of that key is changed, if possible. 
If only <F6>:auto<#1e>repeat<#1e>mode<F0> is specified, the global 
auto<#1e>repeat mode for the entire keyboard is changed, if possible, 
without affecting the per<#1e>key settings. An error occurs if <F6>:key<F0> 
is specified without <F6>:auto<#1e>repeat<#1e>mode<F0>.

<arg>

display <F3><#1f> A <F6>display<F3>.

<keyword2>

:key<#1e>click<#1e>percent<F3> <#1f> An integer (0 100).

:bell<#1e>percent<F3> <#1f> An integer (0 100).

:bell<#1e>pitch<F3> <#1f> A <F0>card16<F3>.

:bell<#1e>duration<F3> <#1f> A <F0>card16<F3>.

:led <F3><#1f> A <F0>card8<F3>.

:led<#1e>mode<F3> <#1f> Either <F0>:on<F3> or <F0>:off<F3>.

:key <F3><#1f> A <F0>card8<F3> keycode.

:auto<#1e>repeat<#1e>mode <F3><#1f> Either <F0>:on<F3>, <F0>:off<F3>, 
or <F0>:default<F3>.

<syntax0>

<|,"14<#1e>172">keyboard<#1e>control <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:keyboard<#1e>control", Sort String = "keyboard<#1e>control">

<return,
	Left Tab =		-0.90/0/0.10/7.50 inches>

<Tab><F3>Returns: <F2><HR>
<Tab>key<#1e>click<#1e>percent, bell<#1e>percent <F3><#1f> Type <F0>card8
<F3>.<F2><HR>
<Tab>bell<#1e>pitch bell<#1e>duration <F3><#1f> Type <F0>card16<F3>.<F2><HR>
<Tab>led<#1e>mask <F3><#1f> Type <F0>card32<F3>.<F2><HR>
<Tab>global<#1e>auto<#1e>repeat <F3><#1f> Either <F0>:on<F3> or <F0>:off
<F3>.<F2><HR>
<Tab>auto<#1e>repeats <F3><#1f> Type <F0>bit<#1e>vector<F3>.

<para>

Returns the current control values for the keyboard. For the LEDs, 
the least significant bit of <F2>led<#1e>mask<F0> corresponds to 
LED one, and each one bit in <F2>led<#1e>mask<F0> indicates an LED 
that is lit. <F2>auto<#1e>repeats<F0> is a bit vector; each one 
bit indicates that auto<#1e>repeat is enabled for the corresponding 
key. The vector is represented as 32 bytes. Byte <F2>n<F0> (from 
0) contains the bits for keys 8<F2>n<F0> to 8<F2>n<F0>+7, with 
the least significant bit in the byte representing key 8<F2>n<F0>.

<arg>

display<F3> <#1f> A <F6>display<F3>.

<syntax0>

modifier<#1e>mapping <F2>display <F0><Tab><F3>Function<Index, Doc = operations, "xlib:modifier<#1e>mapping", Sort String = "modifier<#1e>mapping">

<return,
	Left Tab =		-0.90/0/0.10/7.50 inches>

<Tab><F3>Returns: <F2><HR>
<Tab>shift<#1e>keycodes<F3>,<F2> lock<#1e>keycodes<F3>,<F2> control<#1e>key
codes<F3>,<F2> mod1<#1e>keycodes<F3>,<Tab><Tab><Tab><F2>mod2<#1e>keycodes
<F3>, <F2>mod3<#1e>keycodes<F3>, <F2>mod4<#1e>keycodes<F3>, <F2>mod5<#1e>
keycodes<F3> <#1f> <HR>
<Tab>Type <F0>list<F3> of <F0>card8<F3>.

<para>

Returns the set of keycodes used for each modifier on the <F2>display<F0> 
keyboard. Each return value is a list of the <F6>card8<F0> keycodes 
used for each modifier key. The order of keycodes within each list 
is server<#1e>dependent.

<arg>

display <F3><#1f> A <F6>display<F3>.

<syntax0>

query<#1e>keymap <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:query<#1e>keymap", Sort String = "query<#1e>keymap">

<return>

<Tab><F3>Returns: <F2><HR>
  keymap <F3><#1f> Type <F0>bit<#1e>vector <F3>256. 

<para>

Returns a bit vector that describes the state of the keyboard. Each 
one bit indicates that the corresponding key is currently pressed. 
The vector is represented as 32 bytes. Byte <F2>n<F0> (from 0) contains 
the bits for keys 8<F2>n<F0> to 8<F2>n<F0>+7, with the least significant 
bit in the byte representing key 8<F2>n<F0>.

<arg>

display<F3> <#1f> A <F6>display<F3>.

<syntax0>

set<#1e>modifier<#1e>mapping <F2>display <F3>&key <F0>:shift<F3> <F0>:lock
<F3> <F0>:control<F3> <F0>:mod1<F3> <F0>:mod2<F3> <Tab>Function<Index, Doc = operations, "xlib:set<#1e>modifier<#1e>mapping", Sort String = "set<#1e>modifier<#1e>mapping"><HR>
<F0>:mod3 :mod4<F3> <F0>:mod5

<return>

<Tab><F3>Returns: <F2><HR>
  status <F3><#1f> One of <F0>:success<F3>, <F0>:failed<F3>, 
or <F0>:device<#1e>busy<F3>. 

<para>

Changes the set of keycodes mapped to the specified modifier keys 
on the<SP><F2>display<F0> keyboard. Each keyword argument contains 
a sequence of new<SP><F6>card8<F0> keycodes for a specific modifier. 
The return value indicates<SP>whether the change was completed successfully.

A status of <F6>:failed<F0> is returned if hardware limitations 
prevent the<SP>requested change. For example, multiple keycodes per 
modifier may not be<SP>supported, up transitions on a given keycode 
may not be supported, or<SP>autorepeat may be mandatory for a given 
keycode. If <F6>:failed<F0> is returned,<SP>the mappings for all 
modifiers remain unchanged.

<para,
	New Page =		yes>

<|,"14<#1e>173">A status of <F6>:device<#1e>busy<F0> is returned if a new 
keycode given for a<SP>modifier was not previously mapped to that 
modifier and is currently in<SP>the down state. In this case, the 
mappings for all modifiers remain<SP>unchanged.

<arg>

display <F3><#1f> A <F6>display<F3>.

<keyword2>

:shift<F3>, <F0>:lock<F3>, <F0>:control<F3>, <F0>:mod1<F3>, <F0>:mod2
<F3>, <F0>:mod3<F3>, <F0>:mod4<F3>, <F0>:mod5<F3> <#1f> A sequence 
of <F0>card8<F3> keycodes for the given modifier.

<p1rule,
	Allow Page Break After = yes>

<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8><Index, "keyboard", "encodings", To Named = p1rule>Keyboard <Tab><F6>14.4<F0><#04>Handling 
the great diversity of keyboard devices and international<FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Encodings<Tab><F0>language<SP>character encodings is a difficult 
problem for interactive programs that need<SP>to receive text input 
but must also be portable. The X Window System solves<SP>this problem 
by using different sets of encodings for device keys (<F2>keycodes<F0>)<SP>an
d for character symbols (<F2>keysyms<F0>). Each X server maintains 
a <F2>keyboard<SP>mapping<F0> that associates keycodes and keysyms, 
and which can be returned or<SP>changed by client programs.

<para>

To handle text input, a CLX client program must follow these steps:

<item>

<Autonum, item, 1, First = Yes, Restart = Yes><Tab>Receive a <F6>:key<#1e>press<F0> 
(or <F6>:key<#1e>release<F0>) event containing a keycode.

<Autonum, item, 1><Tab>Convert the keycode into its corresponding 
keysym, based on the current<SP>keyboard mapping. See <F6>keycode<#1e>keysym
<F0>.

<Autonum, item, 1><Tab>Convert the keysym into the corresponding Common 
Lisp character. See<SP><F6>keysym<#1e>character<F0>.

<p2rule>

<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Index, "keycodes", To Named = p2rule><Index, "keysyms", To Named = p2rule><Tab><F6>Keycodes and<Tab>14.4.1<F0><#04>
A <F2>keycode<F0> represents a physical (or logical) key. In CLX, 
keycodes<FJ>

<p2para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break Within = yes,
	Allow Page Break After = yes,
	TOC Doc Name =		>

<Tab><F6>Keysyms<Tab><F0>are values of type (<F6>integer<F0> 8 
255). A keycode value carries no intrinsic information, although server 
implementors may attempt to encode geometry (for example, matrix) 
information in some fashion so it can be interpreted in a server<#1e> 
dependent fashion. The mapping between keys and keycodes cannot be 
changed.

<para>

A <F2>keysym<F0> is an encoding of a symbol on the cap of a key. 
In CLX, keysyms are values of type <F6>card32<F0>. The set of defined 
keysyms include the ISO Latin character sets (1<#1e>4), Katakana, 
Arabic, Cyrillic, Greek, Technical, Special, Publishing, APL, Hebrew, 
and miscellaneous keys found on keyboards (RETURN, HELP, TAB, and 
so on). The encoding of keysyms is defined by the X Protocol.

A list of keysyms is associated with each keycode. The length of the 
list can vary with each keycode. The list is intended to convey the 
set of symbols on the corresponding key. By convention, if the list 
contains a single keysym and if that keysym is alphabetic and case 
distinction is relevant, then it should be treated as equivalent to 
a two<#1e>element list of the lowercase and uppercase keysyms. For 
example, if the list contains the single keysym for uppercase A, the 
client should treat it as if it were a pair with lowercase as the 
first keysym and uppercase A as the second keysym.

<para,
	Bottom Margin =		0.12 inches>

For any keycode, the first keysym in the list should be chosen as 
the interpretation of a key press when no modifier keys are down. 
The second keysym in the list normally should be chosen when the <F6>:shift
<F0> modifier is on, or when the <F6>:lock<F0> modifier is on and <F6>:lock
<F0> is interpreted as <F6>:shift<#1e>lock<F0>. When the <F6>:lock<F0> 
modifier is on and is interpreted as <F6>:caps<#1e>lock<F0>, it 
is suggested that the <F6>:shift<F0> modifier first be applied to 
choose a keysym, but if that keysym is lowercase alphabetic, the corresponding 
uppercase keysym should be used instead. 

<|,"14<#1e>174">Other interpretations of <F6>:caps<#1e>lock<F0> are possible; 
for example, it may be viewed as equivalent to <F6>:shift<#1e>lock<F0>, 
but only applying when the first keysym is lowercase alphabetic and 
the second keysym is the corresponding uppercase alphabetic. No interpretation 
of keysyms beyond the first two in a list is suggested here. No spatial 
geometry of the symbols on the key is defined by their order in the 
keysym list, although a geometry might be defined on a vendor<#1e>specific 
basis. The X server does not use the mapping between keycodes and 
keysyms. Rather, the X server stores the mapping merely for reading 
and writing by clients.

<p2rule>

<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Index, "keyboard", "mapping", To Named = p2rule><Tab><F6>Keyboard<Tab>14.4.2<F0><#04>The X server 
maintains a keyboard mapping that associates each<FJ>

<p2para,
	Bottom Margin =		0.12 inches,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break Within = yes,
	Allow Page Break After = yes,
	TOC Doc Name =		>

<Tab><F6>Mapping<Tab><F0>keycode with<SP>one or more keysyms. The 
following paragraphs describe the CLX functions used to return<SP>or 
change the mapping of keycodes.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

change<#1e>keyboard<#1e>mapping <F2>display keysyms<F3> &key (<F0>:start
<F3> 0) <F0>:end <Tab><F3>Function<Index, Doc = operations, "xlib:change<#1e>keyboard<#1e>mapping", Sort String = "change<#1e>keyboard<#1e>mapping"><HR>
(<F0>:first<#1e>keycode :start<F3>)

<para,
	Bottom Margin =		0.12 inches>

Changes the mapping of keycodes to <F2>keysyms<F0>. A <F6>:mapping<#1e>notif
y<F0> event is<SP>generated for all clients.

<para>

The new <F2>keysyms<F0> are specified as a two<#1e>dimensional array 
in which: 

(<F6>aref<F0><SP><F2>keysyms<F0> (+ <F6>:start<F0> <F2>i<F0>) <F2>j
<F0>) 

is <F2>keysym<F0> <F2>j<F0> associated with keycode (+<SP><F6>:first<#1e>k
eycode<F0> <F2>i<F0>). The maximum number of <F2>keysyms<F0> 
associated with any<SP>one keycode is given by: 

(<F6>array<#1e>dimension<F0> <F2>keysyms<F0> 1)

<para,
	Bottom Margin =		0.12 inches>

<F2>keysyms<F0> should<SP>contain <F6>nil<F0> elements to represent 
those keysyms that are undefined for<SP>a given keycode. <F6>:start<F0> 
and <F6>:end<F0> define the subsequence of the <F2>keysyms<F0> 
array that<SP>defines the new mapping, and the number of keycode mappings 
changed. By<SP>default, <F6>:end<F0> is given by:

<para>

(<F6>array<#1e>dimension<F0> <F2>keysyms<F0> 0) 

The keycodes<SP>whose mappings are changed are given by <F6>:first<#1e>keycode
<F0> through the following: 

(+<SP><F6>:first<#1e>keycode <F0>(- <F6>:end :start<F0>) -1) 

keycodes outside this range of are<SP>not affected. <F6>:first<#1e>keycode
<F0> must not be less than (<F6>display<#1e>min<#1e>keycode<F0><SP><F2>disp
lay<F0>), and the last keycode modified must not be greater than<SP>(<F6>disp
lay<#1e>max<#1e>keycode<F0> <F2>display<F0>).

<arg>

display<F3> <#1f> A <F6>display<F3>.

keysyms <#1f> <F3>A two<#1e>dimensional array of keysym (<F6>card32<F3>) 
values.

<keyword2>

:start<F3>, <F0>:end<F3> <#1f> Indexes for the subsequence of <F2>keysyms
<F3> used.

:first<#1e>keycode<F3> <#1f> A <F0>card8<F3> defining the first 
keycode mapping changed.

<syntax0>

<|,"14<#1e>175">keyboard<#1e>mapping <F2>displa<F3>y &key <F0>:first<#1e>keycode 
:start :end :data<Tab><F3>Function<Index, Doc = operations, "xlib:keyboard<#1e>mapping", Sort String = "keyboard<#1e>mapping">

<return>

<Tab><F3>Returns: <F2><HR>
  mappings <F3><#1f> Type (<F0>array card32<F3> (* *)).

<para>

Returns the keysyms mapped to the given range of keycodes for the<SP><F2>displ
ay<F0> keyboard. The mappings are returned in the form of a<SP>two<#1e>dimensi
onal array of <F6>card32<F0> keysym values. The <F6>:data<F0> 
argument, if<SP>given, must be a two<#1e>dimensional array in which 
the returned mappings<SP>will be stored. In this case:

(<F6>array<#1e>dimension :data<F0> 1) 

defines the<SP>maximum number of keysyms returned for any keycode. 
Otherwise, a new<SP>array is created and returned. 

Upon return: 

(<F6>aref<F0> <F2>mappings<F0> (+ <F2>:start<F0> <F2>i<F0>)<SP><F2>j
<F0>) 

will contain keysym <F2>j<F0> associated with keycode (+<SP><F6>:first<#1e>k
eycode<F0> <F6>i<F0>) (or <F6>nil<F0>, if keysym<SP><F2>j<F0> 
is undefined for that<SP>keycode).

<F6>:first<#1e>keycode<F0> specifies the first keycode whose mapping 
is returned; by<SP>default, <F6>:first<#1e>keycode<F0> is (<F6>display<#1e>m
in<#1e>keycode<F0> <F2>display<F0>).<SP><F6>:start<F0> and <F6>:end<F0> 
define the subsequence of the returned array in which<SP>the returned 
mappings are stored. By default, <F6>:start<F0> is given by<SP><F6>:first<#1e>
keycode<F0> and <F6>:end<F0> is given by: 

(1+ (<F6>display<#1e>max<#1e>keycode<F0> <F2>display<F0>))<SP>

<F6>:first<#1e>keycode<F0> must not be less than (<F6>display<#1e>min<#1e>ke
ycode<F0> <F2>display<F0>), and<FJ>
the last keycode returned must not be greater than (<F6>display<#1e>max<#1e>ke
ycode<F0><SP><F2>display<F0>).

<arg>

display<F3> <#1f> A <F6>display<F3>.

<keyword2>

:first<#1e>keycode<F3> <#1f> A <F0>card8<F3> defining the first 
keycode mapping returned.

:start<F3>, <F0>:end <F3><#1f> Indexes for the subsequence of the 
returned array which is modified.

:data <F3><#1f> If given, a two<#1e>dimensional array to receive 
the returned keysyms.

<p2rule>

<Frame,
	Name =			p2rule,
	Placement =		At Anchor,
	Width =			4.75 inches,
	Height =		0.15 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p2stacked,
	Font =			F3>

<Index, "keycodes", "usage", To Named = p1rule><Index, "keysyms", "usage", To Named = p1rule><Tab><F6>Using Keycodes<Tab>14.4.3
<F0><#04>The following paragraphs describe the CLX functions used 
to:

<p2para,
	Bottom Margin =		0 inches,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break Within = yes,
	Allow Page Break After = yes,
	TOC Doc Name =		>

<Tab><F6>and Keysyms<Tab>

<bullet>

<F9>w<Tab><F0>Convert a keycode into a keysym

<F9>w<Tab><F0>Convert a keysym into a character

<syntax0>

keycode<#1e>keysym <F2>display keycode keysym<#1e>index<F0> <Tab><F3>Functio
n<Index, Doc = operations, "xlib:keycode<#1e>keysym", Sort String = "keycode<#1e>keysym">

<return>

<Tab><F3>Returns: <F2><HR>
  keysym <F3><#1f> Type <F0>keysym<F3>.

<para>

Returns the <F2>keysym<F0> at the given <F2>keysym<#1e>index<F0> 
from the keysym list for the<SP><F2>keycode<F0> in the current keyboard 
mapping for the <F2>display<F0> server.

<arg>

display<F3> <#1f> A <F6>display<F3>.

keycode <F3><#1f> A <F6>card8<F3>.

keysym<#1e>index<F3> <#1f> A <F6>card8<F3>.

<syntax0>

<|,"14<#1e>176">keycode<#1e>character <F2>display keysym <F3>&optional (<F2>state
<F3> 0)<F0><Tab><F3>Function<Index, Doc = operations, "xlib:keycode<#1e>character", Sort String = "keycode<#1e>character">

<return>

<Tab><F3>Returns: <F2><HR>
  character <F3><#1f> Type <F0>character<F3> or <F0>null<F3>.

<para>

Returns the <F2>character<F0> associated with the <F2>keysym<F0> 
and the <F2>state<F0>. The <F2>state<F0><SP>is a <F6>mask16<F0> 
bit mask representing the state of the <F2>display<F0> modifier 
keys<SP>and pointer buttons. See <F6>state<#1e>mask<#1e>key<F0> 
in paragraph 1.6, Data Types. If the<SP><F2>keysym<F0> does not 
represent a Common Lisp character, then <F6>nil<F0> is returned.

The <F2>state<F0> determines the bits attribute of the returned <F2>characte
r<F0>, as<SP>follows:

<F6>:control<Tab>char<#1e>control<#1e>bit<HR>
:mod<#1e>1<Tab>char<#1e>meta<#1e>bit<HR>
:mod<#1e>2<Tab>char<#1e>super<#1e>bit<HR>
:mod<#1e>3<Tab>char<#1e>hyper<#1e>bit

<arg>

display<F3> <#1f> A <F6>display<F3>.

keysym<F3> <#1f> A <F6>keysym<F3>.

state<F3> <#1f> A <F6>mask16<F3>.

<p1rule>

<Index, "client", "termination", To Named = p1rule><Index, "control", "client termination", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8>Client <Tab><F6>14.5<#04><F0>The CLX functions affecting client 
termination are discussed in the<FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Termination<Tab><F0>following paragraphs.

<para>

When a display connection to an X server is closed, whether by an 
explicit<SP>call to <F6>close<#1e>display<F0> or by some external 
condition, the server<SP>automatically performs a sequence of operations 
to clean up server state<SP>information associated with the closed 
connection. The effect of these<SP>operations depends the <F2>close<#1e>down 
mode<F0> and the <F2>save<#1e>set<F0> that<SP>the client has specified 
for the closed display connection. The close<#1e>down<SP>mode of a 
display determines whether server resources allocated by the<SP>connection 
are freed or not. The save<#1e>set identifies windows that will<SP>remain 
after the connection is closed.

The display save<#1e>set is used primarily by window managers that 
reparent the<SP>top<#1e>level windows of other clients. For example, 
such a window manager can<SP>automatically create a frame window that 
encloses a top<#1e>level client<SP>window, along with a set of controls 
used for window management.<SP>Ordinarily, termination of the window 
manager client would then destroy all<SP>client windows! However, 
the window manager can prevent this by adding to<SP>its save<#1e>set 
those windows created by other clients that should be<SP>preserved.

When a display connection closes, an X server performs the following<SP>operati
ons:

<item>

<Autonum, item, 1, Restart = Yes><F9><Tab><F0>For each selection 
owned by a window created on the connection, the selection owner is 
set to <F6>nil<F0>.

<Autonum, item, 1><F9><Tab><F0>An active or passive grab established 
for a window created on the connection is released.

<Autonum, item, 1><F9><Tab><F0>If the connection has grabbed the 
server, the server is ungrabbed.

<item,
	Bottom Margin =		0.14 inches,
	New Page =		yes>

<|,"14<#1e>177"><Autonum, item, 1><F9><Tab><F0>Server resources and colormap 
cells allocated by the connection are freed and destroyed, depending 
on the close<#1e>down mode, as follows:

<indentA,
	Bottom Margin =		0.15 inches>

<F6>:retain<#1e>permanent<F0> <#1f> All resources are marked <F2>permanent
<F0>, and no resources are destroyed. These resources can later be 
destroyed by a call to <F6>kill<#1e>client<F0>.

<F6>:retain<#1e>temporary<F0> <#1f> All resources are marked <F2>temporary
<F0>, and no resources are destroyed. These resources can later be 
destroyed by a call to <F6>kill<#1e>client<F0> or <F6>kill<#1e>temporary<#1e>
clients<F0>.

<indentA>

<F6>:destroy<F0> <#1f> All resources are destroyed.

<para,
	Bottom Margin =		0.12 inches>

When server resources allocated by a display connection are destroyed 
<#1f><SP>whether by closing the connection with close<#1e>down mode <F6>:destr
oy<F0> or by later<SP>calling <F6>kill<#1e>client<F0> or <F6>kill<#1e>tempo
rary<#1e>clients<F0> <#1f> then an X server performs<SP>the following 
operations on each member of the save<#1e>set before actually<SP>destroying 
resources.

<item,
	Bottom Margin =		0.14 inches>

<Autonum, item, 1, Restart = Yes><F9><Tab><F0>If the save<#1e>set 
window is a descendant of a window created on the connection, the 
save<#1e>set window is reparented. The new parent is the closest ancestor 
such that the save<#1e>set window is no longer a descendant of any 
window created on the connection. The position of the reparented window 
with respect to its parent remains unchanged.

<Autonum, item, 1><F9><Tab><F0>If the save<#1e>set window is unmapped, 
then it is mapped.

<para,
	Bottom Margin =		0.12 inches>

If the last connection open to an X server is closed with close<#1e>down 
mode<SP><F6>:destroy<F0>, the server resets its state to restore 
all initial defaults.<SP>The server state after reset is the same 
as its initial state when first<SP>started. When an X server resets, 
it performs the following operations:<Index, "X server", Sort String = "x server", "reset operations">

<bullet,
	Bottom Margin =		0.13 inches>

<F9>w<Tab><F0>All permanent and temporary server resources from 
previously<#1e>closed connections are destroyed.

<F9>w<Tab><F0>All but the predefined atoms are deleted.

<F9>w<Tab><F0>All root window properties are deleted.

<F9>w<Tab><F0>All device control attributes and mappings are restored 
to their original default values.

<F9>w<Tab><F0>The default background and cursor for all root windows 
are restored.

<F9>w<Tab><F0>The default font path is restored.

<F9>w<Tab><F0>The input focus is set to <F6>:pointer<#1e>root<F0>.

<F9>w<Tab><F0>The access control list is reset.

<para>

The following paragraphs describe the CLX functions used to:

<bullet,
	Bottom Margin =		0.13 inches>

<F9>w<Tab><F0>Add or remove a window from a display save<#1e>set.

<F9>w<Tab><F0>Return or change the display close<#1e>down mode.

<F9>w<Tab><F0>Force a connection to be closed or all its server 
resources to be destroyed.

<bullet>

<F9>w<Tab><F0>Force a connection to be closed and all temporary 
resources to be destroyed.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<|,"14<#1e>178">add<#1e>to<#1e>save<#1e>set <F2>window<F0><Tab><F3>Function<Index, Doc = operations, "xlib:add<#1e>to<#1e>save<#1e>set", Sort String = "add<#1e>to<#1e>save<#1e>set">

<para>

Adds the specified <F2>window<F0> to the save<#1e>set of the <F2>window
<F0> display. The <F2>window<F0> must have been created by some 
other display. Windows are removed automatically from the save<#1e>set 
when they are destroyed.

<arg>

window <F3><#1f> A <F6>window<F3>.

<syntax0>

close<#1e>down<#1e>mode <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:close<#1e>down<#1e>mode", Sort String = "close<#1e>down<#1e>mode">

<return>

<Tab><F3>Returns: <F2><HR>
  mode <F3><#1f> One of <F0>:destroy<F3>,<F0> :retain<#1e>permanent<F3>, 
or <F0>:retain<#1e>temporary<F3>.

<para>

Returns and (with <F6>setf<F0>) sets the close<#1e>down mode of 
the client's resources at connection close. 

<arg>

display<F3> <#1f> A <F6>display<F3>.

<syntax>

kill<#1e>client <F2>display resource<#1e>id<F0><Tab><F3>Function<Index, Doc = operations, "xlib:kill<#1e>client", Sort String = "kill<#1e>client">

<para>

Closes the display connection which created the given <F2>resource<#1e>id
<F0>. The<SP><F2>resource<#1e>id<F0> must be valid, but need not 
belong to the given <F2>display<F0>.

If the closed connection was previously open, the connection is closed<SP>accor
ding to its close<#1e>down mode. Otherwise, if the connection had 
been<SP>previously terminated with close<#1e>down mode <F6>:retain<#1e>permane
nt<F0> or<SP><F6>:retain<#1e>temporary<F0>, then all its retained 
server resources <#1f> both permanent<SP>and temporary <#1f> are destroyed.

<arg>

display <F3><#1f> A <F6>display<F3>.

resource<#1e>id<F3> <#1f> A valid <F6>card29<F3> resource ID.

<syntax>

kill<#1e>temporary<#1e>clients <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:kill<#1e>temporary<#1e>clients", Sort String = "kill<#1e>temporary<#1e>clients">

<para>

Closes the <F2>display<F0> connection and destroys all retained 
temporary server<SP>resources for this and all previously<#1e>terminated 
connections.

If the <F2>display<F0> connection was previously open, the connection 
is closed<SP>according to its close<#1e>down mode. Otherwise, if the <F2>displ
ay<F0> connection had<SP>been previously terminated with close<#1e>down 
mode <F6>:retain<#1e>permanent<F0> or<SP><F6>:retain<#1e>temporary<F0>, 
then all its retained server resources <#1f> both permanent<SP>and 
temporary <#1f> are destroyed.

<arg>

display<F3> <#1f> A <F6>display<F3>.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

remove<#1e>from<#1e>save<#1e>set <F2>window<F0><Tab><F3>Function<Index, Doc = operations, "xlib:remove<#1e>from<#1e>save<#1e>set ", Sort String = "remove<#1e>from<#1e>save<#1e>set ">

<para>

Removes the specified <F2>window<F0> from the save<#1e>set of the <F2>window
<F0> display. The <F2>window<F0> must have been created by some 
other display. Windows are removed automatically from the save<#1e>set 
when they are destroyed.

<arg>

window <F3><#1f> A <F6>window<F3>.

<p1rule,
	New Page =		yes>

<|,"14<#1e>179"><Index, "host", "managing access", To Named = p1rule><Index, "control", "host access", To Named = p1rule>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1stacked,
	Font =			F3,
	Left Tab =		-1.70/0 inches>

<F8>Managing Host <Tab><F6>14.6<F0><#04>An X server maintains a 
list of hosts from which client programs can be<FJ>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8><Index, "access control list">Access<Tab><F0>run. Only clients executing 
on hosts that belong to this <F2>access control list<F0> are allowed 
to open a connection to the server. Typically, the access control 
list can be changed by clients running on the same host as the server. 
Some server implementations can also implement other authorization 
mechanisms in addition to, or in place of, this mechanism. The action 
of this mechanism can be conditional based on the authorization protocol 
name and data received by the server at connection setup.

<para>

The following paragraphs describe the CLX functions used to:

<bullet>

<F9>w<Tab><F0>Add or remove hosts on the access control list.

<F9>w<Tab><F0>Return the hosts on the access control list.

<F9>w<Tab><F0>Return or change the state of the access control list 
mechanism

<syntax0>

access<#1e>control <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:access<#1e>control", Sort String = "access<#1e>control">

<return>

<Tab><F3>Returns: <F2><HR>
  enabled<#1e>p <F3><#1f> Type <F0>boolean<F3>.

<para>

Returns and (with <F6>setf<F0>) changes the state of the access 
control list<SP>mechanism for the <F2>display<F0> server. Returns 
true if access control is<SP>enabled; otherwise, <F6>nil<F0> is 
returned. If enabled, the access control list<SP>is used to validate 
each client during connection setup.

Only a client running on the same host as the server is allowed to<SP>enable 
or disable the access control list mechanism.

<arg>

display<F3> <#1f> A <F6>display<F3>.

<syntax0>

access<#1e>hosts<Tab><F2>display<F3> &key (<F0>:result<#1e>type<F3> <F0>'l
ist<F3>)<F0><Tab><F3>Function<Index, Doc = operations, "xlib:access<#1e>hosts", Sort String = "access<#1e>hosts">

<return>

<Tab><F3>Returns: <F2><HR>
  hosts <F3><#1f> <F0>sequence<F3> of <F0>string<F3>.<F2><HR>
  enabled<#1e>p <F3><#1f> Type <F0>boolean<F3>.

<para>

Returns a sequence containing the <F2>hosts<F0> that belong to the 
access<SP>control list of the <F2>display<F0> server. Elements of 
the returned <F2>hosts<F0><SP>sequence are either strings or some 
other type of object recognized as a<SP>host name by <F6>add<#1e>access<#1e>ho
st<F0> and <F6>remove<#1e>access<#1e>host<F0>. The second returned<SP>value 
specifies whether the access control list mechanism is currently<SP>enabled 
or disabled (see <F6>access<#1e>control<F0>).

<arg>

display<F3> <#1f> A <F6>display<F3>.

<F6>:result<#1e>type<F0> <F3><#1f> The type of hosts sequence to 
return.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

add<#1e>access<#1e>host <F2>display host<F0><Tab><F3>Function<Index, Doc = operations, "xlib:add<#1e>access<#1e>host", Sort String = "add<#1e>access<#1e>host">

<para>

Adds the specified <F2>host<F0> to the access control list. Only 
a client running on the same host as the server can change the access 
control list.

<arg>

display<F3> <#1f> A <F6>display<F3>.

host <F3><#1f> A host name. Either a string or some other implementation<#1e>d
ependent type.

<syntax,
	New Page =		yes,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<|,"14<#1e>180">remove<#1e>access<#1e>host <F2>display host<F0><Tab><F3>Function<Index, Doc = operations, "xlib:remove<#1e>access<#1e>host", Sort String = "remove<#1e>access<#1e>host">

<para>

Removes the specified <F2>host<F0> from the access control list. 
Only a client running on the same host as the server can change the 
access control list.

<arg>

display<F3> <#1f> A <F6>display<F3>.

host<F3> <#1f> A host name. Either a string or some other implementation<#1e>d
ependent type.

<p1rule>

<Index, "screen", "saver", To Named = sectitle><Index, "control", "screen saver", To Named = sectitle>
<Frame,
	Name =			p1rule,
	Placement =		At Anchor,
	Width =			6.35 inches,
	Height =		0.153 inches,
	Vertical Alignment =	0.007 inches,
	Shared Contents =	yes>

<p1para,
	Alignment =		Both,
	Font =			F3,
	Allow Page Break After = yes>

<F8>Screen Saver<Tab><F6>14.7<F0><#04>To prevent monitor damage, 
an X server implements a screen saver function which blanks screens 
during periods of unuse. The screen saver can be in one of three states:

<bullet>

<F9>w<Tab><F0>Disabled <#1f> No screen blanking is done and screen 
content remains unchanged.

<F9>w<Tab><F0>Deactivated <#1f> The server is being used. When the 
server input devices are unused for a specific amount of time, the 
screen saver becomes activated.

<F9>w<Tab><F0>Activated <#1f> The server input devices are unused. 
The screen saver blanks all server screens or displays a server<#1e>dependent 
image. As soon as an input event from either the pointer or the keyboard 
occurs, the screen saver is deactivated and its timer is reset.

<para>

The following paragraphs describe the CLX functions used to:

<bullet>

<F9>w<Tab><F0>Return or change screen saver control values.

<F9>w<Tab><F0>Activate or reset the screen saver

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

activate<#1e>screen<#1e>saver <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:activate<#1e>screen<#1e>saver", Sort String = "activate<#1e>screen<#1e>saver">

<para>

Activates the screen saver for the <F2>display<F0> server.

<arg>

display<F3> <#1f> A <F6>display<F3>.

<syntax,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

reset<#1e>screen<#1e>saver <F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:reset<#1e>screen<#1e>saver", Sort String = "reset<#1e>screen<#1e>saver">

<para>

Deactivates the screen saver for the <F2>display<F0> server (if 
necessary) and resets its timer, just as if a pointer or keyboard 
event had occurred.

<arg>

display<F3> <#1f> A <F6>display<F3>.

<syntax0>

screen<#1e>saver<Tab><F2>display<F0><Tab><F3>Function<Index, Doc = operations, "xlib:screen<#1e>saver", Sort String = "screen<#1e>saver">

<return>

<Tab><F3>Returns: <F2><HR>
  timeout<F3>,<F2> period <F3><#1f> Type <F0>int16<F3>.<HR>
  <F2>blanking<F3>,<F2> exposures <F3><#1f> One of <F0>:yes<F3> 
or <F0>:no<F3>.

<para>

Returns the current control values for the <F2>display<F0> server 
screen saver. See <F6>set<#1e>screen<#1e>saver<F0>.

<arg>

display<F3> <#1f> A <F6>display<F3>.

<syntax,
	New Page =		yes,
	Left Tab =		-0.90/0 inches,
	Right Tab =		7.50 inches>

<|,"14<#1e>181">set<#1e>screen<#1e>saver <F2>display timeout period blanking 
exposures <F0><Tab><F3>Function<Index, Doc = operations, "xlib:set<#1e>screen<#1e>saver", Sort String = "set<#1e>screen<#1e>saver">

<para>

Changes the current control values for the <F2>display<F0> server 
screen saver.<SP>The screen saver is reset. The screen saver is also 
disabled if:

<bullet>

<F9>w<Tab><F2>timeout<F0> is zero, or

<F9>w<Tab><F0>Both <F2>blanking<F0> and <F2>exposures<F0> are 
disabled and the server cannot regenerate the screen contents without 
sending <F6>:exposure<F0> events.

<para>

The <F2>timeout <F0>specifies the (non<#1e>negative) number of seconds 
of input<SP>device inactivity that must elapse before the screen saver 
is activated.<SP>The <F2>timeout<F0> can be set to <F6>:default<F0> 
to restore the server default timeout<SP>interval.

If <F2>blanking<F0> is <F6>:yes<F0> and the screen hardware supports 
blanking, blanking is enabled; that is, the screen saver will simply 
blank all<SP>screens when it is activated. <F2>blanking<F0> can 
be set to <F6>:default<F0> to<SP>restore the server default state 
for blanking.

If <F2>exposures<F0> is <F6>:yes<F0>, exposures are enabled. If 
exposures are<SP>enabled, or if the server is capable of regenerating 
screen contents<SP>without sending <F6>:exposure<F0> events, the 
screen saver will display<SP>some server<#1e>dependent image when 
activated. Frequently, this image will<SP>consist of a repeating animation 
sequence, in which case <F2>period<F0><SP>specifies the (non<#1e>negative) 
number of seconds for each repetition. A<SP><F2>period<F0> of zero 
is a hint that no repetition should occur.

<arg>

display <F3><#1f> A <F6>display<F3>.

timeout<F3> <#1f> Specifies the delay until timeout takes over.

period<F3> <#1f> Specifies the periodic change interval, if used.

blanking<F3> <#1f> Specifies whether the blanking option is available.

exposures <F3><#1f> Specifies whether exposures are allowed during 
blanking.

<newpage>

<|,"14<#1e>182">
