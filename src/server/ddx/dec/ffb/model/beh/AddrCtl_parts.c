/*
 * *****************************************************************
 * *                                                               *
 * *    Copyright (c) Digital Equipment Corporation, 1991, 1994    *
 * *                                                               *
 * *   All Rights Reserved.  Unpublished rights  reserved  under   *
 * *   the copyright laws of the United States.                    *
 * *                                                               *
 * *   The software contained on this media  is  proprietary  to   *
 * *   and  embodies  the  confidential  technology  of  Digital   *
 * *   Equipment Corporation.  Possession, use,  duplication  or   *
 * *   dissemination of the software and media is authorized only  *
 * *   pursuant to a valid written license from Digital Equipment  *
 * *   Corporation.                                                *
 * *                                                               *
 * *   RESTRICTED RIGHTS LEGEND   Use, duplication, or disclosure  *
 * *   by the U.S. Government is subject to restrictions  as  set  *
 * *   forth in Subparagraph (c)(1)(ii)  of  DFARS  252.227-7013,  *
 * *   or  in  FAR 52.227-19, as applicable.                       *
 * *                                                               *
 * *****************************************************************
 */
/*
 * HISTORY
 */
#ifndef lint
static char *rcsid = "@(#)$RCSfile: AddrCtl_parts.c,v $ $Revision: 1.1.2.2 $ (DEC) $Date: 1993/11/19 21:21:52 $";
#endif
addrctl_code( adr )
     Net_Entry **adr;
{
  extern void AddrCtl();
  ModeType t_mode;
  CmdType t_cmd;
  DmaStatusType t_dmaStatus;
  CtlPipe2Type t_pipe2;
  CtlCopyLogicType t_ctlCopyLogic;
  CtlAddrGen1Type t_ctl;
  CtlPipe2Type t_pipe1;
  int new_z [12];
  register Net_Entry *z;

  t_mode.z16 = (*(adr+133))->value;
  t_mode.rotate.src = (*(adr+132))->value;
  t_mode.rotate.dst = (*(adr+131))->value;
  t_mode.visual.src = (*(adr+130))->value;
  t_mode.visual.dst = (*(adr+129))->value;
  t_mode.mode = (*(adr+128))->value;
  t_mode.simple = (*(adr+127))->value;
  t_mode.stipple = (*(adr+126))->value;
  t_mode.line = (*(adr+125))->value;
  t_mode.copy = (*(adr+124))->value;
  t_mode.dmaRd = (*(adr+123))->value;
  t_mode.dmaWr = (*(adr+122))->value;
  t_mode.z = (*(adr+121))->value;
  t_cmd.readFlag0 = (*(adr+118))->value;
  t_cmd.newAddr = (*(adr+117))->value;
  t_cmd.newError = (*(adr+116))->value;
  t_cmd.copy64 = (*(adr+115))->value;
  t_cmd.color = (*(adr+114))->value;
  t_cmd.planeMask = (*(adr+113))->value;
  t_dmaStatus.first = (*(adr+112))->value;
  t_dmaStatus.second = (*(adr+111))->value;
  t_dmaStatus.last = (*(adr+110))->value;
  t_pipe2.selSavedVals = (*(adr+107))->value;
  t_pipe2.saveCurrentVals = (*(adr+106))->value;
  t_pipe2.selAddr = (*(adr+105))->value;
  t_pipe2.stepBres = (*(adr+104))->value;
  t_pipe2.stepZ = (*(adr+103))->value;
  t_pipe2.selectZ = (*(adr+102))->value;
  t_pipe2.readZ = (*(adr+101))->value;
  t_pipe2.enableZ = (*(adr+100))->value;
  t_pipe2.readFlag = (*(adr+99))->value;
  t_pipe2.color = (*(adr+98))->value;
  t_pipe2.planeMask = (*(adr+97))->value;
  t_pipe2.block = (*(adr+96))->value;
  t_pipe2.newAddr = (*(adr+95))->value;
  t_pipe2.lastDma = (*(adr+94))->value;
  t_pipe2.first = (*(adr+93))->value;
  t_pipe2.unaligned = (*(adr+92))->value;
  t_ctlCopyLogic.flush = (*(adr+81))->value;
  t_ctlCopyLogic.wrMemData = (*(adr+80))->value;
  t_ctl.req1 = (*(adr+78))->value;
  t_ctl.copy64 = (*(adr+77))->value;
  t_ctl.bresError.selError = (*(adr+76))->value;
  t_ctl.bresError.saveCurrError = (*(adr+75))->value;
  t_ctl.bresError.selSavedError = (*(adr+74))->value;
  t_ctl.bresError.stepBres = (*(adr+73))->value;
  t_ctl.stipMask.blockMode = (*(adr+72))->value;
  t_ctl.stipMask.visual32 = (*(adr+71))->value;
  t_ctl.stipMask.unaligned = (*(adr+70))->value;
  t_ctl.req2 = (*(adr+69))->value;
  t_ctl.addr.selAddr = (*(adr+68))->value;
  t_ctl.addr.selCurAddr = (*(adr+67))->value;
  t_ctl.addr.saveCurrentVals = (*(adr+66))->value;
  t_ctl.addr.selSavedVals = (*(adr+65))->value;
  t_ctl.addr.selectZ = (*(adr+64))->value;
  t_ctl.addr.stepZ = (*(adr+63))->value;
  t_ctl.addr.stepBres = (*(adr+62))->value;
  t_ctl.addr.errorSign = (*(adr+61))->value;
  t_ctl.addr.lineMode = (*(adr+60))->value;
  t_ctl.addr.visual32 = (*(adr+59))->value;
  t_ctl.addr.negateIncVal = (*(adr+58))->value;
  t_ctl.addr.plus8 = (*(adr+57))->value;
  t_ctl.addr.plus4 = (*(adr+56))->value;
  t_ctl.addr.plus1 = (*(adr+55))->value;
  t_ctl.memCmd.readFlag = (*(adr+54))->value;
  t_ctl.memCmd.selectZ = (*(adr+53))->value;
  t_ctl.memCmd.readZ = (*(adr+52))->value;
  t_ctl.memCmd.planeMask = (*(adr+51))->value;
  t_ctl.memCmd.color = (*(adr+50))->value;
  t_ctl.memCmd.block = (*(adr+49))->value;
  t_ctl.memCmd.fastFill = (*(adr+48))->value;
  t_ctl.memCmd.packed8bit = (*(adr+47))->value;
  t_ctl.memCmd.unpacked8bit = (*(adr+46))->value;
  t_ctl.memCmd.line = (*(adr+45))->value;
  t_ctl.color.selAddr1 = (*(adr+44))->value;
  t_ctl.color.selAddr0 = (*(adr+43))->value;
  t_ctl.color.saveCurrentVals = (*(adr+42))->value;
  t_ctl.color.selSavedVals = (*(adr+41))->value;
  t_ctl.color.stepZ = (*(adr+40))->value;
  t_ctl.color.notLine = (*(adr+39))->value;
  t_ctl.color.bresError = (*(adr+38))->value;
  t_ctl.color.stepBres = (*(adr+37))->value;
  t_ctl.color.stepIndex = (*(adr+36))->value;
  t_ctl.color.selDither = (*(adr+35))->value;
  t_ctl.color.dstVisual = (*(adr+34))->value;
  t_ctl.color.mode = (*(adr+33))->value;
  t_ctl.selDataMux.notZ = (*(adr+32))->value;
  t_ctl.selDataMux.notData32 = (*(adr+31))->value;
  t_ctl.selDataMux.data64 = (*(adr+30))->value;
  t_ctl.byteMask.selMode = (*(adr+29))->value;
  t_ctl.byteMask.selAddrMask = (*(adr+28))->value;
  t_ctl.byteMask.enable = (*(adr+27))->value;
  t_ctl.byteMask.readZ = (*(adr+26))->value;
  t_ctl.byteMask.bigPixels = (*(adr+25))->value;
  t_ctl.byteMask.z16Sel = (*(adr+24))->value;
  t_ctl.makeStipple.visual32 = (*(adr+23))->value;
  t_ctl.makeStipple.lineMode = (*(adr+22))->value;
  t_ctl.makeStipple.transparent = (*(adr+21))->value;
  t_ctl.makeStipple.unaligned = (*(adr+20))->value;
  t_ctl.selDmaRdData = (*(adr+19))->value;
  t_ctl.selEdge = (*(adr+18))->value;
  t_ctl.selOnes = (*(adr+17))->value;
  t_pipe1.selSavedVals = (*(adr+16))->value;
  t_pipe1.saveCurrentVals = (*(adr+15))->value;
  t_pipe1.selAddr = (*(adr+14))->value;
  t_pipe1.stepBres = (*(adr+13))->value;
  t_pipe1.stepZ = (*(adr+12))->value;
  t_pipe1.selectZ = (*(adr+11))->value;
  t_pipe1.readZ = (*(adr+10))->value;
  t_pipe1.enableZ = (*(adr+9))->value;
  t_pipe1.readFlag = (*(adr+8))->value;
  t_pipe1.color = (*(adr+7))->value;
  t_pipe1.planeMask = (*(adr+6))->value;
  t_pipe1.block = (*(adr+5))->value;
  t_pipe1.newAddr = (*(adr+4))->value;
  t_pipe1.lastDma = (*(adr+3))->value;
  t_pipe1.first = (*(adr+2))->value;
  t_pipe1.unaligned = (*(adr+1))->value;

  AddrCtl( (*(adr+149))->value, (*(adr+148))->value, (*(adr+147))->value, (*(adr+146))->value, (*(adr+145))->value, (*(adr+144))->value, (*(adr+143))->value, (*(adr+142))->value, (*(adr+141))->value, (*(adr+140))->value, (*(adr+139))->value, (*(adr+138))->value, (*(adr+137))->value, (*(adr+136))->value, (*(adr+135))->value, (*(adr+134))->value, t_mode, (*(adr+120))->value, (*(adr+119))->value, t_cmd, t_dmaStatus, (*(adr+109))->value, (*(adr+108))->value, t_pipe2, &new_z[0], &new_z[1], &new_z[2], &new_z[3], &new_z[4], &new_z[5], &new_z[6], &new_z[7], &new_z[8], &new_z[9], &t_ctlCopyLogic, &new_z[10], &t_ctl, &t_pipe1, &new_z[11] );
  z = (*(adr+91));
  assert_output( z, new_z[0] );
  z = (*(adr+90));
  assert_output( z, new_z[1] );
  z = (*(adr+89));
  assert_output( z, new_z[2] );
  z = (*(adr+88));
  assert_output( z, new_z[3] );
  z = (*(adr+87));
  assert_output( z, new_z[4] );
  z = (*(adr+86));
  assert_output( z, new_z[5] );
  z = (*(adr+85));
  assert_output( z, new_z[6] );
  z = (*(adr+84));
  assert_output( z, new_z[7] );
  z = (*(adr+83));
  assert_output( z, new_z[8] );
  z = (*(adr+82));
  assert_output( z, new_z[9] );
  z = (*(adr+81));
  assert_output( z, t_ctlCopyLogic.flush );
  z = (*(adr+80));
  assert_output( z, t_ctlCopyLogic.wrMemData );
  z = (*(adr+79));
  assert_output( z, new_z[10] );
  z = (*(adr+78));
  assert_output( z, t_ctl.req1 );
  z = (*(adr+77));
  assert_output( z, t_ctl.copy64 );
  z = (*(adr+76));
  assert_output( z, t_ctl.bresError.selError );
  z = (*(adr+75));
  assert_output( z, t_ctl.bresError.saveCurrError );
  z = (*(adr+74));
  assert_output( z, t_ctl.bresError.selSavedError );
  z = (*(adr+73));
  assert_output( z, t_ctl.bresError.stepBres );
  z = (*(adr+72));
  assert_output( z, t_ctl.stipMask.blockMode );
  z = (*(adr+71));
  assert_output( z, t_ctl.stipMask.visual32 );
  z = (*(adr+70));
  assert_output( z, t_ctl.stipMask.unaligned );
  z = (*(adr+69));
  assert_output( z, t_ctl.req2 );
  z = (*(adr+68));
  assert_output( z, t_ctl.addr.selAddr );
  z = (*(adr+67));
  assert_output( z, t_ctl.addr.selCurAddr );
  z = (*(adr+66));
  assert_output( z, t_ctl.addr.saveCurrentVals );
  z = (*(adr+65));
  assert_output( z, t_ctl.addr.selSavedVals );
  z = (*(adr+64));
  assert_output( z, t_ctl.addr.selectZ );
  z = (*(adr+63));
  assert_output( z, t_ctl.addr.stepZ );
  z = (*(adr+62));
  assert_output( z, t_ctl.addr.stepBres );
  z = (*(adr+61));
  assert_output( z, t_ctl.addr.errorSign );
  z = (*(adr+60));
  assert_output( z, t_ctl.addr.lineMode );
  z = (*(adr+59));
  assert_output( z, t_ctl.addr.visual32 );
  z = (*(adr+58));
  assert_output( z, t_ctl.addr.negateIncVal );
  z = (*(adr+57));
  assert_output( z, t_ctl.addr.plus8 );
  z = (*(adr+56));
  assert_output( z, t_ctl.addr.plus4 );
  z = (*(adr+55));
  assert_output( z, t_ctl.addr.plus1 );
  z = (*(adr+54));
  assert_output( z, t_ctl.memCmd.readFlag );
  z = (*(adr+53));
  assert_output( z, t_ctl.memCmd.selectZ );
  z = (*(adr+52));
  assert_output( z, t_ctl.memCmd.readZ );
  z = (*(adr+51));
  assert_output( z, t_ctl.memCmd.planeMask );
  z = (*(adr+50));
  assert_output( z, t_ctl.memCmd.color );
  z = (*(adr+49));
  assert_output( z, t_ctl.memCmd.block );
  z = (*(adr+48));
  assert_output( z, t_ctl.memCmd.fastFill );
  z = (*(adr+47));
  assert_output( z, t_ctl.memCmd.packed8bit );
  z = (*(adr+46));
  assert_output( z, t_ctl.memCmd.unpacked8bit );
  z = (*(adr+45));
  assert_output( z, t_ctl.memCmd.line );
  z = (*(adr+44));
  assert_output( z, t_ctl.color.selAddr1 );
  z = (*(adr+43));
  assert_output( z, t_ctl.color.selAddr0 );
  z = (*(adr+42));
  assert_output( z, t_ctl.color.saveCurrentVals );
  z = (*(adr+41));
  assert_output( z, t_ctl.color.selSavedVals );
  z = (*(adr+40));
  assert_output( z, t_ctl.color.stepZ );
  z = (*(adr+39));
  assert_output( z, t_ctl.color.notLine );
  z = (*(adr+38));
  assert_output( z, t_ctl.color.bresError );
  z = (*(adr+37));
  assert_output( z, t_ctl.color.stepBres );
  z = (*(adr+36));
  assert_output( z, t_ctl.color.stepIndex );
  z = (*(adr+35));
  assert_output( z, t_ctl.color.selDither );
  z = (*(adr+34));
  assert_output( z, t_ctl.color.dstVisual );
  z = (*(adr+33));
  assert_output( z, t_ctl.color.mode );
  z = (*(adr+32));
  assert_output( z, t_ctl.selDataMux.notZ );
  z = (*(adr+31));
  assert_output( z, t_ctl.selDataMux.notData32 );
  z = (*(adr+30));
  assert_output( z, t_ctl.selDataMux.data64 );
  z = (*(adr+29));
  assert_output( z, t_ctl.byteMask.selMode );
  z = (*(adr+28));
  assert_output( z, t_ctl.byteMask.selAddrMask );
  z = (*(adr+27));
  assert_output( z, t_ctl.byteMask.enable );
  z = (*(adr+26));
  assert_output( z, t_ctl.byteMask.readZ );
  z = (*(adr+25));
  assert_output( z, t_ctl.byteMask.bigPixels );
  z = (*(adr+24));
  assert_output( z, t_ctl.byteMask.z16Sel );
  z = (*(adr+23));
  assert_output( z, t_ctl.makeStipple.visual32 );
  z = (*(adr+22));
  assert_output( z, t_ctl.makeStipple.lineMode );
  z = (*(adr+21));
  assert_output( z, t_ctl.makeStipple.transparent );
  z = (*(adr+20));
  assert_output( z, t_ctl.makeStipple.unaligned );
  z = (*(adr+19));
  assert_output( z, t_ctl.selDmaRdData );
  z = (*(adr+18));
  assert_output( z, t_ctl.selEdge );
  z = (*(adr+17));
  assert_output( z, t_ctl.selOnes );
  z = (*(adr+16));
  assert_output( z, t_pipe1.selSavedVals );
  z = (*(adr+15));
  assert_output( z, t_pipe1.saveCurrentVals );
  z = (*(adr+14));
  assert_output( z, t_pipe1.selAddr );
  z = (*(adr+13));
  assert_output( z, t_pipe1.stepBres );
  z = (*(adr+12));
  assert_output( z, t_pipe1.stepZ );
  z = (*(adr+11));
  assert_output( z, t_pipe1.selectZ );
  z = (*(adr+10));
  assert_output( z, t_pipe1.readZ );
  z = (*(adr+9));
  assert_output( z, t_pipe1.enableZ );
  z = (*(adr+8));
  assert_output( z, t_pipe1.readFlag );
  z = (*(adr+7));
  assert_output( z, t_pipe1.color );
  z = (*(adr+6));
  assert_output( z, t_pipe1.planeMask );
  z = (*(adr+5));
  assert_output( z, t_pipe1.block );
  z = (*(adr+4));
  assert_output( z, t_pipe1.newAddr );
  z = (*(adr+3));
  assert_output( z, t_pipe1.lastDma );
  z = (*(adr+2));
  assert_output( z, t_pipe1.first );
  z = (*(adr+1));
  assert_output( z, t_pipe1.unaligned );
  z = (*(adr+0));
  assert_output( z, new_z[11] );
}
