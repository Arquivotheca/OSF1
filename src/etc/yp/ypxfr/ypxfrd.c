/*
 * *****************************************************************
 * *                                                               *
 * *    Copyright (c) Digital Equipment Corporation, 1991, 1994    *
 * *                                                               *
 * *   All Rights Reserved.  Unpublished rights  reserved  under   *
 * *   the copyright laws of the United States.                    *
 * *                                                               *
 * *   The software contained on this media  is  proprietary  to   *
 * *   and  embodies  the  confidential  technology  of  Digital   *
 * *   Equipment Corporation.  Possession, use,  duplication  or   *
 * *   dissemination of the software and media is authorized only  *
 * *   pursuant to a valid written license from Digital Equipment  *
 * *   Corporation.                                                *
 * *                                                               *
 * *   RESTRICTED RIGHTS LEGEND   Use, duplication, or disclosure  *
 * *   by the U.S. Government is subject to restrictions  as  set  *
 * *   forth in Subparagraph (c)(1)(ii)  of  DFARS  252.227-7013,  *
 * *   or  in  FAR 52.227-19, as applicable.                       *
 * *                                                               *
 * *****************************************************************
 */
/*
 * HISTORY
 */
#ifndef lint
static char     *sccsid = "@(#)$RCSfile: ypxfrd.c,v $ $Revision: 4.2 $ (DEC) $Date: 1991/09/19 22:01:35 $";
#endif
/*
 */
#include <rpc/rpc.h>
#include <rpcsvc/ypxfrd.h>
/* 
 * @(#)ypxfrd.x	1.1 90/07/23 4.1NFSSRC Copyr 1990 Sun Micro 
 * This is NOT source code!
 * DO NOT EDIT THIS FILE!
 */


bool_t
xdr_answer(xdrs, objp)
	XDR *xdrs;
	answer *objp;
{
	if (!xdr_enum(xdrs, (enum_t *)objp)) {
		return (FALSE);
	}
	return (TRUE);
}




bool_t
xdr_pagblock(xdrs, objp)
	XDR *xdrs;
	pagblock objp;
{
	if (!xdr_opaque(xdrs, objp, PBLEN)) {
		return (FALSE);
	}
	return (TRUE);
}




bool_t
xdr_dirblock(xdrs, objp)
	XDR *xdrs;
	dirblock objp;
{
	if (!xdr_opaque(xdrs, objp, DBLEN)) {
		return (FALSE);
	}
	return (TRUE);
}




bool_t
xdr_pathname(xdrs, objp)
	XDR *xdrs;
	pathname *objp;
{
	if (!xdr_string(xdrs, objp, 1024)) {
		return (FALSE);
	}
	return (TRUE);
}




bool_t
xdr_hosereq(xdrs, objp)
	XDR *xdrs;
	hosereq *objp;
{
	if (!xdr_pathname(xdrs, &objp->map)) {
		return (FALSE);
	}
	if (!xdr_pathname(xdrs, &objp->domain)) {
		return (FALSE);
	}
	return (TRUE);
}




bool_t
xdr_pagdat(xdrs, objp)
	XDR *xdrs;
	pagdat *objp;
{
	if (!xdr_int(xdrs, &objp->blkno)) {
		return (FALSE);
	}
	if (!xdr_pagblock(xdrs, objp->blkdat)) {
		return (FALSE);
	}
	return (TRUE);
}




bool_t
xdr_dirdat(xdrs, objp)
	XDR *xdrs;
	dirdat *objp;
{
	if (!xdr_int(xdrs, &objp->blkno)) {
		return (FALSE);
	}
	if (!xdr_dirblock(xdrs, objp->blkdat)) {
		return (FALSE);
	}
	return (TRUE);
}




bool_t
xdr_pag(xdrs, objp)
	XDR *xdrs;
	pag *objp;
{
	if (!xdr_answer(xdrs, &objp->status)) {
		return (FALSE);
	}
	switch (objp->status) {
	case OK:
		if (!xdr_pagdat(xdrs, &objp->pag_u.ok)) {
			return (FALSE);
		}
		break;
	}
	return (TRUE);
}




bool_t
xdr_paglist(xdrs, objp)
	XDR *xdrs;
	paglist *objp;
{
	if (!xdr_pag(xdrs, &objp->d)) {
		return (FALSE);
	}
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof(paglist), xdr_paglist)) {
		return (FALSE);
	}
	return (TRUE);
}




bool_t
xdr_dir(xdrs, objp)
	XDR *xdrs;
	dir *objp;
{
	if (!xdr_answer(xdrs, &objp->status)) {
		return (FALSE);
	}
	switch (objp->status) {
	case OK:
		if (!xdr_dirdat(xdrs, &objp->dir_u.ok)) {
			return (FALSE);
		}
		break;
	}
	return (TRUE);
}




bool_t
xdr_dirlist(xdrs, objp)
	XDR *xdrs;
	dirlist *objp;
{
	if (!xdr_dir(xdrs, &objp->d)) {
		return (FALSE);
	}
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof(dirlist), xdr_dirlist)) {
		return (FALSE);
	}
	return (TRUE);
}




bool_t
xdr_du(xdrs, objp)
	XDR *xdrs;
	du *objp;
{
	if (!xdr_paglist(xdrs, &objp->p)) {
		return (FALSE);
	}
	if (!xdr_dirlist(xdrs, &objp->d)) {
		return (FALSE);
	}
	return (TRUE);
}




bool_t
xdr_dbmfyl(xdrs, objp)
	XDR *xdrs;
	dbmfyl *objp;
{
	if (!xdr_answer(xdrs, &objp->status)) {
		return (FALSE);
	}
	switch (objp->status) {
	case OK:
		if (!xdr_du(xdrs, &objp->dbmfyl_u.ok)) {
			return (FALSE);
		}
		break;
	}
	return (TRUE);
}


