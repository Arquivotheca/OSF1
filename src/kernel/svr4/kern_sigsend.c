/*
 * *****************************************************************
 * *                                                               *
 * *    Copyright (c) Digital Equipment Corporation, 1991, 1994    *
 * *                                                               *
 * *   All Rights Reserved.  Unpublished rights  reserved  under   *
 * *   the copyright laws of the United States.                    *
 * *                                                               *
 * *   The software contained on this media  is  proprietary  to   *
 * *   and  embodies  the  confidential  technology  of  Digital   *
 * *   Equipment Corporation.  Possession, use,  duplication  or   *
 * *   dissemination of the software and media is authorized only  *
 * *   pursuant to a valid written license from Digital Equipment  *
 * *   Corporation.                                                *
 * *                                                               *
 * *   RESTRICTED RIGHTS LEGEND   Use, duplication, or disclosure  *
 * *   by the U.S. Government is subject to restrictions  as  set  *
 * *   forth in Subparagraph (c)(1)(ii)  of  DFARS  252.227-7013,  *
 * *   or  in  FAR 52.227-19, as applicable.                       *
 * *                                                               *
 * *****************************************************************
 */
/*
 * HISTORY
 */
#ifndef lint
static char *rcsid = "@(#)$RCSfile: kern_sigsend.c,v $ $Revision: 1.1.2.7 $ (DEC) $Date: 1993/10/14 13:54:45 $";
#endif

#include <sys/user.h>
#include <sys/proc.h>
#include <sys/procset.h>
#include <sys/errno.h>
#include <sys/siginfo.h>
#include <sys/signal.h>
#include <sys/audit.h>

#if     SEC_BASE
#include <sys/security.h>
#endif

/*
 * Can process p send the signal signo to process q?
 * Lifted from bsd/kern_sig.c, where cansignal() also lives.
 */
#define	CANSIGNAL(p, q, signo)	cansignal(p, q, signo)

#define AUD_PID 0
#define AUD_SIG 1
#define SET_AUDIT_VEC(__vec, __pid, __sig)				\
		(__vec)[AUD_PID] = (__pid);				\
		(__vec)[AUD_SIG] = (__sig);

/*
 * sigsendset
 *	Send a signal to each process defined by the complex set
 *	in procset (uap->psp), if we have the correct permissions.
 *
 * Returns:
 *	0 - if succeeded sending to at least 1 process and there
 *		were no permission problems.
 *	-1 with errno of:
 *		EINVAL - parameter errors
 *		EPERM - permission problems
 *		ESRCH - no process to send signal to
 */
sigsendset(cp, args, retval)
	register struct proc *cp;
	void *args;	
	long *retval;
{
	register struct args {
		procset_t	*psp;
		long		signo;
	} *uap = (struct args *) args;
	register struct proc *p;
	procset_t	procset;
	k_siginfo_t	siginfo;
	int error;
	int sendcount = 0;
	long audvec[2];

	ASSERT(syscall_on_master());
	*retval = 0;

	if ((unsigned) uap->signo > NSIG || (unsigned) uap->signo < 0)
		return EINVAL;

	if (error = copyin(uap->psp, &procset, sizeof(procset_t)))
		return error;

	/*
	 * If the value of id is P_MYID, the content of id is replaced with
	 * the value of the corresponding id_type referring to this process.
	 */
	if (error = validated_selection_criterion(cp, &procset)) {
		SET_AUDIT_VEC(audvec, 0, uap->signo);
		AUDIT_CALL2(u.u_event, error, audvec, *retval,
			   AUD_HPR, "0a000000");
		return (error);
	}

	for (p = allproc; p != NULL; p = p->p_nxt) {
		/*
		 * For init to be selected, the idtype specified must
		 * be P_PID and the id specified must be init's (1).
		 */
		if (p->p_pid == 1) {
			if (!(procset.p_lidtype == P_PID 
			      && procset.p_lid == 1
			      && procset.p_ridtype == P_ALL 
			      && procset.p_op == POP_AND)) {
				continue;
			} else {
				/* init was specified correctly */
				if (uap->signo == SIGKILL) {
					/* can't do this! */
					SET_AUDIT_VEC(audvec, p->p_pid,
						      uap->signo);
					AUDIT_CALL2(u.u_event, EINVAL,
						   audvec, *retval,
						   AUD_HPR, "Qa000000");
					return(EINVAL);
				}
			}
		}

		/* check whether p is this in the set */
		if (!selected(p, &procset))
			continue;

		/* check permission to send to the proc in question */
		if (
#if     SEC_ARCH
		  !sec_can_kill(p) ||
#endif
		  !CANSIGNAL(cp, p, uap->signo)) {
			/*
			 * Record here that a permission failure
			 * occurred. If no other send succeeds,
			 * this will be the return status.
			 */
			error = EPERM;
			SET_AUDIT_VEC(audvec, p->p_pid, uap->signo);
			AUDIT_CALL(u.u_event, error, audvec, *retval,
				   AUD_HPR, "Qa000000");
			continue;
		}
		
		siginfo.si_signo = uap->signo;
		siginfo.si_code = SI_USER;  /* signal generated by a process */
		siginfo.si_errno = 0;	/* no error */
		siginfo.si_pid = cp->p_pid;
		siginfo.si_uid = cp->p_ruid;	/* is this the correct uid? */
		if (uap->signo) {
			psignal_info(p, uap->signo, &siginfo);
			SET_AUDIT_VEC(audvec, p->p_pid, uap->signo);
			AUDIT_CALL(u.u_event, 0, audvec, *retval,
				   AUD_HPR, "Qa000000");
		}
		sendcount++;
	}

	if (!sendcount && !error) {
		error = ESRCH;
		SET_AUDIT_VEC(audvec, 0, uap->signo);
		AUDIT_CALL2(u.u_event, error, audvec, *retval,
			   AUD_HPR, "0a000000");

	}
	/*
	 * If we managed to send to any process, then return success.
	 * Error could be set to EPERM if one or more sends failed
	 * because of privilege. If something succeeded, all is
	 * forgiven here.
	 */
	if (sendcount)
		error = 0;

	return error;
}
