#!/usr/bin/ksh 
#
# *****************************************************************
# *                                                               *
# *    Copyright (c) Digital Equipment Corporation, 1991, 1994    *
# *                                                               *
# *   All Rights Reserved.  Unpublished rights  reserved  under   *
# *   the copyright laws of the United States.                    *
# *                                                               *
# *   The software contained on this media  is  proprietary  to   *
# *   and  embodies  the  confidential  technology  of  Digital   *
# *   Equipment Corporation.  Possession, use,  duplication  or   *
# *   dissemination of the software and media is authorized only  *
# *   pursuant to a valid written license from Digital Equipment  *
# *   Corporation.                                                *
# *                                                               *
# *   RESTRICTED RIGHTS LEGEND   Use, duplication, or disclosure  *
# *   by the U.S. Government is subject to restrictions  as  set  *
# *   forth in Subparagraph (c)(1)(ii)  of  DFARS  252.227-7013,  *
# *   or  in  FAR 52.227-19, as applicable.                       *
# *                                                               *
# *****************************************************************
#
# HISTORY
#
# @(#)$RCSfile: makesyscalls.ksh,v $ $Revision: 4.1.13.5 $ (DEC) $Date: 1993/06/07 21:10:02 $
#
# Script to convert the syscalls.master into one of the following based
# upon passed in switches.
#
#	-h	creates syscall.h
#	-k dir	creates ${dir}/syscalls.c and ${dir}/init_sysent.c
#
#
###############################################################################
# DEFAULT VALUES:                                                             #

	SWITCHES="k:h"			# supported command line options.
	PROGRAM=$0
	KMOD=""
	

	sysnames="/dev/null"
	syssw="/dev/null"
	syshdr="/dev/null"

# Temporary files
	sysdcl="sysent.dcl"
	syscompat="sysent.compat"
	sysent="sysent.switch"

#                                                                             #
###############################################################################

###############################################################################
# This section parses the command line.                                       #
#                                                                             #

	test $DEBUG && print -u2 "DEBUGGING: ${PROGRAM}($*)" && set -x

	set -- `getopt ${SWITCHES} $*`
	if [ $? != 0 ]
	then
		print -u2 "${PROGRAM} <-${SWITCHES}> <master> [kmod_prefix]"
		exit 2
	fi
	for i in $*
	do
		case $i in
			-k ) KFLAG=1
				CONFIG=$2
				shift 2;;
			-h ) HFLAG=1
				shift;;
			-- ) shift; break;;
		esac
	done

	# Reject attempt if we do not have 1 or 2 arguments

	case "$#" in
		[12])  # right number of args, perform search
			INPUT="$1"
			KMOD="$2"
			;;
		*)  # wrong number of args, error
			print -u2 "Usage ${PROGRAM}: <-${SWITCHES}> <master> [kmod_prefix]"
			exit 1 ;;
	esac
#                                                                             #
###############################################################################

if [ ${KFLAG:=0} -eq 1 ]
then
	FLAG=1
	sysnames="${CONFIG}/${KMOD}syscalls.C"
	syssw="${CONFIG}/${KMOD}init_sysent.C"
fi

if [ ${HFLAG:=0} -eq 1 ]
then
	FLAG=1
	syshdr="./${KMOD}syscall.H"
fi

if [ ${FLAG:=0} -ne 1 ]
then
        print -u2 "At least -h, or -k flag must be specified."
        exit 1
fi


# name of compat option:
compat=COMPAT_43

case $(uname) in 
	ULTRIX)	AWK="nawk";;
	*) 	AWK="awk";;
esac

${AWK} < ${INPUT} "
BEGIN {
	sysdcl = \"$sysdcl\"
	syscompat = \"$syscompat\"
	sysent = \"$sysent\"
	sysnames = \"$sysnames\"
	syshdr = \"$syshdr\"
	compat = \"$compat\"
	"'

	printf "/*\n * System call switch table.\n *\n" > sysdcl
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysdcl

	printf "\n#if %s\n", compat > syscompat
	printf "#ifdef __STDC__\n" > syscompat
	printf "#define compat(n, name) n, 0, o##name\n" > syscompat
	printf "#define pcompat(n, name) n, 1, o##name\n" > syscompat
	printf "#define upcompat(n, name) n, UPAR, o##name\n\n" > syscompat
	printf "#else\n" > syscompat
	printf "#define compat(n, name) n, 0, o/**/name\n" > syscompat
	printf "#define pcompat(n, name) n, 1, o/**/name\n" > syscompat
	printf "#define upcompat(n, name) n, UPAR, o/**/name\n\n" > syscompat
	printf "#endif\n" > syscompat

	printf "/*\n * System call names.\n *\n" > sysnames
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysnames

	printf "/*\n * System call numbers.\n *\n" > syshdr
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > syshdr
}
# function to save repative code.
NR == 1 {
	printf " * created from%s\n */\n\n", $0 > sysdcl
	printf "#include <unix_locks.h>\n" > sysdcl
	printf "#include <sys/param.h>\n" > sysdcl
	printf "#include <sys/systm.h>\n\n" > sysdcl
	printf "#if\tUNIX_LOCKS\n" > sysdcl
	printf "#define\tUPAR\t1\n" > sysdcl
	printf "#else\n" > sysdcl
	printf "#define\tUPAR\t0\n" > sysdcl
	printf "#endif\n\n" > sysdcl
	printf "#include <sys/secdefines.h>\n\n" >sysdcl
	printf "int\tnosys();\n\n" > sysdcl

	printf "struct sysent KMODsysent[] = {\n" > sysent

	printf " * created from%s\n */\n\n", $0 > sysnames
	printf "char *KMODsyscallnames[] = {\n" > sysnames

	printf " * created from%s\n */\n\n", $0 > syshdr
	first = -1
	next
}
NF == 0 || $1 ~ /^;/ {
	next
}
$1 ~ /^#[ 	]*if/ {
	if_count++
	print > sysent
	print > sysdcl
	print > syscompat
	print > sysnames
	print > syshdr
	savesyscall = syscall
	next
}
$1 ~ /^#[ 	]*else/ {
	print > sysent
	print > sysdcl
	print > syscompat
	print > sysnames
	print > syshdr
	syscall = savesyscall
	next
}
$1 ~ /^#/ {
	if_count--
	print > sysent
	print > sysdcl
	print > syscompat
	print > sysnames
	print > syshdr
	next
}
syscall != $1 && first != -1  {
	if ( if_count == 0 ) {		# if count is not zero then we are
					# in a nested if statement.
		printf "Warning: syscall number out of sync at %d %d; line is:\n", syscall, first
		print
	}
	syscall = savesyscall = $1
}
{	if (first == -1)
		first = syscall
}
{	comment = $6
	for (i = 7; i <= NF; i++)
		comment = comment " " $i
	if (NF < 7)
		$7 = $6
}

$2 == "STD" {
	printf("int\t%s();\n", $6) > sysdcl
	parallel = "0";
	if ($3 == "PARALLEL") parallel="1"
	if ($3 == "UPARALLEL") parallel="UPAR"
	printf("\t%d, %s, %s,\t", $4, parallel, $6 ) > sysent
	printf("{") > sysent
	# painful way of getting single quotes around chars
	printf("%c%s%c", 39, substr($5, 1, 1), 39) > sysent
	for (i = 2; i <= length($5); i++ ) {
		printf(",%c%s%c", 39, substr($5, i, 1), 39) > sysent
	}
	printf("},") > sysent
	printf("\t\t/* %d = %s */\n", syscall, $7) > sysent
	printf("\t\"%s\",\t\t\t/* %d = %s */\n", $7, syscall, $7) > sysnames
	printf("#define\tSYS_KMOD%s\t%d\n", \
	    $7, syscall) > syshdr
}
$2 == "PSTD" || $2 == "STDALT" {
	parallel = "0";
	if ($3 == "PARALLEL") parallel="1"
	if ($3 == "UPARALLEL") parallel="UPAR"
	printf("\t%d, %s, %s,\t", $4, parallel, $6) > sysent
	printf("{") > sysent
	printf("%c%s%c", 39, substr($5, 1, 1), 39) > sysent
	for (i = 2; i<= length($5); i++) {
		printf(",%c%s%c", 39, substr($5, i, 1), 39) > sysent
	}
	printf("},") > sysent
	printf("\t\t/* %d = %s (alternate) */\n", syscall, $7) > sysent
	printf("\t\"alternate %s\",\t\t/* %d = %s (alternate) */\n", \
	    $7, syscall, $7) > sysnames
	printf("#define\tSYS_alt_KMOD%s\t%d\t/* %d is alternate %s */\n", \
	    $7, syscall, syscall, comment) > syshdr
}
$2 == "COMPAT" {
	printf("int\to%s();\n", $6) > syscompat
	parallel=""
	if ($3 == "PARALLEL") parallel="p"
	if ($3 == "UPARALLEL") parallel="up"
	printf("\t%scompat(%d,%s),\t", parallel, $4, $6) > sysent
	printf("{") > sysent
	printf("%c%s%c", 39, substr($5, 1, 1), 39) > sysent
	for (i = 2; i<= length($5); i++) {
		printf(",%c%s%c", 39, substr($5, i, 1), 39) > sysent
	}
	printf("},") > sysent
	printf("\t/* %d = old %s */\n", syscall, $7) > sysent
	printf("\t\"old %s\",\t\t/* %d = old %s */\n", \
	    $7, syscall, $7) > sysnames
	printf("#define\tSYS_old_KMOD%s\t%d\t/* %d is old %s */\n", \
	    $7, syscall, syscall, comment) > syshdr
}
$2 == "OBSOL" {
	printf("\t0, 1, nosys,\t{" ) > sysent
	printf ( "%c0%c", 39, 39 ) > sysent
	for ( i = 2; i <= 9; i++ )
		printf ( ",%c0%c", 39, 39 ) > sysent
	printf ( "},\t\t/* %d = obsolete %s */\n", syscall, comment) > sysent
	printf("\t\"obs %s\",\t\t\t/* %d = obsolete %s */\n", \
	    $6, syscall, comment) > sysnames
	printf("\t\t\t\t/* %d is obsolete %s */\n", \
	    syscall, comment) > syshdr
}
$2 == "UNIMPL" {
	printf("\t0, 1, nosys,\t{" ) > sysent
	printf ( "%c0%c", 39, 39 ) > sysent
	for ( i = 2; i <= 9; i++ )
		printf ( ",%c0%c", 39, 39 ) > sysent
	printf ( "},\t\t/* %d = %s */\n", syscall, comment) > sysent
	printf("\t\"#%d\",\t\t\t/* %d = %s */\n", \
	    syscall, syscall, comment) > sysnames
}
{ syscall++ }
END {
	printf("\n#else /* %s */\n", compat) > syscompat
	printf("#define compat(n, name) 0, 0, nosys\n") > syscompat
	printf("#define pcompat(n, name) 0, 1, nosys\n") > syscompat
	printf("#define upcompat(n, name) 0, UPAR, nosys\n") > syscompat
	printf("#endif /* %s */\n\n", compat) > syscompat

	printf("};\n\n") > sysent
	printf("int\tKMODnsysent = sizeof(KMODsysent) / sizeof(KMODsysent[0]);\n") > sysent

	printf("};\n") > sysnames
	printf("\n") > syshdr
	printf("#define\tKMODFIRST\t%d\n", first) > syshdr
	printf("#define\tKMODLAST\t%d\n", syscall-1) > syshdr

} '					# end of awk program.

cat $sysdcl $syscompat $sysent >$syssw
rm $sysdcl $syscompat $sysent

if [ ${KFLAG:=0} -eq 1 ]
then
	sed "s/KMOD/${KMOD}/g" <${KMOD}syscalls.C >${KMOD}syscalls.c
	sed "s/KMOD/${KMOD}/g" <${KMOD}init_sysent.C >${KMOD}init_sysent.c
	rm ${KMOD}syscalls.C ${KMOD}init_sysent.C
fi

if [ ${HFLAG:=0} -eq 1 ]
then
        sed "s/KMOD/${KMOD}/g" <${KMOD}syscall.H >${KMOD}syscall.h
        rm ${KMOD}syscall.H
fi

