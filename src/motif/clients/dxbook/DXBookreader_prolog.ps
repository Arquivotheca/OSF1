%%Copyright: 1986,1987,1988,1989,1990,1991 DIGITAL EQUIPMENT CORPORATION.
%%+All Rights Reserved.
%%DocumentData: Clean7Bit
%%LanguageLevel: 1
%%Orientation: Portrait
%%Pages: (atend)
%%PageOrder: Ascend
%%DocumentFonts: (atend) 
%%DocumentNeededFonts: (atend) 
%%DocumentProcSets: Underlay Color5044
%%DocumentSuppliedProcSets: Underlay Color5044
%%DocumentProcessColors: (atend)
%%DocumentCustomColors: (atend)
%%EndComments
%
%%BeginResource: procset Underlay
%%CreationDate: (2/10/92)
%
% EPSF files up to 65,000 bytes long
% may be an underlay. Define the EPSF as a PostScript proceedure
% called /UNDERLAY and prefix to Bookreader Print's PS output  For example:.
% /UNDERLAY ( EPSF code here ) cvx def
%
% To create a "Preliminary" underlay change /UNDERLAY* to /UNDERLAY
/UNDERLAY* (
  /Note (Preliminary) def
  /NoteSize 120 def
  /NoteFont /Helvetica findfont NoteSize scalefont def
  /Note where { pop Note length 0 gt {
    /NoteWidth NoteFont setfont Note stringwidth pop def
    PaperWidth 36 mul PaperHeight 36 mul moveto
    PaperHeight PaperWidth atan rotate
    NoteWidth -2 div NoteSize .729 mul -2 div rmoveto 
    Note true charpath .075 setseparationgray fill
  }if  }if
) cvx def
%%EndResource
%
%%BeginResource: procset Color5044
%%CreationDate: (1/21/91)
%%Version:1.0 3
%Implementation of Adobe 5044 color specification
%/ndf allows command override during color separation
/Color5044Dict 100 dict def
Color5044Dict begin
/bdf {bind def} def
/ndf
  {1 index where
    {pop pop pop
    }
    {dup xcheck
      {bind} if
    def
    }
    ifelse
  } bdf
/setcmykcolor
  {1 exch sub
  3 
    {dup 5 -1 roll sub 0 2 copy lt
      {exch} if
    pop exch
    } repeat
  pop setrgbcolor
  }ndf
/setcmykcoloroverprint
  {4
    {dup -1 eq
      {pop 0} if
      4 1 roll
    } repeat
  setcmykcolor
  } ndf
/findcmykcustomcolor
  {5 /packedarray where
    {pop packedarray
    }
    {array astore readonly
    }
    ifelse
  } ndf
/setcustomcolor
  {exch aload pop pop
  4
    {4 index mul 4 1 roll
    } repeat
  setcmykcolor pop
  } ndf
/setseparationgray
  {1 exch sub systemdict /setgray get exec
  } ndf
/setoverprint {pop} ndf
/currentoverprint false ndf
%CMYK multi-proc colorimage
/colorimage
  {4 ne
    {(\nUnsupported number of colors for colorimage.\n) print flush quit
    } if
  not
    {(\nSingle procedure form  colorimage unsupported.\n) print flush quit
    } if
  save 20 dict begin /&saveobj exch def
  /&Kproc exch def /&Yproc exch def /&Mproc exch def /&Cproc exch def
    {&Cproc &Mproc &Yproc &Kproc
    /&K exch def /&Y exch def /&M exch def /&C exch def
    0 1 &K length 1 sub
      {/&i exch def
      &K &i 255
      &C &i get 30 mul
      &M &i get 59 mul add
      &Y &i get 11 mul add
      &K &i get 100 mul add
      100 idiv
      dup 255 gt
        {pop 255} if
      sub put
      } for
    &K
    } image
  &saveobj end restore
  } ndf
/customcolorimage
  {pop systemdict /image get exec
  } ndf
/separationimage
  {systemdict /image get exec
  } ndf
end
%%EndResource
Color5044Dict begin
%
/DEC_DVC$dict 300 dict def
DEC_DVC$dict begin
%
/DVC$PSJob save def
%
/DOCPSE ISOLatin1Encoding 256 array copy def
mark						% CREATE DOCPSE ENCODING
  8#055 /hyphen
  8#201 /bullet    8#202 /emdash     8#203 /endash    8#204 /dagger
  8#205 /daggerdbl 8#206 /registered 8#207 /trademark %8#210 /Delta
  8#211 /fi        8#212 /fl         8#213 /OE        8#214 /oe
  8#215 /Ydieresis
  counttomark -1 bitshift			% DIVIDE BY 2
  {DOCPSE 3 1 roll put} repeat			% STACK NOW CONTAINS MARK
cleartomark
%
/ReENCODE {		% /basefont /newfont encoding ReENCODE
    /newencoding exch def	%ARG: NAME OF ENCODING VECTOR
    /newfontname exch def	%ARG: NEW NAME FOR FONT AFTER RE-ENCODING
    findfont
    /basefontdict exch def	%ARG: NAME OF FONT TO BE RE-ENCODED
    basefontdict maxlength dict begin	%CREATE AND OPEN NEW DICT
	basefontdict {		%COPY ENTRIES FROM BASE FONT DICT TO NEW ONE
	    1 index /FID ne {
		def		%IF NOT THE ONE WE'RE ENCODING, JUST COPY PTRS
	    } { %else
		pop pop		%IGNORE FID AND ENCODING FOR ONE WE'RE ENCODING
	    } ifelse
	} forall
	/FontName newfontname def	%DEFINE NEW NAME 
	/Encoding newencoding def	%DEFINE NEW ENCODING VECTOR
	newfontname currentdict definefont	%TURN IT INTO A PS FONT
	pop			%IGNORE MODIFIED DICT RETURNED BY DEFINEFONT
    end
}def
%
/cvsstr 64 string def
/tempmatrix matrix def
%
% Exit page (temporarily) to add fonts/characters.
/XP { }def
% 
% Resume page
/RP { }def
%
% End Page: EP
/EP {DVC$PSPage restore}def
%
% Purge fonts to reclaim VM
/PF {
  currentoverprint
  currentrgbcolor
  EP			%Does restore
  PageSetup     %Does save
  setrgbcolor
  setoverprint
}def
%
% ABBREVIATIONS 
/S /show load def
/SV /save load def
/RST /restore load def
%
/Yadjust {Ymax exch sub} def
%
/XY {						% (x,y) POSITION ABSOLUTE
  Yadjust moveto
} def
%
/X {						% (x,0) POSITION ABSOLUTE
  currentpoint exch pop moveto
} def
%
/Y {						% (0,y) POSITION ABSOLUTE 
  currentpoint pop exch Yadjust moveto
} def
%
/xy {						% (x,y) POSITION RELATIVE
  neg rmoveto
} def
%
/x {						% (x,0) POSITION RELATIVE
  0 rmoveto
} def
%
/y {						% (0,y) POSITION RELATIVE
  0 exch neg rmoveto
} def
%
/R {						% Draw a rectangle
  /ht exch def  /wd exch def   gsave
  currentpoint  newpath  moveto
  0 ht rlineto  wd 0 rlineto
  0 ht neg rlineto  wd neg 0 rlineto
  closepath fill grestore wd 0 rmoveto
}def
%
%Setup Page Media:  <paper-height> <paper-width> PM
/PM {
  /Xmax exch Resolution mul def
  /Ymax exch Resolution mul def
  /UNDERLAY where {
    pop
    /eps_save save def		% save before EPSF underlay
    Resolution 72 div dup scale % Revert coords to points
    count array astore /DVCstack exch def % save op stack
    /dict_count countdictstack def % # of dicts
    userdict begin		% default dict
    /showpage {}def		% disable showpage
    0 setgray
      {UNDERLAY} stopped {(Error executing /UNDERLAY)== quit}if
    countdictstack dict_count sub {end} repeat % clean up dict stack
    clear DVCstack aload pop	% restore op stack
    eps_save restore		% restore after EPSF
  }if
  PageSetup
}def
%
%Setup page coordinates
/PageSetup
{
  /DVC$PSPage save def
  PortraitMode not {PaperWidth 0 translate  90 rotate} if
  /Xpos 0 def
  /Ypos 0 def
}def
%
% Begin EPS file: <xoffset> <yoffset> SPB
/SPB {
  Yadjust transform		% convert from DVC to device coords
  EP				% page-level restore
  /eps_save save def		% save before EPSF
  Resolution 72 div dup scale 	% Revert coords to points
  itransform			% convert position back to points  
  translate			% set position for EPSF
  PortraitMode not {90 rotate} if % rotate for EPSF
  count array astore /DVCstack exch def	% save op stack
  /dict_count countdictstack def % # of dicts
  userdict begin		% default dict
  /showpage {}def		% disable showpage
  0 setgray
}def
%
% End EPS file
/SPE {
  countdictstack dict_count sub {end} repeat % clean up dict stack
  clear DVCstack aload pop	% restore op stack
  eps_save restore		% restore after EPSF
  PageSetup			% restore DVC coords
}def
%
% Print-Page Routine: <Page #> PP
/PP {
  gsave
  showpage
  grestore
}def
%
%
/ps-scalefont {
    % FOR PS FONTS, LOOK AT SIZE REQUESTED.  IF IT HAS A DECIMAL REMAINDER
    % EQUIVALENT TO .001-.009 POINTS, THAT'S 
    % A FLAG TO STRETCH IT VERTICALLY BY ADDING 1-9 EXTRA POINTS TO THE 
    % VERTICAL SCALING.
                % save requested size - as entered and as integer
    dup /x-size exch def cvi /x-int exch def
                % calc decimal remainder, mul x 1000, round
    x-size x-int sub 1000 mul round cvi /remainder exch def
                % see how we scale...
    remainder 50 lt remainder 450 gt or {
                % scale isomorphically
        /ystretch 0 def
        x-size scalefont
    } {
                % scale anamorphically
        /ystretch remainder def
        x-int ystretch add /y-size exch def
        [x-int 0 0 y-size 0 0] makefont
    } ifelse
}def
%
/DPSF {		% /procname size /fontname DPSF
    findfont exch ps-scalefont [ exch /setfont cvx ] cvx def
}def
%
%
% set color routine: Color# SC
/SC {ColorPalette exch get 1.0 setcustomcolor}bind def
%
%%EndProlog


